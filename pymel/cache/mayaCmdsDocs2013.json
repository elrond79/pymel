{
    "TanimLayer": {
        "description": "", 
        "flags": {}
    }, 
    "aaf2fcp": {
        "description": "This command is used to convert an aff file to a Final Cut Pro (fcp) xml file The conversion process can take several seconds to complete and the command is meant to be run asynchronously ", 
        "flags": {
            "deleteFile": {
                "docstring": "Delete terporary file. Can only be used with the terminate option"
            }, 
            "dstPath": {
                "docstring": "Specifiy a destination path"
            }, 
            "getFileName": {
                "docstring": "Query output file name"
            }, 
            "progress": {
                "docstring": "Request progress report"
            }, 
            "srcFile": {
                "docstring": "Specifiy a source file"
            }, 
            "terminate": {
                "docstring": "Complete the taskFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "waitCompletion": {
                "docstring": "Wait for the conversion process to complete"
            }
        }
    }, 
    "about": {
        "description": "This command displays version information about the application if it is executed without flags. If one of the above flags is specified then the specified version information is returned. ", 
        "flags": {
            "apiVersion": {
                "docstring": "Return the api version"
            }, 
            "application": {
                "docstring": "Return the application name string"
            }, 
            "batch": {
                "docstring": "Returns true if application is in batch mode."
            }, 
            "buildDirectory": {
                "docstring": "Return the build directory string"
            }, 
            "codeset": {
                "docstring": "Returns a string identifying the codeset (codepage) of the locale that Maya is running in. Example return values include \"UTF-8\", \"ISO-8859-1\", \"1252\". Note that the codeset values and naming conventions are highly platform dependent. They may differ in format even if they have the same meaning (e.g. \"utf8\" vs. \"UTF-8\")."
            }, 
            "connected": {
                "docstring": "Return whether the user is connected or not to the Internet."
            }, 
            "currentDate": {
                "docstring": "Returns the current date in the format yyyy/mm/dd, e.g. 2003/05/04."
            }, 
            "currentTime": {
                "docstring": "Returns the current time in the format hh:mm:ss, e.g. 14:27:53."
            }, 
            "cutIdentifier": {
                "docstring": "Return the cut string"
            }, 
            "date": {
                "docstring": "Return the build date string"
            }, 
            "environmentFile": {
                "docstring": "Return the location of the application defaults file."
            }, 
            "evalVersion": {
                "docstring": "Returns true if this is an eval version of the application."
            }, 
            "file": {
                "docstring": "Return the file version string"
            }, 
            "fontInfo": {
                "docstring": "Returns a string of the specifications of the fonts requested, and the specifications of the fonts that are actually being used."
            }, 
            "helpDataDirectory": {
                "docstring": "Returns the help data directory."
            }, 
            "irix": {
                "docstring": "Returns true if the operating system is Irix. Always false with support for Irix removed."
            }, 
            "is64": {
                "docstring": "Returns true if the application is 64 bit."
            }, 
            "languageResources": {
                "docstring": "Returns a string array of the currently installed language resources. Each string entry consists of three elements delimited with a colon (':'). The first token is the locale code (ISO 639-1 language code followed by ISO 3166-1 country code). The second token is the language name in English. This third token is the alpha-3 code (ISO 639-2). For example English is represented as \"en_US:English:enu\"."
            }, 
            "linux": {
                "docstring": "Returns true if the operating system is Linux."
            }, 
            "linux64": {
                "docstring": "Returns true if the operating system is Linux 64 bit."
            }, 
            "liveUpdate": {
                "docstring": "Show the Live Update web page. In query mode return the number of available updates.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "localizedResourceLocation": {
                "docstring": "Returns the path to the top level of the localized resource directory, if we are running in an alternate language. Returns an empty string if we are running in the default language."
            }, 
            "macOS": {
                "docstring": "Returns true if the operating system is Macintosh."
            }, 
            "macOSppc": {
                "docstring": "Returns true if the operating system is a PowerPC Macintosh."
            }, 
            "macOSx86": {
                "docstring": "Returns true if the operating system is an Intel Macintosh."
            }, 
            "ntOS": {
                "docstring": "Returns true if the operating system is Windows."
            }, 
            "operatingSystem": {
                "docstring": "Returns the operating system type. Valid return types are \"nt\", \"win64\", \"mac\", \"linux\" and \"linux64\""
            }, 
            "operatingSystemVersion": {
                "docstring": "Returns the operating system version. on Linux this returns the equivalent of uname -srvm"
            }, 
            "product": {
                "docstring": "Return the license product name"
            }, 
            "qtVersion": {
                "docstring": "Return Qt version string"
            }, 
            "query": {
                "docstring": ""
            }, 
            "uiLanguage": {
                "docstring": "Returns the language that Maya's running in. Example return values include \"en_US\" for English and \"ja_JP\" for Japanese."
            }, 
            "uiLanguageIsLocalized": {
                "docstring": "Returns true if we are running in an alternate language, not the default (English)."
            }, 
            "version": {
                "docstring": "Return the version string"
            }, 
            "win64": {
                "docstring": "Returns true if the operating system is Windows x64 based."
            }, 
            "windowManager": {
                "docstring": "Returns the name of the Window Manager that is assumed to be running."
            }, 
            "windows": {
                "docstring": "Returns true if the operating system is Windows based."
            }
        }
    }, 
    "addAttr": {
        "description": "This command is used to add a dynamic attribute to a node or nodes. Either the longName or the shortName or both must be specified. If neither a dataType nor an attributeType is specified, a double attribute will be added. The dataType flag can be specified more than once indicating that any of the supplied types will be accepted (logical-or). To add a non-double attribute the following criteria can be used to determine whether the dataType or the attributeType flag is appropriate. Some types, such as double3can use either. In these cases the -dtflag should be used when you only wish to access the data as an atomic entity (eg. you never want to access the three individual values that make up a double3). In general it is best to use the -atin these cases for maximum flexibility. In most cases the -dtversion will not display in the attribute editor as it is an atomic type and you are not allowed to change individual parts of it. All attributes flagged as \"(compound)\" below or the compound attribute itself are not actually added to the node until all of the children are defined (using the \"-p\" flag to set their parent to the compound being created). See the EXAMPLES section for more details. Type of attributeFlag and argument to useboolean-at bool32 bit integer-at long16 bit integer-at short8 bit integer-at bytechar-at charenum-at enum (specify the enum names using the enumName flag)float-at \"float\" (use quotes since float is a mel keyword)double-at doubleangle value-at doubleAnglelinear value-at doubleLinearstring-dt \"string\" (use quotes since string is a mel keyword)array of strings-dt stringArraycompound-at compoundmessage (no data)-at messagetime-at time4x4 double matrix-dt \"matrix\" (use quotes since matrix is a mel keyword)4x4 float matrix-at fltMatrixreflectance-dt reflectanceRGBreflectance (compound)-at reflectancespectrum-dt spectrumRGBspectrum (compound)-at spectrum2 floats-dt float22 floats (compound)-at float23 floats-dt float33 floats (compound)-at float32 doubles-dt double22 doubles (compound)-at double23 doubles-dt double33 doubles (compound)-at double32 32-bit integers-dt long22 32-bit integers (compound)-at long23 32-bit integers-dt long33 32-bit integers (compound)-at long32 16-bit integers-dt short22 16-bit integers (compound)-at short23 16-bit integers-dt short33 16-bit integers (compound)-at short3array of doubles-dt doubleArrayarray of 32-bit ints-dt Int32Arrayarray of vectors-dt vectorArraynurbs curve-dt nurbsCurvenurbs surface-dt nurbsSurfacepolygonal mesh-dt meshlattice-dt latticearray of double 4D points-dt pointArrayIn query mode, return type is based on queried flag.", 
        "flags": {
            "attributeType": {
                "docstring": "Specifies the attribute type, see above table for more details. Note that the attribute types \"float\", \"matrix\" and \"string\" are also MEL keywords and must be enclosed in quotes."
            }, 
            "binaryTag": {
                "docstring": "This flag is obsolete and does not do anything any more"
            }, 
            "cachedInternally": {
                "docstring": "Whether or not attribute data is cached internally in the node. This flag is currently not supported (it will always be set to a default value of true)."
            }, 
            "category": {
                "docstring": "An attribute category is a string associated with the attribute to identify it. (e.g. the name of a plugin that created the attribute, version information, etc.) Any attribute can be associated with an arbitrary number of categories however categories can not be removed once associated."
            }, 
            "dataType": {
                "docstring": "Specifies the data type. See \"setAttr\" for more information on data type names."
            }, 
            "defaultValue": {
                "docstring": "Specifies the default value for the attribute (can only be used for numeric attributes)."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enumName": {
                "docstring": "Flag used to specify the ui names corresponding to the enum values. The specified string should contain a colon-separated list of the names, with optional values. If values are not specified, they will treated as sequential integers starting with 0. For example: -enumName \"A:B:C\" would produce options: A,B,C with values of 0,1,2; -enumName \"zero:one:two:thousand=1000\" would produce four options with values 0,1,2,1000; and -enumName \"solo=1:triplet=3:quintet=5\" would produce three options with values 1,3,5. (Note that there is a current limitation of the Channel Box that will sometimes incorrectly display an enumerated attribute's pull-down menu. Extra menu items can appear that represent the numbers inbetween non-sequential option values. To avoid this limitation, specify sequential values for the options of any enumerated attributes that will appear in the Channel Box. For example: \"solo=1:triplet=2:quintet=3\".)"
            }, 
            "exists": {
                "docstring": "Returns true if the attribute queried is a user-added, dynamic attribute; false if not.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "fromPlugin": {
                "docstring": "Was the attribute originally created by a plugin? Normally set automatically when the API call is made - only added here to support storing it in a file independently from the creating plugin."
            }, 
            "hasMaxValue": {
                "docstring": "Flag indicating whether an attribute has a maximum value. (can only be used for numeric attributes)."
            }, 
            "hasMinValue": {
                "docstring": "Flag indicating whether an attribute has a minimum value. (can only be used for numeric attributes)."
            }, 
            "hasSoftMaxValue": {
                "docstring": "Flag indicating whether a numeric attribute has a soft maximum."
            }, 
            "hasSoftMinValue": {
                "docstring": "Flag indicating whether a numeric attribute has a soft minimum."
            }, 
            "hidden": {
                "docstring": "Will this attribute be hidden from the UI?"
            }, 
            "indexMatters": {
                "docstring": "Sets whether an index must be used when connecting to this multi-attribute. Setting indexMatters to false forces the attribute to non-readable."
            }, 
            "internalSet": {
                "docstring": "Whether or not the internal cached value is set when this attribute value is changed. This is an internal flag used for updating UI elements."
            }, 
            "keyable": {
                "docstring": "Is the attribute keyable by default?"
            }, 
            "longName": {
                "docstring": "Sets the long name of the attribute."
            }, 
            "maxValue": {
                "docstring": "Specifies the maximum value for the attribute (can only be used for numeric attributes)."
            }, 
            "minValue": {
                "docstring": "Specifies the minimum value for the attribute (can only be used for numeric attributes)."
            }, 
            "multi": {
                "docstring": "Makes the new attribute a multi-attribute."
            }, 
            "niceName": {
                "docstring": "Sets the nice name of the attribute for display in the UI. Setting the attribute's nice name to a non-empty string overrides the default behaviour of looking up the nice name from Maya's string catalog. (Use the MEL commands \"attributeNiceName\" and \"attributeQuery -niceName\" to lookup an attribute's nice name in the catalog.)"
            }, 
            "numberOfChildren": {
                "docstring": "How many children will the new attribute have?"
            }, 
            "parent": {
                "docstring": "Attribute that is to be the new attribute's parent."
            }, 
            "query": {
                "docstring": ""
            }, 
            "readable": {
                "docstring": "Can outgoing connections be made from this attribute?"
            }, 
            "shortName": {
                "docstring": "Sets the short name of the attribute."
            }, 
            "softMaxValue": {
                "docstring": "Soft maximum, valid for numeric attributes only. Specifies the upper default limit used in sliders for this attribute."
            }, 
            "softMinValue": {
                "docstring": "Soft minimum, valid for numeric attributes only. Specifies the upper default limit used in sliders for this attribute."
            }, 
            "storable": {
                "docstring": "Can the attribute be stored out to a file?"
            }, 
            "usedAsColor": {
                "docstring": "Is the attribute to be used as a color definition? Must have 3 DOUBLE or 3 FLOAT children to use this flag. The attribute type \"-at\" should be \"double3\" or \"float3\" as appropriate. It can also be used to less effect with data types \"-dt\" as \"double3\" or \"float3\" as well but some parts of the code do not support this alternative. The special attribute types/data \"spectrum\" and \"reflectance\" also support the color flag and on them it is set by default."
            }, 
            "usedAsFilename": {
                "docstring": "Is the attribute to be treated as a filename definition? This flag is only supported on attributes with data type \"-dt\" of \"string\"."
            }, 
            "writable": {
                "docstring": "Can incoming connections be made to this attribute?"
            }
        }
    }, 
    "addDynamic": {
        "description": "Makes the \"object\" specified as second argument the source of an existing field or emitter specified as the first argument. In practical terms, what this means is that a field will emanate its force from its owner object, and an emitter will emit from its owner object. addDynamic makes the specified field or emitter a child of the owner's transform (adding it to the model if it was not already there), and makes the necessary attribute connections. If either of the arguments is omitted, addDynamic searches the selection list for objects to use instead. If more than one possible owner or field/emitter is selected, addDynamic will do nothing. If the specified field/emitter already has a source, addDynamic will remove the current source and replace it with the newly specified source. If a subset of the owner object's cvs/particles/vertices is selected, addDynamic will add the field/emitter to that subset only. ", 
        "flags": {}
    }, 
    "addExtension": {
        "description": "This command is used to add an extension attribute to a node type. Either the longName or the shortName or both must be specified. If neither a dataType nor an attributeType is specified, a double attribute will be added. The dataType flag can be specified more than once indicating that any of the supplied types will be accepted (logical-or). To add a non-double attribute the following criteria can be used to determine whether the dataType or the attributeType flag is appropriate. Some types, such as double3can use either. In these cases the -dtflag should be used when you only wish to access the data as an atomic entity (eg. you never want to access the three individual values that make up a double3). In general it is best to use the -atin these cases for maximum flexibility. In most cases the -dtversion will not display in the attribute editor as it is an atomic type and you are not allowed to change individual parts of it. All attributes flagged as \"(compound)\" below or the compound attribute itself are not actually added to the node until all of the children are defined (using the \"-p\" flag to set their parent to the compound being created). See the EXAMPLES section for more details. Type of attributeFlag and argument to useboolean-at bool32 bit integer-at long16 bit integer-at short8 bit integer-at bytechar-at charenum-at enum (specify the enum names using the enumName flag)float-at \"float\" (use quotes since float is a mel keyword)double-at doubleangle value-at doubleAnglelinear value-at doubleLinearstring-dt \"string\" (use quotes since string is a mel keyword)array of strings-dt stringArraycompound-at compoundmessage (no data)-at messagetime-at time4x4 double matrix-dt \"matrix\" (use quotes since matrix is a mel keyword)4x4 float matrix-at fltMatrixreflectance-dt reflectanceRGBreflectance (compound)-at reflectancespectrum-dt spectrumRGBspectrum (compound)-at spectrum2 floats-dt float22 floats (compound)-at float23 floats-dt float33 floats (compound)-at float32 doubles-dt double22 doubles (compound)-at double23 doubles-dt double33 doubles (compound)-at double32 32-bit integers-dt long22 32-bit integers (compound)-at long23 32-bit integers-dt long33 32-bit integers (compound)-at long32 16-bit integers-dt short22 16-bit integers (compound)-at short23 16-bit integers-dt short33 16-bit integers (compound)-at short3array of doubles-dt doubleArrayarray of 32-bit ints-dt Int32Arrayarray of vectors-dt vectorArraynurbs curve-dt nurbsCurvenurbs surface-dt nurbsSurfacepolygonal mesh-dt meshlattice-dt latticearray of double 4D points-dt pointArray", 
        "flags": {
            "attributeType": {
                "docstring": "Specifies the attribute type, see above table for more details. Note that the attribute types \"float\", \"matrix\" and \"string\" are also MEL keywords and must be enclosed in quotes."
            }, 
            "binaryTag": {
                "docstring": "This flag is obsolete and does not do anything any more"
            }, 
            "cachedInternally": {
                "docstring": "Whether or not attribute data is cached internally in the node. This flag is currently not supported (it will always be set to a default value of true)."
            }, 
            "category": {
                "docstring": "An attribute category is a string associated with the attribute to identify it. (e.g. the name of a plugin that created the attribute, version information, etc.) Any attribute can be associated with an arbitrary number of categories however categories can not be removed once associated."
            }, 
            "dataType": {
                "docstring": "Specifies the data type. See \"setAttr\" for more information on data type names."
            }, 
            "defaultValue": {
                "docstring": "Specifies the default value for the attribute (can only be used for numeric attributes)."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enumName": {
                "docstring": "Flag used to specify the ui names corresponding to the enum values. The specified string should contain a colon-separated list of the names, with optional values. If values are not specified, they will treated as sequential integers starting with 0. For example: -enumName \"A:B:C\" would produce options: A,B,C with values of 0,1,2; -enumName \"zero:one:two:thousand=1000\" would produce four options with values 0,1,2,1000; and -enumName \"solo=1:triplet=3:quintet=5\" would produce three options with values 1,3,5. (Note that there is a current limitation of the Channel Box that will sometimes incorrectly display an enumerated attribute's pull-down menu. Extra menu items can appear that represent the numbers inbetween non-sequential option values. To avoid this limitation, specify sequential values for the options of any enumerated attributes that will appear in the Channel Box. For example: \"solo=1:triplet=2:quintet=3\".)"
            }, 
            "exists": {
                "docstring": "Returns true if the attribute queried is a user-added, dynamic attribute; false if not.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "fromPlugin": {
                "docstring": "Was the attribute originally created by a plugin? Normally set automatically when the API call is made - only added here to support storing it in a file independently from the creating plugin."
            }, 
            "hasMaxValue": {
                "docstring": "Flag indicating whether an attribute has a maximum value. (can only be used for numeric attributes)."
            }, 
            "hasMinValue": {
                "docstring": "Flag indicating whether an attribute has a minimum value. (can only be used for numeric attributes)."
            }, 
            "hasSoftMaxValue": {
                "docstring": "Flag indicating whether a numeric attribute has a soft maximum."
            }, 
            "hasSoftMinValue": {
                "docstring": "Flag indicating whether a numeric attribute has a soft minimum."
            }, 
            "hidden": {
                "docstring": "Will this attribute be hidden from the UI?"
            }, 
            "indexMatters": {
                "docstring": "Sets whether an index must be used when connecting to this multi-attribute. Setting indexMatters to false forces the attribute to non-readable."
            }, 
            "internalSet": {
                "docstring": "Whether or not the internal cached value is set when this attribute value is changed. This is an internal flag used for updating UI elements."
            }, 
            "keyable": {
                "docstring": "Is the attribute keyable by default?"
            }, 
            "longName": {
                "docstring": "Sets the long name of the attribute."
            }, 
            "maxValue": {
                "docstring": "Specifies the maximum value for the attribute (can only be used for numeric attributes)."
            }, 
            "minValue": {
                "docstring": "Specifies the minimum value for the attribute (can only be used for numeric attributes)."
            }, 
            "multi": {
                "docstring": "Makes the new attribute a multi-attribute."
            }, 
            "niceName": {
                "docstring": "Sets the nice name of the attribute for display in the UI. Setting the attribute's nice name to a non-empty string overrides the default behaviour of looking up the nice name from Maya's string catalog. (Use the MEL commands \"attributeNiceName\" and \"attributeQuery -niceName\" to lookup an attribute's nice name in the catalog.)"
            }, 
            "nodeType": {
                "docstring": "Specifies the type of node to which the attribute will be added. See the nodeType command for the names of different node types."
            }, 
            "numberOfChildren": {
                "docstring": "How many children will the new attribute have?"
            }, 
            "parent": {
                "docstring": "Attribute that is to be the new attribute's parent."
            }, 
            "readable": {
                "docstring": "Can outgoing connections be made from this attribute?"
            }, 
            "shortName": {
                "docstring": "Sets the short name of the attribute."
            }, 
            "softMaxValue": {
                "docstring": "Soft maximum, valid for numeric attributes only. Specifies the upper default limit used in sliders for this attribute."
            }, 
            "softMinValue": {
                "docstring": "Soft minimum, valid for numeric attributes only. Specifies the upper default limit used in sliders for this attribute."
            }, 
            "storable": {
                "docstring": "Can the attribute be stored out to a file?"
            }, 
            "usedAsColor": {
                "docstring": "Is the attribute to be used as a color definition? Must have 3 DOUBLE or 3 FLOAT children to use this flag. The attribute type \"-at\" should be \"double3\" or \"float3\" as appropriate. It can also be used to less effect with data types \"-dt\" as \"double3\" or \"float3\" as well but some parts of the code do not support this alternative. The special attribute types/data \"spectrum\" and \"reflectance\" also support the color flag and on them it is set by default."
            }, 
            "usedAsFilename": {
                "docstring": "Is the attribute to be treated as a filename definition? This flag is only supported on attributes with data type \"-dt\" of \"string\"."
            }, 
            "writable": {
                "docstring": "Can incoming connections be made to this attribute?"
            }
        }
    }, 
    "addPP": {
        "description": "Adds per-point (per-cv, per-vertex, or per-particle) attribute capability for an attribute of an emitter or field. The -atr flag identifies the attribute. If no attribute is named, addPP returns a warning and does nothing. The command adds any other necessary attributes wherever they are needed, and makes all necessary connections. If any of the attributes already exist, the command simply connects to them. The command also toggles any relevant attributes in the emitter or field to indicate that per-point capability is being used. The command adds a separate per-point attribute to the owning object for each emitter/field. For example, for emission rate, there is a separate ratePP for each emitter. These attributes are named according to the convention emitter/field nameattr namePP. For example, if a particle shape owned an emitter \"smoke\", that shape would get attribute \"smokeRatePP.\" The name of the object must be the emitter or field for which per-point capability is to be added (or the name of its parent transform). The addPP command adds the per-point capability for that emitter or field but not for any others owned by the same object. If per-point capability is not supported for a named object, the command will issue a warning, but will continue executing for any other objects which were valid. If no objects are named, addPP uses any objects in the current selection list for which the specified attribute is applicable. (For example, it would add per-point rate for all selected emitters.) If addPP detects that the owner object has left-over attributes from a deleted emitter, it will remove those attributes before adding the new ones. Thus, you can delete the emitter, make a new one, and run addPP again, and addPP will clean up after the deleted emitter. This is most commonly used if you have a geometry emitter and then decide to change the geometry. Likewise, if addPP detects that some cvs or vertices have been added to the geometry, then it will expand the corresponding multi-attributes as necessary. However, if it detects that some cvs/vertices have been removed, it will not remove any entries from the multi. See the user manual for more discussion. ", 
        "flags": {
            "attribute": {
                "docstring": "Name of attribute to which you wish to add PP capability. Currently the only attribute supported is rate (for emitters).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "adskAsset": {
        "description": "", 
        "flags": {
            "assetID": {
                "docstring": ""
            }, 
            "library": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "resolved": {
                "docstring": ""
            }
        }
    }, 
    "adskAssetLibrary": {
        "description": "", 
        "flags": {
            "unload": {
                "docstring": ""
            }, 
            "unloadAll": {
                "docstring": ""
            }
        }
    }, 
    "adskAssetList": {
        "description": "", 
        "flags": {
            "infoType": {
                "docstring": ""
            }
        }
    }, 
    "adskAssetListUI": {
        "description": "", 
        "flags": {
            "commandSuffix": {
                "docstring": ""
            }, 
            "materialLoaded": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "uiCommand": {
                "docstring": ""
            }
        }
    }, 
    "affectedNet": {
        "description": "This command gets the list of attributes on a node or node type and creates nodes of type TdnAffect, one for each attribute, that are connected iff the source node's attribute affects the destination node's attribute. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "type": {
                "docstring": "Get information from the given node type instead of one nodeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "affects": {
        "description": "This command returns the list of attributes on a node or node type which affect the named attribute. ", 
        "flags": {
            "by": {
                "docstring": "Show attributes that are affected by the given one rather than the ones that affect it."
            }, 
            "type": {
                "docstring": "static node type from which to get 'affects' informationFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "agFormatIn": {
        "description": "", 
        "flags": {
            "file": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }
        }
    }, 
    "agFormatOut": {
        "description": "", 
        "flags": {
            "file": {
                "docstring": ""
            }
        }
    }, 
    "aimConstraint": {
        "description": "Constrain an object's orientation to point at a target object or at the average position of a number of targets. An aimConstraint takes as input one or more \"target\" DAG transform nodes at which to aim the single \"constraint object\" DAG transform node. The aimConstraint orients the constrained object such that the aimVector (in the object's local coordinate system) points to the in weighted average of the world space position target objects. The upVector (again the the object's local coordinate system) is aligned in world space with the worldUpVector. ", 
        "flags": {
            "aimVector": {
                "docstring": "Set the aim vector. This is the vector in local coordinates that points at the target. If not given at creation time, the default value of (1.0, 0.0, 0.0) is used."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "layer": {
                "docstring": "Specify the name of the animation layer where the constraint should be added."
            }, 
            "maintainOffset": {
                "docstring": "The offset necessary to preserve the constrained object's initial rotation will be calculated and used as the offset."
            }, 
            "name": {
                "docstring": "Sets the name of the constraint node to the specified name. Default name is constrainedObjectName_constraintType"
            }, 
            "offset": {
                "docstring": "Sets or queries the value of the offset. Default is 0,0,0."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the listed target(s) from the constraint."
            }, 
            "skip": {
                "docstring": "Specify the axis to be skipped. Valid values are \"x\", \"y\", \"z\" and \"none\". During creation, \"none\" is the default.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "targetList": {
                "docstring": "Return the list of target objects."
            }, 
            "upVector": {
                "docstring": "Set local up vector. This is the vector in local coordinates that aligns with the world up vector. If not given at creation time, the default value of (0.0, 1.0, 0.0) is used."
            }, 
            "weight": {
                "docstring": "Sets the weight value for the specified target(s). If not given at creation time, the default value of 1.0 is used."
            }, 
            "weightAliasList": {
                "docstring": "Returns the names of the attributes that control the weight of the target objects. Aliases are returned in the same order as the targets are returned by the targetList flag"
            }, 
            "worldUpObject": {
                "docstring": "Set the DAG object use for worldUpType \"object\" and \"objectrotation\". See worldUpType for greater detail. The default value is no up object, which is interpreted as world space."
            }, 
            "worldUpType": {
                "docstring": "Set the type of the world up vector computation. The worldUpType can have one of 5 values: \"scene\", \"object\", \"objectrotation\", \"vector\", or \"none\". If the value is \"scene\", the upVector is aligned with the up axis of the scene and worldUpVector and worldUpObject are ignored. If the value is \"object\", the upVector is aimed as closely as possible to the origin of the space of the worldUpObject and the worldUpVector is ignored. If the value is \"objectrotation\" then the worldUpVector is interpreted as being in the coordinate space of the worldUpObject, transformed into world space and the upVector is aligned as closely as possible to the result. If the value is \"vector\", the upVector is aligned with worldUpVector as closely as possible and worldUpMatrix is ignored. Finally, if the value is \"none\" no twist calculation is performed by the constraint, with the resulting \"upVector\" orientation based previous orientation of the constrained object, and the \"great circle\" rotation needed to align the aim vector with its constraint. The default worldUpType is \"vector\"."
            }, 
            "worldUpVector": {
                "docstring": "Set world up vector. This is the vector in world coordinates that up vector should align with. See -wut/worldUpType (below)for greater detail. If not given at creation time, the default value of (0.0, 1.0, 0.0) is used."
            }
        }
    }, 
    "air": {
        "description": "The air field simulates the effects of moving air. The affected objects will be accelerated or decelerated so that their velocities match that of the air. With the '-vco true' flag thrown, only accelerations are applied. By parenting an air field to a moving part of an object (ie. a foot of a character) and using '-i 1 -m 0 -s .5 -vco true' flags, one can simulate the movement of air around the foot as it moves, since the TOTAL velocity vector of the field would be only based on the movement of the foot. This can be done while the character walks through leaves or dust on the ground. For each listed object, the command creates a new field. The transform is the associated dependency node. Use connectDynamic to cause the field to affect a dynamic object. If fields are created, this command returns the field names. If a field was queried, the results of the query are returned. If a field was edited, the field name is returned. If the -pos flag is specified, a field is created at the position specified. If not, if object names are provided or the active selection list is non-empty, the command creates a field for every object in the list and calls addDynamic to add it to the object; otherwise the command defaults to -pos 0 0 0. Setting the -pos flag with objects named on the command line is an error. ", 
        "flags": {
            "attenuation": {
                "docstring": "Attentuation rate of field The air field attenuates so as to taper the field's magnitude to zero when the maximum distance is reached. Thus, attenuation has no effect unless useMaxDistance is true and a positive maximum distance has been set."
            }, 
            "directionX": {
                "docstring": ""
            }, 
            "directionY": {
                "docstring": ""
            }, 
            "directionZ": {
                "docstring": "Direction that the air will try to match the affected particles' velocity to. NOTE: This is not the velocity; this is only the direction. Use the -s flag to set the speed."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enableSpread": {
                "docstring": "This tells the system whether or not to use the spread angle given by '-sp'. If this is 'false' then all connected objectswithin the maximum distance will be affected. Also, if this is set to 'false', all affected objects are forced to match their velocities along the direction vector. If this is set to 'true' and spread is used, then the direction of the force is along the direction from the field to the object."
            }, 
            "fanSetup": {
                "docstring": "Similar to 'windSetup' except that the effects of a fan or a person blowing air are approximated. The user can pass the same flags on the command line to adjust them from the defaults. These are the values that get set to approximate a 'fan': inheritVelocity 1.0 inheritRotation true componentOnly false enableSpread true spread .5 (45 degrees from center )"
            }, 
            "inheritRotation": {
                "docstring": "If this is set to 'true', then the direction vector described with -dx, -dy, and -dz will be considered local to the owning object. Therefore, if the owning object's transform undergoes any rotation (by itself or one of its parents), the direction vector of the air field will undergo that same rotation."
            }, 
            "inheritVelocity": {
                "docstring": "Amount (from 0 to 1) of the field-owner's velocity added to the vector determined by the direction and speed flags. The combination of these two vectors makes up the TOTAL velocity vector for the air field. This allows the air to be determined directly by the motion of the owning object."
            }, 
            "magnitude": {
                "docstring": "The speed along the direction vector that the air is moving. Use this in conjunction with the -dx -dy -dz flags."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which field is exerted. -1 indicates that the field has no maximum distance."
            }, 
            "name": {
                "docstring": "name of field"
            }, 
            "perVertex": {
                "docstring": "Per-vertex application. If this flag is set true, then each individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical copy of the force field. If this flag is set to false, then the force is exerted only from the geometric center of the set of points."
            }, 
            "position": {
                "docstring": "Position in space where you want to place a field. The field then emanates from this position in space rather than from an object. Note that you can both use -pos (creating a field at a position) and also provide object names."
            }, 
            "query": {
                "docstring": ""
            }, 
            "speed": {
                "docstring": "How fast the affected objects' speed reaches the speed (based on the -mag, -dx, -dy, -dz flags) of the air field. This value gets clamped internally to be between 0.0 and 1.0. A value of 0.0 will make the air field have no effect. A value of 1.0 will try to match the air field's speed much quicker, but not necessarily immediately."
            }, 
            "spread": {
                "docstring": "This represents the angle from the direction vector within which objects will be affected. The values are in the range of 0 to 1. A value of 0 will result in an effect only exactly in front of the air field along the direction vector. A value of 1 will result in any object in front of the owning object, 90 degrees in all direction from the direction vector."
            }, 
            "torusSectionRadius": {
                "docstring": ""
            }, 
            "velocityComponentOnly": {
                "docstring": "If this is 'false', the air will accelerate or decelerate the affected objects so that their velocities will eventually match the TOTAL velocity vector of the air field. If this is 'true', only ACCELERTION is applied to the affected objects so that their velocity component along the TOTAL velocity vector matches or is greater in magnitude than the TOTAL velocity vector. This will not slow objects down to match velocities, only speed them up to match components. This is most useful when using the -iv flag with a value 0."
            }, 
            "volumeExclusion": {
                "docstring": ""
            }, 
            "volumeOffset": {
                "docstring": ""
            }, 
            "volumeShape": {
                "docstring": ""
            }, 
            "volumeSweep": {
                "docstring": ""
            }, 
            "wakeSetup": {
                "docstring": "Like the 'windSetup' and 'fanSetup', 'wakeSetup' sets certain values in the field to approximate the movement of air near a moving object, such as a character's foot or hand. The values that are set are: inheritVelocity 1.0 inheritRotation false componentOnly true enableSpread false speed 0.0Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "windSetup": {
                "docstring": "This will set some of the values above in a way that approximates the effects of a basic wind. This allows the user to then change certain values as he/she wishes on the same command line. First the preset values get set, and then any other flags that were passed get taken into account. These are the values that get set to approximate 'wind': inheritVelocity 0.0 inheritRotation true componentOnly false enableSpread false"
            }
        }
    }, 
    "aliasAttr": {
        "description": "Allows aliases (alternate names) to be defined for any attribute of a specified node. When an attribute is aliased, the alias will be used by the system to display information about the attribute. The user may, however, freely use either the alias or the original name of the attribute. Only a single alias can be specified for an attribute so setting an alias on an already-aliased attribute destroys the old alias. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Specifies that aliases listed should be removed (otherwise new aliases are added).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "align": {
        "description": "Align or spread objects along X Y and Z axis. ", 
        "flags": {
            "alignToLead": {
                "docstring": "When set, the min, center or max values are computed from the lead object. Otherwise, the values are averaged for all objects.Default is false"
            }, 
            "coordinateSystem": {
                "docstring": "Defines the X, Y, and Z coordinates. Default is the world coordinatesFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "xAxis": {
                "docstring": "Any of none, min, mid, max, dist, stack.This defines the kind of alignment to perfom, default is none."
            }, 
            "yAxis": {
                "docstring": "Any of none, min, mid, max, dist, stack.This defines the kind of alignment to perfom, default is none."
            }, 
            "zAxis": {
                "docstring": "Any of none, min, mid, max, dist, stack.This defines the kind of alignment to perfom, default is none."
            }
        }
    }, 
    "alignCtx": {
        "description": "The alignCtx command creates a tool for aligning and distributing objects. ", 
        "flags": {
            "align": {
                "docstring": "Align objects"
            }, 
            "anchorFirstObject": {
                "docstring": "Anchor first or last selected object. Default false. Only applicable when aligning objects."
            }, 
            "distribute": {
                "docstring": "Distribute objects"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }, 
            "showAlignTouch": {
                "docstring": "Show or hide align touching handles. Default true. Only applicable when aligning objects.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "alignCurve": {
        "description": "The curve align command is used to align curves in maya. The main alignment options are positional, tangent and curvature continuity. Curvature continuity implies tangent continuity. Positional continuity means the curves (move) or the ends of the curves (modify) are changed. Tangent continuity means one of the curves is modified to be tangent at the points where they meet. Curvature continuity means one of the curves is modified to be curvature continuous as well as tangent. The default behaviour, when no curves or flags are passed, is to only do positional and tangent continuity on the active list with the end of the first curve and the start of the other curve used for alignment. ", 
        "flags": {
            "attach": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curvatureContinuity": {
                "docstring": "Curvature continuity is on if true and off otherwise.Default:falseAdvanced flags"
            }, 
            "curvatureScale1": {
                "docstring": "Curvature scale applied to curvature of first curve for curvature continuity.Default:0.0"
            }, 
            "curvatureScale2": {
                "docstring": "Curvature scale applied to curvature of second curve for curvature continuity.Default:0.0"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "joinParameter": {
                "docstring": "Parameter on reference curve where modified curve is to be aligned to.Default:123456.0"
            }, 
            "keepMultipleKnots": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "positionalContinuity": {
                "docstring": "Positional continuity is on if true and off otherwise.Default:true"
            }, 
            "positionalContinuityType": {
                "docstring": "Positional continuity type legal values: 1 - move first curve, 2 - move second curve, 3 - move both curves, 4 - modify first curve, 5 - modify second curve, 6 - modify both curvesDefault:1"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reverse1": {
                "docstring": "If true, reverse the first input curve before doing align. Otherwise, do nothing to the first input curve before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "reverse2": {
                "docstring": "If true, reverse the second input curve before doing align. Otherwise, do nothing to the second input curve before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "tangentContinuity": {
                "docstring": "Tangent continuity is on if true and off otherwise.Default:true"
            }, 
            "tangentContinuityType": {
                "docstring": "Tangent continuity type legal values: 1 - do tangent continuity on first curve, 2 - do tangent continuity on second curveDefault:1"
            }, 
            "tangentScale1": {
                "docstring": "Tangent scale applied to tangent of first curve for tangent continuity.Default:1.0"
            }, 
            "tangentScale2": {
                "docstring": "Tangent scale applied to tangent of second curve for tangent continuity.Default:1.0"
            }
        }
    }, 
    "alignSurface": {
        "description": "The surface align command is used to align surfaces in maya. The main alignment options are positional, tangent and curvature continuity. Curvature continuity implies tangent continuity. NOTE: this tool is based on Studio's align tool. Positional continuity means the surfaces (move) or the ends of the surfaces (modify) are changed. Tangent continuity means one of the surfaces is modified to be tangent at the points where they meet. Curvature continuity means one of the surfaces is modified to be curvature continuous as well as tangent. The default behaviour, when no surfaces or flags are passed, is to only do positional and tangent continuity on the active list with the end of the first surface and the start of the other surface used for alignment. ", 
        "flags": {
            "attach": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curvatureContinuity": {
                "docstring": "Curvature continuity is on if true and off otherwise.Default:false"
            }, 
            "curvatureScale1": {
                "docstring": "Curvature scale applied to curvature of first surface for curvature continuity.Default:0.0"
            }, 
            "curvatureScale2": {
                "docstring": "Curvature scale applied to curvature of second surface for curvature continuity.Default:0.0"
            }, 
            "directionU": {
                "docstring": "If true use U direction of surface and V direction otherwise.Default:trueAdvanced flags"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "joinParameter": {
                "docstring": "Parameter on reference surface where modified surface is to be aligned to.Default:123456.0"
            }, 
            "keepMultipleKnots": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "positionalContinuity": {
                "docstring": "Positional continuity is on if true and off otherwise.Default:true"
            }, 
            "positionalContinuityType": {
                "docstring": "Positional continuity type legal values: 1 - move first surface, 2 - move second surface, 3 - move both surfaces, 4 - modify first surface, 5 - modify second surface, 6 - modify both surfacesDefault:1"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reverse1": {
                "docstring": "If true, reverse the direction (specified by directionU) of the first input surface before doing align. Otherwise, do nothing to the first input surface before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "reverse2": {
                "docstring": "If true, reverse the direction (specified by directionU) of the second input surface before doing align. Otherwise, do nothing to the second input surface before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "swap1": {
                "docstring": "If true, swap the UV directions of the first input surface before doing align. Otherwise, do nothing to the first input surface before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "swap2": {
                "docstring": "If true, swap the UV directions of the second input surface before doing align. Otherwise, do nothing to the second input surface before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "tangentContinuity": {
                "docstring": "Tangent continuity is on if true and off otherwise.Default:true"
            }, 
            "tangentContinuityType": {
                "docstring": "Tangent continuity type legal values: 1 - do tangent continuity on first surface, 2 - do tangent continuity on second surfaceDefault:1"
            }, 
            "tangentScale1": {
                "docstring": "Tangent scale applied to tangent of first surface for tangent continuity.Default:1.0"
            }, 
            "tangentScale2": {
                "docstring": "Tangent scale applied to tangent of second surface for tangent continuity.Default:1.0"
            }, 
            "twist": {
                "docstring": "If true, reverse the second surface in the opposite direction (specified by directionU) before doing align. This will avoid twists in the aligned surfaces. Otherwise, do nothing to the second input surface before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }
        }
    }, 
    "allNodeTypes": {
        "description": "This command returns a list containing the type names of every kind of creatable node registered with the system. Note that some node types are abstract and cannot be created. These will not show up on this list. (e.g. transform and polyShape both inherit from dagObject, but dagObject cannot be created directly so it will not appear on this list.) ", 
        "flags": {
            "includeAbstract": {
                "docstring": "Show every node type, even the abstract ones which cannot be created via the 'createNode' command. These will have the suffix \"(abstract)\" appended to them in the list.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "ambientLight": {
        "description": "The ambientLight command is used to edit the parameters of existing ambientLights, or to create new ones. The default behaviour is to create a new ambientlight. ", 
        "flags": {
            "ambientShade": {
                "docstring": "ambientShade"
            }, 
            "discRadius": {
                "docstring": "radius of the disc around the light"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": ""
            }, 
            "intensity": {
                "docstring": "intensity of the light (expressed as a percentage)"
            }, 
            "name": {
                "docstring": "specify the name of the light"
            }, 
            "position": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rgb": {
                "docstring": "color of the light (0-1)"
            }, 
            "rotation": {
                "docstring": ""
            }, 
            "shadowColor": {
                "docstring": "the shadow color"
            }, 
            "shadowDither": {
                "docstring": "dither the shadowFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "shadowSamples": {
                "docstring": "number of shadow samples."
            }, 
            "softShadow": {
                "docstring": "soft shadow"
            }, 
            "useRayTraceShadows": {
                "docstring": "ray trace shadows"
            }
        }
    }, 
    "angleBetween": {
        "description": "Returns the axis and angle required to rotate one vector onto another. If the construction history (ch) flag is ON, then the name of the new dependency node is returned. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn construction history on or off. If true, a dependency node will be created and its name is returned.Default:falseFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "euler": {
                "docstring": "return the rotation as 3 Euler angles instead of axis + angle"
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "vector1": {
                "docstring": "vector to compute the rotation from"
            }, 
            "vector1X": {
                "docstring": ""
            }, 
            "vector1Y": {
                "docstring": ""
            }, 
            "vector1Z": {
                "docstring": ""
            }, 
            "vector2": {
                "docstring": "vector to compute the rotation to"
            }, 
            "vector2X": {
                "docstring": ""
            }, 
            "vector2Y": {
                "docstring": ""
            }, 
            "vector2Z": {
                "docstring": ""
            }
        }
    }, 
    "animCurveEditor": {
        "description": "Edit a characteristic of a graph editor ", 
        "flags": {
            "autoFit": {
                "docstring": "on | off | tgl auto fit-to-view"
            }, 
            "classicMode": {
                "docstring": "When on, the graph editor is displayed in \"Classic Mode\", otherwise \"Suites Mode\" is used."
            }, 
            "clipTime": {
                "docstring": "Valid values: \"on\" \"off\"Display the clips with their offset and scale applied to the anim curves in the clip."
            }, 
            "constrainDrag": {
                "docstring": "Constrains all Graph Editor animation curve drag operations to either the X-axis, the Y-axis, or to neither of those axes. Values to supply are: 0 for not constraining any axis, 1 for constraing the X-axis, or 2 for constraining the Y-axis. When used in queries, this flag returns the latter values and these values have the same interpretation as above. Note: when the shift key is pressed before dragging the animation curve, the first mouse movement will instead determine (and override) any prior set constrained axis.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "curvesShown": {
                "docstring": "Returns a string array containing the names of the animCurve nodes currently displayed in the graph editor."
            }, 
            "curvesShownForceUpdate": {
                "docstring": "Returns a string array containing the names of the animCurve nodes currently displayed in the graph editor. Unlike the curvesShown flag, this will force an update of the graph editor for the case where the mainListConnection has been modified since the last refresh."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "denormalizeCurvesCommand": {
                "docstring": "Sets the script which is run to denormalize curves in the graph editor. This is intended for internal use only."
            }, 
            "displayActiveKeyTangents": {
                "docstring": "on | off | tgl display tangents in the editor"
            }, 
            "displayActiveKeys": {
                "docstring": "on | off | tgl display tangents in the editor"
            }, 
            "displayInfinities": {
                "docstring": "on | off | tgl display infinities in the editor"
            }, 
            "displayKeys": {
                "docstring": "on | off | tgl display keyframes in the editor"
            }, 
            "displayNormalized": {
                "docstring": "When on, display all curves normalized to the range -1 to +1."
            }, 
            "displayTangents": {
                "docstring": "on | off | tgl display tangents in the editor"
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "lookAt": {
                "docstring": "all | selected | currentTime fitView helpers"
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "menu": {
                "docstring": "Specify a script to be run when the editor is created. The function will be passed one string argument which is the new editor's name."
            }, 
            "normalizeCurvesCommand": {
                "docstring": "Sets the script which is run to normalize curves in the graph editor. This is intended for internal use only."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "preSelectionHighlight": {
                "docstring": "When on, the curve/key/tangent under the mouse pointer is highlighted to ease selection."
            }, 
            "query": {
                "docstring": ""
            }, 
            "renormalizeCurves": {
                "docstring": "This flag causes the curve normalization factors to be recalculated."
            }, 
            "resultSamples": {
                "docstring": "Specify the sampling for result curvesNote: the smaller this number is, the longer it will take to update the display."
            }, 
            "resultScreenSamples": {
                "docstring": "Specify the screen base result sampling for result curves. If 0, then results are sampled in time."
            }, 
            "resultUpdate": {
                "docstring": "Valid values: \"interactive\" \"delayed\"Controls how changes to animCurves are reflected in the result curves (if results are being shown). If resultUpdate is \"interactive\", then as interactive changes are being made to the animCurve, the result curves will be updated. If modelUpdate is delayed (which is the default setting), then result curves are updated once the final change to an animCurve has been made."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "showBufferCurves": {
                "docstring": "Valid values: \"on\" \"off\" \"tgl\"Display buffer curves."
            }, 
            "showResults": {
                "docstring": "Valid values: \"on\" \"off\" \"tgl\"Display result curves from expression or other non-keyed action."
            }, 
            "showUpstreamCurves": {
                "docstring": "If true, the dependency graph is searched upstream for all curves that drive the selected plugs (showing multiple curves for example in a typical driven key setup, where first the driven key curve is encountered, followed by the actual animation curve that drives the source object). If false, only the first curves encountered will be shown. Note that, even if false, multiple curves can be shown if e.g. a blendWeighted node is being used to combine multiple curves."
            }, 
            "smoothness": {
                "docstring": "Valid values: \"coarse\" \"rough\" \"medium\" \"fine\"Specify the display smoothness of animation curves."
            }, 
            "snapTime": {
                "docstring": "none | integer | keyframe keyframe move snap in time"
            }, 
            "snapValue": {
                "docstring": "none | integer | keyframe keyframe move snap in values"
            }, 
            "stackedCurves": {
                "docstring": "Switches the display mode between normal (all curves sharing one set of axes) to stacked (each curve on its own value axis, stacked vertically)."
            }, 
            "stackedCurvesMax": {
                "docstring": "Sets the maximum value on the per-curve value axis when in stacked mode."
            }, 
            "stackedCurvesMin": {
                "docstring": "Sets the minimum value on the per-curve value axis when in stacked mode."
            }, 
            "stackedCurvesSpace": {
                "docstring": "Sets the spacing between curves when in stacked mode."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "animDisplay": {
        "description": "This command changes certain display options used by animation windows. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "modelUpdate": {
                "docstring": "Controls how changes to animCurves are propagated through the dependency graph. Valid modes are \"none\", \"interactive\" or \"delayed\". If modelUpdate is \"none\" then changing an animCurve will not cause the model to be updated (change currentTime in order to update the model). If modelUpdate is \"interactive\" (which is the default setting), then as interactive changes are being made to the animCurve, the model will be updated. If modelUpdate is delayed, then the model is updated once the final change to an animCurve has been made. With modelUpdate set to either \"interactive\" or \"delayed\", changes to animCurves made via commands will also cause the model to be updated."
            }, 
            "query": {
                "docstring": ""
            }, 
            "refAnimCurvesEditable": {
                "docstring": "Specify if animation curves from referenced files are editable.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "timeCode": {
                "docstring": "Controls whether the animation windows (time slider, graph editor and dope sheet) use time codes in their displays."
            }, 
            "timeCodeOffset": {
                "docstring": "This flag has now been deprecated. It still exists to not break legacy scripts, but it will now do nothing. See the new timeCode command to set and query timeCodes."
            }
        }
    }, 
    "animLayer": {
        "description": "This command creates and edits animation layers. ", 
        "flags": {
            "addSelectedObjects": {
                "docstring": "Adds selected object(s) to the layer."
            }, 
            "affectedLayers": {
                "docstring": "Return the layers that the currently selected object(s) are members of"
            }, 
            "animCurves": {
                "docstring": "In query mode returns the anim curves associated with this layer"
            }, 
            "attribute": {
                "docstring": "Adds a specific attribute on a object to the layer."
            }, 
            "baseAnimCurves": {
                "docstring": "In query mode returns the base layer anim curves associated with this layer, if any."
            }, 
            "bestAnimLayer": {
                "docstring": "In query mode returns the best anim layers for keying for the selected objects. If used in conjunction with -at, will return the best anim layers for keying for the specific plugs (attributes) specified."
            }, 
            "bestLayer": {
                "docstring": "Return the layer that will be keyed for specified attribute."
            }, 
            "blendNodes": {
                "docstring": "In query mode returns the blend nodes associated with this layer"
            }, 
            "children": {
                "docstring": "Get the list of children layers. return value is a string array."
            }, 
            "collapse": {
                "docstring": "Determine if a layer is collapse in the layer editor."
            }, 
            "copy": {
                "docstring": "Copy from layer."
            }, 
            "copyAnimation": {
                "docstring": "copy animation from specified layer to destination layer, only animation that are on attribute layered by both layer that are concerned."
            }, 
            "copyNoAnimation": {
                "docstring": "Copy from layer without the animation curves."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "excludeBoolean": {
                "docstring": "When adding selected object(s) to the layer, excludes any boolean attributes."
            }, 
            "excludeDynamic": {
                "docstring": "When adding selected object(s) to the layer, excludes any dynamic attributes."
            }, 
            "excludeEnum": {
                "docstring": "When adding selected object(s) to the layer, excludes any enum attributes."
            }, 
            "excludeRotate": {
                "docstring": "When adding selected object(s) to the layer, exclude the rotate attribute."
            }, 
            "excludeScale": {
                "docstring": "When adding selected object(s) to the layer, exclude the scale attribute."
            }, 
            "excludeTranslate": {
                "docstring": "When adding selected object(s) to the layer, excludes the translate attribute."
            }, 
            "excludeVisibility": {
                "docstring": "When adding selected object(s) to the layer, exclude the visibility attribute."
            }, 
            "exists": {
                "docstring": "Determine if an layer exists."
            }, 
            "extractAnimation": {
                "docstring": "transfer animation from specified layer to destination layer, only animation that are on attribute layered by both layer that are concerned."
            }, 
            "findCurveForPlug": {
                "docstring": "finds the parameter curve containing the animation data for the specified plug on the given layer.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "forceUIRebuild": {
                "docstring": "rebuilds the animation layers user interface."
            }, 
            "forceUIRefresh": {
                "docstring": "refreshes the animation layers user interface."
            }, 
            "layeredPlug": {
                "docstring": "returns the plug on the blend node corresponding to the specified layer"
            }, 
            "lock": {
                "docstring": "Set the lock state of the specified layer. A locked layer can not receive key. Default is false."
            }, 
            "moveLayerAfter": {
                "docstring": "Move layer after the specified layer"
            }, 
            "moveLayerBefore": {
                "docstring": "Move layer before the specified layer"
            }, 
            "mute": {
                "docstring": "Set the mute state of the specified layer. Default is false."
            }, 
            "override": {
                "docstring": "Set the overide state of the specified layer. Default is false."
            }, 
            "parent": {
                "docstring": "Set the parent of the specified layer. Default is the animation layer root."
            }, 
            "passthrough": {
                "docstring": "Set the passthrough state of the specified layer. Default is true."
            }, 
            "preferred": {
                "docstring": "Determine if a layer is a preferred layer, the best layer algorithm will try to set keyframe in preferred layer first."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeAllAttributes": {
                "docstring": "Remove all objects from layer."
            }, 
            "removeAttribute": {
                "docstring": "Remove object from layer."
            }, 
            "root": {
                "docstring": "Return the base layer if it exist"
            }, 
            "selected": {
                "docstring": "Determine if a layer is selected, a selected layer will be show in the timecontrol, graph editor."
            }, 
            "solo": {
                "docstring": "Set the solo state of the specified layer. Default is false."
            }, 
            "weight": {
                "docstring": "Set the weight of the specified layer between 0.0 and 1.0. Default is 1."
            }, 
            "writeBlendnodeDestinations": {
                "docstring": "In edit mode writes the destination plugs of the blend nodes that belong to the layer into the blend node. This is used for layer import/export purposes and is not for general use."
            }
        }
    }, 
    "animView": {
        "description": "This command allows you to specify the current view range within an animation editor. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "endTime": {
                "docstring": "End time to display within the editor"
            }, 
            "maxValue": {
                "docstring": "Upper value to display within the editor"
            }, 
            "minValue": {
                "docstring": "Lower value to display within the editor"
            }, 
            "nextView": {
                "docstring": "Switches to the next view.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "previousView": {
                "docstring": "Switches to the previous view."
            }, 
            "query": {
                "docstring": ""
            }, 
            "startTime": {
                "docstring": "Start time to display within the editor"
            }
        }
    }, 
    "annotate": {
        "description": "This command is used to create an annotation to be attached to the specified objects at the specified point. ", 
        "flags": {
            "point": {
                "docstring": "Specifies the point about which the annotation text is to be centered."
            }, 
            "text": {
                "docstring": "Specifies the annotation text.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "applyAttrPattern": {
        "description": "Take the attribute structure described by a pre-defined pattern and apply it either to a node (as dynamic attributes) or a node type (as extension attributes). The same pattern can be applied more than once to different nodes or node types as the operation duplicates the attribute structure described by the pattern. See the 'createAttrPatterns' command for a description of how to create a pattern. ", 
        "flags": {
            "nodeType": {
                "docstring": "Name of the node type to which the attribute pattern is to be applied. This flag will cause a new extension attribute tree to be created, making the new attributes available on all nodes of the given type. If it is not specified then either a node name must be specified or a node must be selected for application of dynamic attributes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "patternName": {
                "docstring": "The name of the pattern to apply. The pattern with this name must have been previously created using the createAttrPatterns command."
            }
        }
    }, 
    "applyTake": {
        "description": "This command takes data in a device (refered to as a take) and converts it into a form that may be played back and reviewed. The take can either be imported through the readTake action, or recorded by the recordDevice action. The take is either converted into animation curves or if the -preview flag is used, into blendDevice nodes. The command looks for animation curves attached to the target attributes of a device attachment. If animation curves exist, the take is pasted over the existing curves. If the curves do not exist, new animation curves are created. If devices are not specified, all of the devices with take data and that are enabled for applyTake, will have their data applied. See also: recordDevice, enableDevice, readTake, writeTake ", 
        "flags": {
            "channel": {
                "docstring": "This flag overrides the set channel enable value. If a channel is specified, it will be enabled.C: The default is all applyTake enabled channels for the device(s)."
            }, 
            "device": {
                "docstring": "Specifies which device contains the take.C: The default is all applyTake enabled devices."
            }, 
            "filter": {
                "docstring": "This flag specifies the filters to use during the applyTake. If this flag is used multiple times, the ordering of the filters is from left to right.C: The default is no filters."
            }, 
            "preview": {
                "docstring": "Applies the take to blendDevice nodes attached to the target attributes connected to the device attachments. Animation curves attached to the attributes will not be altered, but for the time that preview data is defined, the preview data will be the data used during playback.C: The default is to not preview."
            }, 
            "recurseChannel": {
                "docstring": "When this flag is used, the children of the channel(s) specified by -c/channel are also applied. C: The default is all of the enabled channels."
            }, 
            "reset": {
                "docstring": "Resets the blendDevice nodes affected by -preview. The preview data is removed and if animation curves exist, they are used during playback.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "specifyChannel": {
                "docstring": "This flag is used with -c/channel flag. When used, applyTake will only work on the channels listed with the -c/channel flag.C: The default is all of the enabled channels."
            }, 
            "startTime": {
                "docstring": "The default start time for a take is determined at record time. The startTime option sets the starting time of the take in the current animation units.C: The default is the first time stamp of the take. If a time stamp does not exist for the take, 0 is used."
            }
        }
    }, 
    "arcLenDimContext": {
        "description": "Command used to register the arcLenDimCtx tool. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "arcLengthDimension": {
        "description": "This command is used to create an arcLength dimension to display the arcLength of a curve/surface at a specified point on the curve/surface. ", 
        "flags": {}
    }, 
    "arclen": {
        "description": "This command returns the arclength of a curve if the history flag is not set (the default). If the history flag is set, a node is created that can produce the arclength, and is connected and its name returned. Having the construction history option on makes this command useful for expressions. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "arrayMapper": {
        "description": "Create an arrayMapper node and connect it to a target object. If the -type flag is used, then this command also creates an external node used for computing the output values. If the input attribute does not already exist, it will be created. The output attribute must exists. If a flag is omitted, the selection list will be used to supply the needed objects. If none are found, that action is omitted. ", 
        "flags": {
            "destAttr": {
                "docstring": "Specifies the attribute which will be the downstream connection for the output data from the mapper node. The attribute type will be used to determine which output attribute to use: float array gets outValuePP, vector array gets outColorPP. If the flag is omitted, no output connection is made."
            }, 
            "inputU": {
                "docstring": "Specifies the upstream attribute to connect to the mapper's uCoordPP attribute. If the flag is omitted, no input connection is made."
            }, 
            "inputV": {
                "docstring": "Specifies the upstream attribute to connect to the mapper's vCoordPP attribute. If the flag is omitted, no input connection is made."
            }, 
            "mapTo": {
                "docstring": "Specifies an existing node to be used to compute the output values. This node must be of the appropriate type. Currently, only ramp nodes may be used.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "target": {
                "docstring": "Specifies the target object to be connected to."
            }, 
            "type": {
                "docstring": "Specifies the node type to create which will be used to compute the output values. Currently, only ramp is valid. If the flag is omitted, no connection is made and the external node is not created."
            }
        }
    }, 
    "art3dPaintCtx": {
        "description": "This is a tool context command for 3d Paint tool. In query mode, return type is based on queried flag.", 
        "flags": {
            "accopacity": {
                "docstring": "Sets opacity accumulation on/off. C: Default is false (Except for sculpt tool for which it is true by default). Q: When queried, it returns a boolean."
            }, 
            "afterStrokeCmd": {
                "docstring": ""
            }, 
            "alphablendmode": {
                "docstring": "Specifies the blend mode used while painting RGB channel. Currently, we support the following blend modes: \"Default\" \"Lighten\" \"Darken\" \"Difference\" \"Exclusion\" \"Hard Light\" \"Soft Light\" \"Multiply\" \"Screen\" \"Overlay\" Default is \"Default\"."
            }, 
            "assigntxt": {
                "docstring": "Sends a request to the tool to allocate and assign file textures to the specified attibute on the selected shaders."
            }, 
            "attrnames": {
                "docstring": ""
            }, 
            "beforeStrokeCmd": {
                "docstring": ""
            }, 
            "brushalignment": {
                "docstring": "Specifies the path brush alignemnt. If true, the brush will align to stroke path, otherwise it will align to up vector. C: Default is true. Q: When queried, it returns a boolean."
            }, 
            "brushdepth": {
                "docstring": ""
            }, 
            "brushfeedback": {
                "docstring": "Specifies if the brush additional feedback should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "brushtype": {
                "docstring": ""
            }, 
            "clear": {
                "docstring": "Floods all cvs/vertices to the current value."
            }, 
            "commonattr": {
                "docstring": "Returns a string with the names of all common to all the shaders paintable attributes and supported by the Paint Texture Tool.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dragSlider": {
                "docstring": "Sets the current brush drag state for resizing or offsetting the brush (like the 'b' and 'm' default hotkeys). The string argument is one of: \"radius\", \"lowradius\", \"opacity\", \"value\", \"depth\", \"displacement\", \"uvvector\" or \"none\". C: Default is \"none\"."
            }, 
            "dynclonemode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandfilename": {
                "docstring": "If true, it will expand the name of the export file and concatenate it with the surface name. Otherwise it will take the name as it is. C: Default is true."
            }, 
            "exportaspectratio": {
                "docstring": ""
            }, 
            "exportfilemode": {
                "docstring": "Specifies the export channel.The valid entries here are: \"alpha\", \"luminance\", \"rgb\", \"rgba\". C: Default is \"luminance/rgb\". Q: When queried, it returns a string."
            }, 
            "exportfilesave": {
                "docstring": "Exports the attribute map and saves to a specified file."
            }, 
            "exportfilesizex": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfilesizey": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfiletype": {
                "docstring": "Specifies the image file format. It can be one of the following: \"iff\", \"tiff\", \"jpeg\", \"alias\", \"rgb\", \"fit\" \"postScriptEPS\", \"softimage\", \"wavefrontRLA\", \"wavefrontEXP\". C: default is tiff. Q: When queried, it returns a string."
            }, 
            "extendFillColor": {
                "docstring": "States if the painted textures will be automatically postprocessed on each stroke to fill in the background color. Default is true."
            }, 
            "fileformat": {
                "docstring": ""
            }, 
            "filetxtaspectratio": {
                "docstring": "Specifies the aspect ration of the texture width and height. Default is 1."
            }, 
            "filetxtsizex": {
                "docstring": "Specifies the width of the texture. Default is 256."
            }, 
            "filetxtsizey": {
                "docstring": "Specifies the height of the texture. Default is 256."
            }, 
            "floodOpacity": {
                "docstring": ""
            }, 
            "floodall": {
                "docstring": ""
            }, 
            "floodselect": {
                "docstring": ""
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "importfileload": {
                "docstring": "Load the attribute map a specified file."
            }, 
            "importfilemode": {
                "docstring": "Specifies the channel to import. The valid entries here are: \"alpha\", \"luminance\", \"red\", \"green\", \"blue\", and \"rgb\" C: Default is \"alpha\". Q: When queried, it returns a string."
            }, 
            "importreassign": {
                "docstring": "Specifies if the multiply atrribute maps are to be reassigned while importing. Only maps previously exported from within Artisan can be reassigned. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "keepaspectratio": {
                "docstring": "States if the aspect ratio of the file texture sizes should remain constant. Default is true. boolean."
            }, 
            "lastRecorderCmd": {
                "docstring": ""
            }, 
            "lastStampName": {
                "docstring": ""
            }, 
            "lowerradius": {
                "docstring": "Sets the lower size of the brush (only apply on tablet)."
            }, 
            "makeStroke": {
                "docstring": ""
            }, 
            "mappressure": {
                "docstring": "Sets the tablet pressure mapping when the table is used. There are four options: \"none\" - the pressure has no effect, \"opacity\" - the pressure is mapped to the opacity, \"radius\" - the is mapped to modify the radius of the brush, \"both\" - the pressure modifies both the opacity and the radius. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "opacity": {
                "docstring": "Sets the brush opacity. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "outline": {
                "docstring": "Specifies if the brush should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "outwhilepaint": {
                "docstring": "Specifies if the brush outline should be drawn while painting. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "paintmode": {
                "docstring": "Specifies the paint mode. There are two possibilities: \"screen\" and \"tangent\". C: Default is \"screen\". Q: When queried, it returns a string."
            }, 
            "paintoperationtype": {
                "docstring": "Specifies the operation type used by the Paint Tool. Currently, we support the following paint modes: \"Paint\", \"Smear\", \"Blur\", \"Erase\" and \"Clone\". Default is \"Paint\"."
            }, 
            "painttxtattr": {
                "docstring": "Specifies the attribute on the shader which the user wants to paint. Currently, we support the following attributes: \"Color\", \"Transparency\", \"Ambient\", \"Incandescence\", \"BumpMap\", \"Diffuse\", \"Translucence\" \"Eccentricity\" \"SpecularColor\", \"Reflectivity\", \"ReflectedColor\". Default is \"Color\"."
            }, 
            "painttxtattrname": {
                "docstring": "Returns a string with the names of all paintable attributes supported by the Paint Texture Tool."
            }, 
            "pfxScale": {
                "docstring": "Specifies the scale for Paint Effect brushes."
            }, 
            "pfxWidth": {
                "docstring": "Specifies the width for Paint Effect brushes."
            }, 
            "pickColor": {
                "docstring": ""
            }, 
            "pickValue": {
                "docstring": ""
            }, 
            "playbackCursor": {
                "docstring": ""
            }, 
            "playbackPressure": {
                "docstring": ""
            }, 
            "preserveclonesource": {
                "docstring": ""
            }, 
            "pressureMapping1": {
                "docstring": ""
            }, 
            "pressureMapping2": {
                "docstring": ""
            }, 
            "pressureMapping3": {
                "docstring": ""
            }, 
            "pressureMax1": {
                "docstring": ""
            }, 
            "pressureMax2": {
                "docstring": ""
            }, 
            "pressureMax3": {
                "docstring": ""
            }, 
            "pressureMin1": {
                "docstring": ""
            }, 
            "pressureMin2": {
                "docstring": ""
            }, 
            "pressureMin3": {
                "docstring": ""
            }, 
            "profileShapeFile": {
                "docstring": "Passes a name of the image file for the stamp shape profile."
            }, 
            "projective": {
                "docstring": "Specifies the projective paint mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Sets the size of the brush. C: Default is 1.0 cm. Q: When queried, it returns a float."
            }, 
            "record": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "Specifies the reflection mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "reflectionaboutorigin": {
                "docstring": ""
            }, 
            "reflectionaxis": {
                "docstring": "Specifies the reflection axis. There are three possibilities: \"x\", \"y\" and \"z\". C: Default is \"x\". Q: When queried, it returns a string."
            }, 
            "reloadtexfile": {
                "docstring": "Sends a request to the tool to reload the texture from the disc."
            }, 
            "resizeratio": {
                "docstring": "Specifies the scale by which to resize the current textures."
            }, 
            "resizetxt": {
                "docstring": "Sends a request to the tool to resize all the currently in use textures."
            }, 
            "rgbcolor": {
                "docstring": ""
            }, 
            "rgbflood": {
                "docstring": ""
            }, 
            "saveTextureOnStroke": {
                "docstring": "States if the original texture will be automatically saved on each stroke. Default is false."
            }, 
            "saveonstroke": {
                "docstring": "States if the temporary texture will be automatically saved on each stroke. Default is false."
            }, 
            "savetexture": {
                "docstring": "Sends a request to the tool to save the texture to the disc."
            }, 
            "screenRadius": {
                "docstring": ""
            }, 
            "selectclonesource": {
                "docstring": ""
            }, 
            "shadernames": {
                "docstring": "Returns a string with the names of all shaders assigned to selected surfaces."
            }, 
            "shapenames": {
                "docstring": "Returns a string with the names of all surfaces which are being painted on."
            }, 
            "showactive": {
                "docstring": "Sets on/off the display of the surface isoparms. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "stampDepth": {
                "docstring": ""
            }, 
            "stampProfile": {
                "docstring": "Sets the brush profile of the current stamp. Currently, the following profiles are supported: \"gaussian\", \"soft\", \"solid\" and \"square\". C: Default is gaussian. Q: When queried, it returns a string."
            }, 
            "stampSpacing": {
                "docstring": "Specifies the stamp spacing. Default is 1.0."
            }, 
            "strokesmooth": {
                "docstring": ""
            }, 
            "surfaceConformedBrushVertices": {
                "docstring": "Enables/disables the the display of the effective brush area as affected vertices."
            }, 
            "tablet": {
                "docstring": "Returns true if the tablet device is present, false if it is absent"
            }, 
            "tangentOutline": {
                "docstring": "Enables/disables the display of the brush circle tangent to the surface."
            }, 
            "updateEraseTex": {
                "docstring": ""
            }, 
            "usepressure": {
                "docstring": "Sets the tablet pressure on/off. C: Default is false. Q: When queried, it returns a boolean."
            }, 
            "worldRadius": {
                "docstring": ""
            }
        }
    }, 
    "artAttr": {
        "description": "", 
        "flags": {}
    }, 
    "artAttrCtx": {
        "description": "This is a context command to set the flags on the artAttrContext, which is the base context for attribute painting operations. All commands require the name of the context as the last argument as this provides the name of the context to create, edit or query. This is a context command to set the flags on the Attribute Paint Tool context. ", 
        "flags": {
            "accopacity": {
                "docstring": "Sets opacity accumulation on/off. C: Default is false (Except for sculpt tool for which it is true by default). Q: When queried, it returns a boolean."
            }, 
            "activeListChangedProc": {
                "docstring": "Accpts a string which contains a MEL command that is invoked whenever the active list changes. There may be some situations where the UI, for example, needs to be updated, when objects are selected/deselected in the scene. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "afterStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately after the end of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "alphaclamp": {
                "docstring": "Specifies if the weight value should be alpha clamped to the lower and upper bounds. There are four options here: \"none\" - no clamping is performed, \"lower\" - clamps only to the lower bound, \"upper\" - clamps only to the upper bounds, \"both\" - clamps to the lower and upper bounds. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "alphaclamplower": {
                "docstring": "Specifies the lower bound for the alpha values. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "alphaclampupper": {
                "docstring": "Specifies the upper bound for the alpha values. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "attrSelected": {
                "docstring": "Returns a name of the currently selected attribute. Q: When queried, it returns a string."
            }, 
            "beforeStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately before the start of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "brushalignment": {
                "docstring": "Specifies the path brush alignemnt. If true, the brush will align to stroke path, otherwise it will align to up vector. C: Default is true. Q: When queried, it returns a boolean."
            }, 
            "brushfeedback": {
                "docstring": "Specifies if the brush additional feedback should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "clamp": {
                "docstring": "Specifies if the weight value should be clamped to the lower and upper bounds. There are four options here: \"none\" - no clamping is performed, \"lower\" - clamps only to the lower bound, \"upper\" - clamps only to the upper bounds, \"both\" - clamps to the lower and upper bounds. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "clamplower": {
                "docstring": "Specifies the lower bound for the values. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "clampupper": {
                "docstring": "Specifies the upper bound for the values. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "clear": {
                "docstring": "Floods all cvs/vertices to the current value."
            }, 
            "colorAlphaValue": {
                "docstring": ""
            }, 
            "colorRGBAValue": {
                "docstring": ""
            }, 
            "colorRGBValue": {
                "docstring": ""
            }, 
            "colorRamp": {
                "docstring": "Allows a user defined color ramp to be used to map values to colors."
            }, 
            "colorfeedback": {
                "docstring": "Sets on/off the color feedback display. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "colorfeedbackOverride": {
                "docstring": ""
            }, 
            "colorrangelower": {
                "docstring": "Specifies the value which maps to black when color feedback mode is on C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "colorrangeupper": {
                "docstring": "Specifies the value which maps to the maximum color when color feedback mode is on C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "dataTypeIndex": {
                "docstring": "When the selected paintable attribute is a vectorArray, it specifies which field to paint on."
            }, 
            "disablelighting": {
                "docstring": "If color feedback is on, this flag determines whether lighting is disabled or not for the surfaces that are affected C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "dragSlider": {
                "docstring": "Sets the current brush drag state for resizing or offsetting the brush (like the 'b' and 'm' default hotkeys). The string argument is one of: \"radius\", \"lowradius\", \"opacity\", \"value\", \"depth\", \"displacement\", \"uvvector\" or \"none\". C: Default is \"none\"."
            }, 
            "duringStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command during the stroke, each time the mouse is dragged. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "dynclonemode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandfilename": {
                "docstring": "If true, it will expand the name of the export file and concatenate it with the surface name. Otherwise it will take the name as it is. C: Default is true."
            }, 
            "exportaspectratio": {
                "docstring": ""
            }, 
            "exportfilemode": {
                "docstring": "Specifies the export channel.The valid entries here are: \"alpha\", \"luminance\", \"rgb\", \"rgba\". C: Default is \"luminance/rgb\". Q: When queried, it returns a string."
            }, 
            "exportfilesave": {
                "docstring": "Exports the attribute map and saves to a specified file."
            }, 
            "exportfilesizex": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfilesizey": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfiletype": {
                "docstring": "Specifies the image file format. It can be one of the following: \"iff\", \"tiff\", \"jpeg\", \"alias\", \"rgb\", \"fit\" \"postScriptEPS\", \"softimage\", \"wavefrontRLA\", \"wavefrontEXP\". C: default is tiff. Q: When queried, it returns a string."
            }, 
            "filterNodes": {
                "docstring": "Sets the node filter."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "importfileload": {
                "docstring": "Load the attribute map a specified file."
            }, 
            "importfilemode": {
                "docstring": "Specifies the channel to import. The valid entries here are: \"alpha\", \"luminance\", \"red\", \"green\", \"blue\", and \"rgb\" C: Default is \"alpha\". Q: When queried, it returns a string."
            }, 
            "importreassign": {
                "docstring": "Specifies if the multiply atrribute maps are to be reassigned while importing. Only maps previously exported from within Artisan can be reassigned. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "interactiveUpdate": {
                "docstring": "Specifies how often to transfer the painted values into the attribute. TRUE: transfer them \"continuously\" (many times per stroke) FALSE: transfer them only at the end of a stroke (on mouse button release) C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "lastRecorderCmd": {
                "docstring": ""
            }, 
            "lastStampName": {
                "docstring": ""
            }, 
            "lowerradius": {
                "docstring": "Sets the lower size of the brush (only apply on tablet)."
            }, 
            "makeStroke": {
                "docstring": ""
            }, 
            "mappressure": {
                "docstring": "Sets the tablet pressure mapping when the table is used. There are four options: \"none\" - the pressure has no effect, \"opacity\" - the pressure is mapped to the opacity, \"radius\" - the is mapped to modify the radius of the brush, \"both\" - the pressure modifies both the opacity and the radius. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "maxvalue": {
                "docstring": "Specifies the maximum value for each attribute. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "minvalue": {
                "docstring": "Specifies the minimum value for each attribute. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "objattrArray": {
                "docstring": "An array of all paintable attributes. Each element of the array is a string with the following information: NodeType.NodeName.AttributeName.MenuType \\*MenuType: type(level) of the item in the Menu (UI). Q: When queried, it returns a string."
            }, 
            "opacity": {
                "docstring": "Sets the brush opacity. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "outline": {
                "docstring": "Specifies if the brush should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "outwhilepaint": {
                "docstring": "Specifies if the brush outline should be drawn while painting. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "paintNodeArray": {
                "docstring": "An array of paintable nodes. Q: When queried, it returns a string."
            }, 
            "paintattrselected": {
                "docstring": "An array of selected paintable attributes. Each element of the array is a string with the following information: NodeType.NodeName.AttributeName."
            }, 
            "paintmode": {
                "docstring": "Specifies the paint mode. There are two possibilities: \"screen\" and \"tangent\". C: Default is \"screen\". Q: When queried, it returns a string."
            }, 
            "paintoperationtype": {
                "docstring": ""
            }, 
            "pickColor": {
                "docstring": ""
            }, 
            "pickValue": {
                "docstring": ""
            }, 
            "playbackCursor": {
                "docstring": ""
            }, 
            "playbackPressure": {
                "docstring": ""
            }, 
            "preserveclonesource": {
                "docstring": ""
            }, 
            "profileShapeFile": {
                "docstring": "Passes a name of the image file for the stamp shape profile."
            }, 
            "projective": {
                "docstring": "Specifies the projective paint mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Sets the size of the brush. C: Default is 1.0 cm. Q: When queried, it returns a float."
            }, 
            "rampMaxColor": {
                "docstring": "Defines a special color to be used when the value is greater than or equal to the maximum value."
            }, 
            "rampMinColor": {
                "docstring": "Defines a special color to be used when the value is less than or equal to the minimum value."
            }, 
            "record": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "Specifies the reflection mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "reflectionaboutorigin": {
                "docstring": ""
            }, 
            "reflectionaxis": {
                "docstring": "Specifies the reflection axis. There are three possibilities: \"x\", \"y\" and \"z\". C: Default is \"x\". Q: When queried, it returns a string."
            }, 
            "screenRadius": {
                "docstring": ""
            }, 
            "selectclonesource": {
                "docstring": ""
            }, 
            "selectedattroper": {
                "docstring": "Sets the edit weight operation. Four edit weights operations are provided : \"absolute\" - the value of the weight is replaced by the current one, \"additive\" - the value of the weight is added to the current one, \"scale\" - the value of the weight is multiplied by the current one, \"smooth\" - the value of the weight is divided by the current one. C: Default is \"absolute\". Q: When queried, it returns a string."
            }, 
            "showactive": {
                "docstring": "Sets on/off the display of the surface isoparms. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "stampDepth": {
                "docstring": ""
            }, 
            "stampProfile": {
                "docstring": "Sets the brush profile of the current stamp. Currently, the following profiles are supported: \"gaussian\", \"soft\", \"solid\" and \"square\". C: Default is gaussian. Q: When queried, it returns a string."
            }, 
            "stampSpacing": {
                "docstring": ""
            }, 
            "strokesmooth": {
                "docstring": ""
            }, 
            "surfaceConformedBrushVertices": {
                "docstring": "Enables/disables the the display of the effective brush area as affected vertices."
            }, 
            "tablet": {
                "docstring": "Returns true if the tablet device is present, false if it is absent"
            }, 
            "tangentOutline": {
                "docstring": "Enables/disables the display of the brush circle tangent to the surface."
            }, 
            "toolOffProc": {
                "docstring": "Accepts a strings describing the name of a MEL procedure which is invoked whenever the tool is turned off. For example, cloth invokes \"clothPaintToolOff\" when the cloth paint tool is turned on. Define this callback if your tool requires special functionality when your tool is deactivated. It is typical that if you implement a toolOffProc you will want to implement a toolOnProc as well (see the -toolOnProc flag. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "toolOnProc": {
                "docstring": "Accepts a strings describing the name of a MEL procedure which is invoked whenever the tool is turned on. For example, cloth invokes \"clothPaintToolOn\" when the cloth paint tool is turned on. Define this callback if your tool requires special functionality when your tool is activated. It is typical that if you implement a toolOnProc you will want to implement a toolOffProc as well (see the -toolOffProc flag. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "useColorRamp": {
                "docstring": "Specifies whether the user defined color ramp should be used to map values from to colors. If this is turned off, the default greyscale feedback will be used."
            }, 
            "useMaxMinColor": {
                "docstring": "Specifies whether the out of range colors should be used. See rampMinColor and rampMaxColor flags for further details."
            }, 
            "usepressure": {
                "docstring": "Sets the tablet pressure on/off. C: Default is false. Q: When queried, it returns a boolean."
            }, 
            "value": {
                "docstring": "Specifies the value for each attribute. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "whichTool": {
                "docstring": "The string defines the name of the tool to be used for the Artisan context. An example is \"artClothPaint\". In query mode, the tool name for the given context is returned. Note: due to the way MEL works, always specify the -query flag last when specifying a flag which takes arguments."
            }, 
            "worldRadius": {
                "docstring": ""
            }
        }
    }, 
    "artAttrPaintVertexCtx": {
        "description": "This is a context command to set the flags on the artAttrContext, which is the base context for attribute painting operations. All commands require the name of the context as the last argument as this provides the name of the context to create, edit or query. This is a context command to set the flags on the Paint color on vertex Tool context. In query mode, return type is based on queried flag.", 
        "flags": {
            "accopacity": {
                "docstring": "Sets opacity accumulation on/off. C: Default is false (Except for sculpt tool for which it is true by default). Q: When queried, it returns a boolean."
            }, 
            "activeListChangedProc": {
                "docstring": "Accpts a string which contains a MEL command that is invoked whenever the active list changes. There may be some situations where the UI, for example, needs to be updated, when objects are selected/deselected in the scene. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "afterStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately after the end of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "alphaclamp": {
                "docstring": "Specifies if the weight value should be alpha clamped to the lower and upper bounds. There are four options here: \"none\" - no clamping is performed, \"lower\" - clamps only to the lower bound, \"upper\" - clamps only to the upper bounds, \"both\" - clamps to the lower and upper bounds. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "alphaclamplower": {
                "docstring": "Specifies the lower bound for the alpha values. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "alphaclampupper": {
                "docstring": "Specifies the upper bound for the alpha values. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "attrSelected": {
                "docstring": "Returns a name of the currently selected attribute. Q: When queried, it returns a string."
            }, 
            "beforeStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately before the start of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "brushalignment": {
                "docstring": "Specifies the path brush alignemnt. If true, the brush will align to stroke path, otherwise it will align to up vector. C: Default is true. Q: When queried, it returns a boolean."
            }, 
            "brushfeedback": {
                "docstring": "Specifies if the brush additional feedback should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "clamp": {
                "docstring": "Specifies if the weight value should be clamped to the lower and upper bounds. There are four options here: \"none\" - no clamping is performed, \"lower\" - clamps only to the lower bound, \"upper\" - clamps only to the upper bounds, \"both\" - clamps to the lower and upper bounds. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "clamplower": {
                "docstring": "Specifies the lower bound for the values. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "clampupper": {
                "docstring": "Specifies the upper bound for the values. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "clear": {
                "docstring": "Floods all cvs/vertices to the current value."
            }, 
            "colorAlphaValue": {
                "docstring": ""
            }, 
            "colorRGBAValue": {
                "docstring": ""
            }, 
            "colorRGBValue": {
                "docstring": ""
            }, 
            "colorRamp": {
                "docstring": "Allows a user defined color ramp to be used to map values to colors."
            }, 
            "colorfeedback": {
                "docstring": "Sets on/off the color feedback display. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "colorfeedbackOverride": {
                "docstring": ""
            }, 
            "colorrangelower": {
                "docstring": "Specifies the value which maps to black when color feedback mode is on C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "colorrangeupper": {
                "docstring": "Specifies the value which maps to the maximum color when color feedback mode is on C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "dataTypeIndex": {
                "docstring": "When the selected paintable attribute is a vectorArray, it specifies which field to paint on."
            }, 
            "disablelighting": {
                "docstring": "If color feedback is on, this flag determines whether lighting is disabled or not for the surfaces that are affected C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "dragSlider": {
                "docstring": "Sets the current brush drag state for resizing or offsetting the brush (like the 'b' and 'm' default hotkeys). The string argument is one of: \"radius\", \"lowradius\", \"opacity\", \"value\", \"depth\", \"displacement\", \"uvvector\" or \"none\". C: Default is \"none\"."
            }, 
            "duringStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command during the stroke, each time the mouse is dragged. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "dynclonemode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandfilename": {
                "docstring": "If true, it will expand the name of the export file and concatenate it with the surface name. Otherwise it will take the name as it is. C: Default is true."
            }, 
            "exportaspectratio": {
                "docstring": ""
            }, 
            "exportfilemode": {
                "docstring": "Specifies the export channel.The valid entries here are: \"alpha\", \"luminance\", \"rgb\", \"rgba\". C: Default is \"luminance/rgb\". Q: When queried, it returns a string."
            }, 
            "exportfilesave": {
                "docstring": "Exports the attribute map and saves to a specified file."
            }, 
            "exportfilesizex": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfilesizey": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfiletype": {
                "docstring": "Specifies the image file format. It can be one of the following: \"iff\", \"tiff\", \"jpeg\", \"alias\", \"rgb\", \"fit\" \"postScriptEPS\", \"softimage\", \"wavefrontRLA\", \"wavefrontEXP\". C: default is tiff. Q: When queried, it returns a string."
            }, 
            "filterNodes": {
                "docstring": "Sets the node filter."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "importfileload": {
                "docstring": "Load the attribute map a specified file."
            }, 
            "importfilemode": {
                "docstring": "Specifies the channel to import. The valid entries here are: \"alpha\", \"luminance\", \"red\", \"green\", \"blue\", and \"rgb\" C: Default is \"alpha\". Q: When queried, it returns a string."
            }, 
            "importreassign": {
                "docstring": "Specifies if the multiply atrribute maps are to be reassigned while importing. Only maps previously exported from within Artisan can be reassigned. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "interactiveUpdate": {
                "docstring": "Specifies how often to transfer the painted values into the attribute. TRUE: transfer them \"continuously\" (many times per stroke) FALSE: transfer them only at the end of a stroke (on mouse button release) C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "lastRecorderCmd": {
                "docstring": ""
            }, 
            "lastStampName": {
                "docstring": ""
            }, 
            "lowerradius": {
                "docstring": "Sets the lower size of the brush (only apply on tablet)."
            }, 
            "makeStroke": {
                "docstring": ""
            }, 
            "mappressure": {
                "docstring": "Sets the tablet pressure mapping when the table is used. There are four options: \"none\" - the pressure has no effect, \"opacity\" - the pressure is mapped to the opacity, \"radius\" - the is mapped to modify the radius of the brush, \"both\" - the pressure modifies both the opacity and the radius. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "maxvalue": {
                "docstring": "Specifies the maximum value for each attribute. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "minvalue": {
                "docstring": "Specifies the minimum value for each attribute. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "objattrArray": {
                "docstring": "An array of all paintable attributes. Each element of the array is a string with the following information: NodeType.NodeName.AttributeName.MenuType \\*MenuType: type(level) of the item in the Menu (UI). Q: When queried, it returns a string."
            }, 
            "opacity": {
                "docstring": "Sets the brush opacity. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "outline": {
                "docstring": "Specifies if the brush should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "outwhilepaint": {
                "docstring": "Specifies if the brush outline should be drawn while painting. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "paintComponent": {
                "docstring": "Specifies whether face or vertex or vertex face is being painted. 1 - Vertex 2 - VertexFace 3 - Face C: Default is Vertex. Q: When queried, it returns a int."
            }, 
            "paintNodeArray": {
                "docstring": "An array of paintable nodes. Q: When queried, it returns a string."
            }, 
            "paintNumChannels": {
                "docstring": ""
            }, 
            "paintRGBA": {
                "docstring": "Specifies whether RGB or RGBA channels are being painted. TRUE: RGBA channels. FALSE: RGB channels. Alpha channel remains unaffected. C: Default is FALSE (Painting RGB channels). Q: When queried, it returns a int."
            }, 
            "paintVertexFace": {
                "docstring": "Specifies whether vertex face is being painted. TRUE: Vertex face being painted. (Allows each face connected to the vertex to be painted) FALSE: Vertex being painted.(affects all connected faces) C: Default is FALSE. Q: When queried, it returns a int."
            }, 
            "paintattrselected": {
                "docstring": "An array of selected paintable attributes. Each element of the array is a string with the following information: NodeType.NodeName.AttributeName."
            }, 
            "paintmode": {
                "docstring": "Specifies the paint mode. There are two possibilities: \"screen\" and \"tangent\". C: Default is \"screen\". Q: When queried, it returns a string."
            }, 
            "paintoperationtype": {
                "docstring": ""
            }, 
            "pickColor": {
                "docstring": ""
            }, 
            "pickValue": {
                "docstring": ""
            }, 
            "playbackCursor": {
                "docstring": ""
            }, 
            "playbackPressure": {
                "docstring": ""
            }, 
            "preserveclonesource": {
                "docstring": ""
            }, 
            "profileShapeFile": {
                "docstring": "Passes a name of the image file for the stamp shape profile."
            }, 
            "projective": {
                "docstring": "Specifies the projective paint mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Sets the size of the brush. C: Default is 1.0 cm. Q: When queried, it returns a float."
            }, 
            "rampMaxColor": {
                "docstring": "Defines a special color to be used when the value is greater than or equal to the maximum value."
            }, 
            "rampMinColor": {
                "docstring": "Defines a special color to be used when the value is less than or equal to the minimum value."
            }, 
            "record": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "Specifies the reflection mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "reflectionaboutorigin": {
                "docstring": ""
            }, 
            "reflectionaxis": {
                "docstring": "Specifies the reflection axis. There are three possibilities: \"x\", \"y\" and \"z\". C: Default is \"x\". Q: When queried, it returns a string."
            }, 
            "screenRadius": {
                "docstring": ""
            }, 
            "selectclonesource": {
                "docstring": ""
            }, 
            "selectedattroper": {
                "docstring": "Sets the edit weight operation. Four edit weights operations are provided : \"absolute\" - the value of the weight is replaced by the current one, \"additive\" - the value of the weight is added to the current one, \"scale\" - the value of the weight is multiplied by the current one, \"smooth\" - the value of the weight is divided by the current one. C: Default is \"absolute\". Q: When queried, it returns a string."
            }, 
            "showactive": {
                "docstring": "Sets on/off the display of the surface isoparms. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "stampDepth": {
                "docstring": ""
            }, 
            "stampProfile": {
                "docstring": "Sets the brush profile of the current stamp. Currently, the following profiles are supported: \"gaussian\", \"soft\", \"solid\" and \"square\". C: Default is gaussian. Q: When queried, it returns a string."
            }, 
            "stampSpacing": {
                "docstring": ""
            }, 
            "strokesmooth": {
                "docstring": ""
            }, 
            "surfaceConformedBrushVertices": {
                "docstring": "Enables/disables the the display of the effective brush area as affected vertices."
            }, 
            "tablet": {
                "docstring": "Returns true if the tablet device is present, false if it is absent"
            }, 
            "tangentOutline": {
                "docstring": "Enables/disables the display of the brush circle tangent to the surface."
            }, 
            "toolOffProc": {
                "docstring": "Accepts a strings describing the name of a MEL procedure which is invoked whenever the tool is turned off. For example, cloth invokes \"clothPaintToolOff\" when the cloth paint tool is turned on. Define this callback if your tool requires special functionality when your tool is deactivated. It is typical that if you implement a toolOffProc you will want to implement a toolOnProc as well (see the -toolOnProc flag. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "toolOnProc": {
                "docstring": "Accepts a strings describing the name of a MEL procedure which is invoked whenever the tool is turned on. For example, cloth invokes \"clothPaintToolOn\" when the cloth paint tool is turned on. Define this callback if your tool requires special functionality when your tool is activated. It is typical that if you implement a toolOnProc you will want to implement a toolOffProc as well (see the -toolOffProc flag. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "useColorRamp": {
                "docstring": "Specifies whether the user defined color ramp should be used to map values from to colors. If this is turned off, the default greyscale feedback will be used."
            }, 
            "useMaxMinColor": {
                "docstring": "Specifies whether the out of range colors should be used. See rampMinColor and rampMaxColor flags for further details."
            }, 
            "usepressure": {
                "docstring": "Sets the tablet pressure on/off. C: Default is false. Q: When queried, it returns a boolean."
            }, 
            "value": {
                "docstring": "Specifies the value for each attribute. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "vertexColorRange": {
                "docstring": "Specifies whether the vertex color range should be applied to the currently selected object. C: Default is false Q: When queried, it returns a boolean."
            }, 
            "vertexColorRangeLower": {
                "docstring": "Specifies the min value of the vertex color range. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "vertexColorRangeUpper": {
                "docstring": "Specifies the max value of the vertex color range. C: Default is 1.0. Q: When queried, it returns a float.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "whichTool": {
                "docstring": "The string defines the name of the tool to be used for the Artisan context. An example is \"artClothPaint\". In query mode, the tool name for the given context is returned. Note: due to the way MEL works, always specify the -query flag last when specifying a flag which takes arguments."
            }, 
            "worldRadius": {
                "docstring": ""
            }
        }
    }, 
    "artAttrSkinPaintCtx": {
        "description": "This is a context command to set the flags on the artAttrContext, which is the base context for attribute painting operations. All commands require the name of the context as the last argument as this provides the name of the context to create, edit or query. This is a context command to set the flags on the Paint skin weights tool context. In query mode, return type is based on queried flag.", 
        "flags": {
            "accopacity": {
                "docstring": "Sets opacity accumulation on/off. C: Default is false (Except for sculpt tool for which it is true by default). Q: When queried, it returns a boolean."
            }, 
            "activeListChangedProc": {
                "docstring": "Accpts a string which contains a MEL command that is invoked whenever the active list changes. There may be some situations where the UI, for example, needs to be updated, when objects are selected/deselected in the scene. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "afterStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately after the end of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "alphaclamp": {
                "docstring": "Specifies if the weight value should be alpha clamped to the lower and upper bounds. There are four options here: \"none\" - no clamping is performed, \"lower\" - clamps only to the lower bound, \"upper\" - clamps only to the upper bounds, \"both\" - clamps to the lower and upper bounds. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "alphaclamplower": {
                "docstring": "Specifies the lower bound for the alpha values. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "alphaclampupper": {
                "docstring": "Specifies the upper bound for the alpha values. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "attrSelected": {
                "docstring": "Returns a name of the currently selected attribute. Q: When queried, it returns a string."
            }, 
            "beforeStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately before the start of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "brushalignment": {
                "docstring": "Specifies the path brush alignemnt. If true, the brush will align to stroke path, otherwise it will align to up vector. C: Default is true. Q: When queried, it returns a boolean."
            }, 
            "brushfeedback": {
                "docstring": "Specifies if the brush additional feedback should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "clamp": {
                "docstring": "Specifies if the weight value should be clamped to the lower and upper bounds. There are four options here: \"none\" - no clamping is performed, \"lower\" - clamps only to the lower bound, \"upper\" - clamps only to the upper bounds, \"both\" - clamps to the lower and upper bounds. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "clamplower": {
                "docstring": "Specifies the lower bound for the values. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "clampupper": {
                "docstring": "Specifies the upper bound for the values. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "clear": {
                "docstring": "Floods all cvs/vertices to the current value."
            }, 
            "colorAlphaValue": {
                "docstring": ""
            }, 
            "colorRGBAValue": {
                "docstring": ""
            }, 
            "colorRGBValue": {
                "docstring": ""
            }, 
            "colorRamp": {
                "docstring": "Allows a user defined color ramp to be used to map values to colors."
            }, 
            "colorfeedback": {
                "docstring": "Sets on/off the color feedback display. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "colorfeedbackOverride": {
                "docstring": ""
            }, 
            "colorrangelower": {
                "docstring": "Specifies the value which maps to black when color feedback mode is on C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "colorrangeupper": {
                "docstring": "Specifies the value which maps to the maximum color when color feedback mode is on C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "dataTypeIndex": {
                "docstring": "When the selected paintable attribute is a vectorArray, it specifies which field to paint on."
            }, 
            "disablelighting": {
                "docstring": "If color feedback is on, this flag determines whether lighting is disabled or not for the surfaces that are affected C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "dragSlider": {
                "docstring": "Sets the current brush drag state for resizing or offsetting the brush (like the 'b' and 'm' default hotkeys). The string argument is one of: \"radius\", \"lowradius\", \"opacity\", \"value\", \"depth\", \"displacement\", \"uvvector\" or \"none\". C: Default is \"none\"."
            }, 
            "duringStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command during the stroke, each time the mouse is dragged. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "dynclonemode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandfilename": {
                "docstring": "If true, it will expand the name of the export file and concatenate it with the surface name. Otherwise it will take the name as it is. C: Default is true."
            }, 
            "exportaspectratio": {
                "docstring": ""
            }, 
            "exportfilemode": {
                "docstring": "Specifies the export channel.The valid entries here are: \"alpha\", \"luminance\", \"rgb\", \"rgba\". C: Default is \"luminance/rgb\". Q: When queried, it returns a string."
            }, 
            "exportfilesave": {
                "docstring": "Exports the attribute map and saves to a specified file."
            }, 
            "exportfilesizex": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfilesizey": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfiletype": {
                "docstring": "Specifies the image file format. It can be one of the following: \"iff\", \"tiff\", \"jpeg\", \"alias\", \"rgb\", \"fit\" \"postScriptEPS\", \"softimage\", \"wavefrontRLA\", \"wavefrontEXP\". C: default is tiff. Q: When queried, it returns a string."
            }, 
            "filterNodes": {
                "docstring": "Sets the node filter."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "importfileload": {
                "docstring": "Load the attribute map a specified file."
            }, 
            "importfilemode": {
                "docstring": "Specifies the channel to import. The valid entries here are: \"alpha\", \"luminance\", \"red\", \"green\", \"blue\", and \"rgb\" C: Default is \"alpha\". Q: When queried, it returns a string."
            }, 
            "importreassign": {
                "docstring": "Specifies if the multiply atrribute maps are to be reassigned while importing. Only maps previously exported from within Artisan can be reassigned. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "influence": {
                "docstring": "Specifies which joint has been selected by the user for painting. Q: When queried, it returns a string."
            }, 
            "interactiveUpdate": {
                "docstring": "Specifies how often to transfer the painted values into the attribute. TRUE: transfer them \"continuously\" (many times per stroke) FALSE: transfer them only at the end of a stroke (on mouse button release) C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "lastRecorderCmd": {
                "docstring": ""
            }, 
            "lastStampName": {
                "docstring": ""
            }, 
            "lowerradius": {
                "docstring": "Sets the lower size of the brush (only apply on tablet)."
            }, 
            "makeStroke": {
                "docstring": ""
            }, 
            "mappressure": {
                "docstring": "Sets the tablet pressure mapping when the table is used. There are four options: \"none\" - the pressure has no effect, \"opacity\" - the pressure is mapped to the opacity, \"radius\" - the is mapped to modify the radius of the brush, \"both\" - the pressure modifies both the opacity and the radius. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "maxvalue": {
                "docstring": "Specifies the maximum value for each attribute. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "minvalue": {
                "docstring": "Specifies the minimum value for each attribute. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "objattrArray": {
                "docstring": "An array of all paintable attributes. Each element of the array is a string with the following information: NodeType.NodeName.AttributeName.MenuType \\*MenuType: type(level) of the item in the Menu (UI). Q: When queried, it returns a string."
            }, 
            "opacity": {
                "docstring": "Sets the brush opacity. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "outline": {
                "docstring": "Specifies if the brush should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "outwhilepaint": {
                "docstring": "Specifies if the brush outline should be drawn while painting. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "paintNodeArray": {
                "docstring": "An array of paintable nodes. Q: When queried, it returns a string."
            }, 
            "paintSelectMode": {
                "docstring": "Specifies whether the paint select tool: adds to selection (1) removes from selection (2), toggles selection (3) Q: When queried, it returns an int as defined above.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "paintattrselected": {
                "docstring": "An array of selected paintable attributes. Each element of the array is a string with the following information: NodeType.NodeName.AttributeName."
            }, 
            "paintmode": {
                "docstring": "Specifies the paint mode. There are two possibilities: \"screen\" and \"tangent\". C: Default is \"screen\". Q: When queried, it returns a string."
            }, 
            "paintoperationtype": {
                "docstring": ""
            }, 
            "pickColor": {
                "docstring": ""
            }, 
            "pickValue": {
                "docstring": ""
            }, 
            "playbackCursor": {
                "docstring": ""
            }, 
            "playbackPressure": {
                "docstring": ""
            }, 
            "preserveclonesource": {
                "docstring": ""
            }, 
            "profileShapeFile": {
                "docstring": "Passes a name of the image file for the stamp shape profile."
            }, 
            "projective": {
                "docstring": "Specifies the projective paint mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Sets the size of the brush. C: Default is 1.0 cm. Q: When queried, it returns a float."
            }, 
            "rampMaxColor": {
                "docstring": "Defines a special color to be used when the value is greater than or equal to the maximum value."
            }, 
            "rampMinColor": {
                "docstring": "Defines a special color to be used when the value is less than or equal to the minimum value."
            }, 
            "record": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "Specifies the reflection mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "reflectionaboutorigin": {
                "docstring": ""
            }, 
            "reflectionaxis": {
                "docstring": "Specifies the reflection axis. There are three possibilities: \"x\", \"y\" and \"z\". C: Default is \"x\". Q: When queried, it returns a string."
            }, 
            "screenRadius": {
                "docstring": ""
            }, 
            "selectclonesource": {
                "docstring": ""
            }, 
            "selectedattroper": {
                "docstring": "Sets the edit weight operation. Four edit weights operations are provided : \"absolute\" - the value of the weight is replaced by the current one, \"additive\" - the value of the weight is added to the current one, \"scale\" - the value of the weight is multiplied by the current one, \"smooth\" - the value of the weight is divided by the current one. C: Default is \"absolute\". Q: When queried, it returns a string."
            }, 
            "showactive": {
                "docstring": "Sets on/off the display of the surface isoparms. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "skinPaintMode": {
                "docstring": "Specifies whether the skin paint tool is in paint skin weights mode (1) Marquee select mode (0), or paint select mode (2) Q: When queried, it returns an int as defined above."
            }, 
            "stampDepth": {
                "docstring": ""
            }, 
            "stampProfile": {
                "docstring": "Sets the brush profile of the current stamp. Currently, the following profiles are supported: \"gaussian\", \"soft\", \"solid\" and \"square\". C: Default is gaussian. Q: When queried, it returns a string."
            }, 
            "stampSpacing": {
                "docstring": ""
            }, 
            "strokesmooth": {
                "docstring": ""
            }, 
            "surfaceConformedBrushVertices": {
                "docstring": "Enables/disables the the display of the effective brush area as affected vertices."
            }, 
            "tablet": {
                "docstring": "Returns true if the tablet device is present, false if it is absent"
            }, 
            "tangentOutline": {
                "docstring": "Enables/disables the display of the brush circle tangent to the surface."
            }, 
            "toolOffProc": {
                "docstring": "Accepts a strings describing the name of a MEL procedure which is invoked whenever the tool is turned off. For example, cloth invokes \"clothPaintToolOff\" when the cloth paint tool is turned on. Define this callback if your tool requires special functionality when your tool is deactivated. It is typical that if you implement a toolOffProc you will want to implement a toolOnProc as well (see the -toolOnProc flag. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "toolOnProc": {
                "docstring": "Accepts a strings describing the name of a MEL procedure which is invoked whenever the tool is turned on. For example, cloth invokes \"clothPaintToolOn\" when the cloth paint tool is turned on. Define this callback if your tool requires special functionality when your tool is activated. It is typical that if you implement a toolOnProc you will want to implement a toolOffProc as well (see the -toolOffProc flag. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "useColorRamp": {
                "docstring": "Specifies whether the user defined color ramp should be used to map values from to colors. If this is turned off, the default greyscale feedback will be used."
            }, 
            "useMaxMinColor": {
                "docstring": "Specifies whether the out of range colors should be used. See rampMinColor and rampMaxColor flags for further details."
            }, 
            "usepressure": {
                "docstring": "Sets the tablet pressure on/off. C: Default is false. Q: When queried, it returns a boolean."
            }, 
            "value": {
                "docstring": "Specifies the value for each attribute. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "whichTool": {
                "docstring": "The string defines the name of the tool to be used for the Artisan context. An example is \"artClothPaint\". In query mode, the tool name for the given context is returned. Note: due to the way MEL works, always specify the -query flag last when specifying a flag which takes arguments."
            }, 
            "worldRadius": {
                "docstring": ""
            }, 
            "xrayJoints": {
                "docstring": "Specifies whether joints should be displayed in xray mode while painting Q: When queried, it returns a boolean."
            }
        }
    }, 
    "artAttrTool": {
        "description": "The artAttrTool command manages the list of tool types which are used for attribute painting. This command supports querying the list contents as well as adding new tools to the list. Note that there is a set of built-in tools. The list of built-ins can be queried by starting Maya and doing an \"artAttrTool -q\". The tools which are managed by this command are all intended for attribute painting via Artisan: when you create a new context via artAttrCtx you specify the tool name via artAttrCtx's -whichToolflag. Typically the user may wish to simply use one of the built-in tools. However, if you need to have custom Properties and Values sheets asscociated with your tool, you will need to define a custom tool via artAttrTool -add \"toolName\". For an example of a custom attribute painting tool, see the devkit example customtoolPaint.mel. In query mode, return type is based on queried flag.", 
        "flags": {
            "add": {
                "docstring": "Adds the named tool to the internal list of tools."
            }, 
            "exists": {
                "docstring": "Checks if the named tool exists, returning true if found, and false otherwise."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Removes the named tool from the internal list of tools.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "artBaseCtx": {
        "description": "", 
        "flags": {
            "accopacity": {
                "docstring": ""
            }, 
            "afterStrokeCmd": {
                "docstring": ""
            }, 
            "beforeStrokeCmd": {
                "docstring": ""
            }, 
            "brushalignment": {
                "docstring": ""
            }, 
            "brushfeedback": {
                "docstring": ""
            }, 
            "clear": {
                "docstring": ""
            }, 
            "dragSlider": {
                "docstring": ""
            }, 
            "dynclonemode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "expandfilename": {
                "docstring": ""
            }, 
            "exportaspectratio": {
                "docstring": ""
            }, 
            "exportfilemode": {
                "docstring": ""
            }, 
            "exportfilesave": {
                "docstring": ""
            }, 
            "exportfilesizex": {
                "docstring": ""
            }, 
            "exportfilesizey": {
                "docstring": ""
            }, 
            "exportfiletype": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "importfileload": {
                "docstring": ""
            }, 
            "importfilemode": {
                "docstring": ""
            }, 
            "importreassign": {
                "docstring": ""
            }, 
            "lastRecorderCmd": {
                "docstring": ""
            }, 
            "lastStampName": {
                "docstring": ""
            }, 
            "lowerradius": {
                "docstring": ""
            }, 
            "makeStroke": {
                "docstring": ""
            }, 
            "mappressure": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "opacity": {
                "docstring": ""
            }, 
            "outline": {
                "docstring": ""
            }, 
            "outwhilepaint": {
                "docstring": ""
            }, 
            "paintmode": {
                "docstring": ""
            }, 
            "paintoperationtype": {
                "docstring": ""
            }, 
            "pickColor": {
                "docstring": ""
            }, 
            "pickValue": {
                "docstring": ""
            }, 
            "playbackCursor": {
                "docstring": ""
            }, 
            "playbackPressure": {
                "docstring": ""
            }, 
            "preserveclonesource": {
                "docstring": ""
            }, 
            "profileShapeFile": {
                "docstring": ""
            }, 
            "projective": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "record": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": ""
            }, 
            "reflectionaboutorigin": {
                "docstring": ""
            }, 
            "reflectionaxis": {
                "docstring": ""
            }, 
            "screenRadius": {
                "docstring": ""
            }, 
            "selectclonesource": {
                "docstring": ""
            }, 
            "showactive": {
                "docstring": ""
            }, 
            "stampDepth": {
                "docstring": ""
            }, 
            "stampProfile": {
                "docstring": ""
            }, 
            "stampSpacing": {
                "docstring": ""
            }, 
            "strokesmooth": {
                "docstring": ""
            }, 
            "surfaceConformedBrushVertices": {
                "docstring": ""
            }, 
            "tablet": {
                "docstring": ""
            }, 
            "tangentOutline": {
                "docstring": ""
            }, 
            "usepressure": {
                "docstring": ""
            }, 
            "worldRadius": {
                "docstring": ""
            }
        }
    }, 
    "artBuildPaintMenu": {
        "description": "?? ", 
        "flags": {}
    }, 
    "artFluidAttr": {
        "description": "", 
        "flags": {}
    }, 
    "artFluidAttrCtx": {
        "description": "This command is used to paint properties (such as density) of selected fluid volumes. In query mode, return type is based on queried flag.", 
        "flags": {
            "accopacity": {
                "docstring": "Sets opacity accumulation on/off. C: Default is false (Except for sculpt tool for which it is true by default). Q: When queried, it returns a boolean."
            }, 
            "activeListChangedProc": {
                "docstring": ""
            }, 
            "afterStrokeCmd": {
                "docstring": ""
            }, 
            "alphaclamp": {
                "docstring": ""
            }, 
            "alphaclamplower": {
                "docstring": ""
            }, 
            "alphaclampupper": {
                "docstring": ""
            }, 
            "attrSelected": {
                "docstring": ""
            }, 
            "autoSave": {
                "docstring": "A MEL command to save the fluid state. Called before an event which could overwrite unsaved values of painted fluid properties. Such events include: changing current time, changing the current paintable property, and exiting the paint tool. (To turn auto-save off, pass in an empty-valued string argument: e.g., \"\".)"
            }, 
            "beforeStrokeCmd": {
                "docstring": ""
            }, 
            "brushalignment": {
                "docstring": "Specifies the path brush alignemnt. If true, the brush will align to stroke path, otherwise it will align to up vector. C: Default is true. Q: When queried, it returns a boolean."
            }, 
            "brushfeedback": {
                "docstring": "Specifies if the brush additional feedback should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "clamp": {
                "docstring": ""
            }, 
            "clamplower": {
                "docstring": ""
            }, 
            "clampupper": {
                "docstring": ""
            }, 
            "clear": {
                "docstring": "Floods all cvs/vertices to the current value."
            }, 
            "colorAlphaValue": {
                "docstring": ""
            }, 
            "colorRGBAValue": {
                "docstring": ""
            }, 
            "colorRGBValue": {
                "docstring": ""
            }, 
            "colorRamp": {
                "docstring": ""
            }, 
            "colorfeedback": {
                "docstring": ""
            }, 
            "colorfeedbackOverride": {
                "docstring": ""
            }, 
            "colorrangelower": {
                "docstring": ""
            }, 
            "colorrangeupper": {
                "docstring": ""
            }, 
            "currentPaintableFluid": {
                "docstring": "Query the name of the fluid on which this context is currently painting. Returns string.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dataTypeIndex": {
                "docstring": ""
            }, 
            "delaySelectionChanged": {
                "docstring": "Internal use only. Under normal conditions, the tool responds to changes to the selection list so it can update its list of paintable geometry. When -dsl true is used, the tool will not update its paintable list until a corresponding -dsl false is called."
            }, 
            "disablelighting": {
                "docstring": ""
            }, 
            "displayAsRender": {
                "docstring": "When true, sets the \"Shaded Display\" attribute of the fluid to \"AsRender\": all fluid properties displayed as hardware rendered. When false, displays only the currently selected paintable attribute of the fluid."
            }, 
            "displayVelocity": {
                "docstring": "Turns on/off velocity display, independently of the above \"dar/displayAsRender\" setting. Use this flag to enable velocity display while only displaying density, for example."
            }, 
            "doAutoSave": {
                "docstring": "Execute the -autoSave command if there are unsaved painted fluid properties."
            }, 
            "dragSlider": {
                "docstring": "Sets the current brush drag state for resizing or offsetting the brush (like the 'b' and 'm' default hotkeys). The string argument is one of: \"radius\", \"lowradius\", \"opacity\", \"value\", \"depth\", \"displacement\", \"uvvector\" or \"none\". C: Default is \"none\"."
            }, 
            "duringStrokeCmd": {
                "docstring": ""
            }, 
            "dynclonemode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandfilename": {
                "docstring": "If true, it will expand the name of the export file and concatenate it with the surface name. Otherwise it will take the name as it is. C: Default is true."
            }, 
            "exportaspectratio": {
                "docstring": ""
            }, 
            "exportfilemode": {
                "docstring": "Specifies the export channel.The valid entries here are: \"alpha\", \"luminance\", \"rgb\", \"rgba\". C: Default is \"luminance/rgb\". Q: When queried, it returns a string."
            }, 
            "exportfilesave": {
                "docstring": "Exports the attribute map and saves to a specified file."
            }, 
            "exportfilesizex": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfilesizey": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfiletype": {
                "docstring": "Specifies the image file format. It can be one of the following: \"iff\", \"tiff\", \"jpeg\", \"alias\", \"rgb\", \"fit\" \"postScriptEPS\", \"softimage\", \"wavefrontRLA\", \"wavefrontEXP\". C: default is tiff. Q: When queried, it returns a string."
            }, 
            "filterNodes": {
                "docstring": ""
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "importfileload": {
                "docstring": "Load the attribute map a specified file."
            }, 
            "importfilemode": {
                "docstring": "Specifies the channel to import. The valid entries here are: \"alpha\", \"luminance\", \"red\", \"green\", \"blue\", and \"rgb\" C: Default is \"alpha\". Q: When queried, it returns a string."
            }, 
            "importreassign": {
                "docstring": "Specifies if the multiply atrribute maps are to be reassigned while importing. Only maps previously exported from within Artisan can be reassigned. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "interactiveUpdate": {
                "docstring": ""
            }, 
            "lastRecorderCmd": {
                "docstring": ""
            }, 
            "lastStampName": {
                "docstring": ""
            }, 
            "lowerradius": {
                "docstring": "Sets the lower size of the brush (only apply on tablet)."
            }, 
            "makeStroke": {
                "docstring": ""
            }, 
            "mappressure": {
                "docstring": "Sets the tablet pressure mapping when the table is used. There are four options: \"none\" - the pressure has no effect, \"opacity\" - the pressure is mapped to the opacity, \"radius\" - the is mapped to modify the radius of the brush, \"both\" - the pressure modifies both the opacity and the radius. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "maxvalue": {
                "docstring": ""
            }, 
            "minvalue": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "objattrArray": {
                "docstring": ""
            }, 
            "opacity": {
                "docstring": "Sets the brush opacity. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "outline": {
                "docstring": "Specifies if the brush should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "outwhilepaint": {
                "docstring": "Specifies if the brush outline should be drawn while painting. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "paintNodeArray": {
                "docstring": ""
            }, 
            "paintattrselected": {
                "docstring": ""
            }, 
            "paintmode": {
                "docstring": "Specifies the paint mode. There are two possibilities: \"screen\" and \"tangent\". C: Default is \"screen\". Q: When queried, it returns a string."
            }, 
            "paintoperationtype": {
                "docstring": ""
            }, 
            "pickColor": {
                "docstring": ""
            }, 
            "pickValue": {
                "docstring": ""
            }, 
            "playbackCursor": {
                "docstring": ""
            }, 
            "playbackPressure": {
                "docstring": ""
            }, 
            "preserveclonesource": {
                "docstring": ""
            }, 
            "profileShapeFile": {
                "docstring": "Passes a name of the image file for the stamp shape profile."
            }, 
            "projective": {
                "docstring": "Specifies the projective paint mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "property": {
                "docstring": "Specifies a property to paint on the fluid. Valid values are \"color\", \"density\", \"densityAndColor,\" \"densityAndFuel,\" \"temperature,\" \"fuel\", \"velocity\"."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Sets the size of the brush. C: Default is 1.0 cm. Q: When queried, it returns a float."
            }, 
            "rampMaxColor": {
                "docstring": ""
            }, 
            "rampMinColor": {
                "docstring": ""
            }, 
            "record": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "Specifies the reflection mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "reflectionaboutorigin": {
                "docstring": ""
            }, 
            "reflectionaxis": {
                "docstring": "Specifies the reflection axis. There are three possibilities: \"x\", \"y\" and \"z\". C: Default is \"x\". Q: When queried, it returns a string."
            }, 
            "rgbValue": {
                "docstring": "Specifies the values of the red, green, and blue components of the color to use when painting the property \"color.\""
            }, 
            "screenRadius": {
                "docstring": ""
            }, 
            "selectclonesource": {
                "docstring": ""
            }, 
            "selectedattroper": {
                "docstring": ""
            }, 
            "showactive": {
                "docstring": "Sets on/off the display of the surface isoparms. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "stampDepth": {
                "docstring": ""
            }, 
            "stampProfile": {
                "docstring": "Sets the brush profile of the current stamp. Currently, the following profiles are supported: \"gaussian\", \"soft\", \"solid\" and \"square\". C: Default is gaussian. Q: When queried, it returns a string."
            }, 
            "stampSpacing": {
                "docstring": ""
            }, 
            "strokesmooth": {
                "docstring": ""
            }, 
            "surfaceConformedBrushVertices": {
                "docstring": "Enables/disables the the display of the effective brush area as affected vertices."
            }, 
            "tablet": {
                "docstring": "Returns true if the tablet device is present, false if it is absent"
            }, 
            "tangentOutline": {
                "docstring": "Enables/disables the display of the brush circle tangent to the surface."
            }, 
            "toolOffProc": {
                "docstring": ""
            }, 
            "toolOnProc": {
                "docstring": ""
            }, 
            "useColorRamp": {
                "docstring": ""
            }, 
            "useMaxMinColor": {
                "docstring": ""
            }, 
            "useStrokeDirection": {
                "docstring": "Applicable only during \"velocity\" painting. Specifies whether the value of the painted velocity should come from the direction of the brush stroke, overriding the value specified by the -v/-velocity flag."
            }, 
            "usepressure": {
                "docstring": "Sets the tablet pressure on/off. C: Default is false. Q: When queried, it returns a boolean."
            }, 
            "value": {
                "docstring": ""
            }, 
            "velocity": {
                "docstring": "Specifies the values of the x, y, and z components of the velocity to use when painting the property \"velocity\"."
            }, 
            "whichTool": {
                "docstring": ""
            }, 
            "worldRadius": {
                "docstring": ""
            }
        }
    }, 
    "artPuttyCtx": {
        "description": "This is a context command to set the flags on the artAttrContext, which is the base context for attribute painting operations. All commands require the name of the context as the last argument as this provides the name of the context to create, edit or query. This command is used to modify NURBS surfaces using a brush based interface (Maya Artisan). This is accomplished by moving the control vertices (cvs) under the brush in the specified direction. In query mode, return type is based on queried flag.", 
        "flags": {
            "accopacity": {
                "docstring": "Sets opacity accumulation on/off. C: Default is false (Except for sculpt tool for which it is true by default). Q: When queried, it returns a boolean."
            }, 
            "activeListChangedProc": {
                "docstring": "Accpts a string which contains a MEL command that is invoked whenever the active list changes. There may be some situations where the UI, for example, needs to be updated, when objects are selected/deselected in the scene. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "afterStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately after the end of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "alphaclamp": {
                "docstring": "Specifies if the weight value should be alpha clamped to the lower and upper bounds. There are four options here: \"none\" - no clamping is performed, \"lower\" - clamps only to the lower bound, \"upper\" - clamps only to the upper bounds, \"both\" - clamps to the lower and upper bounds. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "alphaclamplower": {
                "docstring": "Specifies the lower bound for the alpha values. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "alphaclampupper": {
                "docstring": "Specifies the upper bound for the alpha values. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "attrSelected": {
                "docstring": "Returns a name of the currently selected attribute. Q: When queried, it returns a string."
            }, 
            "autosmooth": {
                "docstring": "Sets up the auto smoothing option. When the brush is in the smooth mode, adjusting the strength will adjust how fast the surfaces is smoothed out. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "beforeStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately before the start of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "brushalignment": {
                "docstring": "Specifies the path brush alignemnt. If true, the brush will align to stroke path, otherwise it will align to up vector. C: Default is true. Q: When queried, it returns a boolean."
            }, 
            "brushfeedback": {
                "docstring": "Specifies if the brush additional feedback should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "clamp": {
                "docstring": "Specifies if the weight value should be clamped to the lower and upper bounds. There are four options here: \"none\" - no clamping is performed, \"lower\" - clamps only to the lower bound, \"upper\" - clamps only to the upper bounds, \"both\" - clamps to the lower and upper bounds. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "clamplower": {
                "docstring": "Specifies the lower bound for the values. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "clampupper": {
                "docstring": "Specifies the upper bound for the values. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "clear": {
                "docstring": "Floods all cvs/vertices to the current value."
            }, 
            "collapsecvtol": {
                "docstring": "Specifies the tolerance for the collapse cv detection. C: Default is 0.005 cm. Q: When queried, it returns a float."
            }, 
            "colorAlphaValue": {
                "docstring": ""
            }, 
            "colorRGBAValue": {
                "docstring": ""
            }, 
            "colorRGBValue": {
                "docstring": ""
            }, 
            "colorRamp": {
                "docstring": "Allows a user defined color ramp to be used to map values to colors."
            }, 
            "colorfeedback": {
                "docstring": "Sets on/off the color feedback display. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "colorfeedbackOverride": {
                "docstring": ""
            }, 
            "colorrangelower": {
                "docstring": "Specifies the value which maps to black when color feedback mode is on C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "colorrangeupper": {
                "docstring": "Specifies the value which maps to the maximum color when color feedback mode is on C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "dataTypeIndex": {
                "docstring": "When the selected paintable attribute is a vectorArray, it specifies which field to paint on."
            }, 
            "disablelighting": {
                "docstring": "If color feedback is on, this flag determines whether lighting is disabled or not for the surfaces that are affected C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "dispdecr": {
                "docstring": "Decreases a maximum displacement by 10%.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dispincr": {
                "docstring": "Increases a maximum displacement by 10%."
            }, 
            "dragSlider": {
                "docstring": "Sets the current brush drag state for resizing or offsetting the brush (like the 'b' and 'm' default hotkeys). The string argument is one of: \"radius\", \"lowradius\", \"opacity\", \"value\", \"depth\", \"displacement\", \"uvvector\" or \"none\". C: Default is \"none\"."
            }, 
            "duringStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command during the stroke, each time the mouse is dragged. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "dynclonemode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "erasesrfupd": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandfilename": {
                "docstring": "If true, it will expand the name of the export file and concatenate it with the surface name. Otherwise it will take the name as it is. C: Default is true."
            }, 
            "exportaspectratio": {
                "docstring": ""
            }, 
            "exportfilemode": {
                "docstring": "Specifies the export channel.The valid entries here are: \"alpha\", \"luminance\", \"rgb\", \"rgba\". C: Default is \"luminance/rgb\". Q: When queried, it returns a string."
            }, 
            "exportfilesave": {
                "docstring": "Exports the attribute map and saves to a specified file."
            }, 
            "exportfilesizex": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfilesizey": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfiletype": {
                "docstring": "Specifies the image file format. It can be one of the following: \"iff\", \"tiff\", \"jpeg\", \"alias\", \"rgb\", \"fit\" \"postScriptEPS\", \"softimage\", \"wavefrontRLA\", \"wavefrontEXP\". C: default is tiff. Q: When queried, it returns a string."
            }, 
            "filterNodes": {
                "docstring": "Sets the node filter."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "importfileload": {
                "docstring": "Load the attribute map a specified file."
            }, 
            "importfilemode": {
                "docstring": "Specifies the channel to import. The valid entries here are: \"alpha\", \"luminance\", \"red\", \"green\", \"blue\", and \"rgb\" C: Default is \"alpha\". Q: When queried, it returns a string."
            }, 
            "importreassign": {
                "docstring": "Specifies if the multiply atrribute maps are to be reassigned while importing. Only maps previously exported from within Artisan can be reassigned. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "interactiveUpdate": {
                "docstring": "Specifies how often to transfer the painted values into the attribute. TRUE: transfer them \"continuously\" (many times per stroke) FALSE: transfer them only at the end of a stroke (on mouse button release) C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "invertrefvector": {
                "docstring": "Sets the invert of the reference vector option when the reflection is ON. If it is true, the reference vector for the reflected stroke is negated with respect to the original one. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "lastRecorderCmd": {
                "docstring": ""
            }, 
            "lastStampName": {
                "docstring": ""
            }, 
            "lowerradius": {
                "docstring": "Sets the lower size of the brush (only apply on tablet)."
            }, 
            "makeStroke": {
                "docstring": ""
            }, 
            "mappressure": {
                "docstring": "Sets the tablet pressure mapping when the table is used. There are four options: \"none\" - the pressure has no effect, \"opacity\" - the pressure is mapped to the opacity, \"radius\" - the is mapped to modify the radius of the brush, \"both\" - the pressure modifies both the opacity and the radius. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "maxdisp": {
                "docstring": "Defines a maximum displacement ( maxDisp in [0.0..5.0] ). C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "maxvalue": {
                "docstring": "Specifies the maximum value for each attribute. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "minvalue": {
                "docstring": "Specifies the minimum value for each attribute. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "mouldtypehead": {
                "docstring": ""
            }, 
            "mouldtypemouse": {
                "docstring": "Specifies the putty operations/mode (\"push\" - pushes cvs along the given direction (see refvector flag), \"pull\" - pulls cvs along the specified direction, \"smooth\" - smooths the sculpt, \"erase\" - erases the paint). C: Default is \"push\". Q: When queried, it returns a string."
            }, 
            "mouldtypetail": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "objattrArray": {
                "docstring": "An array of all paintable attributes. Each element of the array is a string with the following information: NodeType.NodeName.AttributeName.MenuType \\*MenuType: type(level) of the item in the Menu (UI). Q: When queried, it returns a string."
            }, 
            "opacity": {
                "docstring": "Sets the brush opacity. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "outline": {
                "docstring": "Specifies if the brush should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "outwhilepaint": {
                "docstring": "Specifies if the brush outline should be drawn while painting. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "paintNodeArray": {
                "docstring": "An array of paintable nodes. Q: When queried, it returns a string."
            }, 
            "paintattrselected": {
                "docstring": "An array of selected paintable attributes. Each element of the array is a string with the following information: NodeType.NodeName.AttributeName."
            }, 
            "paintmode": {
                "docstring": "Specifies the paint mode. There are two possibilities: \"screen\" and \"tangent\". C: Default is \"screen\". Q: When queried, it returns a string."
            }, 
            "paintoperationtype": {
                "docstring": ""
            }, 
            "pickColor": {
                "docstring": ""
            }, 
            "pickValue": {
                "docstring": ""
            }, 
            "playbackCursor": {
                "docstring": ""
            }, 
            "playbackPressure": {
                "docstring": ""
            }, 
            "polecv": {
                "docstring": "Pull all the pole cvs to the same position"
            }, 
            "preserveclonesource": {
                "docstring": ""
            }, 
            "profileShapeFile": {
                "docstring": "Passes a name of the image file for the stamp shape profile."
            }, 
            "projective": {
                "docstring": "Specifies the projective paint mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Sets the size of the brush. C: Default is 1.0 cm. Q: When queried, it returns a float."
            }, 
            "rampMaxColor": {
                "docstring": "Defines a special color to be used when the value is greater than or equal to the maximum value."
            }, 
            "rampMinColor": {
                "docstring": "Defines a special color to be used when the value is less than or equal to the minimum value."
            }, 
            "record": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "Specifies the reflection mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "reflectionaboutorigin": {
                "docstring": ""
            }, 
            "reflectionaxis": {
                "docstring": "Specifies the reflection axis. There are three possibilities: \"x\", \"y\" and \"z\". C: Default is \"x\". Q: When queried, it returns a string."
            }, 
            "refsurface": {
                "docstring": "Sets on/off the update of the reference surface. If it is true the reference surface is automatically updated on the per stroke bases. If it is false, the user has to update the reference surface explicitly by pressing the update button (see updaterefsrf). C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "refvector": {
                "docstring": "Specifies the direction of the push/pull operation (\"normal\" - sculpt along normals, \"firstnormal\" - sculpt along the first normal of the stroke, \"view\" - sculpt along the view direction, \"xaxis\", \"yaxis\", \"zaxis\" - sculpt along a given axis directions, \"uisoparm\", \"visoparm\" - sculpt along U or V isoparametric lines), \"uvvector\" - sculpt along an arbitrary vector in UV space. C: Default is \"normal\". Q: When queried, it returns a string."
            }, 
            "refvectoru": {
                "docstring": "Specifies the U component of the UV vector to be used when -refVector is set to \"uvvector\"."
            }, 
            "refvectorv": {
                "docstring": "Specifies the V component of the UV vector to be used when -refVector is set to \"uvvector\"."
            }, 
            "screenRadius": {
                "docstring": ""
            }, 
            "selectclonesource": {
                "docstring": ""
            }, 
            "selectedattroper": {
                "docstring": "Sets the edit weight operation. Four edit weights operations are provided : \"absolute\" - the value of the weight is replaced by the current one, \"additive\" - the value of the weight is added to the current one, \"scale\" - the value of the weight is multiplied by the current one, \"smooth\" - the value of the weight is divided by the current one. C: Default is \"absolute\". Q: When queried, it returns a string."
            }, 
            "showactive": {
                "docstring": "Sets on/off the display of the surface isoparms. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "smoothiters": {
                "docstring": "Sets the quality of the smoothing operation (number of iterations). C: Default is 3. Q: When queried, it returns an int."
            }, 
            "stampDepth": {
                "docstring": ""
            }, 
            "stampProfile": {
                "docstring": "Sets the brush profile of the current stamp. Currently, the following profiles are supported: \"gaussian\", \"soft\", \"solid\" and \"square\". C: Default is gaussian. Q: When queried, it returns a string."
            }, 
            "stampSpacing": {
                "docstring": ""
            }, 
            "stitchcorner": {
                "docstring": "Sets on/off the stitching corner mode C: Default is \"off\". Q: When queried, it returns a boolean."
            }, 
            "stitchedgeflood": {
                "docstring": "Triggers postprocessing stitching edge procedure."
            }, 
            "stitchtype": {
                "docstring": "Sets on/off the stitching mode ( \"off\" - stitching is turned off, \"position\" - position stitching is done without taking care about the tangent continuity C0, \"tan\" - C1 continuity is preserved). C: Default is \"position\". Q: When queried, it returns a string."
            }, 
            "strokesmooth": {
                "docstring": ""
            }, 
            "surfaceConformedBrushVertices": {
                "docstring": "Enables/disables the the display of the effective brush area as affected vertices."
            }, 
            "tablet": {
                "docstring": "Returns true if the tablet device is present, false if it is absent"
            }, 
            "tangentOutline": {
                "docstring": "Enables/disables the display of the brush circle tangent to the surface."
            }, 
            "toolOffProc": {
                "docstring": "Accepts a strings describing the name of a MEL procedure which is invoked whenever the tool is turned off. For example, cloth invokes \"clothPaintToolOff\" when the cloth paint tool is turned on. Define this callback if your tool requires special functionality when your tool is deactivated. It is typical that if you implement a toolOffProc you will want to implement a toolOnProc as well (see the -toolOnProc flag. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "toolOnProc": {
                "docstring": "Accepts a strings describing the name of a MEL procedure which is invoked whenever the tool is turned on. For example, cloth invokes \"clothPaintToolOn\" when the cloth paint tool is turned on. Define this callback if your tool requires special functionality when your tool is activated. It is typical that if you implement a toolOnProc you will want to implement a toolOffProc as well (see the -toolOffProc flag. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "updateerasesrf": {
                "docstring": "Updates the erase surface."
            }, 
            "updaterefsrf": {
                "docstring": "Updates the reference surface."
            }, 
            "useColorRamp": {
                "docstring": "Specifies whether the user defined color ramp should be used to map values from to colors. If this is turned off, the default greyscale feedback will be used."
            }, 
            "useMaxMinColor": {
                "docstring": "Specifies whether the out of range colors should be used. See rampMinColor and rampMaxColor flags for further details."
            }, 
            "usepressure": {
                "docstring": "Sets the tablet pressure on/off. C: Default is false. Q: When queried, it returns a boolean."
            }, 
            "value": {
                "docstring": "Specifies the value for each attribute. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "whichTool": {
                "docstring": "The string defines the name of the tool to be used for the Artisan context. An example is \"artClothPaint\". In query mode, the tool name for the given context is returned. Note: due to the way MEL works, always specify the -query flag last when specifying a flag which takes arguments."
            }, 
            "worldRadius": {
                "docstring": ""
            }
        }
    }, 
    "artSelect": {
        "description": "", 
        "flags": {}
    }, 
    "artSelectCtx": {
        "description": "This command is used to select/deselect/toggle components on selected surfaces using a brush interface (Maya Artisan). Since, it selects components of the surface, it only works in the component mode. In query mode, return type is based on queried flag.", 
        "flags": {
            "accopacity": {
                "docstring": "Sets opacity accumulation on/off. C: Default is false (Except for sculpt tool for which it is true by default). Q: When queried, it returns a boolean."
            }, 
            "addselection": {
                "docstring": "If true, each new stroke adds cvs to the active list. If false, each stroke replaces the previous selection. C: Default is true. Q: When queried, it returns a boole"
            }, 
            "afterStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately after the end of a stroke. C: Default is no command. Q: When queried, it returns the current commandFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "beforeStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately before the start of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "brushalignment": {
                "docstring": "Specifies the path brush alignemnt. If true, the brush will align to stroke path, otherwise it will align to up vector. C: Default is true. Q: When queried, it returns a boolean."
            }, 
            "brushfeedback": {
                "docstring": "Specifies if the brush additional feedback should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "clear": {
                "docstring": "Floods all cvs/vertices to the current value."
            }, 
            "dragSlider": {
                "docstring": "Sets the current brush drag state for resizing or offsetting the brush (like the 'b' and 'm' default hotkeys). The string argument is one of: \"radius\", \"lowradius\", \"opacity\", \"value\", \"depth\", \"displacement\", \"uvvector\" or \"none\". C: Default is \"none\"."
            }, 
            "dynclonemode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandfilename": {
                "docstring": "If true, it will expand the name of the export file and concatenate it with the surface name. Otherwise it will take the name as it is. C: Default is true."
            }, 
            "exportaspectratio": {
                "docstring": ""
            }, 
            "exportfilemode": {
                "docstring": "Specifies the export channel.The valid entries here are: \"alpha\", \"luminance\", \"rgb\", \"rgba\". C: Default is \"luminance/rgb\". Q: When queried, it returns a string."
            }, 
            "exportfilesave": {
                "docstring": "Exports the attribute map and saves to a specified file."
            }, 
            "exportfilesizex": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfilesizey": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfiletype": {
                "docstring": "Specifies the image file format. It can be one of the following: \"iff\", \"tiff\", \"jpeg\", \"alias\", \"rgb\", \"fit\" \"postScriptEPS\", \"softimage\", \"wavefrontRLA\", \"wavefrontEXP\". C: default is tiff. Q: When queried, it returns a string."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "importfileload": {
                "docstring": "Load the attribute map a specified file."
            }, 
            "importfilemode": {
                "docstring": "Specifies the channel to import. The valid entries here are: \"alpha\", \"luminance\", \"red\", \"green\", \"blue\", and \"rgb\" C: Default is \"alpha\". Q: When queried, it returns a string."
            }, 
            "importreassign": {
                "docstring": "Specifies if the multiply atrribute maps are to be reassigned while importing. Only maps previously exported from within Artisan can be reassigned. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "importthreshold": {
                "docstring": "Specifies the threshold for the import of the attribute maps. C: Default is 0.5. Q: When queried, it returns a float."
            }, 
            "lastRecorderCmd": {
                "docstring": ""
            }, 
            "lastStampName": {
                "docstring": ""
            }, 
            "lowerradius": {
                "docstring": "Sets the lower size of the brush (only apply on tablet)."
            }, 
            "makeStroke": {
                "docstring": ""
            }, 
            "mappressure": {
                "docstring": "Sets the tablet pressure mapping when the table is used. There are four options: \"none\" - the pressure has no effect, \"opacity\" - the pressure is mapped to the opacity, \"radius\" - the is mapped to modify the radius of the brush, \"both\" - the pressure modifies both the opacity and the radius. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "opacity": {
                "docstring": "Sets the brush opacity. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "outline": {
                "docstring": "Specifies if the brush should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "outwhilepaint": {
                "docstring": "Specifies if the brush outline should be drawn while painting. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "paintmode": {
                "docstring": "Specifies the paint mode. There are two possibilities: \"screen\" and \"tangent\". C: Default is \"screen\". Q: When queried, it returns a string."
            }, 
            "paintoperationtype": {
                "docstring": ""
            }, 
            "pickColor": {
                "docstring": ""
            }, 
            "pickValue": {
                "docstring": ""
            }, 
            "playbackCursor": {
                "docstring": ""
            }, 
            "playbackPressure": {
                "docstring": ""
            }, 
            "preserveclonesource": {
                "docstring": ""
            }, 
            "profileShapeFile": {
                "docstring": "Passes a name of the image file for the stamp shape profile."
            }, 
            "projective": {
                "docstring": "Specifies the projective paint mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Sets the size of the brush. C: Default is 1.0 cm. Q: When queried, it returns a float."
            }, 
            "record": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "Specifies the reflection mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "reflectionaboutorigin": {
                "docstring": ""
            }, 
            "reflectionaxis": {
                "docstring": "Specifies the reflection axis. There are three possibilities: \"x\", \"y\" and \"z\". C: Default is \"x\". Q: When queried, it returns a string."
            }, 
            "screenRadius": {
                "docstring": ""
            }, 
            "selectall": {
                "docstring": "Selects all vertices/egdes/faces/uvs."
            }, 
            "selectclonesource": {
                "docstring": ""
            }, 
            "selectop": {
                "docstring": "Specifies the selection operation (\"select\", \"unselect\", \"toggle\"). C: Default is \"select\". Q: When queried, it returns a string."
            }, 
            "showactive": {
                "docstring": "Sets on/off the display of the surface isoparms. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "stampDepth": {
                "docstring": ""
            }, 
            "stampProfile": {
                "docstring": "Sets the brush profile of the current stamp. Currently, the following profiles are supported: \"gaussian\", \"soft\", \"solid\" and \"square\". C: Default is gaussian. Q: When queried, it returns a string."
            }, 
            "stampSpacing": {
                "docstring": ""
            }, 
            "strokesmooth": {
                "docstring": ""
            }, 
            "surfaceConformedBrushVertices": {
                "docstring": "Enables/disables the the display of the effective brush area as affected vertices."
            }, 
            "tablet": {
                "docstring": "Returns true if the tablet device is present, false if it is absent"
            }, 
            "tangentOutline": {
                "docstring": "Enables/disables the display of the brush circle tangent to the surface."
            }, 
            "toggleall": {
                "docstring": "Toggle all vertices/egdes/faces/uvs."
            }, 
            "unselectall": {
                "docstring": "Unselects all vertices/egdes/faces/uvs."
            }, 
            "usepressure": {
                "docstring": "Sets the tablet pressure on/off. C: Default is false. Q: When queried, it returns a boolean."
            }, 
            "worldRadius": {
                "docstring": ""
            }
        }
    }, 
    "artSetPaint": {
        "description": "", 
        "flags": {}
    }, 
    "artSetPaintCtx": {
        "description": "This tool allows the user to modify the set membership (add, transfer, remove cvs) on nurbs surfaces using Maya Artisan's interface. In query mode, return type is based on queried flag.", 
        "flags": {
            "accopacity": {
                "docstring": "Sets opacity accumulation on/off. C: Default is false (Except for sculpt tool for which it is true by default). Q: When queried, it returns a boolean."
            }, 
            "afterStrokeCmd": {
                "docstring": ""
            }, 
            "beforeStrokeCmd": {
                "docstring": ""
            }, 
            "brushalignment": {
                "docstring": "Specifies the path brush alignemnt. If true, the brush will align to stroke path, otherwise it will align to up vector. C: Default is true. Q: When queried, it returns a boolean."
            }, 
            "brushfeedback": {
                "docstring": "Specifies if the brush additional feedback should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "clear": {
                "docstring": "Floods all cvs/vertices to the current value."
            }, 
            "dragSlider": {
                "docstring": "Sets the current brush drag state for resizing or offsetting the brush (like the 'b' and 'm' default hotkeys). The string argument is one of: \"radius\", \"lowradius\", \"opacity\", \"value\", \"depth\", \"displacement\", \"uvvector\" or \"none\". C: Default is \"none\"."
            }, 
            "dynclonemode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandfilename": {
                "docstring": "If true, it will expand the name of the export file and concatenate it with the surface name. Otherwise it will take the name as it is. C: Default is true."
            }, 
            "exportaspectratio": {
                "docstring": ""
            }, 
            "exportfilemode": {
                "docstring": "Specifies the export channel.The valid entries here are: \"alpha\", \"luminance\", \"rgb\", \"rgba\". C: Default is \"luminance/rgb\". Q: When queried, it returns a string."
            }, 
            "exportfilesave": {
                "docstring": "Exports the attribute map and saves to a specified file."
            }, 
            "exportfilesizex": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfilesizey": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfiletype": {
                "docstring": "Specifies the image file format. It can be one of the following: \"iff\", \"tiff\", \"jpeg\", \"alias\", \"rgb\", \"fit\" \"postScriptEPS\", \"softimage\", \"wavefrontRLA\", \"wavefrontEXP\". C: default is tiff. Q: When queried, it returns a string."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "importfileload": {
                "docstring": "Load the attribute map a specified file."
            }, 
            "importfilemode": {
                "docstring": "Specifies the channel to import. The valid entries here are: \"alpha\", \"luminance\", \"red\", \"green\", \"blue\", and \"rgb\" C: Default is \"alpha\". Q: When queried, it returns a string."
            }, 
            "importreassign": {
                "docstring": "Specifies if the multiply atrribute maps are to be reassigned while importing. Only maps previously exported from within Artisan can be reassigned. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "lastRecorderCmd": {
                "docstring": ""
            }, 
            "lastStampName": {
                "docstring": ""
            }, 
            "lowerradius": {
                "docstring": "Sets the lower size of the brush (only apply on tablet)."
            }, 
            "makeStroke": {
                "docstring": ""
            }, 
            "mappressure": {
                "docstring": "Sets the tablet pressure mapping when the table is used. There are four options: \"none\" - the pressure has no effect, \"opacity\" - the pressure is mapped to the opacity, \"radius\" - the is mapped to modify the radius of the brush, \"both\" - the pressure modifies both the opacity and the radius. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "objectsetnames": {
                "docstring": ""
            }, 
            "opacity": {
                "docstring": "Sets the brush opacity. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "outline": {
                "docstring": "Specifies if the brush should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "outwhilepaint": {
                "docstring": "Specifies if the brush outline should be drawn while painting. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "paintmode": {
                "docstring": "Specifies the paint mode. There are two possibilities: \"screen\" and \"tangent\". C: Default is \"screen\". Q: When queried, it returns a string."
            }, 
            "paintoperationtype": {
                "docstring": ""
            }, 
            "pickColor": {
                "docstring": ""
            }, 
            "pickValue": {
                "docstring": ""
            }, 
            "playbackCursor": {
                "docstring": ""
            }, 
            "playbackPressure": {
                "docstring": ""
            }, 
            "preserveclonesource": {
                "docstring": ""
            }, 
            "profileShapeFile": {
                "docstring": "Passes a name of the image file for the stamp shape profile."
            }, 
            "projective": {
                "docstring": "Specifies the projective paint mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Sets the size of the brush. C: Default is 1.0 cm. Q: When queried, it returns a float."
            }, 
            "record": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "Specifies the reflection mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "reflectionaboutorigin": {
                "docstring": ""
            }, 
            "reflectionaxis": {
                "docstring": "Specifies the reflection axis. There are three possibilities: \"x\", \"y\" and \"z\". C: Default is \"x\". Q: When queried, it returns a string."
            }, 
            "screenRadius": {
                "docstring": ""
            }, 
            "selectclonesource": {
                "docstring": ""
            }, 
            "setcolorfeedback": {
                "docstring": "Specifies if the color feedback is on or off. C: Default is ON. Q: When queried, it returns a boolean."
            }, 
            "setdisplaycvs": {
                "docstring": "Specifies if the active cvs are displayed. C: Default is ON. Q: When queried, it returns a boolean.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "setopertype": {
                "docstring": "Specifies the setEdit operation (\"add\", \"transfer\", \"remove\"). C: Default is \"add\". Q: When queried, it returns a string."
            }, 
            "settomodify": {
                "docstring": "Specifies the name of the set to modify. Q: When queried, it returns a string."
            }, 
            "showactive": {
                "docstring": "Sets on/off the display of the surface isoparms. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "stampDepth": {
                "docstring": ""
            }, 
            "stampProfile": {
                "docstring": "Sets the brush profile of the current stamp. Currently, the following profiles are supported: \"gaussian\", \"soft\", \"solid\" and \"square\". C: Default is gaussian. Q: When queried, it returns a string."
            }, 
            "stampSpacing": {
                "docstring": ""
            }, 
            "strokesmooth": {
                "docstring": ""
            }, 
            "surfaceConformedBrushVertices": {
                "docstring": "Enables/disables the the display of the effective brush area as affected vertices."
            }, 
            "tablet": {
                "docstring": "Returns true if the tablet device is present, false if it is absent"
            }, 
            "tangentOutline": {
                "docstring": "Enables/disables the display of the brush circle tangent to the surface."
            }, 
            "usepressure": {
                "docstring": "Sets the tablet pressure on/off. C: Default is false. Q: When queried, it returns a boolean."
            }, 
            "worldRadius": {
                "docstring": ""
            }
        }
    }, 
    "artUserPaintCtx": {
        "description": "This is a context command to set the flags on the artAttrContext, which is the base context for attribute painting operations. All commands require the name of the context as the last argument as this provides the name of the context to create, edit or query. This command executes a scriptable paint (Maya Artisan). It allows the user to apply mel commands/scripts to modify cvs' attributes for all cvs under the paint brush. ", 
        "flags": {
            "accopacity": {
                "docstring": "Sets opacity accumulation on/off. C: Default is false (Except for sculpt tool for which it is true by default). Q: When queried, it returns a boolean."
            }, 
            "activeListChangedProc": {
                "docstring": "Accpts a string which contains a MEL command that is invoked whenever the active list changes. There may be some situations where the UI, for example, needs to be updated, when objects are selected/deselected in the scene. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "afterStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately after the end of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "alphaclamp": {
                "docstring": "Specifies if the weight value should be alpha clamped to the lower and upper bounds. There are four options here: \"none\" - no clamping is performed, \"lower\" - clamps only to the lower bound, \"upper\" - clamps only to the upper bounds, \"both\" - clamps to the lower and upper bounds. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "alphaclamplower": {
                "docstring": "Specifies the lower bound for the alpha values. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "alphaclampupper": {
                "docstring": "Specifies the upper bound for the alpha values. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "attrSelected": {
                "docstring": "Returns a name of the currently selected attribute. Q: When queried, it returns a string."
            }, 
            "beforeStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command immediately before the start of a stroke. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "brushalignment": {
                "docstring": "Specifies the path brush alignemnt. If true, the brush will align to stroke path, otherwise it will align to up vector. C: Default is true. Q: When queried, it returns a boolean."
            }, 
            "brushfeedback": {
                "docstring": "Specifies if the brush additional feedback should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "chunkCommand": {
                "docstring": ""
            }, 
            "clamp": {
                "docstring": "Specifies if the weight value should be clamped to the lower and upper bounds. There are four options here: \"none\" - no clamping is performed, \"lower\" - clamps only to the lower bound, \"upper\" - clamps only to the upper bounds, \"both\" - clamps to the lower and upper bounds. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "clamplower": {
                "docstring": "Specifies the lower bound for the values. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "clampupper": {
                "docstring": "Specifies the upper bound for the values. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "clear": {
                "docstring": "Floods all cvs/vertices to the current value."
            }, 
            "colorAlphaValue": {
                "docstring": ""
            }, 
            "colorRGBAValue": {
                "docstring": ""
            }, 
            "colorRGBValue": {
                "docstring": ""
            }, 
            "colorRamp": {
                "docstring": "Allows a user defined color ramp to be used to map values to colors."
            }, 
            "colorfeedback": {
                "docstring": "Sets on/off the color feedback display. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "colorfeedbackOverride": {
                "docstring": ""
            }, 
            "colorrangelower": {
                "docstring": "Specifies the value which maps to black when color feedback mode is on C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "colorrangeupper": {
                "docstring": "Specifies the value which maps to the maximum color when color feedback mode is on C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "dataTypeIndex": {
                "docstring": "When the selected paintable attribute is a vectorArray, it specifies which field to paint on."
            }, 
            "disablelighting": {
                "docstring": "If color feedback is on, this flag determines whether lighting is disabled or not for the surfaces that are affected C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "dragSlider": {
                "docstring": "Sets the current brush drag state for resizing or offsetting the brush (like the 'b' and 'm' default hotkeys). The string argument is one of: \"radius\", \"lowradius\", \"opacity\", \"value\", \"depth\", \"displacement\", \"uvvector\" or \"none\". C: Default is \"none\"."
            }, 
            "duringStrokeCmd": {
                "docstring": "The passed string is executed as a MEL command during the stroke, each time the mouse is dragged. C: Default is no command. Q: When queried, it returns the current command"
            }, 
            "dynclonemode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandfilename": {
                "docstring": "If true, it will expand the name of the export file and concatenate it with the surface name. Otherwise it will take the name as it is. C: Default is true."
            }, 
            "exportaspectratio": {
                "docstring": ""
            }, 
            "exportfilemode": {
                "docstring": "Specifies the export channel.The valid entries here are: \"alpha\", \"luminance\", \"rgb\", \"rgba\". C: Default is \"luminance/rgb\". Q: When queried, it returns a string."
            }, 
            "exportfilesave": {
                "docstring": "Exports the attribute map and saves to a specified file."
            }, 
            "exportfilesizex": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfilesizey": {
                "docstring": "Specifies the width of the attribute map to export. C: Default width is 256. Q: When queried, it returns an integer."
            }, 
            "exportfiletype": {
                "docstring": "Specifies the image file format. It can be one of the following: \"iff\", \"tiff\", \"jpeg\", \"alias\", \"rgb\", \"fit\" \"postScriptEPS\", \"softimage\", \"wavefrontRLA\", \"wavefrontEXP\". C: default is tiff. Q: When queried, it returns a string."
            }, 
            "filterNodes": {
                "docstring": "Sets the node filter."
            }, 
            "finalizeCmd": {
                "docstring": "Specifies the name of the mel script/procedure which is called at the end of each stroke. Q: When queried, it returns a string."
            }, 
            "fullpaths": {
                "docstring": "Specifies whether full path names should be used when surface names are passed to scripts. If false, just the surface name is passed. C: Default is false Q: When queried, it returns a boolean.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "getArrayAttrCommand": {
                "docstring": "Specifies the name of the mel script/procedure which is called once for every surface that is selected for painting. This procedure returns a string, which is interpreted as a list of names referring to double array attributes on some dependency node. Q: When queried, it returns a string."
            }, 
            "getSurfaceCommand": {
                "docstring": "Specifies the name of the mel script/procedure which is called once for every dependency node on the selection list, whenever Artisan processes the selection list. It returns the name of the surface to paint on. Q: When queried, it returns a string."
            }, 
            "getValueCommand": {
                "docstring": "Specifies the name of the mel script/procedure which is called every time a value on the surface is needed by the scriptable paint tool. Q: When queried, it returns a string."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "importfileload": {
                "docstring": "Load the attribute map a specified file."
            }, 
            "importfilemode": {
                "docstring": "Specifies the channel to import. The valid entries here are: \"alpha\", \"luminance\", \"red\", \"green\", \"blue\", and \"rgb\" C: Default is \"alpha\". Q: When queried, it returns a string."
            }, 
            "importreassign": {
                "docstring": "Specifies if the multiply atrribute maps are to be reassigned while importing. Only maps previously exported from within Artisan can be reassigned. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "initializeCmd": {
                "docstring": "Specifies the name of the mel script/procedure which is called in the beginning of each stroke. Q: When queried, it returns a string."
            }, 
            "interactiveUpdate": {
                "docstring": "Specifies how often to transfer the painted values into the attribute. TRUE: transfer them \"continuously\" (many times per stroke) FALSE: transfer them only at the end of a stroke (on mouse button release) C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "lastRecorderCmd": {
                "docstring": ""
            }, 
            "lastStampName": {
                "docstring": ""
            }, 
            "lowerradius": {
                "docstring": "Sets the lower size of the brush (only apply on tablet)."
            }, 
            "makeStroke": {
                "docstring": ""
            }, 
            "mappressure": {
                "docstring": "Sets the tablet pressure mapping when the table is used. There are four options: \"none\" - the pressure has no effect, \"opacity\" - the pressure is mapped to the opacity, \"radius\" - the is mapped to modify the radius of the brush, \"both\" - the pressure modifies both the opacity and the radius. C: Default is \"none\". Q: When queried, it returns a string."
            }, 
            "maxvalue": {
                "docstring": "Specifies the maximum value for each attribute. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "minvalue": {
                "docstring": "Specifies the minimum value for each attribute. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "objattrArray": {
                "docstring": "An array of all paintable attributes. Each element of the array is a string with the following information: NodeType.NodeName.AttributeName.MenuType \\*MenuType: type(level) of the item in the Menu (UI). Q: When queried, it returns a string."
            }, 
            "opacity": {
                "docstring": "Sets the brush opacity. C: Default is 1.0. Q: When queried, it returns a float."
            }, 
            "outline": {
                "docstring": "Specifies if the brush should be drawn. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "outwhilepaint": {
                "docstring": "Specifies if the brush outline should be drawn while painting. C: Default is FALSE. Q: When queried, it returns a boolean."
            }, 
            "paintNodeArray": {
                "docstring": "An array of paintable nodes. Q: When queried, it returns a string."
            }, 
            "paintattrselected": {
                "docstring": "An array of selected paintable attributes. Each element of the array is a string with the following information: NodeType.NodeName.AttributeName."
            }, 
            "paintmode": {
                "docstring": "Specifies the paint mode. There are two possibilities: \"screen\" and \"tangent\". C: Default is \"screen\". Q: When queried, it returns a string."
            }, 
            "paintoperationtype": {
                "docstring": ""
            }, 
            "pickColor": {
                "docstring": ""
            }, 
            "pickValue": {
                "docstring": ""
            }, 
            "playbackCursor": {
                "docstring": ""
            }, 
            "playbackPressure": {
                "docstring": ""
            }, 
            "preserveclonesource": {
                "docstring": ""
            }, 
            "profileShapeFile": {
                "docstring": "Passes a name of the image file for the stamp shape profile."
            }, 
            "projective": {
                "docstring": "Specifies the projective paint mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Sets the size of the brush. C: Default is 1.0 cm. Q: When queried, it returns a float."
            }, 
            "rampMaxColor": {
                "docstring": "Defines a special color to be used when the value is greater than or equal to the maximum value."
            }, 
            "rampMinColor": {
                "docstring": "Defines a special color to be used when the value is less than or equal to the minimum value."
            }, 
            "record": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "Specifies the reflection mode. C: Default is 'false'. Q: When queried, it returns a boolean."
            }, 
            "reflectionaboutorigin": {
                "docstring": ""
            }, 
            "reflectionaxis": {
                "docstring": "Specifies the reflection axis. There are three possibilities: \"x\", \"y\" and \"z\". C: Default is \"x\". Q: When queried, it returns a string."
            }, 
            "screenRadius": {
                "docstring": ""
            }, 
            "selectclonesource": {
                "docstring": ""
            }, 
            "selectedattroper": {
                "docstring": "Sets the edit weight operation. Four edit weights operations are provided : \"absolute\" - the value of the weight is replaced by the current one, \"additive\" - the value of the weight is added to the current one, \"scale\" - the value of the weight is multiplied by the current one, \"smooth\" - the value of the weight is divided by the current one. C: Default is \"absolute\". Q: When queried, it returns a string."
            }, 
            "setValueCommand": {
                "docstring": "Specifies the name of the mel script/procedure which is called every time a value on the surface is changed. Q: When queried, it returns a string."
            }, 
            "showactive": {
                "docstring": "Sets on/off the display of the surface isoparms. C: Default is TRUE. Q: When queried, it returns a boolean."
            }, 
            "stampDepth": {
                "docstring": ""
            }, 
            "stampProfile": {
                "docstring": "Sets the brush profile of the current stamp. Currently, the following profiles are supported: \"gaussian\", \"soft\", \"solid\" and \"square\". C: Default is gaussian. Q: When queried, it returns a string."
            }, 
            "stampSpacing": {
                "docstring": ""
            }, 
            "strokesmooth": {
                "docstring": ""
            }, 
            "surfaceConformedBrushVertices": {
                "docstring": "Enables/disables the the display of the effective brush area as affected vertices."
            }, 
            "tablet": {
                "docstring": "Returns true if the tablet device is present, false if it is absent"
            }, 
            "tangentOutline": {
                "docstring": "Enables/disables the display of the brush circle tangent to the surface."
            }, 
            "toolCleanupCmd": {
                "docstring": "Specifies the name of the mel script/procedure which is called when this tool is exited. Q: When queried, it returns a string."
            }, 
            "toolOffProc": {
                "docstring": "Accepts a strings describing the name of a MEL procedure which is invoked whenever the tool is turned off. For example, cloth invokes \"clothPaintToolOff\" when the cloth paint tool is turned on. Define this callback if your tool requires special functionality when your tool is deactivated. It is typical that if you implement a toolOffProc you will want to implement a toolOnProc as well (see the -toolOnProc flag. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "toolOnProc": {
                "docstring": "Accepts a strings describing the name of a MEL procedure which is invoked whenever the tool is turned on. For example, cloth invokes \"clothPaintToolOn\" when the cloth paint tool is turned on. Define this callback if your tool requires special functionality when your tool is activated. It is typical that if you implement a toolOnProc you will want to implement a toolOffProc as well (see the -toolOffProc flag. In query mode, the name of the currently registered MEL command is returned and this will be an empty string if none is defined."
            }, 
            "toolSetupCmd": {
                "docstring": "Specifies the name of the mel script/procedure which is called once for every selected surface when an initial click is received on that surface. Q: When queried, it returns a string."
            }, 
            "useColorRamp": {
                "docstring": "Specifies whether the user defined color ramp should be used to map values from to colors. If this is turned off, the default greyscale feedback will be used."
            }, 
            "useMaxMinColor": {
                "docstring": "Specifies whether the out of range colors should be used. See rampMinColor and rampMaxColor flags for further details."
            }, 
            "usepressure": {
                "docstring": "Sets the tablet pressure on/off. C: Default is false. Q: When queried, it returns a boolean."
            }, 
            "value": {
                "docstring": "Specifies the value for each attribute. C: Default is 0.0. Q: When queried, it returns a float."
            }, 
            "whichTool": {
                "docstring": "The string defines the name of the tool to be used for the Artisan context. An example is \"artClothPaint\". In query mode, the tool name for the given context is returned. Note: due to the way MEL works, always specify the -query flag last when specifying a flag which takes arguments."
            }, 
            "worldRadius": {
                "docstring": ""
            }
        }
    }, 
    "assembly": {
        "description": "Command to register representation managers for the multiple representation framework, to create them, and to edit and query them. Since they are DAG nodes, representation managers have node names, shown in the various DAG editors (Outliner, Hypergraph, Node Editor). At assembly creation time, the node name defaults to the node type name. In query mode, return type is based on queried flag.", 
        "flags": {
            "active": {
                "docstring": "Set or query the active representation for a specific assembly."
            }, 
            "addRepresentation": {
                "docstring": "Add a representation to a specific assembly."
            }, 
            "canCreate": {
                "docstring": "Query the representation types the specific assembly can create. If the flag argument is not an assembly, invoke the creation predicate in the registry and return the supported representation types. "
            }, 
            "createPredicate": {
                "docstring": "Query or edit the creation predicate procedure for a given registered assembly type. This predicate is invoked to query the list of representation types that a registered assembly type can create."
            }, 
            "createRepresentation": {
                "docstring": "Create a specific type of representation for an assembly. Notice that \"input\" flag must be used with this flag."
            }, 
            "defaultType": {
                "docstring": "Set or query the default type of assembly."
            }, 
            "deleteRepresentation": {
                "docstring": "Delete a specific representation from an assembly."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "input": {
                "docstring": "Specify the additional parameters of representation creation procedure when creating a representation. This flag must be used with createRepresentation flag."
            }, 
            "isAType": {
                "docstring": "Query whether the given object is of an assembly type."
            }, 
            "listRepTypes": {
                "docstring": "Query the supported representation types for the default type of assembly."
            }, 
            "listRepTypesProc": {
                "docstring": "Set or query the procedure that provides supported representation types for the default type of assembly."
            }, 
            "listRepresentations": {
                "docstring": "Query the created representations for a specific assembly."
            }, 
            "name": {
                "docstring": "Specify the name of the assembly when creating it."
            }, 
            "originalRepType": {
                "docstring": "Set or query the original representation type for the default assembly."
            }, 
            "postCreateUIProc": {
                "docstring": "Set or query the UI post-creation procedure with a specific representation type for the default assembly. "
            }, 
            "preCreateUIProc": {
                "docstring": "Set or query the UI pre-creation procedure with a specific representation type for the default assembly. "
            }, 
            "proc": {
                "docstring": "Specify the procedure when setting the UI post-creation procedure or the UI pre-creation procedure for the default assembly."
            }, 
            "query": {
                "docstring": ""
            }, 
            "repLabel": {
                "docstring": "Query the label of the specific representation. "
            }, 
            "repType": {
                "docstring": "Specify the representation type when to query the created representations for a specific assembly. "
            }, 
            "repTypeLabel": {
                "docstring": "Query the label of the specific representation type. "
            }, 
            "repTypeLabelProc": {
                "docstring": "Set or query the procedure that provides the representation type label for the default type of assembly."
            }, 
            "revertToOriginal": {
                "docstring": "Import all objects from a specific assembly's original representation and delete it."
            }, 
            "type": {
                "docstring": "Set or query properties for the specified registered assembly type. Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "assignCommand": {
        "description": "This command allows the user to assign hotkeys and manipulate the internal array of named command objects. Each object in the array has an 1-based index which is used for referencing. Under expected usage you should not need to use this command directly as the Hotkey Editor may be used to assign hotkeys. In query mode, return type is based on queried flag.", 
        "flags": {
            "addDivider": {
                "docstring": "Appends an \"annotated divider\" item to the end of the list of commands."
            }, 
            "altModifier": {
                "docstring": "This flag specifies if an alt modifier is used for the key."
            }, 
            "annotation": {
                "docstring": "The string is the english name describing the command."
            }, 
            "command": {
                "docstring": "This is the command that is executed when this object is mapped to a key or menuItem."
            }, 
            "commandModifier": {
                "docstring": "This flag specifies if a command modifier is used for the key. This is only available on systems which support a separate command key."
            }, 
            "ctrlModifier": {
                "docstring": "This flag specifies if a ctrl modifier is used for the key."
            }, 
            "data1": {
                "docstring": "Optional, user-defined data strings may be attached to the nameCommand objects."
            }, 
            "data2": {
                "docstring": "Optional, user-defined data strings may be attached to the nameCommand objects."
            }, 
            "data3": {
                "docstring": "Optional, user-defined data strings may be attached to the nameCommand objects."
            }, 
            "delete": {
                "docstring": "This tells the Manager to delete the object at position index."
            }, 
            "dividerString": {
                "docstring": "If the passed index corresponds to a \"divider\" item, then the divider's annotation is returned. Otherwise, a null string is returned."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enableCommandRepeat": {
                "docstring": ""
            }, 
            "factorySettings": {
                "docstring": "This flag sets the manager back to factory settings."
            }, 
            "index": {
                "docstring": "The index of the object to operate on. The index value ranges from 1 to the number of name command objects."
            }, 
            "keyArray": {
                "docstring": ""
            }, 
            "keyString": {
                "docstring": "This specifies a key to assign a command to in edit mode. In query mode this flag returns the key string, modifiers and indicates if the command is mapped to keyUp or keyDown."
            }, 
            "keyUp": {
                "docstring": "This flag specifies if the command is executed on keyUp or keyDown."
            }, 
            "name": {
                "docstring": "The name of the command object."
            }, 
            "numDividersPreceding": {
                "docstring": "If the index of a namedCommand object Cis passed in, then this flag returns the number of \"divider\" items preceding Cwhen the namedCommands are sorted by category."
            }, 
            "numElements": {
                "docstring": "This command returns the number of namedCommands in the system. This flag doesn't require the index to be specified."
            }, 
            "optionModifier": {
                "docstring": "This flag specifies if an option modifier is used for the key."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sortByKey": {
                "docstring": "This key tells the manager to sort by key or by order of creation."
            }, 
            "sourceUserCommands": {
                "docstring": "This command sources the user named command file.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "assignInputDevice": {
        "description": "This command associates a command string (i.e. a mel script) with the input device. When the device moves or a button on the device is pressed, the command string is executed as if you typed it into the window. If the command string contains the names of buttons or axes of the device, the current value of these buttons/axes are substituted in. Buttons are reported as booleans and axes as doubles. This command is most useful for associating buttons on a device with commands. For using a device to capture continous movements it is much more efficient to attach the device directly into the dependency graph. ", 
        "flags": {
            "clutch": {
                "docstring": "specify a clutch button. This button must be down for the command string to be executed. If no clutch is specified the command string is executed everytime the device state changes"
            }, 
            "continuous": {
                "docstring": "if this flag is set the command string is continously (once for everytime the device changes state). By default if a clutch button is specified the command string is only executed once when the button is pressed."
            }, 
            "device": {
                "docstring": "specify which device to assign the command string."
            }, 
            "immediate": {
                "docstring": "Immediately executes the command, without using the queue.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "multiple": {
                "docstring": "if this flag is set the other command strings associated with this device are not deleted. By default, when a new command string is attached to the device, all other command strings are deleted."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "assignViewportFactories": {
        "description": "Sets viewport factories for displays as materials or textures. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "materialFactory": {
                "docstring": "Set or query the materialFactory for the node type."
            }, 
            "nodeType": {
                "docstring": "The node type.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "textureFactory": {
                "docstring": "Set or query the textureFactory for the node type."
            }
        }
    }, 
    "attachCurve": {
        "description": "This attach command is used to attach curves. Once the curves are attached, there will be multiple knots at the joined point(s). These can be kept or removed if the user wishes. If there are two curves, the end of the first curve is attached to the start of the second curve. If there are more than two curves, closest endpoints are joined. Note: if the command is done with Keep Original off, the first curve is replaced by the attached curve. All other curves will remain, the command does not delete them. ", 
        "flags": {
            "blendBias": {
                "docstring": "Skew the result toward the first or the second curve depending on the blend factory being smaller or larger than 0.5.Default:0.5"
            }, 
            "blendKnotInsertion": {
                "docstring": "If set to true, insert a knot in one of the original curves (relative position given by the parameter attribute below) in order to produce a slightly different effect.Default:false"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "keepMultipleKnots": {
                "docstring": "If true, keep multiple knots at the join parameter. Otherwise remove them.Default:true"
            }, 
            "method": {
                "docstring": "Attach method (connect-0, blend-1)Default:0"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameter": {
                "docstring": "The parameter value for the positioning of the newly inserted knot.Default:0.1Advanced flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reverse1": {
                "docstring": "If true, reverse the first input curve before doing attach. Otherwise, do nothing to the first input curve before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "reverse2": {
                "docstring": "If true, reverse the second input curve before doing attach. Otherwise, do nothing to the second input curve before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }
        }
    }, 
    "attachDeviceAttr": {
        "description": "This command associates a device/axis pair with a node/attribute pair. When the device axis moves, the value of the attribute is set to the value of the axis. This value can be scaled and offset using the setAttrScale command. In query mode, return type is based on queried flag.", 
        "flags": {
            "attribute": {
                "docstring": "specify the attribute to attach to"
            }, 
            "axis": {
                "docstring": "specify the axis to attach from."
            }, 
            "camera": {
                "docstring": "This flag attaches the device/axis to the current camera. The mapping between device axes and camera controls is uses a heuristic based on the device descripton. The interaction is a copy of the mouse camera navigation controls."
            }, 
            "cameraRotate": {
                "docstring": "This flag attaches the device/axis to the current cameras rotation controls.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "cameraTranslate": {
                "docstring": "This flag attaches the device/axis to the current cameras translate controls."
            }, 
            "clutch": {
                "docstring": "specify a clutch button. This button must be down for the command string to be executed. If no clutch is specified the command string is executed everytime the device state changes"
            }, 
            "device": {
                "docstring": "specify which device to assign the command string."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selection": {
                "docstring": "This flag attaches to the nodes in the selection list. This is different from the default arguments of the command since changing the selection will change the attachments."
            }
        }
    }, 
    "attachSurface": {
        "description": "This attach command is used to attach surfaces. Once the surfaces are attached, there will be multiple knots at the joined point(s). These can be kept or removed if the user wishes. The end of the first surface is attached to the start of the second surface in the specified direction. Note: if the command is done with Keep Original off there will be an extra surface in the model (the second surface). The command does not delete it. The first surface is replaced by the attached surface. ", 
        "flags": {
            "blendBias": {
                "docstring": "Skew the result toward the first or the second curve depending on the blend factory being smaller or larger than 0.5.Default:0.5"
            }, 
            "blendKnotInsertion": {
                "docstring": "If set to true, insert a knot in one of the original curves (relative position given by the parameter attribute below) in order to produce a slightly different effect.Default:false"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "directionU": {
                "docstring": "If true attach in U direction of surface and V direction otherwise.Default:true"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "keepMultipleKnots": {
                "docstring": "If true, keep multiple knots at the join parameter. Otherwise remove them.Default:trueAdvanced flags"
            }, 
            "method": {
                "docstring": "Attach method (connect-0, blend-1)Default:0"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameter": {
                "docstring": "The parameter value for the positioning of the newly inserted knot.Default:0.1"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reverse1": {
                "docstring": "If true, reverse the direction (specified by directionU) of the first input surface before doing attach. Otherwise, do nothing to the first input surface before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "reverse2": {
                "docstring": "If true, reverse the direction (specified by directionU) of the second input surface before doing attach. Otherwise, do nothing to the second input surface before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "swap1": {
                "docstring": "If true, swap the UV directions of the first input surface before doing attach. Otherwise, do nothing to the first input surface before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "swap2": {
                "docstring": "If true, swap the UV directions of the second input surface before doing attach. Otherwise, do nothing to the second input surface before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }, 
            "twist": {
                "docstring": "If true, reverse the second surface in the opposite direction (specified by directionU) before doing attach. This will avoid twists in the attached surfaces. Otherwise, do nothing to the second input surface before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported.Default:false"
            }
        }
    }, 
    "attrColorSliderGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. Create a color slider group consisting of a label, a color canvas, a slider and a button. Clicking on the canvas will bring up the color editor. If the button is visible, it will allow you to map a texture to the attribute. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "attrNavDecision": {
                "docstring": "The first argument is the name of an attribute. The button will be attached to the attribute so the button can be kept in synch with the attribute. The second argument is the navigatorDecisionString that can guide the behaviour that the navigator implements."
            }, 
            "attribute": {
                "docstring": "The name of a unique attribute of type 3double. This newly created field will be attached to the attribute, so that modifications to one will change the other."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "hsvValue": {
                "docstring": "Specifies the color in hsv style."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "By default, the label of this field will be the name of the attribute. This flag can be used to override that name with whatever the user wants."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rgbValue": {
                "docstring": "Specifies the color in rgb style."
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "showButton": {
                "docstring": "Control the display of the texture link button. True by default (show it).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "attrCompatibility": {
        "description": "This command is used to handle compatibility issues between file format versions by providing a mechanism to describe differences between two versions. Only plugin writers should have the potential need to use this command.The first optional command argument argument is a node name and the second optional command argument is an attribute name.Warning:Only use this command to describe changes in names or attributes of nodes that youhave written as plugins. Do notuse this command to change information about builtin dependency graph nodes. ", 
        "flags": {
            "addAttr": {
                "docstring": "Add the given attribute to the named node."
            }, 
            "clear": {
                "docstring": "Clear out the compatibility table. This is only used internally for debugging purposes."
            }, 
            "dumpTable": {
                "docstring": "Dump the current contents of the compatibility table. This is only used internally for debugging purposes."
            }, 
            "enable": {
                "docstring": "Enable or disable the compatibility table. This is only used internally for debugging purposes."
            }, 
            "nodeRename": {
                "docstring": "Replace all uses of the node type 'nodeName' with given string."
            }, 
            "removeAttr": {
                "docstring": "Remove the given attribute from the named node."
            }, 
            "renameAttr": {
                "docstring": "Rename the given attribute name of the given node with the given string."
            }, 
            "type": {
                "docstring": "Change the type of the given attribute to the given type."
            }, 
            "version": {
                "docstring": "Set the version target for subsequent commands to the given string.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "attrControlGrp": {
        "description": "This command creates a control of the type most appropriate for the specified attribute, and associates the control with the attribute. Any change to the control will cause a change in the attribute value, and any change to the attribute value will be reflected in the control. Not all attribute types are supported. ", 
        "flags": {
            "annotation": {
                "docstring": "Sets or queries the annotation value of the control group."
            }, 
            "attribute": {
                "docstring": "Sets or queries the attribute the control represents. The name of the attribute must be fully specified, including the name of the node. Some types of attributes are not supported, but most commonly used attribute types are."
            }, 
            "changeCommand": {
                "docstring": "Sets or queries the change command of the control group. The change command will be executed when the control is used to change the value of the attribute."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "Sets or queries the enable state of the control group. The control is dimmed if the enable state is set to false."
            }, 
            "handlesAttribute": {
                "docstring": "Returns true or false as to whether this command can create a control for the specified attribute. Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "hideMapButton": {
                "docstring": "Force the map button to remain hidden for this control."
            }, 
            "label": {
                "docstring": "Sets or queries the label of the control group."
            }, 
            "preventOverride": {
                "docstring": "Sets or queries the prevent adjustment state of the control group. If true, the RMB menu for the control will not allow adjustments to be made."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "attrEnumOptionMenu": {
        "description": "This command creates an enumerated attribute control. It is usually an option menu. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "attribute": {
                "docstring": "Attribute that the menu controls."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "The command string is executed when the value of the option menu changes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enumeratedItem": {
                "docstring": "Enumerated item and the corresponding string. If this flag is not supplied when the control is created, then the command will try to read the values from the attribute."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The label text."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "attrEnumOptionMenuGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a pre-packaged collection of label and option menu button associated with an attribute of a node. The attribute should be an integer, and this control allows a UI association of strings to the integers of the attribute. When a new menu item is choosen the corresponding integer will be assigned to the attribute. This control will automatically read the enumeration values from the attribute if none are provided. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "attribute": {
                "docstring": "The name of an attribute. The button will be attached to the attribute so the button can be kept in synch with the attribute."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enumeratedItem": {
                "docstring": "Enumerated item and the corresponding string. If this flag is not supplied when the control is created, then the command will try to read the values from the attribute.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "Text for the control."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "attrFieldGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a pre-packaged collection of label text, plus two or three float fields. These fields will be attached to the specified vector attribute, so that changes in either will be reflected in the other. The fields created here are expression fields -- while normally operating as a float field, the user can type in any expression starting with the character \"-\". The field also has an automatic menu brought up by the right mouse button. The contents of this menu change depending on the state of the attribute being watched by the field. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "attribute": {
                "docstring": "The name of a unique attribute of type vector. This newly created field will be attached to the attribute, so that modifications to one will change the other. A \"vector\" attribute is any compound attribute whose children consist of two or three double-valued attributes."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "The command string is executed when the value of any of the floatFields change.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "extraLabel": {
                "docstring": "set an optional string that will be positioned to the right of all the fields."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "hideMapButton": {
                "docstring": "Force the map button to remain hidden for this control."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "By default, the label of this field will be the name of the attribute. This flag can be used to override that name with whatever the user wants."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Sets the maximum value for all fields."
            }, 
            "minValue": {
                "docstring": "Sets the minimum value for all fields."
            }, 
            "numberOfFields": {
                "docstring": "sets the number of fields. Only allowed values are 2 or 3. If not specified, defaults to 3. NOTE: if the -at flag is used when this widget is created, the number of children in the attribute will determine the number of fields. Also note: after creation, the number of fields cannot be changed with the -e flag."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "precision": {
                "docstring": "Sets the precision for all fields"
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "step": {
                "docstring": "Sets the increment for all fields"
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "attrFieldSliderGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a pre-packaged collection of label text, float field and float slider (for values with a min or max specified) The group also supports the notion of a larger secondary range of possible field values. If an attribute is specified for this object, then it will use any min and max values defined in the attribute. The user-specified values can reduce the min and max, but cannot expand them. The field created here is an expression field -- while normally operating as a float field, the user can type in any expression starting with the character \"-\". This will expand the field to occupy the space previously taken by the slider. The field also has an automatic menu brought up by the right mouse button. The contents of this menu change depending on the state of the attribute being watched by the field. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "attribute": {
                "docstring": "The name of a unique attribute of type double or int. This newly created field will be attached to the attribute, so that modifications to one will change the other."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "The command string is executed when the value of the slider or floatField changes. It will be executed only once after a drag of the slider."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fieldMaxValue": {
                "docstring": "Set the maximum value for the field. This flag allows you to specify a maximum bound for the field higher than that of the slider. (See note above about max and min values.)"
            }, 
            "fieldMinValue": {
                "docstring": "Set the minimum value for the field. This flag allows you to specify a minimum bound for the field lower than that of the slider. (See note above about max and min values.)"
            }, 
            "fieldStep": {
                "docstring": "Sets the increment for the float field."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "hideMapButton": {
                "docstring": "Force the map button to remain hidden for this control."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "By default, the label of this field will be the name of the attribute. This flag can be used to override that name with whatever string you want."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Sets the maximum value for both the slider and the field. (See note above about min and max values)"
            }, 
            "minValue": {
                "docstring": "Sets the minimum value for both the slider and the field. (by default max and min are set according to what is in the attribute, if anything. If no max and min are specified, or if only one of the two are specified, then no slider is created.)"
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "precision": {
                "docstring": "Sets the number of digits to the right of the decimal. (If attached to an int attribute, this is automatically set to 0 and cannot be overridden.)"
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "sliderMaxValue": {
                "docstring": "Set the maximum value for the slider. The slider max will be clipped to the field max."
            }, 
            "sliderMinValue": {
                "docstring": "Set the minimum value for the slider. The slider min will be clipped to the field min."
            }, 
            "sliderStep": {
                "docstring": "On Linux the slider step value represents the amount the value will increase or decrease when you click either side of the slider."
            }, 
            "step": {
                "docstring": "Sets the increment for both the slider and float field."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "vertical": {
                "docstring": "Whether the orientation of the controls in this group are horizontal (default) or vertical.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "attrNavigationControlGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a pre-packaged label navigation button. The group is used to help the user manage connections to a particular attribute. When creating the control you have the opportunity to attach scripts to the control that are executed on various UI events. You can define what happens when the navigation button is pressed, and when a node is dragged and dropped onto this attribute. The navigation button can traverse to the connected node or can bring up UI to create new connections to the attribute. The button also can show you state information: if there already exists a connection/if the connection is ignored. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "attrNavDecision": {
                "docstring": "The first argument is the name of an attribute. The button will be attached to the attribute so the button can be kept in synch with the attribute. The second argument is the navigatorDecisionString that can guide the behaviour that the navigator implements."
            }, 
            "attribute": {
                "docstring": "The name of an attribute. The button will be attached to the attribute so the button can be kept in synch with the attribute."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "connectAttrToDropped": {
                "docstring": "The script to execute when a node is dragged and dropped onto an attribute (multilister dnd attribute editor). Your script should take in two arguments: the source node and destination attribute respectively."
            }, 
            "connectNodeToDropped": {
                "docstring": "The script to execute when a node is dragged and dropped onto a node (the multilister issues this). Your script should take in two arguments: the source node and destination node respectively."
            }, 
            "connectToExisting": {
                "docstring": "The script to execute when a connection should be made to an existing node."
            }, 
            "createNew": {
                "docstring": "The script to execute when a new \"connection\" is requested."
            }, 
            "defaultTraversal": {
                "docstring": "The script to execute to find out the name of the default traversal node. The script you attach should be able to take in one argument (the attribute) and return the name of the node that is the default traversal node.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "delete": {
                "docstring": "The script to execute when the connection (and the node connected to) should be deleted."
            }, 
            "disconnect": {
                "docstring": "The script to execute when a \"disconnection\" is requested."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "ignore": {
                "docstring": "The script to execute when the connection should be ignored."
            }, 
            "ignoreNotSupported": {
                "docstring": "Obsolete flag; has no effect."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "Text for the control."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relatedNodes": {
                "docstring": "The script to execute to find out what the related nodes are. The script you attach should be able to take in one argument (the attribute) and return a list of strings that are the name of the nodes that are related."
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "unignore": {
                "docstring": "The script to execute when the connection should be unignored."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "attributeInfo": {
        "description": "This command lists all of the attributes that are marked with certain flags. Combinations of flags may be specified and all will be considered. (The method of combination depends on the state of the \"logicalAnd/and\" flag.) When the \"allAttributes/all\" flag is specified, attributes of all types will be listed. ", 
        "flags": {
            "allAttributes": {
                "docstring": "Show all attributes associated with the node regardless of type. Use of this flag overrides any other attribute type flags and logical operation that may be specified on the command."
            }, 
            "bool": {
                "docstring": "Show the attributes that are of type boolean. Use the 'on' state to get only boolean attributes; the 'off' state to ignore boolean attributes."
            }, 
            "enumerated": {
                "docstring": "Show the attributes that are of type enumerated. Use the 'on' state to get only enumerated attributes; the 'off' state to ignore enumerated attributes."
            }, 
            "hidden": {
                "docstring": "Show the attributes that are marked as hidden. Use the 'on' state to get hidden attributes; the 'off' state to get non-hidden attributes."
            }, 
            "inherited": {
                "docstring": "Filter the attributes based on whether they belong to the node type directly or have been inherited from a root type (e.g. meshShape/direct or dagObject/inherited). Use the 'on' state to get only inherited attributes, the 'off' state to get only directly owned attributes, and leave the flag unspecified to get both."
            }, 
            "internal": {
                "docstring": "Show the attributes that are marked as internal to the node. Use the 'on' state to get internal attributes; the 'off' state to get non-internal attributes."
            }, 
            "leaf": {
                "docstring": "Show the attributes that are complex leaves (ie. that have parent attributes and have no children themselves). Use the 'on' state to get leaf attributes; the 'off' state to get non-leaf attributes."
            }, 
            "logicalAnd": {
                "docstring": "The default is to take the logical 'or' of the above conditions. Specifying this flag switches to the logical 'and' instead."
            }, 
            "multi": {
                "docstring": "Show the attributes that are multis. Use the 'on' state to get multi attributes; the 'off' state to get non-multi attributes."
            }, 
            "short": {
                "docstring": "Show the short attribute names instead of the long names."
            }, 
            "type": {
                "docstring": "static node type from which to get 'affects' informationFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "userInterface": {
                "docstring": "Show the UI-friendly attribute names instead of the Maya ASCII names. Takes precedence over the -s/-short flag if both are specified."
            }, 
            "writable": {
                "docstring": "Show the attributes that are writable (ie. can have input connections). Use the 'on' state to get writable attributes; the 'off' state to get non-writable attributes."
            }
        }
    }, 
    "attributeMenu": {
        "description": "Action to generate popup connection menus for Hypershade. This command is used internally by the Hypershade panel. ", 
        "flags": {
            "beginMenu": {
                "docstring": "If true the menu will be used to start a connection edit so it will list all available attributes for either inputs or outputs. If false the menu will be used to complete a connection so it will list only the attributes compatible with the attribute at the other end of the connection. A plug must be supplied in this case."
            }, 
            "editor": {
                "docstring": "Name of the Hypergraph, Hypershade or Visor editor for which this menu is being built. This argument is no longer mandatory. If it is omitted, the inputs flag and the node must be used to specify the search targets. This allows attributeMenu to be used in the absence of a hypershade editor."
            }, 
            "finishMenu": {
                "docstring": "finishes the menu"
            }, 
            "inputs": {
                "docstring": "If true only attributes which can be used as inputs will be listed. If false only attributes which can be used as outputs will be listed"
            }, 
            "plug": {
                "docstring": "If inputs is false then we are completing a connection and the name of the plug at the other end of the connection must be supplied."
            }, 
            "regPulldownMenuCommand": {
                "docstring": "This flag will register a callback that allows the user to define their own popup menu for a specific node type for use in the Hypershade and Hypergraph editor. The command signature should look like this: global proc int proc_name(string $editorName, string $nodeName, string $plug, string $mode, string $menuType)The method should return 0 if it does not recognize the node type and the default attributeMenu popup menu will be displayed. If the callback returns one then the menu is considered built and no other menuItems will be added to the popup. The return value from this flag will be the ID to use for the -unregPulldownMenuCommand flag."
            }, 
            "unregPulldownMenuCommand": {
                "docstring": "This flag will unregister a callback procedure that was registered with the -regPulldownMenuCommand flag. The argument should be the integer identifier returned from the -regPulldownMenuCommand flag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "attributeName": {
        "description": "This command takes one \"node.attribute\"-style specifier on the command line and returns either the attribute's long, short, or nice name. (The \"nice\" name, or UI name, is the name used to display the attribute in Maya's interface, and may be localized when running Maya in a language other than English.) If more than one \"node.attribute\" specifier is given on the command line, only the first valid specifier is processed. ", 
        "flags": {
            "leaf": {
                "docstring": "When false, shows parent multi attributes (like \"controlPoints[2].xValue\"). When true, shows only the leaf-level attribute name (like \"xValue\"). Default is true. Note that for incomplete attribute strings, like a missing multi-parent index (\"controlPoints.xValue\") or an incorrectly named compound (cntrlPnts[2].xValue), this flag defaults to true and provides a result as long as the named leaf-level attribute is defined for the node.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "long": {
                "docstring": "Returns names in \"long name\" format like \"translateX\""
            }, 
            "nice": {
                "docstring": "Returns names in \"nice name\" format like \"Translate X\""
            }, 
            "short": {
                "docstring": "Returns names in \"short name\" format like \"tx\""
            }
        }
    }, 
    "attributeQuery": {
        "description": "attributeQuery returns information about the configuration of an attribute. It handles both boolean flags, returning true or false, as well as other return values. Specifying more than one boolean flag will return the logical \"and\" of all the specified boolean flags. You may not specify any two flags when both do not provide a boolean return type. (eg. \"-internal -hidden\" is okay but \"-range -hidden\" or \"-range -softRange\" is not.) ", 
        "flags": {
            "affectsAppearance": {
                "docstring": "Return true if the attribute affects the appearance of the node"
            }, 
            "affectsWorldspace": {
                "docstring": "Return the status of the attribute flag marking attributes affecting worldspace"
            }, 
            "attributeType": {
                "docstring": "Return the name of the attribute type (will be the same type names as described in the addAttr and addExtension commands)."
            }, 
            "cachedInternally": {
                "docstring": "Return whether the attribute is cached within the node as well as in the datablock"
            }, 
            "categories": {
                "docstring": "Return the categories to which the attribute belongs or an empty list if it does not belong to any."
            }, 
            "channelBox": {
                "docstring": "Return whether the attribute should show up in the channelBox or not"
            }, 
            "connectable": {
                "docstring": "Return the connectable status of the attribute"
            }, 
            "enum": {
                "docstring": "Return true if the attribute is a enum attribute"
            }, 
            "exists": {
                "docstring": "Return true if the attribute exists"
            }, 
            "hidden": {
                "docstring": "Return the hidden status of the attribute"
            }, 
            "indeterminant": {
                "docstring": "Return true if this attribute might be used in evaluation but it's not known for sure until evaluation time"
            }, 
            "indexMatters": {
                "docstring": "Return the indexMatters status of the attribute"
            }, 
            "internal": {
                "docstring": "Return true if the attribute is either internalSet or internalGet"
            }, 
            "internalGet": {
                "docstring": "Return true if the attribute come from getCachedValue"
            }, 
            "internalSet": {
                "docstring": "Return true if the attribute must be set through setCachedValue"
            }, 
            "keyable": {
                "docstring": "Return the keyable status of the attribute"
            }, 
            "listChildren": {
                "docstring": "Return the list of children attributes of the given attribute."
            }, 
            "listDefault": {
                "docstring": "Return the default values of numeric and compound numeric attributes."
            }, 
            "listEnum": {
                "docstring": "Return the list of enum strings for the given attribute."
            }, 
            "listParent": {
                "docstring": "Return the parent of the given attribute."
            }, 
            "listSiblings": {
                "docstring": "Return the list of sibling attributes of the given attribute."
            }, 
            "longName": {
                "docstring": "Return the long name of the attribute."
            }, 
            "maxExists": {
                "docstring": "Return true if the attribute has a hard maximum. A min does not have to be present."
            }, 
            "maximum": {
                "docstring": "Return the hard maximum of the attribute's value"
            }, 
            "message": {
                "docstring": "Return true if the attribute is a message attribute"
            }, 
            "minExists": {
                "docstring": "Return true if the attribute has a hard minimum. A max does not have to be present."
            }, 
            "minimum": {
                "docstring": "Return the hard minimum of the attribute's value"
            }, 
            "multi": {
                "docstring": "Return true if the attribute is a multi-attribute"
            }, 
            "niceName": {
                "docstring": "Return the nice name (or \"UI name\") of the attribute."
            }, 
            "node": {
                "docstring": "Use all attributes from node named NAME"
            }, 
            "numberOfChildren": {
                "docstring": "Return the number of children the attribute has"
            }, 
            "range": {
                "docstring": "Return the hard range of the attribute's value"
            }, 
            "rangeExists": {
                "docstring": "Return true if the attribute has a hard range. Both min and max must be present."
            }, 
            "readable": {
                "docstring": "Return the readable status of the attribute"
            }, 
            "renderSource": {
                "docstring": "Return whether this attribute is marked as a render source or not"
            }, 
            "shortName": {
                "docstring": "Return the short name of the attribute."
            }, 
            "softMax": {
                "docstring": "Return the soft max (slider range) of the attribute's value"
            }, 
            "softMaxExists": {
                "docstring": "Return true if the attribute has a soft maximum. A min does not have to be present."
            }, 
            "softMin": {
                "docstring": "Return the soft min (slider range) of the attribute's value"
            }, 
            "softMinExists": {
                "docstring": "Return true if the attribute has a soft minimum. A max does not have to be present."
            }, 
            "softRange": {
                "docstring": "Return the soft range (slider range) of the attribute's value"
            }, 
            "softRangeExists": {
                "docstring": "Return true if the attribute has a soft range. Both min and max must be present."
            }, 
            "storable": {
                "docstring": "Return true if the attribute is storable"
            }, 
            "type": {
                "docstring": "Use static attributes from nodes of type TYPE. Includes attributes inherited from parent class nodes."
            }, 
            "typeExact": {
                "docstring": "Use static attributes only from nodes of type TYPE. Does not included inherited attributes."
            }, 
            "usedAsColor": {
                "docstring": "Return true if the attribute should bring up a color picker"
            }, 
            "usedAsFilename": {
                "docstring": "Return true if the attribute should bring up a file browser"
            }, 
            "usesMultiBuilder": {
                "docstring": "Return true if the attribute is a multi-attribute and it uses the multi-builder to handle its data"
            }, 
            "worldspace": {
                "docstring": "Return the status of the attribute flag marking worldspace attribute"
            }, 
            "writable": {
                "docstring": "Return the writable status of the attributeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "audioTrack": {
        "description": "This command is used for inserting and removing tracks related to the audio clips displayed in the sequencer. It can also be used to modify the track state, for example, to lock or mute a track. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "insertTrack": {
                "docstring": "This flag is used to insert a new empty track at the track index specified. Indices are 1-based."
            }, 
            "lock": {
                "docstring": "This flag specifies whether all audio clips on the same track as the specified audio node are to be locked at their current location and track."
            }, 
            "mute": {
                "docstring": "This flag specifies whether all audio clips on the same track as the specified audio node are to be muted or not."
            }, 
            "numTracks": {
                "docstring": "To query the number of audio tracksFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeEmptyTracks": {
                "docstring": "This flag is used to remove all tracks that have no clips."
            }, 
            "removeTrack": {
                "docstring": "This flag is used to remove the track with the specified index. The track must have no clips on it before it can be removed."
            }, 
            "solo": {
                "docstring": "This flag specifies whether all audio clips on the same track as the specified audio node are to be soloed or not."
            }, 
            "swapTracks": {
                "docstring": "This flag is used to swap the contents of two specified tracks. Indices are 1-based."
            }
        }
    }, 
    "autoKeyframe": {
        "description": "With no flags, this command will set keyframes on all attributes that have been modified since an \"autoKeyframe -state on\" command was issued. To stop keeping track of modified attributes, use \"autoKeyframe -state off\" autoKeyframe does not create new animation curves. An attribute must have already been keyframed (with the setKeyframe command) for autoKeyframe to add new keyframes for modified attributes. You can also query the current state of autoKeyframing with \"autoKeyframe -query -state\". ", 
        "flags": {
            "characterOption": {
                "docstring": "Valid options are: \"standard\", \"all\". Dictates whether when auto-keying characters the auto-key works as usual or whether it keys all of the character attributes. Default is \"standard\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "noReset": {
                "docstring": "Must be used in conjunction with the state/st flag. When noReset/nr is specified, the list of plugs to be autokeyed is not cleared when the state changes"
            }, 
            "query": {
                "docstring": ""
            }, 
            "state": {
                "docstring": "turns on/off remembering of modified attributes"
            }
        }
    }, 
    "autoPlace": {
        "description": "This command takes a point in the centre of the current modeling pane and projects it onto the live surface. This produces a point in 3 space which is returned. If the um/useMouseflag is set the current mouse position is used rather than the centre of the modeling pane. ", 
        "flags": {
            "useMouse": {
                "docstring": "Use the current mouse position rather than the centre of the active view.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "autoSave": {
        "description": "Provides an interface to the auto-save mechanism. In query mode, return type is based on queried flag.", 
        "flags": {
            "destination": {
                "docstring": "Sets the option for where auto-save files go. 0 - auto-saves go into the workspace autosave folder 1 - auto-saves go into the named folder (set with the -folder flag) 2 - auto-saves go into a folder set by an environment variable (MAYA_AUTOSAVE_FOLDER)"
            }, 
            "destinationFolder": {
                "docstring": "Queries the actual destination folder for auto-saves, based on the current setting of the -destination flag, workspace rules and environment variables. Resolves environment variables etc. and makes any relative path absolute (resolved relative to the workspace root). The returned string will end with a trailing separator ('/').Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "enable": {
                "docstring": "Enables or disables auto-saves."
            }, 
            "folder": {
                "docstring": "Sets the folder for auto-saves used if the destination option is 1."
            }, 
            "interval": {
                "docstring": "Sets the interval between auto-saves (in seconds). The default interval is 600 seconds (10 minutes)."
            }, 
            "limitBackups": {
                "docstring": "Sets whether the number of auto-save files is limited."
            }, 
            "maxBackups": {
                "docstring": "Sets the maximum number of auto-save files, if limiting is in effect."
            }, 
            "perform": {
                "docstring": "Invokes the auto-save process."
            }, 
            "prompt": {
                "docstring": "Sets whether the auto-save prompts the user before auto-saving."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "bakeClip": {
        "description": "This command is used to bake clips and blends into a single clip. ", 
        "flags": {
            "blend": {
                "docstring": "Specify the indicies of the clips being blended."
            }, 
            "clipIndex": {
                "docstring": "Specify the index of the clip to bake."
            }, 
            "keepOriginals": {
                "docstring": "Keep original clips in the trax editor and place the merged clip into the visor. The default is to schedule the merged clip, and to keep the original clips in the visor.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "Specify the name of the new clip to create."
            }
        }
    }, 
    "bakePartialHistory": {
        "description": "This command is used to bake sections of the construction history of a shape node when possible. A typical usage would be on a shape that has both modelling operations and deformers in its history. Using this command with the -prePostDeformers flag will bake the modeling portions of the graph, so that only the deformers remain. Note that not all modeling operations can be baked such that they create exactly the same effect after baking. For example, imagine the history contains a skinning operation followed by a smooth. Before baking, the smooth operation is performed each time the skin deforms, so it will smooth differently depending on the output of the skin. When the smooth operation is baked into the skinning, the skin will be reweighted based on the smooth points to attempt to approximate the original behavior. However, the skin node does not perform the smooth operation, it merely performs skinning with the newly calculated weights and the result will not be identical to before the bake. In general, modeling operations that occur before deformers can be baked precisely. Those which occur after can only be approximated. The -pre and -post flags allow you to control whether only the operations before or after the deformers are baked. When the command is used on an object with no deformers, the entire history will be deleted. ", 
        "flags": {
            "allShapes": {
                "docstring": "Specifies that the bake operation should be performed on all shapes in the entire scene. By default, only selected objects are baked."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "postSmooth": {
                "docstring": "Specifies whether or not a smoothing operation should be done on skin vertices. This smoothing is only done on vertices that are found to deviate largely from other vertex values. The default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preCache": {
                "docstring": "Specifies baking of any history operations that occur before the caching operation, including deformers. In query mode, returns a list of the nodes that will be baked."
            }, 
            "preDeformers": {
                "docstring": "Specifies baking of any modeling operations in the history that occur before the deformers. In query mode, returns a list of the nodes that will be baked."
            }, 
            "prePostDeformers": {
                "docstring": "Specifies baking of all modeling operations in the history whether they are before or after the deformers in the history. If neither the -prePostDeformers nor the -preDeformers flag is specified, prePostDeformers will be used as the default. In query mode, returns a list of the nodes that will be baked."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "bakeResults": {
        "description": "This command allows the user to replace a chain of dependency nodes which define the value for an attribute with a single animation curve. Command allows the user to specify the range and frequency of sampling. This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices should be specified as a range, as shown below. -time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.", 
        "flags": {
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "bakeOnOverrideLayer": {
                "docstring": "If true, all layered and baked attribute will be added as a top override layer.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "destinationLayer": {
                "docstring": ""
            }, 
            "disableImplicitControl": {
                "docstring": "Whether to disable implicit control after the anim curves are obtained as the result of this command. An implicit control to an attribute is some function that affects the attribute without using an explicit dependency graph connection. The control of IK, via ik handles, is an example."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "minimizeRotation": {
                "docstring": ""
            }, 
            "preserveOutsideKeys": {
                "docstring": "Whether to preserve keys that are outside the bake range when there are directly connected animation curves or a pairBlend node which has an animation curve as its direct input. The default (false) is to remove frames outside the bake range. If the channel that you are baking is not controlled by a single animation curve, then a new animation curve will be created with keys only in the bake range. In the case of pairBlend-driven channels, setting pok to true will retain both the pairBlend and its input animCurve. The blended values will be baked onto the animCurve and the weight of the pairBlend weight will be keyed to the animCurve during the baked range."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeBakedAttributeFromLayer": {
                "docstring": "If true, all baked attribute will be removed from the layer. Otherwise all layer associated with the baked attribute will be muted."
            }, 
            "resolveWithoutLayer": {
                "docstring": ""
            }, 
            "sampleBy": {
                "docstring": "Amount to sample by. Default is 1.0 in current timeUnit"
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "simulation": {
                "docstring": "Using this flag instructs the command to preform a simulation instead of just evaluating each attribute separately over the range of time. The simulation flag is required to bake animation that that depends on the whole scene being evaluated at each time step such as dynamics. The default is false."
            }, 
            "smart": {
                "docstring": ""
            }, 
            "sparseAnimCurveBake": {
                "docstring": "When this is true and anim curves are being baked, do not insert any keys into areas of the curve where animation is defined. And, use as few keys as possible to bake the pre and post infinity behavior. When this is false, one key will be inserted at each time step. The default is false."
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }
        }
    }, 
    "bakeSimulation": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.The bakeSimulation command is obsolete. Instead, \"bakeResults -simulation true\" should be used. The bakeSimulation command has retained for backwards compatibility. This command allows the user to replace a chain of dependency nodes, or implicit relationship, such as those between joints and IK handles, which define the value of an attribute, with a single animation curve. Command allows the user to specify the range and frequency of sampling. Unlike the bakeResults command, this command will actually set the time of the current scene to all the times, in sequence, inside the given time interval before it sets the time back to when it is started. As a result, it may modify the scene. In query mode, return type is based on queried flag.", 
        "flags": {
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "bakeOnOverrideLayer": {
                "docstring": ""
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "destinationLayer": {
                "docstring": ""
            }, 
            "disableImplicitControl": {
                "docstring": "Whether to disable implicit control after the anim curves are obtained as the result of this command. An implicit control to an attribute is some function that affects the attribute without using an explicit dependency graph connection. The control of IK, via ik handles, is an example."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "minimizeRotation": {
                "docstring": ""
            }, 
            "preserveOutsideKeys": {
                "docstring": "Whether to preserve keys that are outside the bake range when there are directly connected animation curves. The default (false) is to remove frames outside the bake range. If the channel that you are baking is not controlled by a single animation curve, then a new animation curve will be created with keys only in the bake range."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeBakedAttributeFromLayer": {
                "docstring": ""
            }, 
            "resolveWithoutLayer": {
                "docstring": ""
            }, 
            "sampleBy": {
                "docstring": "Amount to sample by. Default is 1.0 in current timeUnit"
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "simulation": {
                "docstring": "Using this flag instructs the command to preform a simulation instead of just evaluating each attribute separately over the range of time. The simulation flag is required to bake animation that that depends on the whole scene being evaluated at each time step such as dynamics. The default is true."
            }, 
            "smart": {
                "docstring": ""
            }, 
            "sparseAnimCurveBake": {
                "docstring": "When baking anim curves, do not insert any keys into areas of the curve where animation is defined. And, use as few keys as possible to bake the pre and post infinity behaviors. When this is false, one key will be inserted at each time step. The default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }
        }
    }, 
    "baseTemplate": {
        "description": "This is the class for the commands that edit and/or query templates. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified template exists. When used with the matchFile argument, the query will return true if the template exists and the filename it was loaded from matches the filename given."
            }, 
            "fileName": {
                "docstring": "Specifies the filename associated with the template. This argument can be used in conjunction with load, save or query modes. If no filename is associated with a template, a default file name based on the template name will be used. It is recommended but not required that the filename and template name correspond."
            }, 
            "force": {
                "docstring": "This flag is used with some actions to allow them to proceed with an overwrite or destructive operation. When used with load, it will allow an existing template to be reloaded from a file. When used in create mode, it will allow an existing template to be recreated (for example when using fromContainer argument to regenerate a template)."
            }, 
            "load": {
                "docstring": "Load an existing template from a file. If a filename is specified for the template, the entire file (and all templates in it) will be loaded. If no file is specified, a default filename will be assumed, based on the template name."
            }, 
            "matchFile": {
                "docstring": "Used in query mode in conjunction with other flags this flag specifies an optional file name that is to be matched as part of the query operation. "
            }, 
            "query": {
                "docstring": ""
            }, 
            "silent": {
                "docstring": "Silent mode will suppress any error or warning messages that would normally be reported from the command execution. The return values are unaffected."
            }, 
            "unload": {
                "docstring": "Unload the specified template. This action will not delete the associated template file if one exists, it merely removes the template definition from the current session."
            }, 
            "viewList": {
                "docstring": "Used in query mode, returns a list of all views defined on the template.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "baseView": {
        "description": "A view defines the layout information for the attributes of a particular node type or container. Views can be selected from a set of built-in views or may be defined on an associated container template. This command queries the view-related information for a container node or for a given template. The information returned from this command will be based on the view-related settings in force on the container node at the time of the query (i.e. the container's view mode, template name, view name attributes), when applicable. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "itemInfo": {
                "docstring": "Used in query mode in conjunction with the itemList flag. The command will return a list of information for each item in the view, the information fields returned for each item are determined by this argument value. The information fields will be listed in the string array returned. The order in which the keyword is specified will determine the order in which the data will be returned by the command. One or more of the following keywords, separated by colons ':' are used to specify the argument value. itemIndex : sequential item number (0-based)itemName : item name (string)itemLabel : item display label (string)itemDescription : item description field (string)itemLevel : item hierarchy level (0-n)itemIsGroup : (boolean 0 or 1) indicates whether or not this item is a groupitemIsAttribute : (boolean 0 or 1) indicates whether or not this item is an attributeitemNumChildren: number of immediate children (groups or attributes) of this itemitemAttrType : item attribute type (string)itemCallback : item callback field (string)"
            }, 
            "itemList": {
                "docstring": "Used in query mode, the command will return a list of information for each item in the view. The viewName flag is used to select the view to query. The information returned about each item is determined by the itemInfo argument value. For efficiency, it is best to query all necessary item information at one time (to avoid recomputing the view information on each call)."
            }, 
            "query": {
                "docstring": ""
            }, 
            "viewDescription": {
                "docstring": "Used in query mode, returns the description field associated with the selected view. If no description was defined for this view, the value will be empty."
            }, 
            "viewLabel": {
                "docstring": "Used in query mode, returns the display label associated with the view. An appropriate label suitable for the user interface will be returned based on the selected view. Use of the view label is usually more suitable than the view name for display purposes."
            }, 
            "viewList": {
                "docstring": "Used in query mode, command will return a list of all views defined for the given target (container or template)."
            }, 
            "viewName": {
                "docstring": "Used in query mode, specifies the name of the queried view when used in conjunction with a template target. When used in conjunction with a container target, it requires no string argument, and returns the name of the currently active view associated with the container; this value may be empty if the current view is not a valid template view or is generated by one of the built-in views modes. For this reason, the view label is generally more suitable for display purposes. In query mode, this flag can accept a value.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "batchRender": {
        "description": "The batchRender command is used to spawn off a separate rendering session of the current maya file. If no mayaFile is specified, it'll ask you whether you want the current job killed. The batchRender will spawn a separate maya process in which commands will be communicated to it through a commandPort. If Maya is unable to find an available port an error will be produced. Maya will attempt to use ports 7835 through 7844. ", 
        "flags": {
            "filename": {
                "docstring": "Filename to be rendered; if empty, a temporary filename will be created."
            }, 
            "melCommand": {
                "docstring": "Mel command to execute to run a renderer other than the software renderer."
            }, 
            "numProcs": {
                "docstring": "Number of processors to use (0 means use all available processors)."
            }, 
            "preRenderCommand": {
                "docstring": "Command to be run prior to invoking mentalray standalone renderer."
            }, 
            "remoteRenderMachine": {
                "docstring": "Name of remote render machine. Not available on Windows."
            }, 
            "renderCommandOptions": {
                "docstring": "Arguments to the render command for mentalray standalone rendering."
            }, 
            "showImage": {
                "docstring": "Show progress of the current rendering job."
            }, 
            "status": {
                "docstring": ""
            }, 
            "useRemoteRender": {
                "docstring": "If remote rendering is desired. Not available on Windows."
            }, 
            "useStandalone": {
                "docstring": "Batch rendering is to be done with mentalray standalone"
            }, 
            "verbosity": {
                "docstring": "Defines the verbosity level to report the batch rendering status: 1: display only one start message, then one message when all frames are rendered.2: display only start and end frame messages.3: display all messages (default).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "bevel": {
        "description": "The bevel command creates a new bevel surface for the specified curve. The curve can be any nurbs curves. ", 
        "flags": {
            "bevelShapeType": {
                "docstring": "Shape type: 1 - straight cut, 2 - curve out, 3 - curve inDefault:1Advanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "cornerType": {
                "docstring": "Corner type: 1 - linear, 2 - circularDefault:2"
            }, 
            "depth": {
                "docstring": "The depth for bevelDefault:0.5"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "extrudeDepth": {
                "docstring": "The extrude depth for bevelDefault:1.0"
            }, 
            "joinSurfaces": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "numberOfSides": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curveFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "tolerance": {
                "docstring": "The tolerance for bevel offsetsDefault:0.01"
            }, 
            "width": {
                "docstring": "The width for bevelDefault:0.5"
            }
        }
    }, 
    "bevelPlus": {
        "description": "The bevelPlus command creates a new bevel surface for the specified curves using a given style curve. The first curve should be the \"outside\" curve, and the (optional) rest of them should be inside of the first one. For predictable results, the curves should be planar and all in the same plane. ", 
        "flags": {
            "bevelInside": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "capSides": {
                "docstring": "How to cap the bevel. 1 - no caps2 - cap at start only3 - cap at end only4 - cap at start and endDefault:4"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "depth": {
                "docstring": "The depth for the bevel.Default:0.5"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "extrudeDepth": {
                "docstring": "The extrude distance (depth) for bevel.Default:1.0"
            }, 
            "innerStyle": {
                "docstring": "Similar to outerStyle, this style is applied to all but the first (outer) curve specified."
            }, 
            "joinSurfaces": {
                "docstring": "Attach bevelled surfaces into one surface for each input curve.Default:true"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "normalsOutwards": {
                "docstring": "If enabled, the normals point outwards on the resulting NURBS or poly surface."
            }, 
            "numberOfSides": {
                "docstring": "How to apply the bevel. 1 - no bevels2 - bevel at start only3 - bevel at end only4 - bevel at start and endDefault:4"
            }, 
            "outerStyle": {
                "docstring": "Choose a style to use for the bevel of the first (outer) curve. There are 15 predefined styles (values 0 to 14 can be used to select them). For those experienced with MEL, you can, after the fact, specify a custom curve and use it for the style curve. See the documentation for styleCurve node to see what requirements a style curve must satisfy."
            }, 
            "polyOutChordHeight": {
                "docstring": "Chord height is the absolute distance in object space which the center of a polygon edge can deviate from the actual center of the surface span. Only used if Method is Sampling and if polyOutseChordHeight is true.Default:0.1"
            }, 
            "polyOutChordHeightRatio": {
                "docstring": "Chord height ratio is the ratio of the chord length of a surface span to the chord height. (This is a length to height ratio). 0 is a very loose fit. 1 is a very tight fit. This applies to the polygonal output type only. (See also description of chord height.) Used if Method is Sampling and polyOutUseChordHeightRatio is true.Default:0.1Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "polyOutCount": {
                "docstring": "The number of polygons to produce when the polygon is requested. Only used if Method is face count (0).Default:200"
            }, 
            "polyOutCurveSamples": {
                "docstring": "Initial number of samples in the curve direction. Only used if Method is Sampling.Default:6"
            }, 
            "polyOutCurveType": {
                "docstring": "Initial tessellation criteria along the curve. Only used if Method is Sampling. 2 - Complete Curve. This type places a specific number of sample points along the curve, equally spaced in parameter space.3 - Curve Span. This type places a specific number of sample points across each curve span, equally spaced in parameter space.Default:3"
            }, 
            "polyOutExtrusionSamples": {
                "docstring": "Initial number of samples along the extrusion. Only used if Method is Sampling.Default:2"
            }, 
            "polyOutExtrusionType": {
                "docstring": "Initial type tessellation criteria along the extrude direction. Used only if Method is Sampling. 2 - Complete Extrusion. This type places a specific number of lines across the surface, equally spaced in parameter space.3 - Extrusion Section. This type places a specific number of lines across each surface span, equally spaced in parameter space.Default:3"
            }, 
            "polyOutMethod": {
                "docstring": "Method for the polygonal output: 0 - Face Count, 2 - SamplingDefault:2"
            }, 
            "polyOutUseChordHeight": {
                "docstring": "True means use chord height. This is a secondary criteria that refines the tessellation produced using the sampling value. Only used if Method is Sampling.Default:false"
            }, 
            "polyOutUseChordHeightRatio": {
                "docstring": "True means use chord height ratio. This is a secondary criteria that refines the tessellation produced using the sampling value. Only used if Method is Sampling.Default:true"
            }, 
            "polygon": {
                "docstring": "Create a polyset (1) instead of nurbs surface (0)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": "The tolerance for creating NURBS caps.Default:0.01"
            }, 
            "width": {
                "docstring": "The width for the bevel.Default:0.5"
            }
        }
    }, 
    "bezierAnchorPreset": {
        "description": "This command provides a queryable interface for Bezier curve shapes. ", 
        "flags": {
            "preset": {
                "docstring": "Selects a preset to apply to selected Bezier anchors. Valid arguments are: 0: Bezier 1: Bezier Corner 2: CornerFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "bezierAnchorState": {
        "description": "The bezierAnchorState command provides an easy interface to modify anchor states: - Smooth/Broken anchor tangents - Even/Uneven weighted anchor tangents ", 
        "flags": {
            "even": {
                "docstring": "Sets selected anchors (or attached tangent handles) to even weighting when true, uneven otherwise.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "smooth": {
                "docstring": "Sets selected anchors (or attached tangent handles) to smooth when true, broken otherwise."
            }
        }
    }, 
    "bezierCurveToNurbs": {
        "description": "The bezierCurveToNurbs command attempts to convert an existing NURBS curve to a Bezier curve. ", 
        "flags": {}
    }, 
    "bezierInfo": {
        "description": "This command provides a queryable interface for Bezier curve shapes. ", 
        "flags": {
            "anchorFromCV": {
                "docstring": "Returns the Bezier anchor index from a given CV index"
            }, 
            "cvFromAnchor": {
                "docstring": "Returns the CV index for a given Bezier anchor index"
            }, 
            "isAnchorSelected": {
                "docstring": "Returns 1 if an anchor CV is currently selected. 0, otherwise."
            }, 
            "isTangentSelected": {
                "docstring": "Returns 1 if a tangent CV is currently selected. 0, otherwise."
            }, 
            "onlyAnchorsSelected": {
                "docstring": "Returns 1 if the only CV components selected are anchor CVs. 0, otherwise."
            }, 
            "onlyTangentsSelected": {
                "docstring": "Returns 1 if the only CV components selected are tangent CVs. 0, otherwise.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "binMembership": {
        "description": "Command to assign nodes to bins. ", 
        "flags": {
            "addToBin": {
                "docstring": "Add the nodes in a node list to a bin."
            }, 
            "exists": {
                "docstring": "Query if a node exists in a bin. The exists flag can take only one node."
            }, 
            "inheritBinsFromNodes": {
                "docstring": "Let the node in the flag's argument inherit bins from nodes in the specified node list. The node list is specified as the object of the command."
            }, 
            "isValidBinName": {
                "docstring": "Query if the specified bin name is valid. If so, return true. Otherwise, return false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "listBins": {
                "docstring": "Query and return a list of bins a list of nodes belong to. If a bin contains any of the nodes in the selection list, then it should be included in the returned bin list."
            }, 
            "makeExclusive": {
                "docstring": "Make the specified nodes belong exclusively in the specified bin."
            }, 
            "notifyChanged": {
                "docstring": "This flag is used to notify that binMembership has been changed."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeFromBin": {
                "docstring": "Remove the nodes in a node list from a bin."
            }
        }
    }, 
    "bindSkin": {
        "description": "This command binds the currently selected objects to the currently selected skeletons. Shapes which can be bound are: meshes, nurbs curves, nurbs surfaces, lattices, subdivision surfaces, and API shapes. Multiple shapes and multiple skeletons can be bound at once by selecting them or specifying them on the command line. Selection order is not important.The skin is bound using the so-called \"rigid\" bind, in which the components are rigidly attached to the closest bone in the skeleton. Flexors can later be added to the skeleton to smooth out the skinning around joints.The skin(s) can be bound either to the entire skeleton hierarchy of the selected joint(s), or to only the selected joints. The entire hierarchy is the default. The -tsb/-toSelectedBones flag allows binding to only the selected bones.This command can also be used to detach the skin from the skeleton. Detaching the skin is useful in a variety of situations, such as: inserting additional bones, deleting bones, changing the bind position of the skeleton or skin, or simply getting rid of the skinning nodes altogether. The options to use when detaching the skin depend on how much of the skinning info you want to get rid of. Namely: (1) -delete or -unbind: remove all skinning nodes, (2) -unbindKeepHistory: remove the skinning sets, but keep the weights, (3) -disable: disable the skinning but keep the skinning sets and the weights. ", 
        "flags": {
            "byClosestPoint": {
                "docstring": "bind each point in the object to the segment closest to the point. The byClosestPoint and byPartition flags are mutually exclusive. The byClosestPoint flag is the default."
            }, 
            "byPartition": {
                "docstring": "bind each group in the partition to the segment closest to the group's centroid. A partition must be specified with the -p/-partition flag"
            }, 
            "colorJoints": {
                "docstring": "In bind mode, this flag assigns colors to the joints based on the colors assigned to the joint's skin set. In delete and unlock mode, this flag removes the colors from joints that are no longer bound as skin. In disable and unbindKeepHistory mode, this flag does nothing."
            }, 
            "delete": {
                "docstring": "Detach the skin on the selected skeletons and remove all bind- related construction history."
            }, 
            "doNotDescend": {
                "docstring": "Do not descend to shapes that are parented below the selected object(s). Bind only the selected objects."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "Enable or disable a bind that has been disabled on the selected skeletons. To enable the bind on selected bones only, select the bones and use the -tsb flag with the -en flag. This flag is used when you want to temporarily disable the bind without losing the set information or the weight information of the skinning, for example if you want to modify the bindPose."
            }, 
            "name": {
                "docstring": "This flag is obsolete.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "partition": {
                "docstring": "Specify a partition to bind by. This is only valid when used with the -bp/-byPartition flag."
            }, 
            "query": {
                "docstring": ""
            }, 
            "toAll": {
                "docstring": "objects will be bound to the entire selected skeletons. Even bones with zero influence will be bound, whereas the toSkeleton will only bind non-zero influences."
            }, 
            "toSelectedBones": {
                "docstring": "objects will be bound to the selected bones only."
            }, 
            "toSkeleton": {
                "docstring": "objects will be bound to the selected skeletons. The toSkeleton, toAll and toSelectedBones flags are mutually exclusive. The toSkeleton flag is the default."
            }, 
            "unbind": {
                "docstring": "unbind the selected objects. They will no longer move with the skeleton. Any bindSkin history that is no longer used will be deleted."
            }, 
            "unbindKeepHistory": {
                "docstring": "unbind the selected objects. They will no longer move with the skeleton. However, existing weights on the skin will be kept for use the next time the skin is bound. This option is appropriate if you want to modify the skeleton without losing the weighting information on the skin."
            }, 
            "unlock": {
                "docstring": "unlock the selected objects. Since bindSkin will no longer give normal results if bound objects are moved away from the skeleton, bindSkin locks translate, rotate and scale. This command unlocks the selected objects translate, rotate and scale."
            }
        }
    }, 
    "blend": {
        "description": "", 
        "flags": {
            "autoDirection": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "crvsInFirstRail": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "flipLeft": {
                "docstring": ""
            }, 
            "flipRight": {
                "docstring": ""
            }, 
            "leftParameter": {
                "docstring": ""
            }, 
            "multipleKnots": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": ""
            }, 
            "polygon": {
                "docstring": ""
            }, 
            "positionTolerance": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rightParameter": {
                "docstring": ""
            }, 
            "tangentTolerance": {
                "docstring": ""
            }
        }
    }, 
    "blend2": {
        "description": "This command creates a surface by blending between given curves. This is an enhancement (more user control) compared to blend which is now obsolete. ", 
        "flags": {
            "autoAnchor": {
                "docstring": "If true and both paths are closed, automatically determine the value on the right rail so that they matchDefault:true"
            }, 
            "autoNormal": {
                "docstring": "If true, the direction of each starting tangent is computed based on given geometry.Default:true"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "crvsInFirstRail": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "flipLeftNormal": {
                "docstring": "If true, flip the starting tangent off the left boundary.Default:false"
            }, 
            "flipRightNormal": {
                "docstring": "If true, flip the starting tangent off the right boundary.Default:false"
            }, 
            "leftAnchor": {
                "docstring": "The reference parameter on the left boundary where the blend surface starts in the case of the closed rail.Default:0.0"
            }, 
            "leftEnd": {
                "docstring": "The reference parameter on the left boundary where the blend surface ends.Default:1.0"
            }, 
            "leftStart": {
                "docstring": "The reference parameter on the left boundary where the blend surface starts.Default:0.0"
            }, 
            "multipleKnots": {
                "docstring": "If true, use the new blend which produces fully multiple interior knotsDefault:true"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "positionTolerance": {
                "docstring": "The positional C(0) tolerance of the blend surface to the adjacent surfaces.Default:0.1"
            }, 
            "query": {
                "docstring": ""
            }, 
            "reverseLeft": {
                "docstring": "If true, reverse the direction off the left boundary. autoDirection must be false for this value to be considered.Default:false"
            }, 
            "reverseRight": {
                "docstring": "If true, reverse the direction of the right boundary. autoDirection must be false for this value to be considered.Default:falseAdvanced flags"
            }, 
            "rightAnchor": {
                "docstring": "The reference parameter on the right boundary where the blend surface starts in the case of the closed rail.Default:0.0"
            }, 
            "rightEnd": {
                "docstring": "The reference parameter on the right boundary where the blend surface ends.Default:1.0"
            }, 
            "rightStart": {
                "docstring": "The reference parameter on the right boundary where the blend surface starts.Default:0.0"
            }, 
            "tangentTolerance": {
                "docstring": "The tangent G(1) continuity tolerance of the blend surface to the adjacent surfaces.Default:0.1"
            }
        }
    }, 
    "blendCtx": {
        "description": "", 
        "flags": {
            "activeNodes": {
                "docstring": ""
            }, 
            "autoCreate": {
                "docstring": ""
            }, 
            "autoDirection": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "crvsInFirstRail": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "flipLeft": {
                "docstring": ""
            }, 
            "flipRight": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "immediate": {
                "docstring": ""
            }, 
            "leftParameter": {
                "docstring": ""
            }, 
            "multipleKnots": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": ""
            }, 
            "polygon": {
                "docstring": ""
            }, 
            "positionTolerance": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": ""
            }, 
            "rightParameter": {
                "docstring": ""
            }, 
            "tangentTolerance": {
                "docstring": ""
            }, 
            "toolNode": {
                "docstring": ""
            }, 
            "useGlobalTol": {
                "docstring": ""
            }
        }
    }, 
    "blendShape": {
        "description": "This command creates a blendShape deformer, which blends in specified amounts of each target shape to the initial base shape. Each base shape is deformed by its own set of target shapes. Every target shape has an index that associates it with one of the shape weight values.In the create mode the first item on the selection list is treated as the base and the remaining inputs as targets. If the first item on the list has multiple shapes grouped beneath it, the targets must have an identical shape hierarchy. Additional base shapes can be added in edit mode using the deformers -g flag. ", 
        "flags": {
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "envelope": {
                "docstring": "Set the envelope value for the deformer, controlling how much of the total deformation gets applied. Default is 1.0."
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "inBetween": {
                "docstring": "Indicate that the specified target should serve as an inbetween. An inbetween target is one that serves as an intermediate target between the base shape and another target."
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "normalizationGroups": {
                "docstring": "Returns a list of the used normalization group IDs.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "origin": {
                "docstring": "blendShape will be performed with respect to the world by default. Valid values are \"world\" and \"local\". The local flag will cause the blend shape to be performed with respect to the shape's local origin."
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "target": {
                "docstring": "Set target object as the index target shape for the base shape base object. The full influence of target shape takes effect when its shape weight is targetValue.Parameter list: string: the base objectint: indexstring: the target objectdouble: target value"
            }, 
            "topologyCheck": {
                "docstring": "Set the state of checking for a topology match between the shapes being blended. Default is on."
            }, 
            "weight": {
                "docstring": "Set the weight value (second parameter) at index (first parameter)."
            }, 
            "weightCount": {
                "docstring": "Set the number of shape weight values."
            }
        }
    }, 
    "blendShapeEditor": {
        "description": "This command creates an editor that derives from the base editor class that has controls for blendShape, control nodes. ", 
        "flags": {
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "targetControlList": {
                "docstring": ""
            }, 
            "targetList": {
                "docstring": "Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "verticalSliders": {
                "docstring": ""
            }
        }
    }, 
    "blendShapePanel": {
        "description": "This command creates a panel that derives from the base panel class that houses a blendShapeEditor. ", 
        "flags": {
            "blendShapeEditor": {
                "docstring": "Query only flag that returns the name of an editor to be associated with the panel.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "control": {
                "docstring": "Returns the top level control for this panel. Usually used for getting a parent to attach popup menus. CAUTION: panels may not have controls at times. This flag can return \"\" if no control is present."
            }, 
            "copy": {
                "docstring": "Makes this panel a copy of the specified panel. Both panels must be of the same type."
            }, 
            "createString": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the maya panel."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editString": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "init": {
                "docstring": "Initializes the panel's default state. This is usually done automatically on file -new and file -open."
            }, 
            "isUnique": {
                "docstring": "Returns true if only one instance of this panel type is allowed."
            }, 
            "label": {
                "docstring": "Specifies the user readable label for the panel."
            }, 
            "menuBarVisible": {
                "docstring": "Controls whether the menu bar for the panel is displayed."
            }, 
            "needsInit": {
                "docstring": "(Internal) On Edit will mark the panel as requiring initialization. Query will return whether the panel is marked for initialization. Used during file -new and file -open."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this panel."
            }, 
            "popupMenuProcedure": {
                "docstring": "Specifies the procedure called for building the panel's popup menu(s). The default value is \"buildPanelPopupMenu\". The procedure should take one string argument which is the panel's name."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replacePanel": {
                "docstring": "Will replace the specifed panel with this panel. If the target panel is within the same layout it will perform a swap."
            }, 
            "tearOff": {
                "docstring": "Will tear off this panel into a separate window with a paneLayout as the parent of the panel. When queried this flag will return if the panel has been torn off into its own window."
            }, 
            "tearOffCopy": {
                "docstring": "Will create this panel as a torn of copy of the specified source panel."
            }, 
            "unParent": {
                "docstring": "Specifies that the panel should be removed from its layout. This (obviously) cannot be used with query."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "blendTwoAttr": {
        "description": "A blendTwoAttr nodes takes two inputs, and blends the values of the inputs from one to the other, into an output value. The blending of the two inputs uses a blending function, and the following formula:(1 - blendFunction) \\* input[0]  +  blendFunction \\* input[1]  The blendTwoAttr command can be used to blend the animation of an object to transition smoothly between the animation of two other objects. When the blendTwoAttr command is issued, it creates a blendTwoAttr node on the specified attributes, and reconnects whatever was previously connected to the attributes to the new blend nodes. You may also specify which two attributes should be used to blend together. The driver is used when you want to keyframe an object after it is being animated by a blend node. The current driver index specifies which of the two blended attributes should be keyframed. ", 
        "flags": {
            "attribute": {
                "docstring": "A list of attributes for the selected nodes for which a blendTwoAttr node will be created. "
            }, 
            "attribute0": {
                "docstring": "The attribute that should be connected to the first input of the new blendTwoAttr node. When queried, it returns a string."
            }, 
            "attribute1": {
                "docstring": "The attribute that should be connected to the second input of the new blendTwoAttr node. When queried, it returns a string."
            }, 
            "blender": {
                "docstring": "The blender attribute. This is the attribute that will be connected to the newly created blendTwoAttr node(s) blender attribute. This attribute controls how much of each of the two attributes to use in the blend. If this flag is not specified, a new animation curve is created whose value goes from 1 to 0 throughout the time range specified by the -t flag. If -t is not specified, an abrupt change from the value of the first to the value of the second attribute will occur at the current time when this command is issued."
            }, 
            "controlPoints": {
                "docstring": "Explicitly specify whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "driver": {
                "docstring": "The index of the driver attribute for this blend node (0 or 1) When queried, it returns an integer."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "name for the new blend node(s)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "shape": {
                "docstring": "Consider all attributes of shapes below transforms as well, except \"controlPoints\". Default: true"
            }, 
            "time": {
                "docstring": "The time range between which the blending between the 2 attributes should occur. If a single time is specified, then the blend will cause an abrupt change from the first to the second attribute at that time. If a range is specified, a smooth blending will occur over that time range. The default is to make a sudden transition at the current time."
            }
        }
    }, 
    "blindDataType": {
        "description": "This command creates a blind data type, which is represented by a blindDataTemplate node in the DG. A blind data type can have one or more attributes. On the command line, the attributes should be ordered by type for best memory utilization, largest first: string, binary, double, float, int, and finally boolean. Once a blind data type is created, blind data of that type may be assigned using the polyBlindData command. Note that as well as polygon components, blind data may be assigned to objects and to NURBS patches. A blind data type may not be modified after it is created: in order to do so it must be deleted and recreated. Any existing blind data of that type would also need to be deleted and recreated. When used with the query flag, this command will return information about the attributes of the specified blind data type. ", 
        "flags": {
            "dataType": {
                "docstring": "Specifies the dataTypes that are part of BlindData node being created. Allowable strings are \"int\", \"float\", \"double\", \"string\", \"boolean\" and \"binary\". Must be used togeter with the -ldn and -sdn flags to specify each attribute."
            }, 
            "longDataName": {
                "docstring": "Specifies the long names of the datas that are part of BlindData node being created. Must be used togeter with the -dt and -sdn flags to specify each attribute."
            }, 
            "longNames": {
                "docstring": "Specifies that for a query command the long attributes names be listed."
            }, 
            "query": {
                "docstring": "Specifies that this is a special query type command."
            }, 
            "shortDataName": {
                "docstring": "Specifies the short names of the data that are part of BlindData node being created. Must be used togeter with the -dt and -ldn flags to specify each attribute.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "shortNames": {
                "docstring": "Specifies that for a query command the short attribute names be listed."
            }, 
            "typeId": {
                "docstring": "Specifies the typeId of the BlindData type being created."
            }, 
            "typeNames": {
                "docstring": "Specifies that for a query command the data types be listed."
            }
        }
    }, 
    "boneLattice": {
        "description": "This command creates/edits/queries a boneLattice deformer. The name of the created/edited object is returned. Usually you would make use of this functionality through the higher level flexor command. ", 
        "flags": {
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "bicep": {
                "docstring": "Affects the bulging of lattice points on the inside of the bend. Positive/negative values cause the points to bulge outwards/inwards. Default value is 0.0. When queried, this flag returns a float."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "joint": {
                "docstring": "Specifies which joint will be used to drive the bulging behaviors."
            }, 
            "lengthIn": {
                "docstring": "Affects the location of lattice points along the upper half of the bone. Positive/negative values cause the points to move away/towards the center of the bone. Changing this parameter also modifies the regions affected by the creasing, rounding and width parameters. Default value is 0.0. When queried, this flag returns a float."
            }, 
            "lengthOut": {
                "docstring": "Affects the location of lattice points along the lower half of the bone. Positive/negative values cause the points to move away/towards the center of the bone. Changing this parameter also modifies the regions affected by the creasing, rounding and width parameters. Default value is 0.0. When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "transform": {
                "docstring": "Specifies which dag node is being used to rigidly transform the lattice which this node is going to deform. If this flag is not specified an identity matrix will be assumed.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "tricep": {
                "docstring": "Affects the bulging of lattice points on the outside of the bend. Positive/negative values cause the points to bulge outwards/inwards. Default value is 0.0. When queried, this flag returns a float."
            }, 
            "widthLeft": {
                "docstring": "Affects the bulging of lattice points on the left side of the bend. Positive/negative values cause the points to bulge outwards/inwards. Default value is 0.0. When queried, this flag returns a float."
            }, 
            "widthRight": {
                "docstring": "Affects the bulging of lattice points on the right side of the bend. Positive/negative values cause the points to bulge outwards/inwards. Default value is 0.0. When queried, this flag returns a float."
            }
        }
    }, 
    "boundary": {
        "description": "This command produces a boundary surface given 3 or 4 curves. This resulting boundary surface passes through two of the given curves in one direction, while in the other direction the shape is defined by the remaining curve(s). If the \"endPoint\" option is on, then the curve endpoints must touch before a surface will be created. This is the usual situation where a boundary surface is useful. Note that there is no tangent continuity option with this command. Unless all the curve end points are touching, the resulting surface will not pass through all curves. Instead, use the birail command. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endPoint": {
                "docstring": "True means the curve ends must touch before a surface will be created.Default:false"
            }, 
            "endPointTolerance": {
                "docstring": "Tolerance for end points, only used if endPoint attribute is true.Default:0.1Advanced flags"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "order": {
                "docstring": "True if the curve order is important.Default:true"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curveFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "boxDollyCtx": {
        "description": "This command can be used to create, edit, or query a dolly context. ", 
        "flags": {
            "alternateContext": {
                "docstring": "Set the ALT+CRL+LMB to refer to this context.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "toolName": {
                "docstring": ""
            }
        }
    }, 
    "boxZoomCtx": {
        "description": "This command can be used to create, edit, or query a box zoom context. If this context is used on a perspective camera, the field of view and view direction are changed. If the camera is orthographic, the orthographic width and eye point are changed. The left and middle mouse interactively zoom the view. The control key can be used to enable box zoom. A box starting from left to right will zoom in, and a box starting from right to left will zoom out. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "zoomScale": {
                "docstring": "Scale the zoom.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "bufferCurve": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.This command helps manage buffer curve for animated objects ", 
        "flags": {
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "exists": {
                "docstring": "Returns true if a buffer curve currently exists on the specified attribute; false otherwise.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "overwrite": {
                "docstring": "Create a buffer curve. \"true\" means create a buffer curve whether or not one already existed. \"false\" means if a buffer curve exists already then leave it alone. If no flag is specified, then the command defaults to -overwrite false"
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "swap": {
                "docstring": "for animated attributes which have buffer curves, swap the buffer curve with the current animation curve"
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }
        }
    }, 
    "buildBookmarkMenu": {
        "description": "This command handles building the \"dynamic\" Bookmark menu, to show all bookmarks (\"sets\") of a specified type (\"sets -text\") menuName is the string returned by the \"menu\" command. ", 
        "flags": {
            "editor": {
                "docstring": "Name of the editor which this menu belongs toFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "type": {
                "docstring": "Type of bookmark (sets -text) to display"
            }
        }
    }, 
    "buildKeyframeMenu": {
        "description": "This command handles building the \"dynamic\" Keyframe menu, to show attributes of currently selected objects, filtered by the current manipulator. menuName is the string returned by the \"menu\" command. The target menu will entries appended to it (and deleted from it) to always show what's currently keyframable. ", 
        "flags": {}
    }, 
    "button": {
        "description": "Create a button control capable of displaying a textual label and executing a command when selected by the user. ", 
        "flags": {
            "actOnPress": {
                "docstring": "If true then the command specified by the command flag will be executed when a mouse button is pressed. If false then that command will be executed after the mouse button is released. The default value is false."
            }, 
            "actionIsSubstitute": {
                "docstring": "This flag is obsolete and should no longer be used.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "align": {
                "docstring": "This flag is obsolete and should no longer be used. The button label will always be center-aligned."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "command": {
                "docstring": "Command executed when the control is pressed."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The label text. The default label is the name of the control."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "recomputeSize": {
                "docstring": "If true then the control will recompute it's size to just fit the size of the label. If false then the control size will remain fixed as you change the size of the label. The default value of this flag is true."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "buttonManip": {
        "description": "This creates a button manipulator. This manipulator has a position in space and a triad manip for positioning. When you click on the top part of the manip, the command defined by the first argument is executed. The command is associated with the manipulator when it is created. If a dag object is included on the command line, the manip will be parented to the object. This means moving the object will move the manip. You can move the manip independently of the object using its triad. Note that a buttonManip may not be parented to more than one object. ", 
        "flags": {
            "icon": {
                "docstring": "Specify an icon to represent the manipulator.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "cacheFile": {
        "description": "Creates one or more cache files on disk to store attribute data for a span of frames. The caches can be created for either points on a geometry (using the pts/points flag) or for vectorArray output data (using the oa/outAttr flag). When the ia/inAttr flag is used, connects a cacheFile node that associates the data file on disk with the attribute. Frames can be replaced/appended to an existing cache with the rcf/replaceCachedFrame and apf/appendFrame flag. Replaced frames are never deleted. They are stored in the same directory as the original cache files with the name provided by the f/fileName flag. If no file name is provided, the cacheFile name is prefixed with \"backup\" followed by a unique number. Single file caches are backed up in their entirety. To revert to an older version, simply attach to this cache. One file per frame caches only backup the description file and the frames that were replaced. To recover these types of caches, the user must rename these files to the original name. ", 
        "flags": {
            "appendFrame": {
                "docstring": "Appends data to the cache for the times specified by the startTime and endTime flags. If no time is provided, appends the current time. Must be used in conjunction with the pts/points or cnd/cacheableNode flag. Any overwritten frames will not be deleted, but renamed as specified by the f/fileName flag."
            }, 
            "attachFile": {
                "docstring": "Used to indicate that rather than creating a cache file, that an existing cache file on disk should be attached to an attribute in the scene. The inAttr flag is used to specify the attribute."
            }, 
            "cacheFileNode": {
                "docstring": "Specifies the name of the cache file node(s) we are appending/replacing to if more than one cache is attached to the specified geometries. "
            }, 
            "cacheFormat": {
                "docstring": "Cache file format, default is Maya's .mcc format, but others available via pluginFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "cacheInfo": {
                "docstring": "In create mode, used to specify a mel script returning a string array. When creating the cache, this mel script will be executed and the returned strings will be written to the .xml description file of the cache. In query mode, returns descriptive info stored in the cacheFile such as the user name, Maya scene name and maya version number."
            }, 
            "cacheableAttrs": {
                "docstring": "Returns the list of cacheable attributes defined on the accompanying cache node. This argument requires the use of the cacheableNode flag."
            }, 
            "cacheableNode": {
                "docstring": "Specifies the name of a cacheable node whose contents will be cached. A cacheable node is a node that is specially designed to work with the caching mechanism. An example of a cacheable node is a nCloth node. "
            }, 
            "channelIndex": {
                "docstring": "A query-only flag which returns the channel index for the selected geometry for the cacheFile node specified using the cacheFileNode flag."
            }, 
            "channelName": {
                "docstring": "When attachFile is used, used to indicate the channel in the file that should be attached to inAttr. If not specified, the first channel in the file is used. In query mode, allows user to query the channels associated with a description file."
            }, 
            "convertPc2": {
                "docstring": "Convert a PC2 file to the Maya cache format (true), or convert Maya cache to pc2 format (false)"
            }, 
            "createCacheNode": {
                "docstring": "Used to indicate that rather than creating a cache file, that a cacheFile node should be created related to an existing cache file on disk."
            }, 
            "creationChannelName": {
                "docstring": "When creating a new cache, this multi-use flag specifies the channels to be cached. The names come from the cacheable channel names defined by the object being cached. If this flag is not used when creating a cache, then all cacheable channels are cached."
            }, 
            "dataSize": {
                "docstring": "This is a query-only flag that returns the size of the data being cached per frame. This flag is to be used in conjunction with the cacheableNode, points, and outAttr flags."
            }, 
            "deleteCachedFrame": {
                "docstring": "Deletes cached data for the times specified by the startTime/endTime flags. If no time is provided, deletes the current frame. Must be used in conjunction with the pts/points or cnd/cacheableNode flag. Deleted frames will not be removed from disk, but renamed as specified by the f/fileName flag."
            }, 
            "descriptionFileName": {
                "docstring": "This is a query-only flag that returns the name of the description file for an existing cacheFile node. Or if no cacheFile node is specified, it returns the description file name that would be created based on the other flags specified."
            }, 
            "directory": {
                "docstring": "Specifies the directory where the cache files will be located. If the directory flag is not specified, the cache files will be placed in the project data directory."
            }, 
            "doubleToFloat": {
                "docstring": "During cache creation, double data is stored in the file as floats. This helps cut down file size."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endTime": {
                "docstring": "Specifies the end frame of the cache range."
            }, 
            "fileName": {
                "docstring": "Specifies the base file name for the cache files. If more than one object is being cached and the format is OneFilePerFrame, each cache file will be prefixed with this base file name. In query mode, returns the files associated with the specified cacheFile node. When used with rpf/replaceCachedFrame or apf/appendFrame specifies the name of the backup files. If not specified, replaced frames will be stored with a default name. In query mode, this flag can accept a value."
            }, 
            "format": {
                "docstring": "Specifies the format of the cache. Valid values are \"OneFile\" and \"OneFilePerFrame\""
            }, 
            "geometry": {
                "docstring": "A query flag which returns the geometry controlled by the specified cache node"
            }, 
            "inAttr": {
                "docstring": "Specifies the name of the attribute that the cache file will drive. This file is optional when creating cache files. If this flag is not used during create mode, the cache files will be created on disk, but will not be driving anything in the scene. This flag is required when the attachFile flag is used."
            }, 
            "inTangent": {
                "docstring": "Specifies the in-tangent type when interpolating frames before the replaced frame(s). Must be used with the ist/interpStartTime and iet/interpEndTime flags. Valid values are \"linear\", \"smooth\" and \"step\"."
            }, 
            "interpEndTime": {
                "docstring": "Specifies the frame until which there will be linear interpolation, beginning at endTime. Must be used with the rpf/replaceCachedFrame or apf/appendFrame flag. Interpolation is achieved by removing frames between endTime and interpEndTime from the cache. Removed frames will be renamed as specified by the f/fileName flag."
            }, 
            "interpStartTime": {
                "docstring": "Specifies the frame from which to begin linear interpolation, ending at startTime. Must be used with the rpf/replaceCachedFrame or apf/appendFrame flags. Interpolation is achieved by removing frames between interpStartTime and startTime from the cache. These removed frames will will be renamed as specified by the f/fileName flag."
            }, 
            "noBackup": {
                "docstring": "Specifies that backup files should not be created for any files that may be over-written during append, replace or delete cache frames. Can only be used with the apf/appendFrame, rpf/replaceCachedFrame or dcf/deleteCachedFrame flags."
            }, 
            "outAttr": {
                "docstring": "Specifies the name of the attribute that will be cached to disk. "
            }, 
            "outTangent": {
                "docstring": "Specifies the out-tangent type when interpolating frames after the replaced frame(s). Must be used with the ist/interpStartTime and iet/interpEndTime flags. Valid values are \"linear\", \"smooth\" and \"step\"."
            }, 
            "pc2File": {
                "docstring": "Specifies the full path to the pc2 file. Must be used in conjunction with the pc2 flag."
            }, 
            "pointCount": {
                "docstring": "A query flag which returns the number of points stored in the cache file. The channelName flag should be used to specify the channel to be queried."
            }, 
            "points": {
                "docstring": "Specifies the name of a geometry whose points will be cached. "
            }, 
            "prefix": {
                "docstring": "Indicates that the specified fileName should be used as a prefix for the cacheName."
            }, 
            "query": {
                "docstring": ""
            }, 
            "refresh": {
                "docstring": "When used during cache creation, forces a screen refresh during caching. This causes the cache creation to be slower but allows you to see how the simulation is progressing during the cache."
            }, 
            "replaceCachedFrame": {
                "docstring": "Replaces cached data for the times specified by the startTime/endTime flags. If no time is provided, replaces cache file for the current time. Must be used in conjunction with the pts/points or cnd/cacheableNode flag. Replaced frames will not be deleted, but renamed as specified by the f/fileName flag."
            }, 
            "replaceWithoutSimulating": {
                "docstring": "When replacing cached frames, this flag specifies whether the replacement should come from the cached node without simulating or from advancing time and letting the simulation run. This flag is valid only when neither the startTime nor endTime flags are used or when both the startTime and endTime flags specify the same time value."
            }, 
            "runupFrames": {
                "docstring": "Specifies the number of frames of runup to simulate ahead of the starting frame. The value must be greater than or equal to 0. The default is 2."
            }, 
            "sampleMultiplier": {
                "docstring": "Specifies the sample rate when caches are being created as a multiple of simulation Rate. If the value is 1, then a sample will be cached everytime the time is advanced. If the value is 2, then every other sample will be cached, and so on. The default is 1."
            }, 
            "simulationRate": {
                "docstring": "Specifies the simulation rate when caches are being created. During cache creation, the time will be advanced by the simulation rate, until the end time of the cache is reached or surpassed. The value is given in frames. The default value is 1 frame."
            }, 
            "singleCache": {
                "docstring": "When used in conjunction with the pts or cacheableNode flag, specifies whether multiple geometries should be put into a single cache or to create one cache per geometry (default)."
            }, 
            "startTime": {
                "docstring": "Specifies the start frame of the cache range."
            }, 
            "staticCache": {
                "docstring": "If false, during cache creation, do not save a cache for the object if it appears to have no animation or deformation. If true, save a cache even if the object appears to have no animation or deformation. Default is true. In query mode, when supplied a shape, the flag returns true if the shape appears to have no animation or deformation."
            }, 
            "worldSpace": {
                "docstring": "If the points flag is used, turning on this flag will result in the world space positions of the points being written. The expected use of this flag is for cache export."
            }
        }
    }, 
    "cacheFileCombine": {
        "description": "Creates a cacheBlend node that can be used to combine, layer or blend multiple cacheFiles for a given object. ", 
        "flags": {
            "cacheIndex": {
                "docstring": "A query only flag that returns the index related to the cache specified with the connectCache flag."
            }, 
            "channelName": {
                "docstring": "Used in conjunction with the connectCache flag to indicate the channel(s) that should be connected. If not specified, the first channel in the file is used.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "connectCache": {
                "docstring": "An edit flag that specifies a cacheFile node that should be connected to the next available index on the specified cacheBlend node. As a query flag, it returns a string array containing the cacheFiles that feed into the specified cacheBlend node. In query mode, this flag can accept a value."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "keepWeights": {
                "docstring": "This is a flag for use in combination with the connectCache flag only. By default, the connectCache flag will set all weights other than the newly added cacheWeight to 0 so that the new cache gets complete control. This flag disables that behavior so that all existing blend weights are retained."
            }, 
            "layerNode": {
                "docstring": "A query flag that returns a string array of the existing cacheBlends on the selected object(s). Returns an empty string array if no cacheBlends are found."
            }, 
            "nextAvailable": {
                "docstring": "A query flag that returns the next available index on the selected cacheBlend node."
            }, 
            "object": {
                "docstring": "This flag is used in combination with the objectIndex flag. It is used to specify the object whose index you wish to query. "
            }, 
            "objectIndex": {
                "docstring": "In edit mode, used in conjunction with the connectCache flag to indicate the objectIndex to be connected. In query mode, returns the index related to the object specified with the object flag."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "cacheFileMerge": {
        "description": "If selected/specified caches can be successfully merged, will return the start/end frames of the new cache followed by the start/end frames of any gaps in the merged cache for which no data should be written to file. In query mode, will return the names of geometry associated with the specified cache file nodes. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "endTime": {
                "docstring": "Specifies the end frame of the merge range. If not specified, will figure out range from times of caches being merged.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "geometry": {
                "docstring": "Query-only flag used to find the geometry nodes associated with the specified cache files."
            }, 
            "query": {
                "docstring": ""
            }, 
            "startTime": {
                "docstring": "Specifies the start frame of the merge range. If not specified, will figure out range from the times of the caches being merged."
            }
        }
    }, 
    "cacheFileTrack": {
        "description": "This command is used for inserting and removing tracks related to the caches displayed in the trax editor. It can also be used to modify the track state, for example, to lock or mute a track. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "insertTrack": {
                "docstring": "This flag is used to insert a new empty track at the track index specified."
            }, 
            "lock": {
                "docstring": "This flag specifies whether clips on a track are to be locked or not."
            }, 
            "mute": {
                "docstring": "This flag specifies whether clips on a track are to be muted or not."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeEmptyTracks": {
                "docstring": "This flag is used to remove all tracks that have no clips.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "removeTrack": {
                "docstring": "This flag is used to remove the track with the specified index. The track must have no clips on it before it can be removed."
            }, 
            "solo": {
                "docstring": "This flag specifies whether clips on a track are to be soloed or not."
            }, 
            "track": {
                "docstring": "Used to specify a new track index for a cache to be displayed. Track-indices are 1-based."
            }
        }
    }, 
    "callbacks": {
        "description": "This command allows you to add callbacks at key times during UI creation so that the Maya UI can be extended. The list of standard Maya hooks, as well as the arguments which will be passed to the callback based on the context are enumerated in the describeHookssection below. Custom hooks can also be added if third parties want to add UI extensibility to their plugins. ", 
        "flags": {
            "addCallback": {
                "docstring": "Add a callback for the specified hook. The owner must also be specified when adding callbacks."
            }, 
            "clearAllCallbacks": {
                "docstring": "Clear all the callbacks for all hooks and owners. This is generally only used during plugin development and testing as it affects all callbacks registered by Maya and other third parties."
            }, 
            "clearCallbacks": {
                "docstring": "Clear all the callbacks for the specified owner. If a hook is specified, only the callbacks for that hook and owner will be cleared."
            }, 
            "describeHooks": {
                "docstring": "List the standard Maya hooks. Below is a list of the hooks and their associated arguments and return values. Custom hooks added by third parties are not listed. hyperShadePanelBuildCreateMenuThis hook is called to add content to the Hypershade panel create menu. It will be called after the standard Maya node entries have been created. This callback does not have any arguments or return values. In order to preserve the desired look in the Maya UI, these callbacks should add a menu item divider just before returning using: menuItem -divider true.hyperShadePanelBuildCreateSubMenuThis hook is called to get a classification string for the custom renderer shading nodes, to prevent them from being listed with the standard Maya nodes. This callback does not have any arguments. returns: a classification string, such as rendernode/myrendererhyperShadePanelPluginChangeThis hook is called when a plugin change event (loading / unloading) has occurred to inform Maya whether the Hypershade panel needs to be rebuilt. classification (string): classification string belonging to a plugin node, possibly from another pluginchangeType (string): either loadPluginor unloadPluginreturns: (int) non-zero if your plugin is responsible for nodes of this classification, and a Hypershade rebuild is requiredcreateRenderNodeSelectNodeCategoriesThis hook is called when the Create Render Node dialog is being constructed, and allows a third party to have their nodes selected by default. A flag of the form -allWithMyRendererUpis the standard form, and the selection can be set up in the tree lister in the callback. There is no return value for this callback. flag (string): flag passed to the Create Render Node dialog command with the leading minus (-) removedtreeLister (string): the tree lister widget which should be affectedFor example, your callback might look like: global proc myRendererCreateRenderNodeSelectNodeCategoriesCallback(string $flag, string $treeLister){     if($flag == \"allWithMyRendererUp\") {         treeLister -e -selectPath \"myrenderer\" $treeLister;     } } createRenderNodePluginChangeThis hook is called when a plugin change event has occurred to decide if the Create Render Node dialog needs to be closed. classification (string): classification string belonging to a plugin node, possibly from another pluginreturns: (int) non-zero if your plugin is responsible for nodes of this classification, and the Create Render Node dialog needs to be closedrenderNodeClassificationThis hook is called to get a classification string for the custom renderer shading nodes. This is used to determine if a given node type belongs to a plugin renderer. This callback does not have any arguments. returns: a classification string, such as rendernode/myrenderercreateRenderNodeCommandThis hook is called to give plugin renderers the chance to register their own command for creating their nodes from the render node treeLister and Node Editor. The callback should determine from the classification of the node type in question if it is theirs, and if so, return the appropriate command for creating new nodes of that type. postCommand (string): command to be run after the create commandtype (string): nodeTypereturns: (string) MEL create commandbuildRenderNodeTreeListerContentThis hook is called to give plugin renderers the chance to add their content to the render node tree lister. renderNodeTreeLister (string): the render node tree listerpostCommand (string): command to be run post-creationfilterString (string): a space delimited list of filtersAETemplateCustomContentThis hook is called to give plugins a chance to add content to the Attribute Editor for nodes which source AEdependNodeTemplate. nodeName (string): the name of the node for which the Attribute Editor is being constructedfirstConnectedShaderThis hook is called to determine the primary custom shader connected to the given Shading Engine. nodeName (string): the name of the Shading Enginereturns (string): the name of the custom shader if applicableallConnectedShadersThis hook is called to determine all the shaders connected to the given Shading Engine. nodeName (string): the name of the Shading Enginereturns (string): A colon separated list of the connected custom shaders (shader1:shader2:shader3)renderLayerPresetMenuThis hook is called to give plugins a chance to add presets to a renderLayer node. nodeName (string): the name of the renderLayer nodeaddBakingMenuItemsThis hook is called to give plugins a chance to add baking menu items to the global Render - Lighting/Shading menu. menuItemAnchor (string): the name of the menuItem which the new baking menu items should be inserted after.addVertexBakingMenuItemsThis hook is called to give plugins a chance to add baking menu items to the global Polygon - Color menu.addPrelightMenuItemsThis hook is called to give plugins a chance to add pre-lighting menu items to the global Polygon - Color Set Editor menu.addRMBBakingMenuItemsThis hook is called to give plugins a chance to add baking menu items to the RMB menu. objectName (string): The name of the object the right mouse button event occured on.addMayaRenderingPreferencesThis hook is called to give plugins a chance to add custom preferences to the Maya's Rendering Preferences section.updateMayaRenderingPreferencesThis hook is called to give plugins a chance to update custom preferences of the Maya's Rendering Preferences section.addMayaMuscleMenuItemsThis hook is called to give plugins a chance to add menu items to the Maya muscle Displace menu. menuItemAnchor (string): the name of the menuItem which the new Maya muscle menu items should be inserted after.addMayaMuscleShelfButtonsThis hook is called to give plugins a chance to add items to the Maya muscle shelves.addBackburnerRendererMenuItemsThis hook is called to give plugins a chance to add items to Maya's Backburner list of available renderers. Note: The menuItem added must be named with the short name equivalent of the renderer. eg: The Maya software renderer adds a menuItem named 'sw'.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dumpCallbacks": {
                "docstring": "Gives a list of all the registered callbacks for all hooks and owners. Can be useful for debugging."
            }, 
            "executeCallbacks": {
                "docstring": "Execute the callbacks for the specified hook, passing the extra arguments to each callback when it is executed. Returns an array (MEL) or list (Python) containing the return values from each callback that was executed. If a callback returns no value, the array will contain an empty string (MEL) or None (Python)."
            }, 
            "hook": {
                "docstring": "The name of the hook for which the callback should be registered."
            }, 
            "listCallbacks": {
                "docstring": "Get the list of callbacks for the specified hook name. If the owner is specified, only callbacks for the specified hook and owner will be listed."
            }, 
            "owner": {
                "docstring": "The name of the owner registering the callback. This is typically a plugin name."
            }, 
            "removeCallback": {
                "docstring": "Remove an existing callback for the specified hook name. The owner must also be specified when removing a callback."
            }
        }
    }, 
    "camera": {
        "description": "Create, edit, or query a camera with the specified properties. The resulting camera can be repositioned using the viewPlace command. Many of the camera settings only affect the resulting rendered image. E.g. the F/Stop, shutter speed, the film related options, etc. Scaling the camera icon does not change any camera properties. ", 
        "flags": {
            "aspectRatio": {
                "docstring": "The ratio of the film back width to the film back height."
            }, 
            "cameraScale": {
                "docstring": "Scale the camera."
            }, 
            "centerOfInterest": {
                "docstring": "Set the linear distance from the camera's eye point to the center of interest."
            }, 
            "clippingPlanes": {
                "docstring": "Activate manual clipping planes."
            }, 
            "depthOfField": {
                "docstring": "Determines whether a depth of field calculation is performed to give varying focus depending on the distance of the objects."
            }, 
            "displayFieldChart": {
                "docstring": "Activate display of the video field chart when looking through the camera."
            }, 
            "displayFilmGate": {
                "docstring": "Activate display of the film gate icons when looking through the camera."
            }, 
            "displayFilmOrigin": {
                "docstring": "Activate the display of the film origin guide when looking through the camera."
            }, 
            "displayFilmPivot": {
                "docstring": "Activate display of the film pivot guide when looking through the camera."
            }, 
            "displayGateMask": {
                "docstring": "Display the gate mask, file or resolution, as a shaded area to the edge of the viewport."
            }, 
            "displayResolution": {
                "docstring": "Activate display of the current rendering resolution (as defined in the render globals) when looking through the camera."
            }, 
            "displaySafeAction": {
                "docstring": "Activate display of the video Safe Action guide when looking through the camera."
            }, 
            "displaySafeTitle": {
                "docstring": "Activate display of the video Safe Title guide when looking through the camera."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "fStop": {
                "docstring": "A real lens normally contains a diaphragm or other stop which blocks some of the light that would otherwise pass through it. This stop is usually approximately round, and its diameter as seen from the front of the lens is called the lens diameter. The lens diameter is often described by its relation to the focal length of the lens. A lens whose diameter is one-eighth its local length is said to have an F-stop of 8. This is an optical property of the lens."
            }, 
            "farClipPlane": {
                "docstring": "Specify the distance to the far clipping plane."
            }, 
            "farFocusDistance": {
                "docstring": "Linear distance to the far focus plane."
            }, 
            "filmFit": {
                "docstring": "This describes how the digital image (in pixels) relates to the film back. Since the film back is defined in terms of real numbers with some arbitrary film aspect, and the digital image is defined in integer pixels with an equally arbitrary (and different) resolution, relating the two can get complicated. There are 4 choices: horizontalIn this case the digital image is made to fit the film back exactly in the horizontal direction. This then gives each pixel a horizontal size = (film back width) / (horizontal resolution). The pixel height is then = (pixel width) / (pixel aspect ratio). Now that the pixel has a size, resolution gives us a complete image. That image will match the film back exactly in width. It will almost never match in height, either being too tall or too short. By playing with the numbers you can get it pretty close though.verticalThis is the same idea as horizontal fit, only applied vertically. Thus the digital image will match the film back exactly in height, but miss in width.fillThis is a convenience item. The system calculates both horizontal and vertical fits and then applies the one that makes the digital image larger than the film back.overscanOverscanning the film gate in the camera view allows us to choreograph action outside of the frustum from within the camera view without having to resort to a dolly or zoom. This feature is also essential for animating image planes."
            }, 
            "filmFitOffset": {
                "docstring": "Since we know from the above that the digital image may not match the film back exactly, we now have the question of how to position one relative to the other. Thus fit offset. Normally the centers are aligned. Fit offset lets you move the smaller image within the larger one. Specify the distance for film offset (inches)."
            }, 
            "filmRollOrder": {
                "docstring": "Specifies how the roll is applied with respect to the pivot value. Rotate-TranslateThe film back is first rotated then translated by the pivot point value.Translate-RotateThe film back is first translated then rotated by the film roll value."
            }, 
            "filmRollValue": {
                "docstring": "This specifies that amount of rotation around the film back. The roll value is specified in degrees. The rotation occurs around the specified pivot point. This value is used to compute a film roll matrix, which is a component of the post-projection matrix."
            }, 
            "filmTranslateH": {
                "docstring": "The horizontal film translation. Values are normalized to the viewing area."
            }, 
            "filmTranslateV": {
                "docstring": "The vertical film translation. Values are normalized to the viewing area."
            }, 
            "focalLength": {
                "docstring": "This is the distance along the lens axis between the lens and the film plane when \"focal distance\" is infinitely large. This is an optical property of the lens. This double precision parameter is always specified in millimeters."
            }, 
            "focusDistance": {
                "docstring": "Set the focus at a certain distance in front of the camera."
            }, 
            "homeCommand": {
                "docstring": "Specify the command to execute when \"viewSet -home\" is applied to this camera. All occurances of \"%camera\" will be replaced with the cameras name before viewSet runs the command."
            }, 
            "horizontalFieldOfView": {
                "docstring": "This is the film back width as seen by the lens when focused at infinity (ie., focal length away) measured as an angle. Note that it has nothing to do with pixels or the digital image or any aspects. Angle of view is a derived field, that is, it is not used internally by Alias and can be completely determined from other information. It is included as a convenience for the user. Its derivation is aov = 2 \\* atan( fbw / (2 \\* f) ) where \"aov\" is the angle of view, \"fbw\" is the film back width and \"f\" is the focal length."
            }, 
            "horizontalFilmAperture": {
                "docstring": "The horizontal width of the camera's film plane. The camera's film is located on the film plane. The extent of the film which will be exposed to an image of the scene in front of the lens is limited to a rectangular area described by the film back. This double precision parameter is always specified in inches."
            }, 
            "horizontalFilmOffset": {
                "docstring": "Horizontal offset from the center of the film back. Normally the film back will be centered on the lens axis. However, this need not be so. Film offset is the displacement of the center of the film back from the lens axis, also measured in inches. Note that offsetting the film back will distort the image, but will not alter the focus. This double precision parameter is always specified in inches."
            }, 
            "horizontalPan": {
                "docstring": "Horizontal 2D camera pan (inches)"
            }, 
            "horizontalRollPivot": {
                "docstring": "The horizontal pivot point from the center of the film back. The pivot point is used during rotation of the film back. The pivot is the point where the rotation occurs around. This double precision parameter corresponds to the normalized viewport. This value is a part of the post projection matrix."
            }, 
            "horizontalShake": {
                "docstring": "Another horizontal offset from the center of the film back, which can be used and stored on the camera in addition to the horizonal film offset attribute. This allows for film-based camera shake internal to the camera. This works in exactly the same units and coordinates that the film offset attribute does. The effect of this attribute is toggled by the shake enabled attribute."
            }, 
            "journalCommand": {
                "docstring": "Journal interactive camera commands. Commands can be undone when a camera is journaled."
            }, 
            "lensSqueezeRatio": {
                "docstring": "This is presently just an information field in the camera editor is meant to convey the horizontal distortion of the anamorphic lens normally used with some film formats. If it were used, it would do something like pixel aspect. Remember however that lens distortion (intentional or not) is slightly different than the output hardware's quantization. The fact that a \"net\" distortion parameter could be used for both may or may not confuse the issue."
            }, 
            "motionBlur": {
                "docstring": "Determines whether the camera's image is motion blured (as opposed to an object's image). For example, if you want to blur the camera movement when you are performing a flyby."
            }, 
            "name": {
                "docstring": ""
            }, 
            "nearClipPlane": {
                "docstring": "Specify the distance to the NEAR clipping plane."
            }, 
            "nearFocusDistance": {
                "docstring": "Linear distance to the near focus plane."
            }, 
            "orthographic": {
                "docstring": "Activate the orthographic camera."
            }, 
            "orthographicWidth": {
                "docstring": "Set the orthographic projection width."
            }, 
            "overscan": {
                "docstring": "Set the percent of overscan."
            }, 
            "panZoomEnabled": {
                "docstring": "Toggle camera 2D pan and zoom"
            }, 
            "position": {
                "docstring": "Three linear values can be specified to translate the camera."
            }, 
            "postScale": {
                "docstring": "The post-scale value. This value multiplied against the computed projection matrix. It is applied after the the film roll."
            }, 
            "preScale": {
                "docstring": "The pre-scale value. The value is multiplied against the computed projection matrix. It is applied before the film roll."
            }, 
            "query": {
                "docstring": ""
            }, 
            "renderPanZoom": {
                "docstring": "Toggle camera 2D pan and zoom in render"
            }, 
            "rotation": {
                "docstring": "Three angular values can be specified to rotate the camera."
            }, 
            "shakeEnabled": {
                "docstring": "Toggles the effect of the horizontal and vertical shake attributes."
            }, 
            "shakeOverscan": {
                "docstring": "Controls the amount of overscan in the output rendered image. For use when adding film-based camera shake. Acts as a multiplier to the film aperture on the camera."
            }, 
            "shakeOverscanEnabled": {
                "docstring": "Toggles the effect of the shake overscan attribute."
            }, 
            "shutterAngle": {
                "docstring": "Specify the shutter angle (degrees)."
            }, 
            "startupCamera": {
                "docstring": "A startup camera is marked undeletable and implicit. This flag can be used to set or query the startup state of a camera. There must always be at least one startup camera."
            }, 
            "stereoHorizontalImageTranslate": {
                "docstring": "A film-back offset for use in stereo camera rigs."
            }, 
            "stereoHorizontalImageTranslateEnabled": {
                "docstring": "Toggles the effect of the stereo HIT attribute."
            }, 
            "verticalFieldOfView": {
                "docstring": "Set the vertical field of view."
            }, 
            "verticalFilmAperture": {
                "docstring": "The vertical height of the camera's film plane. This double precision parameter is always specified in inches."
            }, 
            "verticalFilmOffset": {
                "docstring": "Vertical offset from the center of the film back. This double precision parameter is always specified in inches."
            }, 
            "verticalLock": {
                "docstring": "Lock the size of the vertical film aperture."
            }, 
            "verticalPan": {
                "docstring": "Vertical 2D camera pan (inches)"
            }, 
            "verticalRollPivot": {
                "docstring": "Vertical pivot point used for rotating the film back. This double precision parameter corresponds to the normalized viewport. This value is used to compute the film roll matrix, which is a component of the post projection matrix."
            }, 
            "verticalShake": {
                "docstring": "Vertical offset from the center of the film back. See horizontal shake attribute description. This is toggled by the shake enabled attribute."
            }, 
            "worldCenterOfInterest": {
                "docstring": "Camera world center of interest point."
            }, 
            "worldUp": {
                "docstring": "Camera world up vector.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "zoom": {
                "docstring": "The percent over the film viewable frustum to display"
            }
        }
    }, 
    "cameraSet": {
        "description": "This command manages camera set nodes. Camera sets allow the users to break a single camera shot into layers. Instead of drawing all objects with a single camera, you can isolate the camera to only focus on certain objects and layer another camera into the viewport that draws the other objects. The situation to use camera sets primarily occurs when building stereoscopic scenes. For example, a set of stereo parameters may make the background objects divergent beyond the tolerable range of the human perceptual system. However, you like the settings because the main focus is in the foreground and the depth is important to the visual look of the scene. You can use camera sets to break apart the shot into a foreground stereo camera and background stereo camera. The foreground stereo camera will retain the original parameters; however, it will only focus on the foreground elements. The background stereo camera will have a different set of stereo parameters and will only draw the background element. Camera sets can be viewed using the stereo viewer and are currently only designed to work with stereo camera rigs. ", 
        "flags": {
            "active": {
                "docstring": "Gets / sets the active camera layer."
            }, 
            "appendTo": {
                "docstring": "Append a new camera and/or object set to then end of the cameraSet layer list. This flag cannot be used in conjunction with insert flag. Additionally, it requires the camera and/or objectSet flag to be used."
            }, 
            "camera": {
                "docstring": "Set/get the camera for a particular layer. When in query mode, You must specify the layer with the layer flag."
            }, 
            "clearDepth": {
                "docstring": "Specifies if the drawing buffer should be cleared before beginning the draw for that layer.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "deleteAll": {
                "docstring": "Delete all camera layers"
            }, 
            "deleteLayer": {
                "docstring": "Delete a layer from the camera set. You must specify the layer using the layer flag."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "insertAt": {
                "docstring": "Inserts the specified camera and/or object set at the specified layer. This flag cannot be used in conjunction with the append flag. Additionally, this flag requires layer and camera (or objectSet) flag to be used."
            }, 
            "layer": {
                "docstring": "Specifies the layer index to be used when accessing layer information"
            }, 
            "name": {
                "docstring": "Gets or sets the name for the created camera set."
            }, 
            "numLayers": {
                "docstring": "Returns the number of layers defined in the specified cameraSet"
            }, 
            "objectSet": {
                "docstring": "Set/get the objectSet for a particular layer. When in query mode, you must specify the layer with the layer flag."
            }, 
            "order": {
                "docstring": "Set the order in which a particular layer is processed. This flag must be used in conjunction with the layer flag."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "cameraView": {
        "description": "This command creates a preset view for a camera which is then independent of the camera. The view stores a camera's eye point, center of interest point, up vector, tumble pivot, horizontal aperture, vertical aperature, focal length, orthographic width, and whether the camera is orthographic or perspective by default. Or you can only store 2D pan/zoom attributes by setting the bookmarkType to 1. These settings can be applied to any other camera through the set camera flag. This command can be used for creation or edit of camera view objects. This command can only be executed with one of the add bookmark, or remove bookmark and one of set camera, or the set view flags set. ", 
        "flags": {
            "addBookmark": {
                "docstring": "Associate this view with the camera specified or the camera in the active model panel. This flag can be used for creation or edit."
            }, 
            "animate": {
                "docstring": ""
            }, 
            "bookmarkType": {
                "docstring": "Specify the bookmark type, which can be: 0. 3D bookmark; 1. 2D Pan/Zoom bookmark.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "camera": {
                "docstring": "Specify the camera to use. This flag should be used in conjunction with the add bookmark, remove bookmark, set camera, or set view flags. If this flag is not specified the camera in the active model panel will be used."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Set the name of the view. This flag can only be used for creation."
            }, 
            "removeBookmark": {
                "docstring": "Remove the association of this view with the camera specified or the camera in the active model panel. This can only be used with edit."
            }, 
            "setCamera": {
                "docstring": "Set this view into a camera specified by the camera flag or the camera in the active model panel. This flag can only be used with edit."
            }, 
            "setView": {
                "docstring": "Set the camera view to match a camera specified or the active model panel. This flag can only be used with edit."
            }
        }
    }, 
    "canCreateManip": {
        "description": "This command returns true if there can be a manipulator made for the specified selection, false otherwise. ", 
        "flags": {}
    }, 
    "canvas": {
        "description": "Creates a control capable of displaying a color swatch. This control can also accept a command to be called when the colour swatch is pressed by the user. Note: The -dgc/dragCallback and -dpc/dropCallback are not available for this control. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "hsvValue": {
                "docstring": "Three float values corresponding to the hue, saturation, and value color components, where the hue value ranges from 0.0 to 360.0 and the saturation and value components range from 0.0 to 1.0."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "pressCommand": {
                "docstring": "Command to be executed when there is a mouse press.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rgbValue": {
                "docstring": "Three float values corresponding to the red, green, and blue color components, all of which range from 0.0 to 1.0."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "changeSubdivComponentDisplayLevel": {
        "description": "Explicitly forces the subdivision surface to display components at a particular level of refinement. ", 
        "flags": {
            "level": {
                "docstring": "Specifies the display level of components."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "If set, level refers to the relative display levelFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "changeSubdivRegion": {
        "description": "Changes a subdivision surface region based on the command parameters. The command operates on the selected subdivision surfaces. ", 
        "flags": {
            "action": {
                "docstring": "Specifies the action to the selection region 1 = delete selection region 2 = enlarge selection region"
            }, 
            "level": {
                "docstring": "Specify the level of the subdivision surface to perform the operationFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "channelBox": {
        "description": "This command creates a channel box, which is sensitive to the active list. It displays certain attributes (channels) of the last node on the active list, and provides a two-way connection to keep the widget up to date. Note: when setting the color of attribute names, that color is only valid for its current Maya session; each subsequent session will display the default color for the attribute name(s) listed in the Channel Box. Any subsequent attributes that are added to the Channel Box will be affected by prior regular expressions in their current Maya session. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "attrBgColor": {
                "docstring": "Controls the background text color of specific attribute names. As with the foreground option, this text coloring also depends on the node name choice for the nodeRegex flag. Arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0. If attrRegex is unspecified then it will assume a value of \"\\*\" for a regular expression. The same idea simultaneously applies to the flag nodeRegex. Note: nodes that are renamed will have their node name coloring be affected in the channel box."
            }, 
            "attrColor": {
                "docstring": "Controls the foreground text color of specific attribute names. This text coloring also depends on the node name choice for the nodeRegex flag. Arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0. If attrRegex is unspecified then it will assume a value of \"\\*\" for a regular expression. The same idea simultaneously applies to the flag nodeRegex. Note: nodes that are renamed will have their node name coloring be affected in the channel box."
            }, 
            "attrFilter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on the channel box. This filters the attributes displayed. A filter of \"0\" can be used to reset the filter."
            }, 
            "attrRegex": {
                "docstring": "Specifies a valid regular expression to specify which attribute names should be selected for foreground text coloring. If attrRegex is unspecified then it will assume a value of \"\\*\" for a regular expression. The same idea simultaneously applies to the flag nodeRegex. The attrColor flag is required to be specified. Note: this regular expression will be treated as though it were case-insensitve"
            }, 
            "attributeEditorMode": {
                "docstring": "Modifies what appears in the channel box for use in the attribute editor. Default is false. Queried, returns a boolean."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "containerAtTop": {
                "docstring": "This flag can be used to specify whether or not the container is drawn at the top of the channel box when a node in the container is selected."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enableLabelSelection": {
                "docstring": "Enables the selection of attributes in the channelBox when used in conjunction with -attributeEditorMode. Default is false. Queried, returns a boolean."
            }, 
            "execute": {
                "docstring": "Immediately executes the command string once for every cell (or every selected cell, if the boolean argument is TRUE) in the channel box, for every matching selected object (ie, for every object would be affected if you changed a cell value.) Before the command is executed, \"#A\" is substituted with the name of the attribute, and \"#N\" with the name of the node, and \"#P\" with the full path name of the node."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fieldWidth": {
                "docstring": "An optional flag which is used to modify the width assigned to fields appearing in the channelBox."
            }, 
            "fixedAttrList": {
                "docstring": "Forces the channel box to only display attributes with the specified names, in the order they are specified. If an empty list is specified, then the channel box will revert to its default behaviour of listing all keyable attributes."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "historyObjectList": {
                "docstring": "Returns a list of strings, the names of every INPUT node associated with an object on the main object list that is of the same type as the node displayed in the INPUT section of the channel box."
            }, 
            "hyperbolic": {
                "docstring": "Determines whether or not the distance that the mouse has been dragged should be interpreted as a linear or hyperbolic function. The default is set to hyperbolic being false."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "labelWidth": {
                "docstring": "An optional flag which is used to modify the width assigned to labels appearing in the channelBox."
            }, 
            "longNames": {
                "docstring": "Controls whether long or short attribute names will be used in the interface. Note that this flag is ignored if the -niceNames flag is set. Default is short names. Queried, returns a boolean."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The channel box will only display the (last) item contained in the selectionConnection object. If a NULL string (\"\") is specified, then the channel box will revert to its default behaviour of working on the active list."
            }, 
            "mainObjectList": {
                "docstring": "Returns a list of strings, the names of every object on the active list that is the same type as the object displayed in the top (main) section of the channel box."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxHeight": {
                "docstring": "An optional flag which is used to limit the height of the channelBox."
            }, 
            "maxWidth": {
                "docstring": "An optional flag which is used to limit the width of the channelBox."
            }, 
            "niceNames": {
                "docstring": "Controls whether the attribute names will be displayed in a more user-friendly, readable way. When this is on, the longNames flag is ignored. When this is off, attribute names will be displayed either long or short, according to the longNames flag. Default is on. Queried, returns a boolean."
            }, 
            "nodeRegex": {
                "docstring": "Specifies a valid regular expression to specify which node names should (potentially) have their attributes selected for foreground text coloring. If nodeRegex is unspecified then it will assume a value of \"\\*' for a regular expression. The same idea simultaneously applies to the flag attrRegex. The attrColor flag is required to be specified. Note: this regular expression will be treated as though it were case-insensitve Note: nodes in namespaces have regular expressions applied as though those nodes weren't in namespaces"
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "outputObjectList": {
                "docstring": "Returns a list of strings, the names of every OUTPUT node associated an object on the main object list that is of the same type as the node displayed in the OUTPUT section of the channel box."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "precision": {
                "docstring": "Controls the number of digits to the right of the decimal point that will be displayed for float-valued channels. Default is 3. Queried, returns an int."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rotationContext": {
                "docstring": "This flag can be used to specify the name of the rotation context that should be used by the channel box. If no rotationContext is specified a default context will created and used."
            }, 
            "scaleContext": {
                "docstring": "This flag can be used to specify the name of the scale context that should be used by the channel box. If no scaleContext is specified a default context will be created and used.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "selectedHistoryAttributes": {
                "docstring": "Returns a list of strings, the names of all the selected attributes in the INPUT section of the channel box."
            }, 
            "selectedMainAttributes": {
                "docstring": "Returns a list of strings, the names of all the selected attributes in the top section of the channel box."
            }, 
            "selectedOutputAttributes": {
                "docstring": "Returns a list of strings, the names of all the selected attributes in the OUTPUT section of the channel box."
            }, 
            "selectedShapeAttributes": {
                "docstring": "Returns a list of strings, the names of all the selected attributes in the middle (shape) section of the channel box."
            }, 
            "shapeObjectList": {
                "docstring": "Returns a list of strings, the names of every shape associated with an object on the main object list that is of the same type as the object displayed in the middle (shape) section of the channel box."
            }, 
            "showNamespace": {
                "docstring": "Controls whether or not the namespace of an object is displayed if the object is not in the root namespace."
            }, 
            "showTransforms": {
                "docstring": "Controls whether this control will display transform attributes only, or all other attributes. False by default. Queried, returns a boolean."
            }, 
            "speed": {
                "docstring": "Controls the speed at which the attributes are changed based on the distance the mouse has been dragged. Common settings for slow/medium/fast are 0.1/1.0/10.0 respectively. The default is 1.0."
            }, 
            "takeFocus": {
                "docstring": "causes the channel box to take over the keyboard focus, if it can."
            }, 
            "translationContext": {
                "docstring": "This flag can be used to specify the name of the translation context that should be used by the channel box. If no translationContext is specified a default context will created and used."
            }, 
            "update": {
                "docstring": "This flag can be used to force an update of the channel box display, for example after changing a display preference."
            }, 
            "useManips": {
                "docstring": "When you click on a field or label in the channel box, the tool switches to a manipulator that can change that value if you drag in the 3d view. This flag controls the kind of manips. Allowed values are \"none\" (self-explanatory), \"invisible\" (you won't see anything, but dragging in the window will adjust any of the selected attributes), and \"standard\" (the same as invisible, except for scale, rotate, and translate, which will be represented by their usual manips.)"
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "character": {
        "description": "This command is used to manage the membership of a character. Characters are a type of set that gathers together the attributes of a node or nodes that a user wishes to animate as a single entity. ", 
        "flags": {
            "addElement": {
                "docstring": "Adds the list of items to the given character. If some of the items cannot be added to the character because they are in another character, the command will fail. When another character is passed to to -addElement, is is added as a sub character. When a node is passed in, it is expanded into its keyable attributes, which are then added to the character."
            }, 
            "addOffsetObject": {
                "docstring": "Indicates that the selected character member objects should be used when calculating and applying offsets. The flag argument is used to specify the character."
            }, 
            "characterPlug": {
                "docstring": "Returns the plug on the character that corresponds to the specified character member."
            }, 
            "clear": {
                "docstring": "An operation which removes all items from the given character."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "empty": {
                "docstring": "Indicates that the character to be created should be empty. (i.e. it ignores any arguments identifying objects to be added to the character."
            }, 
            "excludeDynamic": {
                "docstring": "When creating the character, exclude dynamic attributes."
            }, 
            "excludeRotate": {
                "docstring": "When creating the character, exclude rotate attributes from transform-type nodes."
            }, 
            "excludeScale": {
                "docstring": "When creating the character, exclude scale attributes from transform-type nodes."
            }, 
            "excludeTranslate": {
                "docstring": "When creating the character, exclude translate attributes from transform-type nodes. For example, if your character contains joints only, perhaps you only want to include rotations in the character."
            }, 
            "excludeVisibility": {
                "docstring": "When creating the character, exclude visibility attribute from transform-type nodes."
            }, 
            "flatten": {
                "docstring": "An operation that flattens the structure of the given character. That is, any characters contained by the given character will be replaced by its members so that the character no longer contains other characters but contains the other characters' members."
            }, 
            "forceElement": {
                "docstring": "For use in edit mode only. Forces addition of the items to the character. If the items are in another character which is in the character partition, the items will be removed from the other character in order to keep the characters in the character partition mutually exclusive with respect to membership."
            }, 
            "include": {
                "docstring": "Adds the list of items to the given character. If some of the items cannot be added to the character, a warning will be issued. This is a less strict version of the -add/addElement operation."
            }, 
            "intersection": {
                "docstring": "An operation that returns a list of items which are members of all the character in the list. In general, characters should be mutually exclusive."
            }, 
            "isIntersecting": {
                "docstring": "An operation which tests whether or not the characters in the list have common members. In general, characters should be mutually exclusive, so this should always return false."
            }, 
            "isMember": {
                "docstring": "An operation which tests whether or not all the given items are members of the given character."
            }, 
            "library": {
                "docstring": "Returns the clip library associated with this character, if there is one. A clip library will only exist if you have created clips on your character."
            }, 
            "memberIndex": {
                "docstring": "Returns the memberIndex of the specified character member if used after the query flag. Or if used before the query flag, returns the member that corresponds to the specified index."
            }, 
            "name": {
                "docstring": "Assigns string as the name for a new character. Valid for operations that create a new character."
            }, 
            "noWarnings": {
                "docstring": "Indicates that warning messages should not be reported such as when trying to add an invalid item to a character. (used by UI)"
            }, 
            "nodesOnly": {
                "docstring": "This flag modifies the results of character membership queries. When listing the attributes (e.g. sphere1.tx) contained in the character, list only the nodes. Each node will only be listed once, even if more than one attribute or component of the node exists in the character."
            }, 
            "offsetNode": {
                "docstring": "Returns the name of the characterOffset node used to add offsets to the root of the character.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Removes the list of items from the given character."
            }, 
            "removeOffsetObject": {
                "docstring": "Indicates that the selected character offset objects should be removed as offsets. The flag argument is used to specify the character."
            }, 
            "root": {
                "docstring": "Specifies the transform node which will act as the root of the character being created. This creates a characterOffset node in addition to the character node, which can be used to add offsets to the character to change the direction of the character's animtion without inserting additional nodes in its hierarchy."
            }, 
            "scheduler": {
                "docstring": "Returns the scheduler associated with this character, if there is one. A scheduler will only exist if you have created clips on your character."
            }, 
            "split": {
                "docstring": "Produces a new set with the list of items and removes each item in the list of items from the given set."
            }, 
            "subtract": {
                "docstring": "An operation between two characters which returns the members of the first character that are not in the second character. In general, characters should be mutually exclusive."
            }, 
            "text": {
                "docstring": "Defines an annotation string to be stored with the character."
            }, 
            "union": {
                "docstring": "An operation that returns a list of all the members of all characters listed."
            }, 
            "userAlias": {
                "docstring": "Returns the user defined alias for the given attribute on the character or and empty string if there is not one. Characters automatically alias the attributes where character animation data is stored. A user alias will exist when the automatic aliases are overridden using the aliasAttr command."
            }
        }
    }, 
    "characterMap": {
        "description": "This command is used to create a correlation between the attributes of 2 or more characters. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "mapAttr": {
                "docstring": "In query mode, this flag can be used to query the mapping stored by the specified map node. It returns an array of strings. In non-query mode, this flag can be used to create a mapping between the specified character members. Any previous mapping on the attributes is removed in favor of the newly specified mapping."
            }, 
            "mapMethod": {
                "docstring": "This is is valid in create mode only. It specifies how the mapping should be done. Valid options are: \"byNodeName\", \"byAttrName\", and \"byAttrOrder\". \"byAttrOrder\" is the default. The flags mean the following: \"byAttrOrder\" maps using the order that the character stores the attributes internally, \"byAttrName\" uses the attribute name to find a correspondence, \"byNodeName\" uses the node name \\*and\\* the attribute name to find a correspondence."
            }, 
            "mapNode": {
                "docstring": "This flag can be used to map all the attributes on the source node to their matching attributes on the destination node."
            }, 
            "mapping": {
                "docstring": "This flag is valid in query mode only. It must be used before the query flag with a string argument. It is used for querying the mapping for a particular attribute. A string array is returned."
            }, 
            "proposedMapping": {
                "docstring": "This flag is valid in query mode only. It is used to get an array of the mapping that the character map would prvide if called with the specified characters and the (optional) specified mappingMethod. If a character map exists on the characters, the map is not affected by the query operation. A string array is returned."
            }, 
            "query": {
                "docstring": ""
            }, 
            "unmapAttr": {
                "docstring": "This flag can be used to unmap the mapping stored by the specified map node."
            }, 
            "unmapNode": {
                "docstring": "This flag can be used to unmap all the attributes on the source node to their matching attributes on the destination node. Note that mapped attributes which do not have matching names, will not be unmapped.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "characterize": {
        "description": "This command is used to scan a joint hierarchy for predefined joint names or labels. If the required joints are found, human IK effectors will be created to control the skeleton using full-body IK. Alternatively, you can manually create all of the components required for fullbody IK, and use this command to hook them up. Fullbody IK needs 3 major components: the user input skeleton (sk), the fk skeleton on which keys are set (fk) and the hik effectors (ik). Together fk and ik provide parameters to the fullbody IK engine, which solves for the output and plots it onto sk. This command usage is used internally by Maya when importing data from fbx files, but is not generally recommended. Note that a minimum set of required joint names or joint labels must be found in order for the characterize command to succeed. Please refer to the Maya documentation for details on properly naming or labeling your skeleton. The skeleton should also be z-facing, with its y-axis up, its left hand parallel to positive x-axis and right hand parallel to negative x-axis. END_COMMENT ", 
        "flags": {
            "activatePivot": {
                "docstring": "Activates a pivot that has been properly placed. After activating this new pivot, you will now be able to rotate and translate about this pivot. A pivot behaves in all ways the same as an effector (it IS an effector, except that it is offset from the normal position of the effector to allow one to rotate about a different point."
            }, 
            "addAuxEffector": {
                "docstring": "Adds an auxilliary (secondary) effector to an existing effector."
            }, 
            "addFloorContactPlane": {
                "docstring": "Adds a floor contact plane to one of the hands or feet. With this plane, you will be able to adjust the floor contact height. Select a hand or foot effector and then issue the characterize command with this flag."
            }, 
            "addMissingEffectors": {
                "docstring": "This flag tells the characterize command to look for any effectors that can be added to the skeleton. For example, if the user has deleted some effectors or added fingers to an existing skeleton, \"characterize -e -addMissingEffectors\" can be used to restore them."
            }, 
            "attributeFromHIKProperty": {
                "docstring": "Query for the attribute name associated with a MotionBuilder property."
            }, 
            "attributeFromHIKPropertyMode": {
                "docstring": "Query for the attribute name associated with a MotionBuilder property mode."
            }, 
            "autoActivateBodyPart": {
                "docstring": "Query or change whether auto activation of character nodes representing body parts should be enabled."
            }, 
            "changePivotPlacement": {
                "docstring": "Reverts a pivot back into pivot placement mode. A pivot that is in placement mode will not participate in full body manipulation until it has been activated with the -activatePivot flag."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "effectors": {
                "docstring": "Specify the effectors to be used by human IK by providing 2 pieces of information for each effector: 1) the partial path of the effector and 2) the name of the full body effector this represents. 1) and 2) are to be separated by white space, and multiple entries separated by \",\". Normally, the effectors are automatically created. This flag is for advanced users only."
            }, 
            "fkSkeleton": {
                "docstring": "Specify the fk skeleton to be used by human IK by providing 2 pieces of information for each joint of the FK skeleton: 1) the partial path of the joint and 2) the name of the full body joint this represents. 1) and 2) are to be separated by white space, and multiple entries separated by \",\". Normally, the fk control skeleton is automatically created. This flag is for advanced users only."
            }, 
            "name": {
                "docstring": "At characterization (FBIK creation) time, use this flag to name your FBIK character. This will affect the name of the hikHandle node and the control rig will be put into a namespace that matches the name of your character. If you do not specify the character name, a default one will be used. At the moment edit and query of the character name is not supported.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pinHandFeet": {
                "docstring": "When the character is first being characterized, pin the hands and feet by default."
            }, 
            "placeNewPivot": {
                "docstring": "Creates a new pivot and puts it into placement mode. Note that you will not be able to do full body manipulation about this pivot until you have activated it with the -activatePivot flag. A pivot behaves in all ways the same as an effector (it IS an effector, except that it is offset from the normal position of the effector to allow one to rotate about a different point). A new pivot created with this flag allow you to adjust the offset interactively before activating it."
            }, 
            "posture": {
                "docstring": "Specifies the posture of the character. Valid options are \"biped\" and \"quadruped\". The default is \"biped\"."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sourceSkeleton": {
                "docstring": "This flag can be used to characterize a skeleton that has not been named or labelled according to the FBIK guidelines. It specifies the association between the actual joint names and the expected FBIK joint names. The format of the string is as follows: For each joint that the user wants to involve in the solve: 1) the partial path of the joint and 2) the name of the full body joint this represents. 1) and 2) are to be separated by white space, and multiple entries separated by \",\"."
            }, 
            "stancePose": {
                "docstring": "Specify the default stance pose to be used by human IK. The stance pose is specified by providing 2 pieces of information for each joint involved in the solve: 1) the partial path to the joint and 2) 9 numbers representing translation rotation and scale. 1) and 2) are to be separated by white space, and multiple entries separated by \",\". Normally, the stance pose is taken from the selected skeleton. This flag is for advanced users only."
            }, 
            "type": {
                "docstring": "Specifies the technique used by the characterization to identify the joint type. Valid options are \"label\" and \"name\". When \"label\" is used, the joints must be labelled using the guidelines described in the Maya documentation. When name is used, the joint names must follow the naming conventions described in the Maya documentation. The default is \"name\". This flag cannot be used in conjunction with the sourceSkeleton flag."
            }
        }
    }, 
    "checkBox": {
        "description": "This command creates a check box. A check box is a simple control containing a text label and a state of either on or off. Commands can be attached to any or all of the following events: when the check box is turned on, turned off, or simply when it's state is changed. ", 
        "flags": {
            "align": {
                "docstring": "This flag is obsolete and should no longer be used. The check box label will always be left-aligned."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the check box's state is changed. Note that this flag should not be used in conjunction with onCommand and offCommand. That is, one should either use changeCommand and test the state of the check box from inside the callback, or use onCommand and offCommand as separate callbacks.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "The edit state of the check box. By default, this flag is set to true and the check box value may be changed by clicking on it. If false then the check box is 'read only' and can not be clicked on. The value of the check box can always be changed with the -v/valueflag regardless of the state of the -ed/editableflag."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The label text. The default label is the name of the control."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "offCommand": {
                "docstring": "Command executed when the check box is turned off."
            }, 
            "onCommand": {
                "docstring": "Command executed when the check box is turned on."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "recomputeSize": {
                "docstring": "If true then the control will recompute it's size to just fit the size of the label. If false then the control size will remain fixed as you change the size of the label. The default value of this flag is true."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "State of the check box."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "checkBoxGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates from one to four check boxes in a single row. They can have an optional text label. TelfBaseGrpCmd.cpp ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the group changes state. Note that this flag should not be used in conjunction with onCommand and offCommand. That is, one should either use changeCommand and test the state of a check box from inside the callback, or use onCommand and offCommand as separate callbacks."
            }, 
            "changeCommand1": {
                "docstring": ""
            }, 
            "changeCommand2": {
                "docstring": ""
            }, 
            "changeCommand3": {
                "docstring": ""
            }, 
            "changeCommand4": {
                "docstring": "Specify a changed state command for each respective check box."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "The edit state of the group. By default, this flag is set to true and the check box values may be changed by clicking on them. If false then the check boxes are 'read only' and can not be clicked on. The value of the check boxes can always be changed with the -v/valueflags regardless of the state of the -ed/editableflag."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enable1": {
                "docstring": ""
            }, 
            "enable2": {
                "docstring": ""
            }, 
            "enable3": {
                "docstring": ""
            }, 
            "enable4": {
                "docstring": "Enable state of the individual check boxes."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "When present on creation an optional text label will be built with the group. The string specifes the label text."
            }, 
            "label1": {
                "docstring": ""
            }, 
            "label2": {
                "docstring": ""
            }, 
            "label3": {
                "docstring": ""
            }, 
            "label4": {
                "docstring": "Specify label strings for the respective check boxes in the group."
            }, 
            "labelArray2": {
                "docstring": ""
            }, 
            "labelArray3": {
                "docstring": ""
            }, 
            "labelArray4": {
                "docstring": "Specify multiple labels in a single flag. These flags are ignored if the number of radio buttons doesn't match."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfCheckBoxes": {
                "docstring": "Number of check boxes in the group (1 - 4)."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "offCommand": {
                "docstring": "Command executed when any check box turns off."
            }, 
            "offCommand1": {
                "docstring": ""
            }, 
            "offCommand2": {
                "docstring": ""
            }, 
            "offCommand3": {
                "docstring": ""
            }, 
            "offCommand4": {
                "docstring": "Off command for each respective check box."
            }, 
            "onCommand": {
                "docstring": "Command executed when any check box turns on."
            }, 
            "onCommand1": {
                "docstring": ""
            }, 
            "onCommand2": {
                "docstring": ""
            }, 
            "onCommand3": {
                "docstring": ""
            }, 
            "onCommand4": {
                "docstring": "On command for each respective check box."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value1": {
                "docstring": ""
            }, 
            "value2": {
                "docstring": ""
            }, 
            "value3": {
                "docstring": ""
            }, 
            "value4": {
                "docstring": "Values for the respective check boxes in the group."
            }, 
            "valueArray2": {
                "docstring": ""
            }, 
            "valueArray3": {
                "docstring": ""
            }, 
            "valueArray4": {
                "docstring": "Specifies multiple values in a single flag. These flags are ignored if the number of check boxes doesn't match."
            }, 
            "vertical": {
                "docstring": "Whether the orientation of the checkbox controls in this group are horizontal (default) or vertical.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "checkDefaultRenderGlobals": {
        "description": "Command to check or set the \"changed\" mode for the defaultRenderGlobals node. In query mode, return type is based on queried flag.", 
        "flags": {
            "changed": {
                "docstring": "Check or set the \"changed\" mode of the defaultRenderGlobals node.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "choice": {
        "description": "The choice command provides a mechanism for changing the inputs to an attribute based on some (usually time-based) criteria. For example, an object could be animated from frames 1 to 30 by a motion path, then from frames 30 to 50 it follows keyframe animation, and after frame 50 it returns to the motion path. Or, a revolve surface could change its input curve depending on some transform's rotation value.The choice command creates a choice node (if one does not already exist) on all specified attributes of the selected objects. If the attribute was already connected to something, that something is now reconnected to the i'th index of the choice node's input (or the next available input if the -in/index flag is not specified). If a source attribute is specified, then that attribute is connected to the choice node's i'th input instead.The choice node operates by using the value of its selector attribute to determine which of its input attributes to pass through to its output. The input attributes can be of any type. For example, if the selector attribute was connected by an animation curve with keyframes at (1,1), (30,2) and (50,1), then that would mean that the choice node would pass on the data from input[1] from time 1 to 30, and after time 50, and the data from input[2] between times 30 and 50.This command returns the names of the created or modified choice nodes, and if a keyframe was added to the animation curve, it specifies the index (or value on the animation curve). ", 
        "flags": {
            "attribute": {
                "docstring": "specifies the attributes onto which choice node(s) should be created. The default is all keyable attributes of the given objects. Note that although this flag is not queryable, it can be used to qualify which attributes of the given objects to query. "
            }, 
            "controlPoints": {
                "docstring": "Explicitly specify whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "index": {
                "docstring": "specifies the multi-input index of the choice node to connect the source attribute to. When queried, returns a list of integers one per specified -t/time that indicates the multi-index of the choice node to use at that time."
            }, 
            "name": {
                "docstring": "the name to give to any newly created choice node(s). When queried, returns a list of strings."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selector": {
                "docstring": "specifies the attribute to be used as the choice node's selector. The value of the selector at a given time determines which of the choice node's multi-indices should be used as the output of the choice node at that time. This flag is only editable (it cannot be specified at creation time). When queried, returns a list of strings."
            }, 
            "shape": {
                "docstring": "Consider all attributes of shapes below transforms as well, except \"controlPoints\". Default: true"
            }, 
            "sourceAttribute": {
                "docstring": "specifies the attribute to connect to the choice node that will be selected at the given time(s) specified by -t/time."
            }, 
            "time": {
                "docstring": "specifies the time at which the choice should use the given source attribute, or the currently connected attribute if source attribute is not specified. The default is the curren time. Note that although this flag is not queryable, it can be used to qualify the times at which to query the other attributes. "
            }
        }
    }, 
    "circle": {
        "description": "The circle command creates a circle or partial circle (arc) ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "center": {
                "docstring": "The center point of the circle."
            }, 
            "centerX": {
                "docstring": "X of the center point.Default:0"
            }, 
            "centerY": {
                "docstring": "Y of the center point.Default:0"
            }, 
            "centerZ": {
                "docstring": "Z of the center point.Default:0"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting circle: 1 - linear, 3 - cubicDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "first": {
                "docstring": "The start point of the circle if fixCenter is false. Determines the orientation of the circle if fixCenter is true."
            }, 
            "firstPointX": {
                "docstring": "X of the first point.Default:1"
            }, 
            "firstPointY": {
                "docstring": "Y of the first point.Default:0"
            }, 
            "firstPointZ": {
                "docstring": "Z of the first point.Default:0"
            }, 
            "fixCenter": {
                "docstring": "Fix the center of the circle to the specified center point. Otherwise the circle will start at the specified first point.Default:trueAdvanced flags"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "normal": {
                "docstring": "The normal of the plane in which the circle will lie."
            }, 
            "normalX": {
                "docstring": "X of the normal direction.Default:0"
            }, 
            "normalY": {
                "docstring": "Y of the normal direction.Default:0"
            }, 
            "normalZ": {
                "docstring": "Z of the normal direction.Default:1"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency nodeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "The radius of the circle.Default:1.0"
            }, 
            "sections": {
                "docstring": "The number of sections determines the resolution of the circle. Used only if useTolerance is false.Default:8"
            }, 
            "sweep": {
                "docstring": "The sweep angle determines the completeness of the circle. A full circle is 2Pi radians, or 360 degrees.Default:6.2831853"
            }, 
            "tolerance": {
                "docstring": "The tolerance with which to build a circle. Used only if useTolerance is trueDefault:0.01"
            }, 
            "useTolerance": {
                "docstring": "Use the specified tolerance to determine resolution. Otherwise number of sections will be used.Default:false"
            }
        }
    }, 
    "circularFillet": {
        "description": "The cmd is used to compute the rolling ball surface fillet ( circular fillet ) between two given NURBS surfaces. To generate trim curves on the surfaces, use -cos true. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curveOnSurface": {
                "docstring": "If possible, create 2D curve as a resultFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "positionTolerance": {
                "docstring": "C(0) Tolerance For Fillet SurfaceDefault:0.01"
            }, 
            "primaryRadius": {
                "docstring": "primary RadiusDefault:1.0"
            }, 
            "query": {
                "docstring": ""
            }, 
            "secondaryRadius": {
                "docstring": "secondary RadiusDefault:1.0"
            }, 
            "tangentTolerance": {
                "docstring": "G(1) Tolerance For Fillet SurfaceDefault:0.01Advanced flags"
            }
        }
    }, 
    "clearCache": {
        "description": "Even though dependency graph values are computed or dirty they may still occupy space temporarily within the nodes. This command goes in to all of the data that can be regenerated if required and removes it from the caches (datablocks), thus clearing up space in memory. ", 
        "flags": {
            "allNodes": {
                "docstring": "If toggled then all nodes in the graph are cleared. Otherwise only those nodes that are selected are cleared."
            }, 
            "computed": {
                "docstring": "If toggled then remove all data that is computable. (Warning: If the data is requested for redraw then the recompute will immediately fill the data back in.)"
            }, 
            "dirty": {
                "docstring": "If toggled then remove all heavy data that is dirty.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "clearShear": {
        "description": "", 
        "flags": {}
    }, 
    "clip": {
        "description": "This command is used to create, edit and query character clips. ", 
        "flags": {
            "absolute": {
                "docstring": "This flag is now deprecated. Use aa/allAbsolute, ar/allRelative, ra/rotationsAbsolute, or da/defaultAbsolute instead. This flag controls whether the clip follows its keyframe values or whether they are offset by a value to maintain a smooth path. Default is true."
            }, 
            "absoluteRotations": {
                "docstring": "This flag is now deprecated. Use aa/allAbsolute, ar/allRelative, ra/rotationsAbsolute, or da/defaultAbsolute instead. If true, this overrides the -absolute flag so that rotation channels are always calculated with absolute offsets. This allows you to have absolute offsets on rotations and relative offsets on all other channels."
            }, 
            "active": {
                "docstring": "Query or edit the active clip. This flag is not valid in create mode. Making a clip active causes its animCurves to be hooked directly to the character attributes in addition to being attached to the clip library node. This makes it easier to access the animCurves if you want to edit, delete or add additional animCruves to the clip."
            }, 
            "addTrack": {
                "docstring": "This flag is now obsolete. Use the insertTrack flag on the clipSchedule command instead."
            }, 
            "allAbsolute": {
                "docstring": "Set all channels to be calculated with absolute offsets. This flag cannot be used in conjunction with the ar/allRelative, ra/rotationsAbsolute or da/defaultAbsolute flags."
            }, 
            "allClips": {
                "docstring": "This flag is used to query all the clips in the scene. Nodes of type \"animClip\" that are storing poses, are not returned by this command."
            }, 
            "allRelative": {
                "docstring": "Set all channels to be calculated with relative offsets. This flag cannot be used in conjunction with the aa/allAbsolute, ra/rotationsAbsolute or da/defaultAbsolute flags."
            }, 
            "allSourceClips": {
                "docstring": "This flag is used to query all the source clips in the scene. Nodes of type \"animClip\" that are storing poses or clip instances, are not returned by this command."
            }, 
            "animCurveRange": {
                "docstring": "This flag can be used at the time you create the clip instead of the startTime and endTime flags. It specifies that you want the range of the clip to span the range of keys in the clips associated animCurves."
            }, 
            "character": {
                "docstring": "This is a query only flag which operates on the specified clip. It returns the names of any characters that a clip is associated with."
            }, 
            "constraint": {
                "docstring": "This creates a clip out of any constraints on the character. The constraint will be moved off of the character and into the clip, so that it is only active for the duration of the clip, and its value can be scaled/offset/cycled according to the clip attributes."
            }, 
            "copy": {
                "docstring": "This flag is used to copy a clip or clips to the clipboard. It should be used in conjunction with the name flag to copy the named clips on the specified character and its subcharacters. In query mode, this flag allows you to query what, if anything, has been copied into the clip clipboard."
            }, 
            "defaultAbsolute": {
                "docstring": "Sets all top-level channels except rotations in the clip to relative, and the remaining channels to absolute. This is the default during clip creation if no offset flag is specified. This flag cannot be used in conjunction with the aa/allAbsolute, ar/allRelative, or ra/rotationsAbsolute flags."
            }, 
            "duplicate": {
                "docstring": "Duplicate the clip specified by the name flag. The start time of the new clip should be specified with the startTime flag."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endTime": {
                "docstring": "Specify the clip end"
            }, 
            "expression": {
                "docstring": "This creates a clip out of any expressions on the character. The expression will be moved off of the character and into the clip, so that it is only active for the duration of the clip, and its value can be scaled/offset/cycled according to the clip attributes."
            }, 
            "ignoreSubcharacters": {
                "docstring": "During clip creation, duplication and isolation, subcharacters are included by default. If you want to create a clip on the top level character only, or you want to duplicate the clip on the top level character without including subCharacters, use the ignoreSubcharacters flag."
            }, 
            "isolate": {
                "docstring": "This flag should be used in conjunction with the name flag to specify that a clip or clips should be copied to a new clip library. The most common use of this flag is for export, when you want to only export certain clips from the character, without exporting all of the clips."
            }, 
            "leaveOriginal": {
                "docstring": "This flag is used when creating a clip to specify that the animation curves should be copied to the clip library, and left on the character."
            }, 
            "mapMethod": {
                "docstring": "This is is valid with the paste and pasteInstance flags only. It specifies how the mapping should be done. Valid options are: \"byNodeName\", \"byAttrName\", \"byCharacterMap\", \"byAttrOrder\", \"byMapOrAttrName\" and \"byMapOrNodeName\". \"byAttrName\" is the default. The flags mean the following: \"byAttrOrder\" maps using the order that the character stores the attributes internally, \"byAttrName\" uses the attribute name to find a correspondence, \"byNodeName\" uses the node name \\*and\\* the attribute name to find a correspondence, \"byCharacterMap\" uses the existing characterMap node to do the mapping. \"byMapOrAttrName\" uses a character map if one exists, otherwise uses the attribute name. \"byMapOrNodeName\" uses a character map if one exists, otherwise uses the attribute name."
            }, 
            "name": {
                "docstring": "In create mode, specify the clip name. In query mode, return a list of all the clips. In duplicate mode, specify the clip to be duplicated. In copy mode, specify the clip to be copied. This flag is multi-use, but multiple use is only supported with the copy flag. For use during create and with all other flags, only the first instance of the name flag will be utilized. In query mode, this flag can accept a value."
            }, 
            "newName": {
                "docstring": "Rename a clip. Must be used in conjunction with the clip name flag, which is used to specify the clip to be renamed."
            }, 
            "paste": {
                "docstring": "This flag is used to paste a clip or clips from the clipboard to a character. Clips are added to the clipboard using the c/copy flag."
            }, 
            "pasteInstance": {
                "docstring": "This flag is used to paste an instance of a clip or clips from the clipboard to a character. Unlike the p/paste flag, which duplicates the animCurves from the original source clip, the pi/pasteInstance flag shares the animCurves from the source clip."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Remove the clip specified by the name flag. The clip will be permanently removed from the library and deleted from any times where it has been scheduled."
            }, 
            "removeTrack": {
                "docstring": "This flag is now obsolete. Use removeTrack flag on the clipSchedule command instead."
            }, 
            "rotationOffset": {
                "docstring": "Return the channel offsets used to modify the clip's rotation.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "rotationsAbsolute": {
                "docstring": "Set all channels except rotations to be calculated with relative offsets. Rotation channels will be calculated with absolute offsets. This flag cannot be used in conjunction with the aa/allAbsolute, ar/allRelative or da/defaultAbsolute flags."
            }, 
            "scheduleClip": {
                "docstring": "This flag is used when creating a clip to specify whether or not the clip should immediately be scheduled at the current time. If the clip is not scheduled, the clip will be placed in the library for future use, but will not be placed on the timeline. This flag is for use only when creating a new clip or duplicating an existing. The default is true."
            }, 
            "sourceClipName": {
                "docstring": "This flag is for query only. It returns the name of the source clip that controls an instanced clip."
            }, 
            "split": {
                "docstring": "Split an existing clip into two clips. The split occurs around the specified time."
            }, 
            "startTime": {
                "docstring": "Specify the clip start"
            }, 
            "translationOffset": {
                "docstring": "Return the channel offsets used to modify the clip's translation."
            }, 
            "useChannel": {
                "docstring": "Specify which channels should be acted on. This flag is valid only in conjunction with clip creation, and the isolate flag. The specified channels must be members of the character."
            }
        }
    }, 
    "clipEditor": {
        "description": "Create a clip editor with the given name. ", 
        "flags": {
            "allTrackHeights": {
                "docstring": "OBSOLETE flag. Use clipStyle instead."
            }, 
            "autoFit": {
                "docstring": "on | off | tgl auto fit-to-view"
            }, 
            "characterOutline": {
                "docstring": ""
            }, 
            "clipDropCmd": {
                "docstring": "Command executed when clip node is dropped on the TraX editor"
            }, 
            "clipStyle": {
                "docstring": "Set/return the clip track style in the specified editor. Default is 2. Valid values are 1-3."
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "deleteCmd": {
                "docstring": "Command executed when backspacekey is pressed"
            }, 
            "deselectAll": {
                "docstring": "Deselect all clips and blends in the editor."
            }, 
            "displayActiveKeyTangents": {
                "docstring": "on | off | tgl display tangents in the editor"
            }, 
            "displayActiveKeys": {
                "docstring": "on | off | tgl display tangents in the editor"
            }, 
            "displayInfinities": {
                "docstring": "on | off | tgl display infinities in the editor"
            }, 
            "displayKeys": {
                "docstring": "on | off | tgl display keyframes in the editor"
            }, 
            "displayTangents": {
                "docstring": "on | off | tgl display tangents in the editor"
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "frameAll": {
                "docstring": "Frame view around all clips in the editor."
            }, 
            "frameRange": {
                "docstring": "The editor's current frame range."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "highlightedBlend": {
                "docstring": "Returns the highlighted blend, listed as scheduler and index"
            }, 
            "highlightedClip": {
                "docstring": "Returns the highlighted clip, listed as scheduler and index"
            }, 
            "listAllCharacters": {
                "docstring": "List all characters in the editor and outliner."
            }, 
            "listCurrentCharacters": {
                "docstring": "List only the characters in the editor and outliner."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "lookAt": {
                "docstring": "all | selected | currentTime fitView helpers"
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "manageSequencer": {
                "docstring": "Sets/returns whether the clip editor should manage sequencer nodes. If so, animation clips and characters are not represented.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "menuContext": {
                "docstring": "Returns a string array denoting the type of data object the cursor is over. Returned values are: {\"timeSlider\"} {\"nothing\"} {\"track\", \"track index\", \"character node name\", \"group name\"} {\"clip\", \"clip node name\""
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectBlend": {
                "docstring": "Select the blends specified by the scheduler name and the indicies of the two clips used in the blend. When queried, a string containing the scheduler name and the two clip indicies for all of the selected blends is returned."
            }, 
            "selectClip": {
                "docstring": "Selects the clip specified by the scheduler name and the clip index. When queried, a string containing the scheduler and clip index of all of the selected clips is returned."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "snapTime": {
                "docstring": "none | integer | keyframe keyframe move snap in time"
            }, 
            "snapValue": {
                "docstring": "none | integer | keyframe keyframe move snap in values"
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "clipEditorCurrentTimeCtx": {
        "description": "This command creates a context which may be used to change current time within the track area of a clip editor. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "clipMatching": {
        "description": "This command is used to compute an offset to apply on a source clip in order to automatically align it to a destination clip at a specified match pose element. For this command to work, the character must have an offset object specified. ", 
        "flags": {
            "clipDst": {
                "docstring": "The clip to match so that the source clip can be offsetted correctly. This flag takes in a clip name and the percentage value ranging from 0.0 to 1.0 in order to have the source clip match at a certain time in the destination clip."
            }, 
            "clipSrc": {
                "docstring": "The clip to offset so that it aligns with the destination clip. This flag takes in a clip name and the percentage value ranging from 0.0 to 1.0 in order to have it match at a certain time in the clip."
            }, 
            "matchType": {
                "docstring": "This flag sets the matching type. Translation is the default match type. 0 - Match translation 1 - Match rotation 2 - Match translation and rotation 3 - Match projected translation on ground plane 4 - Match projected rotation on ground plane 5 - Match projected translation and rotation on ground planeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "clipSchedule": {
        "description": "This command is used to create, edit and query clips and blends in the Trax editor. It operates on the clipScheduler node attached to the character. In query mode, if no flags are specified, returns an array of strings in this form: (clipName,clipIndex,clipStart,clipSourceStart,clipSourceEnd,clipScale,clipPreCycle,clipPostCycle,clipHold) ", 
        "flags": {
            "absolute": {
                "docstring": "This flag is now deprecated. Use aa/allAbsolute, ar/allRelative, ra/rotationsAbsolute, or da/defaultAbsolute instead. This flag controls whether the clip follows its keyframe values or whether they are offset by a value to maintain a smooth path."
            }, 
            "absoluteRotations": {
                "docstring": "This flag is now deprecated. Use aa/allAbsolute, ar/allRelative, ra/rotationsAbsolute, or da/defaultAbsolute instead. If true, this overrides the abs/absolute flag so that rotation channels are always calculated with absolute offsets. This allows you to have absolute offsets on rotations and relative offsets on all other channels."
            }, 
            "allAbsolute": {
                "docstring": "Set all channels to be calculated with absolute offsets. This flag cannot be used in conjunction with the ar/allRelative, ra/rotationsAbsolute or da/defaultAbsolute flags."
            }, 
            "allRelative": {
                "docstring": "Set all channels to be calculated with relative offsets. This flag cannot be used in conjunction with the aa/allAbsolute, ra/rotationsAbsolute or da/defaultAbsolute flags."
            }, 
            "blend": {
                "docstring": "This flag is used to blend two clips, whose indices are provided as flag arguments."
            }, 
            "blendNode": {
                "docstring": "This query only flag list all of the blend nodes associated with the blend defined by the two clip indices. This flag returns a string array. In query mode, this flag can accept a value."
            }, 
            "blendUsingNode": {
                "docstring": "This flag is used if you want to blend using an existing blend node. It is used in conjunction with the blend flag. The blend flag specifies the clip indices for the blend. The name of an existing animBlend node should be supplied supplied as an argument for the blendUsingNode flag."
            }, 
            "character": {
                "docstring": "This flag is used to query which characters this scheduler controls. It returns an array of strings."
            }, 
            "clipIndex": {
                "docstring": "Specify the index of the clip to schedule. In query mode, returns an array of strings in this form: (clipName,index,start,sourceStart,sourceEnd,scale,preCycle,postCycle) In query mode, this flag can accept a value."
            }, 
            "cycle": {
                "docstring": "This flag is now obsolete. Use the postCycle flag instead."
            }, 
            "defaultAbsolute": {
                "docstring": "Sets all top-level channels except rotations in the clip to relative, and the remaining channels to absolute. This is the default during clip creation if no offset flag is specified. This flag cannot be used in conjunction with the aa/allAbsolute, ar/allRelative, or ra/rotationsAbsolute flags."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "This flag is used to enable or disable a clip. It must be used in conjunction with the ci/clipIndex flag. The specified clip will be enabled or disabled."
            }, 
            "group": {
                "docstring": "This flag is used to add (true) or remove (false) a list of clips (specified with groupIndex) into a group."
            }, 
            "groupIndex": {
                "docstring": "This flag specifies a multiple number of clips to be added or removed from a group.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "groupName": {
                "docstring": "This flag is used to specify the group that should be added to. If no group by that name exists and new group is created with that name. By default if this is not specified a new group will be created."
            }, 
            "hold": {
                "docstring": "Specify how long to hold the last value of the clip after its normal or cycled end."
            }, 
            "insertTrack": {
                "docstring": "This flag is used to insert a new empty track at the track index specified."
            }, 
            "instance": {
                "docstring": "Create an instanced copy of the named clip. An instanced clip is one that is linked to an original clip. Thus, changes to the animation curve of the original curve will also modify all instanced clips. The name of the instanced clip is returned as a string."
            }, 
            "listCurves": {
                "docstring": "This flag is used to list the animation curves associated with a clip. It should be used in conjunction with the clipIndex flag, which specifies the clip of interest."
            }, 
            "listPairs": {
                "docstring": "This query only flag returns a string array containing the channels in a character that are used by a clip and the names of the animation curves that drive the channels. Each string in the string array consists of the name of a channel, a space, and the name of the animation curve animating that channel. This flag must be used with the ci/clipIndex flag."
            }, 
            "lock": {
                "docstring": "This flag specifies whether clips on a track are to be locked or not. Must be used in conjuction with the track flag."
            }, 
            "mute": {
                "docstring": "This flag specifies whether clips on a track are to be muted or not. Must be used in conjuction with the track flag."
            }, 
            "name": {
                "docstring": "This flag is used to query the name of the clip node associated with the specified clip index, or to specify the name of the instanced clip during instancing. In query mode, this flag can accept a value."
            }, 
            "postCycle": {
                "docstring": "Specify the number of times to repeat the clip after its normal end."
            }, 
            "preCycle": {
                "docstring": "Specify the number of times to repeat the clip before its normal start."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "This flag is used to remove a clip from the timeline. It must be used in conjunction with the ci/clipIndex flag. The specified clip will be removed from the timeline, but will still exist in the library and any instanced clips will remain in the timeline. To permanently remove a clip from the scene, the clip command should be used instead."
            }, 
            "removeBlend": {
                "docstring": "This flag is used to remove an existing blend between two clips, whose indices are provided as flag arguments."
            }, 
            "removeEmptyTracks": {
                "docstring": "This flag is used to remove all tracks that have no clips."
            }, 
            "removeTrack": {
                "docstring": "This flag is used to remove the track with the specified index. The track must have no clips on it before it can be removed."
            }, 
            "rotationsAbsolute": {
                "docstring": "Set all channels except rotations to be calculated with relative offsets. Rotation channels will be calculated with absolute offsets. This flag cannot be used in conjunction with the aa/allAbsolute, ar/allRelative or da/defaultAbsolute flags."
            }, 
            "scale": {
                "docstring": "Specify the amount to scale the clip. Values must be greater than 0."
            }, 
            "shift": {
                "docstring": "This flag allows multiple clips to be shifted by a certain number of tracks and works in conjunction with the shiftIndex flag. The flag specifies the number of tracks to shift the associated clips. Positive values shift the clips down an negative values shift the clips up."
            }, 
            "shiftIndex": {
                "docstring": "This flag allows multiple clips to be shifted by a certain number of tracks and works in conjunction with the shiftAmount flag. The flag specifies the index of the clip to shift. This flag can be used multiple times on the command line to specify a number of clips to shift."
            }, 
            "solo": {
                "docstring": "This flag specifies whether clips on a track are to be soloed or not. Must be used in conjuction with the track flag."
            }, 
            "sourceClipName": {
                "docstring": "This flag is used to query the name of the source clip node associated with the specified clip index."
            }, 
            "sourceEnd": {
                "docstring": "Specify where to end in the source clip's animation curves"
            }, 
            "sourceStart": {
                "docstring": "Specify where to start in the source clip's animation curves"
            }, 
            "start": {
                "docstring": "Specify the placement of the start of the clip"
            }, 
            "track": {
                "docstring": "Specify the track to operate on. For example, which track to place a clip on, which track to mute/lock/solo. In query mode, it may be used in conjuction with the clipIndex flag to return the track number of a clip, where track 1 is the first track of the character. In query mode, this flag can accept a value."
            }, 
            "weight": {
                "docstring": "This flag is used in to set or query the weight of the clip associated with the specified clip index."
            }, 
            "weightStyle": {
                "docstring": "This flag is used to set or query the weightStyle attribute of the clip associated with the specified clip index."
            }
        }
    }, 
    "clipSchedulerOutliner": {
        "description": "This command creates/edits/queries a clip scheduler outliner control. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "clipScheduler": {
                "docstring": "Name of the clip scheduler for which to display information.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "closeCurve": {
        "description": "The closeCurve command closes a curve, making it periodic. The pathname to the newly closed curve and the name of the resulting dependency node are returned. If a curve is not specified in the command, then the first active curve will be used. ", 
        "flags": {
            "blendBias": {
                "docstring": "Skew the result toward the first or the second curve depending on the blend value being smaller or larger than 0.5.Default:0.5"
            }, 
            "blendKnotInsertion": {
                "docstring": "If set to true, insert a knot in one of the original curves (relative position given by the parameter attribute below) in order to produce a slightly different effect.Default:false"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curveOnSurface": {
                "docstring": "If possible, create 2D curve as a resultFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameter": {
                "docstring": "The parameter value for the positioning of the newly inserted knot.Default:0.1Advanced flags"
            }, 
            "preserveShape": {
                "docstring": "0 - without preserving the shape 1 - preserve shape 2 - blendDefault:1"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)"
            }
        }
    }, 
    "closeSurface": {
        "description": "The closeSurface command closes a surface in the U, V, or both directions, making it periodic. The close direction is controlled by the direction flag. If a surface is not specified in the command, then the first selected surface will be used. The pathname to the newly closed surface and the name of the resulting dependency node are returned. This command also handles selected surface isoparms. For example, if an isoparm is specified, surface1.u[0.33], then the surface will be closed in V, regardless of the direction flag. ", 
        "flags": {
            "blendBias": {
                "docstring": "Skew the result toward the first or the second surface depending on the blend value being smaller or larger than 0.5.Default:0.5"
            }, 
            "blendKnotInsertion": {
                "docstring": "If set to true, insert a knot in one of the original surfaces (relative position given by the parameter attribute below) in order to produce a slightly different effect.Default:false"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "direction": {
                "docstring": "The direction in which to close: 0 - U, 1 - V, 2 - Both U and VDefault:0Advanced flags"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameter": {
                "docstring": "The parameter value for the positioning of the newly inserted knot.Default:0.1"
            }, 
            "preserveShape": {
                "docstring": "0 - without preserving the shape 1 - preserve shape 2 - blendDefault:1"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "cluster": {
        "description": "The cluster command creates a cluster or edits the membership of an existing cluster. The command returns the name of the cluster node upon creation of a new cluster. After creating a cluster, the cluster's weights can be modified using the percent command or the set editor window. ", 
        "flags": {
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "bindState": {
                "docstring": "When turned on, this flag adds in a compensation to ensure the clustered objects preserve their spatial position when clustered. This is required to prevent the geometry from jumping at the time the cluster is created in situations when the cluster transforms at cluster time are not identity."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "envelope": {
                "docstring": "Set the envelope value for the deformer. Default is 1.0"
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Enable relative mode for the cluster. In relative mode, Only the transformations directly above the cluster are used by the cluster. Default is off."
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "resetGeometry": {
                "docstring": "Reset the geometry matrices for the objects being deformed by the cluster. This flag is used to get rid of undesirable effects that happen if you scale an object that is deformed by a cluster.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "weightedNode": {
                "docstring": "Transform node in the DAG above the cluster to which all percents are applied. The second DAGobject specifies the descendent of the first DAGobject from where the transformation matrix is evaluated. Default is the cluster handle."
            }
        }
    }, 
    "cmdFileOutput": {
        "description": "This command will open a text file to receive all of the commands and results that normally get printed to the Script Editor window or console. The file will stay open until an explicit -close with the correct file descriptor or a -closeAll, so care should be taken not to leave a file open. To enable logging to commence as soon as Maya starts up, the environment variable MAYA_CMD_FILE_OUTPUT may be specified prior to launching Maya. Setting MAYA_CMD_FILE_OUTPUT to a filename will create and output to that given file. To access the descriptor after Maya has started, use the -query and -open flags together. ", 
        "flags": {
            "close": {
                "docstring": "Closes the file corresponding to the given descriptor. If -3 is returned, the file did not exist. -1 is returned on error, 0 is returned on successful close."
            }, 
            "closeAll": {
                "docstring": "Closes all open files.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "open": {
                "docstring": "Opens the given file for writing (will overwrite if it exists and is writable). If successful, a value is returned to enable status queries and file close. -1 is returned if the file cannot be opened for writing. The -open flag can also be specified in -query mode. In query mode, if the named file is currently opened, the descriptor for the specified file is returned, otherwise -1 is returned. This is an easy way to check if a given file is currently open. "
            }, 
            "query": {
                "docstring": ""
            }, 
            "status": {
                "docstring": "Queries the status of the given descriptor. -3 is returned if no such file exists, -2 indicates the file is not open, -1 indicates an error condition, 0 indicates file is ready for writing."
            }
        }
    }, 
    "cmdScrollFieldExecuter": {
        "description": "A script editor executer control used to issue script commands to Maya. ", 
        "flags": {
            "annotation": {
                "docstring": ""
            }, 
            "appendText": {
                "docstring": "Appends text to the end of this field."
            }, 
            "autoCloseBraces": {
                "docstring": "Specifies whether a closing brace should automatically be added when hitting enter after an opening brace. (default on)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "backgroundColor": {
                "docstring": ""
            }, 
            "clear": {
                "docstring": "Clears the field."
            }, 
            "commandCompletion": {
                "docstring": "Enable/disable command completion"
            }, 
            "copySelection": {
                "docstring": "Copies the current selection from this field."
            }, 
            "currentLine": {
                "docstring": "Sets/returns the current line which the cursor is on."
            }, 
            "cutSelection": {
                "docstring": "Cuts the current selection from this field."
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "docTag": {
                "docstring": ""
            }, 
            "dragCallback": {
                "docstring": ""
            }, 
            "dropCallback": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": ""
            }, 
            "enableBackground": {
                "docstring": ""
            }, 
            "execute": {
                "docstring": "Executes the current selection. If there is no selection, all text is executed."
            }, 
            "executeAll": {
                "docstring": "Executes all text."
            }, 
            "exists": {
                "docstring": ""
            }, 
            "filterKeyPress": {
                "docstring": "Sets a script which will be called to handle key-press events. The function should have the following signature:proc int filterKeyPress(int $modifiers, string $key) modifiers: a bit mask where Shift is bit 1, Ctrl is bit 3, Alt is bit 4, and bit 5 is the 'Windows' key on Windows keyboards and the Command key on Mac keyboards.key: Specifies what key was pressed. The key is either a single ascii character or one of the keyword strings for the special keyboard characters. For example: Up, Down, Right, Left, Home, End, Page_Up, Page_Down, Insert Return, Space F1 to F12The function should return 1 to indicate that they key event has been handled, and 0 to indicate that it has not been handled."
            }, 
            "fullPathName": {
                "docstring": ""
            }, 
            "hasFocus": {
                "docstring": "Whether this control is currently in focus."
            }, 
            "hasSelection": {
                "docstring": "Whether this control currently has a selection or not."
            }, 
            "height": {
                "docstring": ""
            }, 
            "indentSelection": {
                "docstring": ""
            }, 
            "insertText": {
                "docstring": "Inserts the specified text into the position under the cursor, replacing any currently selected text. The selection and cursor position can be set using the selectflag. Appends text to the end of this field."
            }, 
            "isObscured": {
                "docstring": ""
            }, 
            "load": {
                "docstring": "Prompts the user for a script to load into this field."
            }, 
            "loadContents": {
                "docstring": "Loads the contents of the specified filename into this field. The path and extension for this filename is provided internally. This command is only intended for loading the contents of this executer field from a previous instance of this executer field."
            }, 
            "manage": {
                "docstring": ""
            }, 
            "numberOfLines": {
                "docstring": "Returns the total number of lines in the document."
            }, 
            "numberOfPopupMenus": {
                "docstring": ""
            }, 
            "objectPathCompletion": {
                "docstring": "Enable/disable path completion"
            }, 
            "parent": {
                "docstring": ""
            }, 
            "pasteSelection": {
                "docstring": "Pastes text into this field at the current caret position."
            }, 
            "popupMenuArray": {
                "docstring": ""
            }, 
            "preventOverride": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "receiveFocusCommand": {
                "docstring": ""
            }, 
            "redo": {
                "docstring": "Redo the last operation."
            }, 
            "removeStoredContents": {
                "docstring": "Removes the stored contents of this field with the specified filename. The path and extension for the file is provided internally. This command is only intended for removing previously stored contens of this executer field."
            }, 
            "replaceAll": {
                "docstring": "Replaces all instances of the first string in the field text with the second string. The case sensitivity of this operation is set with the -searchMatchCase flag."
            }, 
            "saveSelection": {
                "docstring": "Prompts to save the current selection to a file. The default filename prompt will be prepended with the given string."
            }, 
            "saveSelectionToShelf": {
                "docstring": "Prompts to save the current selection to an item in the shelf."
            }, 
            "searchAndSelect": {
                "docstring": "Searches for (and selects) the sepecified search string using the specified search options."
            }, 
            "searchDown": {
                "docstring": "Specifies whether to search from the cursor down, or up."
            }, 
            "searchMatchCase": {
                "docstring": "Specifies whether the search is to be case sensitive or not."
            }, 
            "searchString": {
                "docstring": "Specifies the string to search for."
            }, 
            "searchWraps": {
                "docstring": "Specifies whether the search should wrap around."
            }, 
            "select": {
                "docstring": "Selects text within a specified range."
            }, 
            "selectAll": {
                "docstring": "Selects all text."
            }, 
            "selectedText": {
                "docstring": "The text in the current selection range."
            }, 
            "showLineNumbers": {
                "docstring": "Shows/hides the line numbes column."
            }, 
            "showTooltipHelp": {
                "docstring": "Enable/disable tooltips in the command execution window"
            }, 
            "source": {
                "docstring": "Prompts the user for a script to source (execute without loading)."
            }, 
            "sourceType": {
                "docstring": "Sets the source type for this command executer field. Valid values are \"mel\" (enabled by default), and \"python\"."
            }, 
            "spacesPerTab": {
                "docstring": "Specifies the number of spaces equivalent to one tab stop. (default 4)"
            }, 
            "storeContents": {
                "docstring": "If the provided string is a fully specified file path, then attempts to store the contents of this field to that path. Otherwise, uses the provided string as a filename only and uses an internally generated path and extension for the file, as used by the -loadContents and -removeStoredContents flags. In both cases, a new unique filename will be generated if the specified name exists. Returns the filename of the file saved upon completion, and an empty string otherwise."
            }, 
            "tabsForIndent": {
                "docstring": "Specifies whether tab characters should be inserted when indenting. (default on)"
            }, 
            "text": {
                "docstring": "Replaces the field text with the given string."
            }, 
            "textLength": {
                "docstring": "The number of characters in this text field."
            }, 
            "undo": {
                "docstring": "Undo the last operation."
            }, 
            "unindentSelection": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": ""
            }, 
            "visible": {
                "docstring": ""
            }, 
            "visibleChangeCommand": {
                "docstring": ""
            }, 
            "width": {
                "docstring": ""
            }
        }
    }, 
    "cmdScrollFieldReporter": {
        "description": "A script editor reporter control used to receive and display the history of processed commmands. ", 
        "flags": {
            "annotation": {
                "docstring": ""
            }, 
            "backgroundColor": {
                "docstring": ""
            }, 
            "clear": {
                "docstring": "Clears the field."
            }, 
            "copySelection": {
                "docstring": "Copies the current selection from this field."
            }, 
            "cutSelection": {
                "docstring": "Cuts the current selection from this field."
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "docTag": {
                "docstring": ""
            }, 
            "dragCallback": {
                "docstring": ""
            }, 
            "dropCallback": {
                "docstring": ""
            }, 
            "echoAllCommands": {
                "docstring": "Echo all commands. (Global parameter, affects all command reporters)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": ""
            }, 
            "enableBackground": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "filterSourceType": {
                "docstring": "Filters the specified source type from showing in this command reporter. Currently supports either \"mel\", \"python\", or \"\" (default). Setting the filter to the empty string (\"\") will remove all filtering and show both \"mel\" and \"python\" results."
            }, 
            "fullPathName": {
                "docstring": ""
            }, 
            "hasFocus": {
                "docstring": "Whether this control is currently in focus."
            }, 
            "height": {
                "docstring": ""
            }, 
            "isObscured": {
                "docstring": ""
            }, 
            "lineNumbers": {
                "docstring": "Show line numbers (in Error/Warning messages). (Global parameter, affects all command reporters)"
            }, 
            "manage": {
                "docstring": ""
            }, 
            "numberOfPopupMenus": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": ""
            }, 
            "pasteSelection": {
                "docstring": "Pastes text into this field at the current caret position."
            }, 
            "popupMenuArray": {
                "docstring": ""
            }, 
            "preventOverride": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "receiveFocusCommand": {
                "docstring": "Command executed when the field receives focus."
            }, 
            "saveSelection": {
                "docstring": "Prompts to save the current selection to a file. The default filename prompt will be prepended with the given string."
            }, 
            "saveSelectionToShelf": {
                "docstring": "Prompts to save the current selection to an item in the shelf."
            }, 
            "select": {
                "docstring": "Selects text within a specified range."
            }, 
            "selectAll": {
                "docstring": "Selects all text."
            }, 
            "stackTrace": {
                "docstring": "Show stack trace. (Global parameter, affects all command reporters)"
            }, 
            "suppressErrors": {
                "docstring": "Suppress errors."
            }, 
            "suppressInfo": {
                "docstring": "Suppress info."
            }, 
            "suppressResults": {
                "docstring": "Suppress results."
            }, 
            "suppressStackTrace": {
                "docstring": "Suppress stack trace.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "suppressWarnings": {
                "docstring": "Suppress warnings."
            }, 
            "text": {
                "docstring": "Replaces the field text with the given string."
            }, 
            "textLength": {
                "docstring": "The number of characters in this text field."
            }, 
            "useTemplate": {
                "docstring": ""
            }, 
            "visible": {
                "docstring": ""
            }, 
            "visibleChangeCommand": {
                "docstring": ""
            }, 
            "width": {
                "docstring": ""
            }
        }
    }, 
    "cmdShell": {
        "description": "This command creates a scrolling field that behaves similar to a unix shell for entering user input. You may specify the number of lines that will be remembered by the field with the -nsl/numberOfSavedLines flag. The default number of lines saved is 100. The shellField also maintains a command history buffer. You can specify the number of input lines that will be saved with the -hlc/historyLineCount flag. The default size of this buffer is 10. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "clear": {
                "docstring": "Erases all visible text, and also deletes any text that had scrolled of the top of the field. After clearing the field it will be blank, and you will not be able to scroll up to see previous lines. This flag does not affect the command history buffer, however."
            }, 
            "command": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfHistoryLines": {
                "docstring": "The number of input lines to be saved in the command history buffer. You can cycle through this buffer by pressing the up and down arrow keys. Valid values are 0 through 32767. Any value less than 0 will be handled as if 0 was specified. Similarly, any value greater than 32767 will be handled as if 32767 was specified.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "numberOfSavedLines": {
                "docstring": "The total number of lines (the scrolled lines and currently visible lines) that will be remembered by the field. Any lines beyond this number will be lost, and the user will not be able to review them by scrolling. Valid values are 1 through 32767. Any value less than 1 will be handled as if 1 was specified. Similarly, any value greater than 32767 will be handled as if 32767 was specified."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "prompt": {
                "docstring": "The text that is used as a prompt."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "coarsenSubdivSelectionList": {
        "description": "Coarsens a subdivision surface set of components based on the selection list. The selected components are selected at a coarser level. ", 
        "flags": {}
    }, 
    "collision": {
        "description": "The collision command causes particles to collide with geometry. It also allows you to specify values for the surface properties (friction and resilience) of the collision. These values are stored in the geoConnector node for the geometry object. Unlike earlier versions of Maya, there is no separate \"collision node.\" If a soft object is in the selection list, the collision command assumes that you want to make it a collider. In order to make the soft object collide with something use, use connectDynamic -c. The collision menu option sorts this out using the lead object rule and issues the necessary commands. On creation, this command returns a string arrayof the geometry names that were setup for particle collision.When the command is used to query information, there are several possible return types. These include: If the -resilience or -friction flag is passed on the command line and a single collision geometry is either selected or on the command line, then resilience or friction value for that collision geometry is returned as a single floatvalue.If the -resilience or -friction flag is passed on the command line and a single collision geometry and a single particle object are either selected or on the command line, then two results might occur. If the particle object is not set up to collide with the geometry, then an error is displayed stating that. If the objects are set up to collide with each other, then the resilience or friction value that the particle object is using for collisions with the geometry is returned as a single floatvalue. This can be different than the geometry's resilience and friction, because the user may break the connection from the geometry's geoConnector node's resilience or friction to the particle, and set a different value in the particle's collisionResilience, collisionFriction or collisionOffset attribute that is used for that geometry. This allows the user to make each particle respond to the same surface differently.If neither flag is pass on the command line and a single geometry and single particle object are either selected or on the command line, then a single integervalue of 1 is returned if the objects are set up to collide with each other, and 0 is returned if they are not.Lastly, if no flags are passed on the command line and a single particle object is either selected or on the command line, then a string arraywith the names of all geometries that the particle object will collide against and the multiIndex that the geometries are connected to is returned. The array is formatted as follows: pPlaneShape1:0 pPlaneShape2:2 nurbsSphereShape1:3...where the number following the \":\" is the multiIndex.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "friction": {
                "docstring": "Friction of the surface. This is the amount of the colliding particle's velocity parallel to the surface which is removed when the particle collides. A value of 0 will mean that no tangential velocity is lost, while a value of 1 will cause the particle to reflect straight along the normal of the surface.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "This flag is obsolete. In maya 2.0, there is no longer a separate \"collision node,\" thus there is nothing to name. See the collision documentation. This flag is included only to allow scripts written with older versions of Maya to run. It will give you a warning message but will not do anything."
            }, 
            "offset": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "resilience": {
                "docstring": "Resilience of the surface. This is the amount of the colliding particle's velocity reflected along the normal of the surface. A value of 1 will give perfect reflection, while a value of 0 will have no reflection along the normal of the surface."
            }
        }
    }, 
    "color": {
        "description": "This command sets the dormant wireframe color of the specified objects to be their class color or if the -ud/userDefined flag is specified, one of the user defined colors. ", 
        "flags": {
            "userDefined": {
                "docstring": "Specifies the user defined color index to set selected object to. The valid range of numbers is [1-8].Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "colorAtPoint": {
        "description": "The colorAtPointcommand is used to query textures or ocean shaders at passed in uv coordinates. (For ocean shaders uv is x and z in worldspace ). The return value is a floating point array whose size is determined by either the number of input uv arguments passed in and the the queried value. One can query alpha only, rgb only, or rgba values. The returned array is only single indexed, so if rgb is specified then the index for red values would be index \\* 3. Blue is index \\* 3 + 1, and green is index \\* 3 + 2. For rgba use a multiple of 4 instead of 3. For alpha only one can simply use the index. There are two basic argument formats that may be used: colorAtPoint -u 0 -v 0 -u .2 -v .1 etc.. for all points or colorAtPoint -mu 0 -mv 0 -xu 1 -xv 1 -su 10 -sv 10 // samples 100 points If one is sampling several points and they are all in a regular grid formation it is more efficient to call this routine with the latter method, which uses a min/max uv and number of samples, rather than a long argument list of uv coords. return values (-o A or RGB or RGBA)individual UV coordinates to sample (-u float -v float)(numbers of calls to -u and -v must match)uniform grid of points to sample (-su int -sv int)(may not use this in combination with -u or -v)bounds for sample grid (-mu float -mv float -xu float -xv float)", 
        "flags": {
            "coordU": {
                "docstring": "Input u coordinate to sample texture at."
            }, 
            "coordV": {
                "docstring": "Input v coordinate to sample texture at."
            }, 
            "maxU": {
                "docstring": "DEFAULT 1.0 Maximum u bounds to sample."
            }, 
            "maxV": {
                "docstring": "DEFAULT 1.0 Maximum v bounds to sample."
            }, 
            "minU": {
                "docstring": "DEFAULT 0.0 Minimum u bounds to sample."
            }, 
            "minV": {
                "docstring": "DEFAULT 0.0 Minimum v bounds to sample."
            }, 
            "output": {
                "docstring": "Type of data to output: A = alpha only RGB = color only RGBA = color and alpha"
            }, 
            "samplesU": {
                "docstring": "DEFAULT 1 The number of points to sample in the U dimension."
            }, 
            "samplesV": {
                "docstring": "DEFAULT 1 The number of points to sample in the V dimension.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "colorEditor": {
        "description": "The colorEditorcommand displays a modal dialog that may be used to specify colors in RGB or HSV. The default behaviour when no arguments are specified is to provide an initial color of black (rgb 0.0 0.0 0.0). The command will return the user's color component values along with a boolean to indicate whether the dialog was dismissed by pressing the \"OK\" button. As an alternative to responding to the colorEditorcommand's return string you can now query the -rgb/rgbValue, -hsv/hsvValue, and -r/resultflags to get the same information. ", 
        "flags": {
            "alpha": {
                "docstring": ""
            }, 
            "hsvValue": {
                "docstring": "Three float values corresponding to the hue, saturation, and value color components, where the hue value ranges from 0.0 to 360.0 and the saturation and value components range from 0.0 to 1.0. Use this flag to specify the initial color of the Color Editor, or query this flag to determine the color set in the editor."
            }, 
            "parent": {
                "docstring": "Specify the parent window for the dialog. The dialog will be centered on this window and raise and lower with it's parent. By default, the dialog is not parented to a particular window and is simply centered on the screen."
            }, 
            "query": {
                "docstring": ""
            }, 
            "result": {
                "docstring": "This query only flag returns true if the dialog's \"OK\" button was pressed, false otherwise. If you query this flag immediately after showing the Color Editor then it will return the same value as the boolean value returned in the colorEditorcommand's return string.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "rgbValue": {
                "docstring": "Three float values corresponding to the red, green, and blue color components, all of which range from 0.0 to 1.0. Use this flag to specify the initial color of the Color Editor, or query this flag to determine the color set in the editor."
            }
        }
    }, 
    "colorIndex": {
        "description": "The index specifies a color index in the color palette. The r, g, and b values (between 0-1) specify the RGB values (or the HSV values if the -hsv flag is used) for the color. ", 
        "flags": {
            "hueSaturationValue": {
                "docstring": "Indicates that rgb values are really hsv values. Upon query, returns the HSV valuses as an array of 3 floats.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "resetToFactory": {
                "docstring": "Resets all color index palette entries to their factory defaults."
            }, 
            "resetToSaved": {
                "docstring": "Resets all color palette entries to their saved values."
            }
        }
    }, 
    "colorIndexSliderGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a color slider group consisting of a label, a color canvas and a slider. The value of the slider defines a color index into the a color table. The corresponding color is displayed in the canvas. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the value changes. This command is not invoked when the value changes via the -v/value flag."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command executed when the value changes by dragging the slider's value marker.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "extraLabel": {
                "docstring": "Sets the string to be the text for the extra label."
            }, 
            "forceDragRefresh": {
                "docstring": ""
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "invisible": {
                "docstring": "Set the invisible color index."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "Label text for the group."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Maximum color index."
            }, 
            "minValue": {
                "docstring": "Minimum color index."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Color index."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "colorSliderButtonGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command object creates a new color slider group with a button and a symbol button. This control is primarily used in the rendering UI. In this context, the button brings up a dialog that allows the user to assign a texture map to this parameter. Once a texture map is available, a symbol button shows up. When this symbol button is pressed, the user is taken to another dialog to edit the texture map. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "buttonCommand": {
                "docstring": "Command string executed when the button is pressed."
            }, 
            "buttonLabel": {
                "docstring": "The button text."
            }, 
            "changeCommand": {
                "docstring": "Command string executed when slider value changes."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command string executed when slider value marker is dragged."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "forceDragRefresh": {
                "docstring": ""
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "hsvValue": {
                "docstring": "Color in hue, saturation, and value format."
            }, 
            "image": {
                "docstring": "Image displayed on the symbol button."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "Label text for the group."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rgbValue": {
                "docstring": "Color in red, green, and blue format."
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "symbolButtonCommand": {
                "docstring": "Command string executed when the symbol button is pressed."
            }, 
            "symbolButtonDisplay": {
                "docstring": "Visibility of the symbol button.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "colorSliderGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a color Slider group consisting of a label, a color canvas and a slider. Clicking on the canvas will bring up the color editor dialog. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command string executed when slider value changes."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command string executed when slider value marker is dragged.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "forceDragRefresh": {
                "docstring": ""
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "hsvValue": {
                "docstring": "Color in hue, saturation, and value format."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "Label text for the group."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rgbValue": {
                "docstring": "Color in red, green, and blue format."
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "columnLayout": {
        "description": "This command creates a layout that arranges its children in a single column. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Sets the children of the layout to be attached on both sides. They will stretch or shrink with the layout."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "columnAlign": {
                "docstring": "Sets the alignment of children containing text or pixmaps. Align values: \"left\" | \"right\" | \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Sets the attachment and offsets for the children of the layout. Side values: \"left\" | \"right\" | \"both\". Left or both is recommended."
            }, 
            "columnOffset": {
                "docstring": "Sets the offsets for children of the layout. Side values: \"left\" | \"right\" | \"both\"."
            }, 
            "columnWidth": {
                "docstring": "Sets the width of the column. Unless the children are attached to both sides of the column, the width cannot be enforced. Larger children will expand layout."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowSpacing": {
                "docstring": "Sets the space between children.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "commandEcho": {
        "description": "This command controls what is echoed to the command window. In query mode, return type is based on queried flag.", 
        "flags": {
            "filter": {
                "docstring": "This flag allows to filter out unwanted commands when echo all commands is enabled. You can provide a partial command name, so all commands that start with a substring specified in filter entry will be filtered out. If filter is empty, all commands are echoed to the command window."
            }, 
            "lineNumbers": {
                "docstring": "If true then file name and line number information is provided in error and warning messages. If false then no file name and line number information is provided in error and warning messages.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "state": {
                "docstring": "If true then all commands are echoed to the command window. If false then only relevant commands are echoed."
            }
        }
    }, 
    "commandLine": {
        "description": "This command creates a single line for command input/output.The left half is for input, the right half for output. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "command": {
                "docstring": "Command executed when the command line text changes."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enterCommand": {
                "docstring": "Command executed when the keypad 'Enter' key is pressed."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "holdFocus": {
                "docstring": "Sets whether the command line should hold focus after exectuing a command.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "inputAnnotation": {
                "docstring": "Annotate the input field with an extra string value."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfHistoryLines": {
                "docstring": "Sets the maximum number of commands saved to the command line history. Up to -nhl/numberOfHistoryLines previous commands will be available by pressing the up-arrow from within the input field.The default value is 50."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "outputAnnotation": {
                "docstring": "Annotate the output field with an extra string value."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sourceType": {
                "docstring": "Sets the source type of this command line. Currently supports \"mel\" (enabled by default), and \"python\"."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "commandPort": {
        "description": "Opens or closes the Maya command port. The command port comprises a socket to which a client program may connect. An example command port client \"mcp\" is included in the Motion Capture developers kit. It supports multi-byte commands and uses utf-8 as its transform format. It will receive utf8 command string and decode it to Maya native coding. The result will also be encoded to utf-8 before sending back. Care should be taken regarding INET domain sockets as no user identification, or authorization is required to connect to a given socket, and all commands (including \"system(...)\") are allowed and executed with the user id and permissions of the Maya user. The prefix flag can be used to reduce this security risk, as only the prefix command is executed. The query flag can be used to determine if a given command port exists. See examples below. ", 
        "flags": {
            "bufferSize": {
                "docstring": "Commands and results are each subject to size limits. This option allows the user to specify the size of the buffer used to communicate with Maya. If unspecified the default buffer size is 4096 characters. Commands longer than bufferSize characters will cause the client connection to close. Results longer that bufferSize characters are replaced with an error message."
            }, 
            "close": {
                "docstring": "Closes the commandPort, deletes the pipes"
            }, 
            "echoOutput": {
                "docstring": "Sends a copy of all comand output to the command port. Typically only the result is transmitted. This option provides a copy of all output."
            }, 
            "listPorts": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Specifies the name of the command port which this command creates. CommandPort names of the form namecreate a UNIX domain socket on the localhost corresponding to name. If namedoes not begin with \"/\", then /tmp/nameis used. If namebegins with \"/\", namedenotes the full path to the socket. Names of the form :port numbercreate an INET domain on the local host at the given port."
            }, 
            "noreturn": {
                "docstring": "Do not write the results from executed commands back to the command port socket. Instead, the results from executed commands are written to the script editor window. As no information passes back to the command port client regarding the execution of the submitted commands, care must be taken not to overflow the command buffer, which would cause the connection to close."
            }, 
            "pickleOutput": {
                "docstring": "Python output will be pickled.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "prefix": {
                "docstring": "The string argument is the name of a Maya command taking one string argument. This command is called each time data is sent to the command port. The data written to the command port is passed as the argument to the prefix command. The data from the command port is encoded as with enocodeString and enclosed in quotes. If newline characters are embedded in the command port data, the input is split into individual lines. These lines are treated as if they were separate writes to the command port. Only the result to the last prefix command is returned."
            }, 
            "query": {
                "docstring": ""
            }, 
            "returnNumCommands": {
                "docstring": "Ignore the result of the command, but return the number of commands that have been read and executed in this call. This is a simple way to track buffer overflow. This flag is ignored when the noreturnflag is specified."
            }, 
            "securityWarning": {
                "docstring": "Enables security warning on command port input."
            }, 
            "sourceType": {
                "docstring": "The string argument is used to indicate which source type would be passed to the commandPort, like \"mel\", \"python\". The default source type is \"mel\"."
            }
        }
    }, 
    "componentBox": {
        "description": "This command creates a component box, which is sensitive to the active list. It displays certain components of the last node on the active list, and provides a two-way connection to keep the widget up to date. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "execute": {
                "docstring": "Immediately executes the command string once for every cell (or every selected cell, if the boolean argument is TRUE) in the component box, for every matching selected object (ie, for every object would be affected if you changed a cell value.) Before the command is executed, \"#A\" is substituted with the name of the attribute, and \"#N\" with the name of the node, and \"#P\" with the full path name of the node.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "labelWidth": {
                "docstring": "An optional flag which is used to modify the width assigned to labels appearing in the componentBox."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxHeight": {
                "docstring": "An optional flag which is used to limit the height of the componentBox."
            }, 
            "maxWidth": {
                "docstring": "An optional flag which is used to limit the width of the componentBox."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "precision": {
                "docstring": "Controls the number of digits to the right of the decimal point that will be displayed for float-valued components. Default is 3. Queried, returns an int."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowHeight": {
                "docstring": "An optional flag which is used to set the height of all rows in the componentBox."
            }, 
            "selectedAttr": {
                "docstring": "Returns a list of names of all the attributes that are selected. This flag is ignored when not being queried."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "componentEditor": {
        "description": "This command creates a new component editor in the current layout. ", 
        "flags": {
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "floatField": {
                "docstring": "assigns a float field that the component editor will use for editing groups of values."
            }, 
            "floatSlider": {
                "docstring": "assigns a float slider that the component editor will use for editing groups of values."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "hidePathName": {
                "docstring": "Hides path name of displayed element. By default this flag is set to false."
            }, 
            "hideZeroColumns": {
                "docstring": "Hides columns whose elements are all zero. By default this flag is set to false."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "lockInput": {
                "docstring": "Prevents the editor from responding to changes in the active list. Independent of selection connection."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "newTab": {
                "docstring": "Creates a new tab, named by the first argument, based on an existing tab, given as the second argument using elements from a set, given in the third argument"
            }, 
            "operationCount": {
                "docstring": "returns the total number of operation types known to the component editor."
            }, 
            "operationLabels": {
                "docstring": "returns a string array containing the names for all operation types known to the editor."
            }, 
            "operationType": {
                "docstring": "Tells the editor which of its known operation types it should be performing. This is a 0-based index."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "precision": {
                "docstring": "Specifies the maximum number of digits displayed to the right of the decimal place. Can be 0 to 20."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeTab": {
                "docstring": "Removes the tab based on the set provided"
            }, 
            "selected": {
                "docstring": "Returns a list of strings, containing the labels of the currently selected columnsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "setOperationLabel": {
                "docstring": "uses the string as the new name for the existing operation type specified by the integer index. Note that there is no messaging system which allows UI to be informed of changes made by this flag."
            }, 
            "showObjects": {
                "docstring": "Restricts the display to columns that are in the current active list."
            }, 
            "showSelected": {
                "docstring": "Restricts the display to those columns which are currently selected. By default this flag is set to false, so all columns are selected. The results from this flag obey the current -hideZeroColumns setting."
            }, 
            "sortAlpha": {
                "docstring": "Controls alphabetical (true), or hierarchical sorting of columns"
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "condition": {
        "description": "This command creates a new named condition object whose true/false value is calculated by running a mel script. This new condition can then be used for dimming, or controlling other scripts, or whatever. In query mode, return type is based on queried flag.", 
        "flags": {
            "delete": {
                "docstring": "Deletes the condition."
            }, 
            "dependency": {
                "docstring": "Each -dependency flag specifies another condition that the new condition will be dependent on. When any of these conditions change, the new-state-script will run, and the state of this condition will be set accordingly. It is possible to define infinite loops, but they will be caught and handled correctly at run-time."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "initialize": {
                "docstring": "Initializes the condition, by forcing it to run its script as soon as it is created. If this flag is not specified, the script will not run until one of the dependencies is triggered."
            }, 
            "query": {
                "docstring": ""
            }, 
            "script": {
                "docstring": "The script that determines the new state of the condition."
            }, 
            "state": {
                "docstring": "Sets the state of the condition. This can be used to create a manually triggered condition: you could create a condition without any dependencies and without a new-state-script. This condition would only change state in response to the -st/state flag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "cone": {
        "description": "The cone command creates a new cone and/or a dependency node that creates one, and returns their names. ", 
        "flags": {
            "axis": {
                "docstring": "The primitive's axisAdvanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting surface: 1 - linear, 3 - cubicDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endSweep": {
                "docstring": "The angle at which to end the surface of revolution. Default is 2Pi radians, or 360 degrees.Default:6.2831853"
            }, 
            "heightRatio": {
                "docstring": "Ratio of \"height\" to \"width\"Default:2.0"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "pivot": {
                "docstring": "The primitive's pivot point"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "The radius of the objectDefault:1.0"
            }, 
            "sections": {
                "docstring": "The number of sections determines the resolution of the surface in the sweep direction. Used only if useTolerance is false.Default:8"
            }, 
            "spans": {
                "docstring": "The number of spans determines the resolution of the surface in the opposite direction.Default:1"
            }, 
            "startSweep": {
                "docstring": "The angle at which to start the surface of revolutionDefault:0"
            }, 
            "tolerance": {
                "docstring": "The tolerance with which to build the surface. Used only if useTolerance is trueDefault:0.01"
            }, 
            "useOldInitBehaviour": {
                "docstring": "Create the cone with base on the origin as in Maya V8.0 and below Otherwise create cone centred at originDefault:false"
            }, 
            "useTolerance": {
                "docstring": "Use the specified tolerance to determine resolution. Otherwise number of sections will be used.Default:false"
            }
        }
    }, 
    "confirmDialog": {
        "description": "The confirmDialog command creates a modal dialog with a message to the user and a variable number of buttons to dismiss the dialog. The dialog is dismissed when the user presses any button or chooses the close item from the window menu. In the case where a button is pressed then the name of the button selected is returned. If the dialog is dismissed via the close item then the string returned is specified by the dismissStringflag. The default behaviour when no arguments are specified is to create an empty single button dialog. ", 
        "flags": {
            "annotation": {
                "docstring": "set the annotation for the buttons"
            }, 
            "backgroundColor": {
                "docstring": "The background color of the dialog. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0. (Windows only flag)"
            }, 
            "button": {
                "docstring": "Create a button with the given string as it's text."
            }, 
            "cancelButton": {
                "docstring": "The cancel button is activated by pressing the escape key. Note that this flag does not create a button, it simply indicates which button created via the buttonflag shall respond to the escape key."
            }, 
            "defaultButton": {
                "docstring": "The default button is activated by pressing the enter key. Note that this flag does not create a button, it simply indicates which button created via the buttonflag shall respond to the enter key."
            }, 
            "dismissString": {
                "docstring": "The string returned when the user selects the 'Close' item from the Window Manager menu. If this flag is not set then the string \"dismiss\" is returned."
            }, 
            "icon": {
                "docstring": "The user can specify one of the four standard icons -- \"question\", \"information\", \"warning\" and \"critical\". The question icon indicates that the messsage is asking a question. The information icon indicates that the message is nothing out of the ordinary. The warning icon indicates that the message is a warning, but can be dealt with. The critical icon indicates that the message represents a critical problem. When no icon flag is present, we assume the user does not want to include any icon in the confirm dialog.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "message": {
                "docstring": "The message text appearing in the dialog."
            }, 
            "messageAlign": {
                "docstring": "Align the message left, center, or right."
            }, 
            "parent": {
                "docstring": "Specify the parent window for the dialog. The dialog will be centered on this window and raise and lower with it's parent. By default, the dialog is not parented to a particular window and is simply centered on the screen."
            }, 
            "title": {
                "docstring": "The dialog title."
            }
        }
    }, 
    "connectAttr": {
        "description": "Connect the attributes of two dependency nodes and return the names of the two connected attributes. The connected attributes must be be of compatible types. First argument is the source attribute, second one is the destination. Refer to dependency node documentation. ", 
        "flags": {
            "force": {
                "docstring": "Forces the connection. If the destination is already connected, the old connection is broken and the new one made."
            }, 
            "lock": {
                "docstring": "If the argument is true, the destination attribute is locked after making the connection. If the argument is false, the connection is unlocked before making the connection."
            }, 
            "nextAvailable": {
                "docstring": "If the destination multi-attribute has set the indexMatters to be false with this flag specified, a connection is made to the next available index. No index need be specified."
            }, 
            "referenceDest": {
                "docstring": "This flag is used for file io only. The flag indicates that the connection replaces a connection made in a referenced file, and the flag argument indicates the original destination from the referenced file. This flag is used so that if the reference file is modified, maya can still attempt to make the appropriate connections in the main scene to the referenced object.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "connectControl": {
        "description": "This command attaches a UI widget, specified as the first argument, to one or more dependency node attributes. The attributes/nodes don't have to exist yet, they will get looked up as needed. With no flag specified, this command works on these kinds of controls: floatField, floatScrollBar, floatSlider, intField, intScrollBar, intSlider, floatFieldGrp, intFieldGrp, checkBox, radioCollection, and optionMenu. With the indexflag, It will also work on the individual components of all other groups. This command sets up a two-way connectionbetween the control and the (first-specified) attribute. If this first attribute is changed in any way, the control will be appropriately updated to match its value. Summary: if you change the control, ALL the connected attributes change. If you change the FIRST attribute attached to the control, then the control will change. NOTE: the two-way connection will not be established if the attributes do not exist when the connectControlcommand is run. If the user later uses the control, the connection will be established at that time. To effectively use connectControlwith radioCollections and optionMenus, you must attach a piece of data to each radioButton and menuItem. This piece of data (an integer) can be attached using the dataflag in the radioButtonand menuItemcommands. When the button/item is selected, the attribute will be set to the value of its data. When the attribute is changed, the collection (or optionMenu) will switch to the item that matches the new attribute value. If no item matches, it will be left unchanged. There are some specialized controls that have connection capability (and more) built right into them. See attrFieldSliderGrp, attrFieldGrp, and attrColorSliderGrp. Using these classes can be easier than using connectControl. ", 
        "flags": {
            "fileName": {
                "docstring": "This flag causes the connection to be treated as a filename, and the conversion from internal to external filename representation is made as the data is copied. This only applies to connections to Tfield controls."
            }, 
            "index": {
                "docstring": "This flag enables you to pick out a sub-control from a group that contains a number of different controls. For example, you can connect one field of a floatFieldGrp. You must count each member of the group, including any text labels that may exist. For example, if you have a check box group with a label, the label will count as index 1, and the first check box as index 2. (Indices are 1-based)"
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "connectDynamic": {
        "description": "Dynamic connection specifies that the force fields, emitters, or collisions of an object affect another dynamic object. The dynamic object that is connected to a field, emitter, or collision object is influenced by those fields, emitters and collision objects. Connections are made to individual fields, emitters, collisions. So, if an object owns several fields, if the user wants some of the fields to affect an object, s/he can specify each field with a \"-f\" flag; but if the user wants to connect all the fields owned by an object, s/he can specify the object name with the \"-f\" flag. The same is true for emitters and collisions. Different connection types (i.e., for fields vs. emitters) between the same pair of objects are logically independent. In other words, an object can be influenced by another object's fields without being influenced by its emitters or collisions. Each connected object must be a dynamic object. The object connected to can be any object that owns fields, emitters, etc.; it need not be dynamic. Objects that can own influences are particles, geometry objects (nurbs and polys) and lattices. You can specify either the shape name or the transform name of the object to be influenced. ", 
        "flags": {
            "collisions": {
                "docstring": "Connects each object to the collision models of the given object."
            }, 
            "delete": {
                "docstring": "Deletes existing connections.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "emitters": {
                "docstring": "Connects each object to the emitters of the given object."
            }, 
            "fields": {
                "docstring": "Connects each object to the fields of the given object."
            }
        }
    }, 
    "connectJoint": {
        "description": "This cmd will connect two skeletons based on the selected two joints. The first selected joint can be made a child of the parent of the second selected joint or a child of the second selected joint, depending on the flags used. Note1: The first selected joint must be the root of a skeleton. The second selected joint must have a parent. Note2: If a joint name is specified in the cmd line, it is used as the child and the first selected joint will be the parent. If no joint name is given at the cmd line, two joints must be selected. ", 
        "flags": {
            "connectMode": {
                "docstring": "The first selected joint will be parented under the parent of the second selected joint.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "parentMode": {
                "docstring": "The first selected joint will be parented under the second selected joint. Both joints will be in the active list(selection list)."
            }
        }
    }, 
    "connectionInfo": {
        "description": "The connectionInfocommand is used to get information about connection sources and destinations. Unlike the isConnected command, this command needs only one end of the connection. ", 
        "flags": {
            "destinationFromSource": {
                "docstring": "If the specified plug (or its ancestor) is a source, this flag returns the list of destinations connected from the source. (array of strings, empty array if none)"
            }, 
            "getExactDestination": {
                "docstring": "If the plug or its ancestor is connection destination, this returns the name of the plug that is the exact destination. (empty string if there is no such connection)."
            }, 
            "getExactSource": {
                "docstring": "If the plug or its ancestor is a connection source, this returns the name of the plug that is the exact source. (empty string if there is no such connection)."
            }, 
            "getLockedAncestor": {
                "docstring": "If the specified plug is locked, its name is returned. If an ancestor of the plug is locked, its name is returned. If more than one ancestor is locked, only the name of the closest one is returned. If neither this plug nor any ancestors are locked, an empty string is returned.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "isDestination": {
                "docstring": "Returns true if the plug (or its ancestor) is the destination of a connection, false otherwise."
            }, 
            "isExactDestination": {
                "docstring": "Returns true if the plug is the exact destination of a connection, false otherwise."
            }, 
            "isExactSource": {
                "docstring": "Returns true if the plug is the exact source of a connection, false otherwise."
            }, 
            "isLocked": {
                "docstring": "Returns true if this plug (or its ancestor) is locked"
            }, 
            "isSource": {
                "docstring": "Returns true if the plug (or its ancestor) is the source of a connection, false otherwise."
            }, 
            "sourceFromDestination": {
                "docstring": "If the specified plug (or its ancestor) is a destination, this flag returns the source of the connection. (string, empty if none)"
            }
        }
    }, 
    "constrain": {
        "description": "This command constrains rigid bodies to the world or other rigid bodies. In query mode, return type is based on queried flag.", 
        "flags": {
            "barrier": {
                "docstring": "Creates a barrier constraint. This command requires one rigid bodies."
            }, 
            "damping": {
                "docstring": "Sets the damping constant. Default value: 0.1 Range: -1000.0 to 1000.0"
            }, 
            "directionalHinge": {
                "docstring": "Creates a directional hinge constraint. This command requires two rigid bodies. The directional hinge always maintains the initial direction of its axis."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "hinge": {
                "docstring": "Creates a hinge constraint. This command requires one or two rigid bodies."
            }, 
            "interpenetrate": {
                "docstring": "Allows (or disallows) the rigid bodies defined in the constrain to ipenetrate.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "nail": {
                "docstring": "Creates a nail constraint. This command requires one rigid body."
            }, 
            "name": {
                "docstring": "Names the rigid constraint."
            }, 
            "orientation": {
                "docstring": "Set initial orientation of the constraint in world space. This command is only valid with hinge and barrier constraints Default value: 0.0 0.0 0.0"
            }, 
            "pinConstraint": {
                "docstring": "Creates a pin constraint. This command requires two rigid bodies."
            }, 
            "position": {
                "docstring": "Set initial position of the constraint in world space. Default value: 0.0 0.0 0.0 for uni-constraints, midpoint of bodies for deul constraint."
            }, 
            "query": {
                "docstring": ""
            }, 
            "restLength": {
                "docstring": "Sets the rest length. Default value: 1.0"
            }, 
            "spring": {
                "docstring": "Creates a spring constraint. This command requires one or two rigidies."
            }, 
            "stiffness": {
                "docstring": "Sets the springs stiffness constant. Default value: 5.0"
            }
        }
    }, 
    "constructionHistory": {
        "description": "This command turns construction history on or off. In query mode, return type is based on queried flag.", 
        "flags": {
            "query": {
                "docstring": ""
            }, 
            "toggle": {
                "docstring": "Turns construction history on or off.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "container": {
        "description": "This command can be used to create and query container nodes. It is also used to perform operations on containers such as: add and remove nodes from the containerpublish attributes from nodes inside the containerreplace the connections and values from one container onto another oneremove a container without removing its member nodes", 
        "flags": {
            "addNode": {
                "docstring": "Specifies the list of nodes to add to container."
            }, 
            "asset": {
                "docstring": "When queried, if all the nodes in nodeList belong to the same container, returns container's name. Otherwise returns empty string. This flag is functionally equivalent to the findContainer flag."
            }, 
            "assetMember": {
                "docstring": "Can be used during query in conjunction with the bindAttr flag to query for the only published attributes related to the specified node within the container. "
            }, 
            "bindAttr": {
                "docstring": "Bind a contained attribute to an unbound published name on the interface of the container; returns a list of bound published names. The first string specifies the node and attribute name to be bound in \"node.attr\" format. The second string specifies the name of the unbound published name. In query mode, returns a string array of the published names and their corresponding attributes. The flag can also be used in query mode in conjunction with the -publishName, -publishAsParent, and -publishAsChild flags."
            }, 
            "connectionList": {
                "docstring": "Returns a list of the exterior connections to the container node."
            }, 
            "current": {
                "docstring": "In create mode, specify that the newly created asset should be current. In edit mode, set the selected asset as current. In query, return the current asset."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "fileName": {
                "docstring": "Used to query for the assets associated with a given file name. "
            }, 
            "findContainer": {
                "docstring": "When queried, if all the nodes in nodeList belong to the same container, returns container's name. Otherwise returns empty string. "
            }, 
            "force": {
                "docstring": "This flag can be used in conjunction with -addNode flag only. If specified, then nodes will be disconnected from their current containers before they are added to new one."
            }, 
            "includeHierarchyAbove": {
                "docstring": "Used to specify that the parent hierarchy of the supplied node list should also be included in the container (or deleted from the container). Hierarchy inclusion will stop at nodes which are members of other containers."
            }, 
            "includeHierarchyBelow": {
                "docstring": "Used to specify that the hierarchy below the supplied node list should also be included in the container (or delete from the container). Hierarchy inclusion will stop at nodes which are members of other containers."
            }, 
            "includeNetwork": {
                "docstring": "Used to specify that the node network connected to supplied node list should also be included in the container. Network traversal will stop at default nodes and nodes which are members of other containers."
            }, 
            "includeNetworkDetails": {
                "docstring": "Used to specify specific parts of the network that should be included. Valid arguments to this flag are: \"channels\", \"sdk\", \"constraints\", \"history\" and \"expressions\", \"inputs\", \"outputs\". The difference between this flag and the includeNetwork flag, is that it will include all connected nodes regardless of their type. Note that dag containers include their children, so they will always include constraint nodes that are parented beneath the selected objects, even when constraints are not specified as an input."
            }, 
            "includeShaders": {
                "docstring": "Used to specify that for any shapes included, their shaders will also be included in the container."
            }, 
            "includeShapes": {
                "docstring": "Used to specify that for any transforms selected, their direct child shapes will be included in the container (or deleted from the container). This flag is not necessary when includeHierarchyBelow is used since the child shapes and all other descendents will automatically be included."
            }, 
            "includeTransform": {
                "docstring": "Used to specify that for any shapes selected, their parent transform will be included in the container (or deleted from the container). This flag is not necessary when includeHierarchyAbove is used since the parent transform and all of its parents will automatically be included."
            }, 
            "isContainer": {
                "docstring": "Return true if the selected or specified node is a container node. If multiple containers are queried, only the state of the first will be returned.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "Sets the name of the newly-created container."
            }, 
            "nodeList": {
                "docstring": "When queried, returns a list of nodes in container."
            }, 
            "nodeNamePrefix": {
                "docstring": "Specifies that the name of published attributes should be of the form \"node_attr\". Must be used with the -publishConnections/-pc flag."
            }, 
            "parentContainer": {
                "docstring": "Flag to query the parent container of a specified container."
            }, 
            "preview": {
                "docstring": "This flag is valid in create mode only. It indicates that you do not want the container to be created, instead you want to preview its contents. When this flag is used, Maya will select the nodes that would be put in the container if you did create the container. For example you can see what would go into the container with -includeNetwork, then modify your selection as desired, and do a create container with the selected objects only."
            }, 
            "publishAndBind": {
                "docstring": "Publish the given name and bind the attribute to the given name. First string specifies the node and attribute name in \"node.attr\" format. Second string specifies the name it should be published with."
            }, 
            "publishAsChild": {
                "docstring": "Publish contained node to the interface of the container to indicate it can be a child of external nodes. The second string is the name of the published node. In query mode, returns a string of the published names and the corresponding nodes. If -publishName flag is used in query mode, only returns the published names; if -bindAttr flag is used in query mode, only returns the name of the published nodes."
            }, 
            "publishAsParent": {
                "docstring": "Publish contained node to the interface of the container to indicate it can be a parent to external nodes. The second string is the name of the published node. In query mode, returns a string of array of the published names and the corresponding nodes. If -publishName flag is used in query mode, only returns the published names; if -bindAttr flag is used in query mode, only returns the name of the published nodes."
            }, 
            "publishAsRoot": {
                "docstring": "Publish or unpublish a node as a root. The significance of root transform node is twofold. When container-centric selection is enabled, the root transform will be selected if a container node in the hierarchy below it is selected in the main scene view. Also, when exporting a container proxy, any published root transformation attributes such as translate, rotate or scale will be hooked up to attributes on a stand-in node. In query mode, returns the node that has been published as root."
            }, 
            "publishAttr": {
                "docstring": "In query mode, can only be used with the -publishName(-pn) flag, and takes an attribute as an argument; returns the published name of the attribute, if any. "
            }, 
            "publishConnections": {
                "docstring": "Publish all connections from nodes inside the container to nodes outside the container."
            }, 
            "publishName": {
                "docstring": "Publish a name to the interface of the container, and returns the actual name published to the interface. In query mode, returns the published names for the container. If the -bindAttr flag is specified, returns only the names that are bound; if the -unbindAttr flag is specified, returns only the names that are not bound; if the -publishAsParent/-publishAsChild flags are specified, returns only names of published parents/children. if the -publishAttr is specified with an attribute argument in the \"node.attr\" format, returns the published name for that attribute, if any."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeContainer": {
                "docstring": "Disconnects all the nodes from container and deletes container node."
            }, 
            "removeNode": {
                "docstring": "Specifies the list of nodes to remove from container."
            }, 
            "type": {
                "docstring": "By default, a container node will be created. Alternatively, the type flag can be used to indicate that a different type of container should be created. At the present time, the only other valid type of container node is \"dagContainer\"."
            }, 
            "unbindAndUnpublish": {
                "docstring": "Unbind the given attribute (in \"node.attr\" format) and unpublish its associated name. Unbinding a compound may trigger unbinds of its compound parents/children. So the advantage of using this one flag is that it will automatically unpublish the names associated with these automatic unbinds."
            }, 
            "unbindAttr": {
                "docstring": "Unbind a published attribute from its published name on the interface of the container, leaving an unbound published name on the interface of the container; returns a list of unbound published names. The first string specifies the node and attribute name to be unbound in \"node.attr\" format, and the second string specifies the name of the bound published name. In query mode, can only be used with the -publishName, -publishAsParent and -publishAsChild flags."
            }, 
            "unbindChild": {
                "docstring": "Unbind the node published as child, but do not remove its published name from the interface of the container."
            }, 
            "unbindParent": {
                "docstring": "Unbind the node published as parent, but do not remove its published name from the interface of the container."
            }, 
            "unpublishChild": {
                "docstring": "Unpublish node published as child from the interface of the container"
            }, 
            "unpublishName": {
                "docstring": "Unpublish an unbound name from the interface of the container."
            }, 
            "unpublishParent": {
                "docstring": "Unpublish node published as parent from the interface of the container"
            }, 
            "unsortedOrder": {
                "docstring": "The -nodeList/-nl flag will return a sorted list of nodes. This flag can be used to get the nodes in the order they were added to the container. This will also display any reordering done with the reorderContainer command."
            }
        }
    }, 
    "containerBind": {
        "description": "This is an accessory command to the container command which is used for some automated binding operations on the container. A container's published interface can be bound using a bindingSet on the associated container template. ", 
        "flags": {
            "allNames": {
                "docstring": "Specifies that all published names on the container should be considered during the binding operation. By default only unbound published names will be operated on. Additionally specifying the 'force' option with 'all' will cause all previously bound published names to be reset (or unbound) before the binding operation is performed; in the event that there is no appropriate binding found for the published name, it will be left in the unbound state."
            }, 
            "bindingSet": {
                "docstring": "Specifies the name of the template binding set to use for the bind or query operation. This flag is not available in query mode. "
            }, 
            "bindingSetConditions": {
                "docstring": "Used in query mode, returns a list of binding set condition entries from the specified template binding set. The list returned is composed of of all published name / condition string pairs for each entry in the binding set. This flag returns all entries in the associated binding set and does not take into account the validity of each entry with respect to the container's list of published names, bound or unbound state, etc.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "bindingSetList": {
                "docstring": "Used in query mode, returns a list of available binding sets that are defined on the associated container template."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "force": {
                "docstring": "This flag is used to force certain operations to proceed that would normally not be performed."
            }, 
            "preview": {
                "docstring": "This flag will provide a preview of the results of a binding operation but will not actually perform it. A list of publishedName/boundName pairs are returned for each published name that would be affected by the binding action. If the binding of a published name will not change as a result of the action it will not be listed. Published names that were bound but will become unbound are also listed, in this case the associated boundName will be indicated by an empty string."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "containerProxy": {
        "description": "Creates a new container with the same published interface, dynamic attributes and attribute values as the specified container but with fewer container members. This proxy container can be used as a reference proxy so that values can be set on container attributes without loading in the full container. The proxy container will contain one or more locator nodes. The first locator has dynamic attributes that serve as stand-ins for the original published attributes. The remaining locators serve as stand-ins for any dag nodes that have been published as parent or as child and will be placed at the world space location of the published parent/child nodes. The expected usage of container proxies is to serve as a reference proxy for a referenced container. For automated creation, export and setup of the proxy see the doExportContainerProxy.mel script which is invoked by the \"Export Container Proxy\" menu item. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "fromTemplate": {
                "docstring": "Specifies the name of a template file which will be used to create the new container proxy. Stand-in attributes will be created and published for all the numeric attributes on the proxy."
            }, 
            "query": {
                "docstring": ""
            }, 
            "type": {
                "docstring": "Specifies the type of container node to use for the proxy. This flag is only valid in conjunction with the fromTemplate flag. When creating a proxy for an existing container, the type created will always be identical to that of the source container. The default value for this flag is 'container'.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "containerPublish": {
        "description": "This is an accessory command to the container command which is used for some advanced publishing operations on the container. For example, the \"publishConnections\" flag on the container will publish all the connections, but this command can be used to publish just the inputs, outputs, or to collapse the shared inputs into a single attribute before publishing. ", 
        "flags": {
            "bindNode": {
                "docstring": "Bind the specified node to the published node name."
            }, 
            "bindTemplateStandins": {
                "docstring": "This flag will create a temporary stand-in attribute for any attributes that exist in the template but are not already bound. This enables you to set values for unbound attributes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "inConnections": {
                "docstring": "Specifies that the unpublished connections to nodes in the container from external nodes should be published."
            }, 
            "mergeShared": {
                "docstring": "For use with the inConnections flag. Indicates that when an external attribute connects to multiple internal attributes within the container, a single published attribute should be used to correspond to all of the internal attributes."
            }, 
            "outConnections": {
                "docstring": "Specifies that the unpublished connections from nodes in the container to external nodes should be published."
            }, 
            "publishNode": {
                "docstring": "Publish a name and type. When first published, nothing will be bound. To bind a node to the published name, use the bindNode flag."
            }, 
            "query": {
                "docstring": ""
            }, 
            "unbindNode": {
                "docstring": "Unbind the node that is published with the name specified by the flag."
            }, 
            "unpublishNode": {
                "docstring": "Unpublish the specified published node name."
            }
        }
    }, 
    "containerTemplate": {
        "description": "A container template is a description of a container's published interface. This command provides the ability to create and save a template file for a container or load an existing template file. Once a template exists, the user can query the template information. In query mode, return type is based on queried flag.", 
        "flags": {
            "addBindingSet": {
                "docstring": "This argument is used to add a new binding set with the given name to a template. A default binding set will be created. If the binding set already exists, the force flag must be used to replace the existing binding set. When used with the fromContainer option, default bindings will be entered based on the current bindings of the designated container. When used without a reference container, the binding set will be made with placeholder entries. The template must be saved before the new binding set is permanently stored with the template file."
            }, 
            "addNames": {
                "docstring": "In edit mode, when used with the fromContainer flag, any published name on the container not present as an attribute on the template will be added to the template."
            }, 
            "addView": {
                "docstring": "This argument is used to add a new view with the given name to a template. By default a view containing a flat list of all template attributes will be created. The layoutMode flag provides more layout options. The template must be saved before the new view is permanently stored with the template file."
            }, 
            "allKeyable": {
                "docstring": "Used when the fromSelection flag is true and fromContainer is false. If true we will use all keyable attributes to define the template or the view, if false we use the attributes passed in with the attribute flag."
            }, 
            "attribute": {
                "docstring": "If fromSelection is true and allKeyable is false, this attribute name will be used to create an attribute item in the template file."
            }, 
            "attributeList": {
                "docstring": "Used in query mode, returns a list of attributes contained in the template definition."
            }, 
            "baseName": {
                "docstring": "Used in query mode, returns the base name of the template. The basename is the template name with any package qualifiers stripped off."
            }, 
            "bindingSetList": {
                "docstring": "Used in query mode, returns a list of all binding sets defined on the template."
            }, 
            "childAnchor": {
                "docstring": "This flag can be optionally specified when querying the publishedNodeList. The resulting list will contain only childAnchor published nodes."
            }, 
            "delete": {
                "docstring": "Delete the specified template and its file. All objects that are associated with this template or contained in the same template file will be deleted. To simply unload a template without permanently deleting its file, use unload instead."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified template exists. When used with the matchFile argument, the query will return true if the template exists and the filename it was loaded from matches the filename given."
            }, 
            "expandCompounds": {
                "docstring": "This argument is used to determine how compound parent attributes and their children will be added to generated views when both are published to the container. When true, the compound parent and all compound child attributes published to the container will be included in the view. When false, only the parent attribute is included in the view. Note: if only the child attributes are published and not the parent, the children will be included in the view, this flag is only used in the situation where both parent and child attributes are published to the container. The default value is false."
            }, 
            "fileName": {
                "docstring": "Specifies the filename associated with the template. This argument can be used in conjunction with load, save or query modes. If no filename is associated with a template, a default file name based on the template name will be used. It is recommended but not required that the filename and template name correspond."
            }, 
            "force": {
                "docstring": "This flag is used with some actions to allow them to proceed with an overwrite or destructive operation. When used with load, it will allow an existing template to be reloaded from a file. When used in create mode, it will allow an existing template to be recreated (for example when using fromContainer argument to regenerate a template)."
            }, 
            "fromContainer": {
                "docstring": "This argument is used in create or edit mode to specify a container node to be used for generating the template contents. In template creation mode, the template definition will be created based on the list of published attributes in the specified container. In edit mode, when used with the addNames flag or with no other flag, any published name on the container not present as an attribute on the template will be added to the template. This flag is also used in conjunction with flags such as addView."
            }, 
            "fromSelection": {
                "docstring": "If true, we will use the active selection list to create the template or the view. If allKeyable is also true then we will create the template from all keyable attributes in the selection, otherwise we will create the template using the attributes specified with the attribute flag."
            }, 
            "layoutMode": {
                "docstring": "This argument is used to specify the layout mode when creating a view. Values correspond as follows: 0: layout in flat list (default when not creating view from container) 1: layout grouped by node (default if creating view from container) The fromContainer or fromSelection argument is required to provide the reference container or selection for layout modes that require node information. Note that views can only refer to defined template attributes. This means that when using the fromContainer or from Selection flag to add a view to an existing template, only attributes that are defined on both the template and the container or the current selection will be included in the view (i.e. published attributes on the container that are not defined in the template will be ignored)."
            }, 
            "load": {
                "docstring": "Load an existing template from a file. If a filename is specified for the template, the entire file (and all templates in it) will be loaded. If no file is specified, a default filename will be assumed, based on the template name."
            }, 
            "matchFile": {
                "docstring": "Used in query mode in conjunction with other flags this flag specifies an optional file name that is to be matched as part of the query operation. "
            }, 
            "matchName": {
                "docstring": "Used in query mode in conjunction with other flags this flag specifies an optional template name that is to be matched as part of the query operation. The base template name is used for matching, any template with the same basename will be matched even across different packages. "
            }, 
            "parentAnchor": {
                "docstring": "This flag can be optionally specified when querying the publishedNodeList. The resulting list will contain only parentAnchor published nodes."
            }, 
            "publishedNodeList": {
                "docstring": "Used in query mode, returns a list of published nodes contained in the template definition. By default all published nodes on the template will be returned. The list of published nodes can be limited to only include certain types of published nodes using one of the childAnchor, parentAnchor or rootTransform flags. If an optional flag is are specified, only nodes of the specified type will be returned."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeBindingSet": {
                "docstring": "This argument is used to remove the named binding set from the template. The template must be saved before the binding set is permanently removed from the template file."
            }, 
            "removeView": {
                "docstring": "This argument is used to remove the named view from the template. The template must be saved before the view is permanently removed from the template file."
            }, 
            "rootTransform": {
                "docstring": "This flag can be optionally specified when querying the publishedNodeList. The resulting list will contain only rootTransform published nodes."
            }, 
            "save": {
                "docstring": "Save the specified template to a file. If a filename is specified for the template, the entire file (and all templates associated with it) will be saved. If no file name is specified, a default filename will be assumed, based on the template name."
            }, 
            "searchPath": {
                "docstring": "The template searchPath is an ordered list of all locations that are being searched to locate template files (first location searched to last location searched). The template search path setting is stored in the current workspace and can also be set and queried as the file rule entry for 'templates' (see the workspace command for more information). In edit mode, this flag allows the search path setting to be customized. When setting the search path value, the list should conform to a path list format expected on the current platform. This means that paths should be separated by a semicolon (;) on Windows and a colon (:) on Linux and MacOSX. Environment variables can also be used. Additional built-in paths may be added automatically by maya to the customized settings. In query mode, this flag returns the current contents of the search path; all paths, both customized and built-in, will be included in the query return value."
            }, 
            "silent": {
                "docstring": "Silent mode will suppress any error or warning messages that would normally be reported from the command execution. The return values are unaffected."
            }, 
            "templateList": {
                "docstring": "Used in query mode, returns a list of all loaded templates. This query can be used with optional matchFile and matchName flags. When used with the matchFile flag, the list of templates will be restricted to those associated with the specified file. When used with the matchName flag, the list of templates will be restricted to those matching the specified template name."
            }, 
            "unload": {
                "docstring": "Unload the specified template. This action will not delete the associated template file if one exists, it merely removes the template definition from the current session."
            }, 
            "updateBindingSet": {
                "docstring": "This argument is used to update an existing binding set with new bindings. When used with the fromContainer argument binding set entries with be replaced or merged in the binding set based on the bindings of the designated container. If the force flag is used, existing entries in the binding set are replaced with new values. When force is not used, only new entries are merged into the binding set, any existing entries will be left as-is. When used without a reference container, the binding set will be updated with placeholder entries. The template must be saved before the new binding set is permanently stored with the template file."
            }, 
            "useHierarchy": {
                "docstring": "If true, and the fromSelection flag is set, the selection list will expand to include it's hierarchy also."
            }, 
            "viewList": {
                "docstring": "Used in query mode, returns a list of all views defined on the template.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "containerView": {
        "description": "A container view defines the layout information for the published attributes of a particular container. Container views can be selected from a set of built-in views or may be defined on an associated container template. This command queries the view-related information for a container node. The information returned from this command will be based on the view-related settings in force on the container node at the time of the query (i.e. the container's view mode, template name, view name attributes). In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "itemInfo": {
                "docstring": "Used in query mode in conjunction with the itemList flag. The command will return a list of information for each item in the view, the information fields returned for each item are determined by this argument value. The information fields will be listed in the string array returned. The order in which the keyword is specified will determine the order in which the data will be returned by the command. One or more of the following keywords, separated by colons ':' are used to specify the argument value. itemIndex : sequential item number (0-based)itemName : item name (string)itemLabel : item display label (string)itemDescription : item description field (string)itemLevel : item hierarchy level (0-n)itemIsGroup : (boolean 0 or 1) indicates whether or not this item is a groupitemIsAttribute : (boolean 0 or 1) indicates whether or not this item is an attributeitemNumChildren: number of immediate children (groups or attributes) of this itemitemAttrType : item attribute type (string)itemCallback : item callback field (string)"
            }, 
            "itemList": {
                "docstring": "Used in query mode, the command will return a list of information for each item in the view. The viewName flag is used to select the view to query. The information returned about each item is determined by the itemInfo argument value. For efficiency, it is best to query all necessary item information at one time (to avoid recomputing the view information on each call)."
            }, 
            "query": {
                "docstring": ""
            }, 
            "viewDescription": {
                "docstring": "Used in query mode, returns the description field associated with the selected view. If no description was defined for this view, the value will be empty."
            }, 
            "viewLabel": {
                "docstring": "Used in query mode, returns the display label associated with the view. An appropriate label suitable for the user interface will be returned based on the selected view. Use of the view label is usually more suitable than the view name for display purposes."
            }, 
            "viewList": {
                "docstring": "Used in query mode, command will return a list of all views defined for the given target (container or template)."
            }, 
            "viewName": {
                "docstring": "Used in query mode, specifies the name of the queried view when used in conjunction with a template target. When used in conjunction with a container target, it requires no string argument, and returns the name of the currently active view associated with the container; this value may be empty if the current view is not a valid template view or is generated by one of the built-in views modes. For this reason, the view label is generally more suitable for display purposes. In query mode, this flag can accept a value.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "contextInfo": {
        "description": "This command allows you to get information on named contexts. ", 
        "flags": {
            "apiImage1": {
                "docstring": ""
            }, 
            "c": {
                "docstring": "Return the class type of the named context."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "escapeContext": {
                "docstring": "Return the command string that will allow you to exit the current tool."
            }, 
            "exists": {
                "docstring": "Return true if the context exists, false if it does not exists (or is internal and therefore untouchable)"
            }, 
            "image1": {
                "docstring": "Returns the name of an xpm associated with the named context."
            }, 
            "image2": {
                "docstring": "Returns the name of an xpm associated with the named context."
            }, 
            "image3": {
                "docstring": "Returns the name of an xpm associated with the named context.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "title": {
                "docstring": "Return the title string of the named context."
            }
        }
    }, 
    "control": {
        "description": "This command allows you to edit or query the properties of any control. In query mode, return type is based on queried flag.", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parentsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "convertIffToPsd": {
        "description": "Converts iff file to PSD file of given size In query mode, return type is based on queried flag.", 
        "flags": {
            "iffFileName": {
                "docstring": "Input iff file name"
            }, 
            "psdFileName": {
                "docstring": "Output file nameFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "xResolution": {
                "docstring": "X resolution of the image"
            }, 
            "yResolution": {
                "docstring": "Y resolution of the image"
            }
        }
    }, 
    "convertSolidTx": {
        "description": "Command to convert a texture on a surface to a file texture. The first argument is a rendering node or attribute. If only the node is specified, the outColor attribute will be sampled. If the node does not have an outColor attribute, the first attribute on the node which is: readable, not writable, not hidden, connectable, and not a multi is used. If lighting is to be baked, a shading group must be specified as the texture. The current selection will be used if a texture and surface are not specified. An image file will be generated for each object and stored in your image segment of your project. The filename will be formatted using the texture and surface names as follows: However, if force is off and there is a name collision a version number will be determined and the filename will be formatted as follows: ", 
        "flags": {
            "alpha": {
                "docstring": "Specify whether to compute the transparency when baking lighting. The conversion will sample both the color and transparency of the shading network; the alpha channel of the file texture will be set to correspond to the result from sampling the transparency. By default transparency is not computed."
            }, 
            "antiAlias": {
                "docstring": "Perform anti-aliasing on the resulting image. Convert solid texture will generally take four times longer than without anti-aliasing. By default this flag is off."
            }, 
            "backgroundColor": {
                "docstring": "Set the background color to a specific value. Default is to use the shader default color to fill the background. Valid values range from 0 to 255 if the pixel format is 8 bits per channel, or 0 to 65535 if the pixel format is 16 bits per channel. This flag automatically sets -backgroundMode to \"color\".Default is black: 0 0 0."
            }, 
            "backgroundMode": {
                "docstring": "Defines how the background of the texture should be filled. Three modes are available:\"shader\"or 1: uses the default shader color.\"color\"or 2: uses the color given by -backgroundColor flag.\"extend\"or 3: extends outwards the color along the seam edges.Default is \"shader\"."
            }, 
            "camera": {
                "docstring": "Specify a camera to use in baking lighting. If a camera is not specified the camera in the active view will be used."
            }, 
            "componentRange": {
                "docstring": "If one or more components have been selected to use, then if this flag is set, then the uv range of the components is used to fit into the texture map resolution. By default this flag is set to false."
            }, 
            "doubleSided": {
                "docstring": "Specify whether the sampler should flip the surface normal if the sample point faces away from the camera. Note: flipping the normal will make the result dependent on the camera (ie. one camera may flip normals where different camera wouldn't). It's not recommended that doubleSided be used in combination with shadows. By default this flag is false."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "fileFormat": {
                "docstring": "File format to be used for output. IFF is the default if unspecified. Other valid formats are: als: Alias PIXcin: Cineoneps: EPSgif: GIFiff: Maya IFFjpg: JPEGyuv: Quantelrla: Wavefront RLAsgi: SGIsi: SoftImage (.pic)tga: Targatif: TIFFbmp: Windows Bitmap"
            }, 
            "fileImageName": {
                "docstring": "Specify the output path and name of file texture image. If the file name doesn't contain a directory separator, the image will be written to source images of the current project. The file will not be versioned if it already exists."
            }, 
            "fillTextureSeams": {
                "docstring": "Specify whether or not to overscan the polygon beyond its outer edges, when creating the file texture, in order to fill the texture seams.Default is true."
            }, 
            "force": {
                "docstring": "If the output image already exists overwrite it. By default this flag is off."
            }, 
            "fullUvRange": {
                "docstring": "Sample using the full uv range of the surface. This flag cannot be used with the -uvr flag. A 2D texture placement node will be created and connected to the file texture. The placement's translate and coverage will be set according to the full UV range of the surface."
            }, 
            "name": {
                "docstring": "Set the name of the file texture node. Name conflict resolution will be used to determine valid names when multiple objects are specified."
            }, 
            "pixelFormat": {
                "docstring": "Specifies the pixel format of the image. Note that not all file formats support all pixel formats. Available options:\"8\": 8 bits per channel, unsigned (0-255)\"16\": 16 bits per channel, unsigned (0-65535)Default is \"8\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "resolutionX": {
                "docstring": "Set the horizontal image resolution. If this flag is not specified, the resolution will be set to 256."
            }, 
            "resolutionY": {
                "docstring": "Set the vertical image resolution. If this flag is not specified, the resolution will be set to 256."
            }, 
            "reuseDepthMap": {
                "docstring": "Specify whether or not to reuse all the generated dmaps.Default is false."
            }, 
            "samplePlane": {
                "docstring": "Specify whether to sample using a virtual plane. This virtual plane has texture coordinates in the rectangle defined by the -samplePlaneRange flag. If the -samplePlaneRange flag is not set then the virtual plane defaults to having texture coordinates in the (0,0) to (1,1) square. If this option is set than all surface based arguments will be ignored."
            }, 
            "samplePlaneRange": {
                "docstring": "Specify the uv range of the texture coordinates used to sample if the -samplePlane option is set. There are four arguments corresponding to uMin, uMax, vMin and vMax. By default the virtual plane is from uMin 0 to uMax 1, and vMin 0 to vMax 1."
            }, 
            "shadows": {
                "docstring": "Specify whether to compute shadows when baking lighting. Disk based shadow maps will be used. Only lights with depth map shadows enabled will contribute to the shading. By default shadows are not computed."
            }, 
            "uvBBoxIntersect": {
                "docstring": "This flag is obsolete."
            }, 
            "uvRange": {
                "docstring": "Specify the uv range in which samples will be computed. There are four arguments corresponding to uMin, uMax, vMin and vMax. Each value should be specified based on the surface's uv space. A 2D texture placement node will be created and connected to the file texture. The placement's frame translate and coverage will be set according to the uv range specified. By default the entire uv range of the surface will be used."
            }, 
            "uvSetName": {
                "docstring": "Specify which uv set has to be used as the driving parametrization for convert solid."
            }
        }
    }, 
    "convertTessellation": {
        "description": "Command to translate the basic tessellation attributes to advanced. If a camera flag is specified the translation will be based on the distance the surface is from the camera. The closer the surface is to the camera the more triangles there will be in the tessellation. If the \"-allCameras\" flags is specified, the renderable camera closest to the surface will be used to set the tessellation. The camera tessellation estimate is also dependent on the current render resolution; a higher resolution the result in a more finely tessellated surface. Multiple NURB surfaces may be specified on the command line, or if no command arguments are specified the surfaces on the active list will be used. This command operates by calculating the chord height such that smooth tessellation is achieved when the surface is rendered. The advanced tessellation setting will be enabled on each surface specified, the primary tessellation parameters will be set, and chord height will be used as the secondary criteria. ", 
        "flags": {
            "allCameras": {
                "docstring": "Specifies that all renderable cameras should be used in calculating the screen based tessellation.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "camera": {
                "docstring": "Specifies the camera which should be used in calculating the screen based tessellation."
            }
        }
    }, 
    "convertUnit": {
        "description": "This command converts values between different units of measure. The command takes a string, because a string can incorporate unit names as well as values (see examples). ", 
        "flags": {
            "fromUnit": {
                "docstring": "The unit to convert from. If not supplied, it is assumed to be the system default. The from unit may also be supplied as part of the value e.g. 11.2m (11.2 meters)."
            }, 
            "toUnit": {
                "docstring": "The unit to convert to. If not supplied, it is assumed to be the system defaultFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "copyAttr": {
        "description": "Given two nodes, transfer the connections and/or the values from the first node to the second for all attributes whose names and data types match. When values are transferred, they are transferred directly. They are not mapped or modified in any way. The transferAttributes command can be used to transfer and remap some mesh attributes. The attributes flag can be used to specify a list of attributes to be processed. If the attributes flag is unused, all attributes will be processed. For dynamic attributes, the values and/or connections will only be transferred if the attributes names on both nodes match. This command does not support geometry shape nodes such as meshes, subds and nurbs. This command does not support transfer of multi-attribute values such as weight arrays. ", 
        "flags": {
            "attribute": {
                "docstring": "The name of the attribute(s) for which connections and/or values will be transferred. If no attributes are specified, then all attributes will be transferred."
            }, 
            "containerParentChild": {
                "docstring": "For use when copying from one container to another only. This option indicates that the published parent and/or child relationships on the original container should be transferred to the target container if the published names match.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "inConnections": {
                "docstring": "Indicates that incoming connections should be transferred."
            }, 
            "keepSourceConnections": {
                "docstring": "For use with the outConnections flag only. Indicates that the connections should be maintained on the first node, in addition to making them to the second node. If outConnections is used and keepSourceConnections is not used, the out connections on the source node will be broken and made to the target node."
            }, 
            "outConnections": {
                "docstring": "Indicates that outgoing connections should be transferred."
            }, 
            "query": {
                "docstring": ""
            }, 
            "renameTargetContainer": {
                "docstring": "For use when copying from one container to another only. This option will rename the target container to the name of the original container, and rename the original container to its old name + \"Orig\". You would want to use this option if your original container was referenced and edited, and you want those edits from the main scene to now apply to the new container."
            }, 
            "values": {
                "docstring": "Indicates that values should be transferred."
            }
        }
    }, 
    "copyDeformerWeights": {
        "description": "Command to copy or mirror the deformer weights accross one of the three major axes. The command can be used to mirror weights either from one surface to another or within the same surface. ", 
        "flags": {
            "destinationDeformer": {
                "docstring": "Specify the deformer used by the destination shape"
            }, 
            "destinationShape": {
                "docstring": "Specify the destination deformed shape"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "mirrorInverse": {
                "docstring": "Values are mirrored from the positive side to the negative. If this flag is used then the direction is inverted."
            }, 
            "mirrorMode": {
                "docstring": "The mirrorMode flag defines the plane of mirroring (XY, YZ, or XZ) when the mirror flag is used. The default plane is XY."
            }, 
            "noMirror": {
                "docstring": "When the no mirror flag is used, the weights are copied instead of mirrored."
            }, 
            "query": {
                "docstring": ""
            }, 
            "smooth": {
                "docstring": "When the smooth flag is used, the weights are smoothly interpolated between the closest vertices, instead of assigned from the single closest."
            }, 
            "sourceDeformer": {
                "docstring": "Specify the deformer whose weights should be mirrored. When queried, returns the deformers used by the source shapes."
            }, 
            "sourceShape": {
                "docstring": "Specify the source deformed shape"
            }, 
            "surfaceAssociation": {
                "docstring": "The surfaceAssociation flag controls how the weights are transferred between the surfaces: \"closestPoint\", \"rayCast\", or \"closestComponent\". The default is closestComponent."
            }, 
            "uvSpace": {
                "docstring": "The uvSpace flag indicates that the weight transfer should occur in UV space, based on the source and destination UV sets specified.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "copyFlexor": {
        "description": "This command copies an existing bone or joint flexor from one bone (joint) to another. The attributes of the flexor and their connections as well as any tweaks in on the latticeFfd are copied from the original to the new flexor. If the selected bone (joint) appears to be a mirror reflection of the bone (joint) of the existing flexor then the transform of the ffd lattice group gets reflected to the new bone (joint). The arguments for the command are the name of the ffd Lattice and the name of the destination joint. If they are not specified at the command line, they will be picked up from the current selection list. ", 
        "flags": {}
    }, 
    "copyKey": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.This command copies curve segments's hierarchies from specified targets and puts them in the clipboard. Source curves are unchanged. The pasteKey command applies these curves to other objects.The shape of the copied curve placed in the clipboard depends on the copyKey \"-option\" specified. Each of these options below will be explained using an example. For all the explanations, let us assume that the source animation curve (from which keys will be copied) has 5 keyframes at times 10, 15, 20, 25, and 30. copyKey -t \"12:22\" -option keysA 5-frame animation curve with one key at 15 and another key at 20 is placed into the keyset clipboard.copyKey -t \"12:22\" -option curveA 10-frame animation is placed into the clipboard. The curve contains the original source-curve keys at times 15 and 20, as well as new keys inserted at times 12 and 22 to preserve the shape of the curve at the given time segment.TbaseKeySetCmd.h ", 
        "flags": {
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "clipboard": {
                "docstring": "Specifies the clipboard to which animation is copied. Valid clipboards are \"api\" and \"anim\". The default clipboard is: anim"
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "forceIndependentEulerAngles": {
                "docstring": "Specifies that the rotation curves should always be placed on the clipboard as independent Euler Angles. The default value is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "option": {
                "docstring": "The option to use when performing the copyKey operation. Valid options are \"keys,\" and \"curve.\" The default copy option is: keys"
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }
        }
    }, 
    "copyNode": {
        "description": "", 
        "flags": {}
    }, 
    "copySkinWeights": {
        "description": "Command to copy or mirror the skinCluster weights accross one of the three major axes. The command can be used to mirror weights either from one surface to another or within the same surface. In query mode, return type is based on queried flag.", 
        "flags": {
            "destinationSkin": {
                "docstring": "Specify the destination skin shape"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "influenceAssociation": {
                "docstring": "The influenceAssociation flag controls how the influences on the source and target skins are matched up. The flag can be included multiple times to specify multiple association schemes that will be invoked one after the other until all influences have been matched up. Supported values are \"closestJoint\", \"closestBone\", \"label\", \"name\", \"oneToOne\". The default is closestJoint."
            }, 
            "mirrorInverse": {
                "docstring": "Values are mirrored from the positive side to the negative. If this flag is used then the direction is inverted."
            }, 
            "mirrorMode": {
                "docstring": "The mirrorMode flag defines the plane of mirroring (XY, YZ, or XZ) when the mirror flag is used. The default plane is XY."
            }, 
            "noBlendWeight": {
                "docstring": "When the no blend flag is used, the blend weights on the skin cluster will not be copied across to the destination.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "noMirror": {
                "docstring": "When the no mirror flag is used, the weights are copied instead of mirrored."
            }, 
            "normalize": {
                "docstring": "Normalize the skin weights."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sampleSpace": {
                "docstring": "Selects which space the attribute transfer is performed in. 0 is world space, 1 is model space. The default is world space."
            }, 
            "smooth": {
                "docstring": "When the smooth flag is used, the weights are smoothly interpolated between the closest vertices, instead of assigned from the single closest."
            }, 
            "sourceSkin": {
                "docstring": "Specify the source skin shape"
            }, 
            "surfaceAssociation": {
                "docstring": "The surfaceAssociation flag controls how the weights are transferred between the surfaces: \"closestPoint\", \"rayCast\", or \"closestComponent\". The default is closestComponent."
            }, 
            "uvSpace": {
                "docstring": "The uvSpace flag indicates that the weight transfer should occur in UV space, based on the source and destination UV sets specified."
            }
        }
    }, 
    "createAttrPatterns": {
        "description": "Create a new instance of an attribute pattern given a pattern type (e.g. XML) and a string or data file containing the description of the attribute tree in the pattern's format. ", 
        "flags": {
            "patternDefinition": {
                "docstring": "Hardcoded string containing the pattern definition, for simpler formats that don't really need a separate file for definition.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "patternFile": {
                "docstring": "File where the pattern information can be found"
            }, 
            "patternType": {
                "docstring": "Name of the pattern definition type to use in creating this instance of the pattern."
            }
        }
    }, 
    "createDisplayLayer": {
        "description": "Create a new display layer. The display layer number will be assigned based on the first unassigned number not less than the base index number found in the display layer global parameters. Normally all objects and their descendants will be added to the new display layer but if the '-nr' flag is specified then only the objects themselves will be added. ", 
        "flags": {
            "empty": {
                "docstring": "If set then create an empty display layer. ie. Do not add the selected items to the new display layer."
            }, 
            "makeCurrent": {
                "docstring": "If set then make the new display layer the current one."
            }, 
            "name": {
                "docstring": "Name of the new display layer being created."
            }, 
            "noRecurse": {
                "docstring": "If set then only add selected objects to the display layer. Otherwise all descendants of the selected objects will also be added."
            }, 
            "number": {
                "docstring": "Number for the new display layer being created.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "createEditor": {
        "description": "This command creates a property sheet for any dependency node. The second argument is the name of the node, and the first is the name of a layout into which the property sheet controls should be placed. The property sheets created by this command can by user-customized using the editorTemplatecommand. ", 
        "flags": {
            "queueForDelete": {
                "docstring": "The specified layout is put on a queue. When the queue is full, layouts past the end of the queue are automatically deleted. If the layout is already on the queue, it is moved to the front. This allows us to dispose of editors when they are no longer being used. This flag should only be used by the showEditor.mel script.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "createLayeredPsdFile": {
        "description": "Creates a layered PSD file with image names as input to individual layers ", 
        "flags": {
            "imageFileName": {
                "docstring": "Layer name, blend mode, Image file name The image in the file will be transferred to layer specified. The image file specified can be in any of the formats supported by maya (ex. iff, jpg, gif, tif etc.). The blend mode options are : \"Normal\", \"Dissolve\", \"Dark\", \"Multiply\", \"Color Burn\", \"Linear Burn\", \"Lighten\", \"Screen\", \"Color Dodge\", \"Linear Dogde\", \"Overlay\", \"Soft Light\", \"Hard Light\", \"Dissolve\", \"Vivid Light\", \"Linear Light\", \"Pin Light\", \"Hard Mix\", \"Difference\", \"Exclusion\", \"Hue\", \"Saturation\", \"Color\", \"Luminosity\""
            }, 
            "psdFileName": {
                "docstring": "PSD file name.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "xResolution": {
                "docstring": "X - resolution of the image."
            }, 
            "yResolution": {
                "docstring": "Y - resolution of the image."
            }
        }
    }, 
    "createNode": {
        "description": "This command creates a new node in the dependency graph of the specified type. ", 
        "flags": {
            "name": {
                "docstring": "Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace doesn't exist, we will create the namespace."
            }, 
            "parent": {
                "docstring": "Specifies the parent in the DAG under which the new node belongs."
            }, 
            "shared": {
                "docstring": "This node is shared across multiple files, so only create it if it does not already exist."
            }, 
            "skipSelect": {
                "docstring": "This node is not to be selected after creation, the original selection will be preserved.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "createNurbsCircleCtx": {
        "description": "", 
        "flags": {
            "attachToSections": {
                "docstring": ""
            }, 
            "degree": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "normal": {
                "docstring": ""
            }, 
            "normalType": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "sections": {
                "docstring": ""
            }, 
            "sweep": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": ""
            }, 
            "toleranceType": {
                "docstring": ""
            }, 
            "useTolerance": {
                "docstring": ""
            }
        }
    }, 
    "createNurbsConeCtx": {
        "description": "", 
        "flags": {
            "attachToHeightRatio": {
                "docstring": ""
            }, 
            "attachToSections": {
                "docstring": ""
            }, 
            "attachToSpans": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "axisType": {
                "docstring": ""
            }, 
            "caps": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endSweep": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "extraTransformOnCaps": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "sections": {
                "docstring": ""
            }, 
            "spans": {
                "docstring": ""
            }, 
            "startSweep": {
                "docstring": ""
            }, 
            "surfaceDegree": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": ""
            }, 
            "toleranceType": {
                "docstring": ""
            }, 
            "useTolerance": {
                "docstring": ""
            }
        }
    }, 
    "createNurbsCubeCtx": {
        "description": "", 
        "flags": {
            "attachToPatchesU": {
                "docstring": ""
            }, 
            "attachToPatchesV": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "axisType": {
                "docstring": ""
            }, 
            "depth": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "surfaceDegree": {
                "docstring": ""
            }, 
            "uPatches": {
                "docstring": ""
            }, 
            "vPatches": {
                "docstring": ""
            }, 
            "width": {
                "docstring": ""
            }
        }
    }, 
    "createNurbsCylinderCtx": {
        "description": "", 
        "flags": {
            "attachToHeightRatio": {
                "docstring": ""
            }, 
            "attachToSections": {
                "docstring": ""
            }, 
            "attachToSpans": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "axisType": {
                "docstring": ""
            }, 
            "caps": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endSweep": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "extraTransformOnCaps": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "sections": {
                "docstring": ""
            }, 
            "spans": {
                "docstring": ""
            }, 
            "startSweep": {
                "docstring": ""
            }, 
            "surfaceDegree": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": ""
            }, 
            "toleranceType": {
                "docstring": ""
            }, 
            "useTolerance": {
                "docstring": ""
            }
        }
    }, 
    "createNurbsPlaneCtx": {
        "description": "", 
        "flags": {
            "attachToPatchesU": {
                "docstring": ""
            }, 
            "attachToPatchesV": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "axisType": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "surfaceDegree": {
                "docstring": ""
            }, 
            "uPatches": {
                "docstring": ""
            }, 
            "vPatches": {
                "docstring": ""
            }, 
            "width": {
                "docstring": ""
            }
        }
    }, 
    "createNurbsSphereCtx": {
        "description": "", 
        "flags": {
            "attachToHeightRatio": {
                "docstring": ""
            }, 
            "attachToSections": {
                "docstring": ""
            }, 
            "attachToSpans": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "axisType": {
                "docstring": ""
            }, 
            "degree": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endSweep": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "sections": {
                "docstring": ""
            }, 
            "spans": {
                "docstring": ""
            }, 
            "startSweep": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": ""
            }, 
            "toleranceType": {
                "docstring": ""
            }, 
            "useTolerance": {
                "docstring": ""
            }
        }
    }, 
    "createNurbsSquareCtx": {
        "description": "", 
        "flags": {
            "attachToSpans": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "axisType": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "spans": {
                "docstring": ""
            }, 
            "surfaceDegree": {
                "docstring": ""
            }, 
            "width": {
                "docstring": ""
            }
        }
    }, 
    "createNurbsTorusCtx": {
        "description": "", 
        "flags": {
            "attachToHeightRatio": {
                "docstring": ""
            }, 
            "attachToSections": {
                "docstring": ""
            }, 
            "attachToSpans": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "axisType": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endSweep": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "minorRadius": {
                "docstring": ""
            }, 
            "minorSweep": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "sections": {
                "docstring": ""
            }, 
            "spans": {
                "docstring": ""
            }, 
            "startSweep": {
                "docstring": ""
            }, 
            "surfaceDegree": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": ""
            }, 
            "toleranceType": {
                "docstring": ""
            }, 
            "useTolerance": {
                "docstring": ""
            }
        }
    }, 
    "createPolyConeCtx": {
        "description": "", 
        "flags": {
            "attachToSubdivisionsAxis": {
                "docstring": ""
            }, 
            "attachToSubdivisionsCap": {
                "docstring": ""
            }, 
            "attachToSubdivisionsHeight": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "roundCap": {
                "docstring": ""
            }, 
            "subdivisionsDepth": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsWidth": {
                "docstring": ""
            }
        }
    }, 
    "createPolyCubeCtx": {
        "description": "", 
        "flags": {
            "attachToSubdivisionsAll": {
                "docstring": ""
            }, 
            "attachToSubdivisionsDepth": {
                "docstring": ""
            }, 
            "attachToSubdivisionsHeight": {
                "docstring": ""
            }, 
            "attachToSubdivisionsWidth": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "depth": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "subdivisionsDepth": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsWidth": {
                "docstring": ""
            }, 
            "width": {
                "docstring": ""
            }
        }
    }, 
    "createPolyCylinderCtx": {
        "description": "", 
        "flags": {
            "attachToSubdivisionsAxis": {
                "docstring": ""
            }, 
            "attachToSubdivisionsCap": {
                "docstring": ""
            }, 
            "attachToSubdivisionsHeight": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "roundCap": {
                "docstring": ""
            }, 
            "subdivisionsAxis": {
                "docstring": ""
            }, 
            "subdivisionsCap": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }
        }
    }, 
    "createPolyHelixCtx": {
        "description": "", 
        "flags": {
            "attachToNumberCoils": {
                "docstring": ""
            }, 
            "attachToRadius": {
                "docstring": ""
            }, 
            "attachToSubdivisionsAxis": {
                "docstring": ""
            }, 
            "attachToSubdivisionsCap": {
                "docstring": ""
            }, 
            "attachToSubdivisionsCoil": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "coils": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "direction": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "roundCap": {
                "docstring": ""
            }, 
            "subdivisionsAxis": {
                "docstring": ""
            }, 
            "subdivisionsCap": {
                "docstring": ""
            }, 
            "subdivisionsCoil": {
                "docstring": ""
            }, 
            "width": {
                "docstring": ""
            }
        }
    }, 
    "createPolyPipeCtx": {
        "description": "", 
        "flags": {
            "attachToSubdivisionsAxis": {
                "docstring": ""
            }, 
            "attachToSubdivisionsCap": {
                "docstring": ""
            }, 
            "attachToSubdivisionsHeight": {
                "docstring": ""
            }, 
            "attachToThickness": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "roundCap": {
                "docstring": ""
            }, 
            "subdivisionsAxis": {
                "docstring": ""
            }, 
            "subdivisionsCap": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "thickness": {
                "docstring": ""
            }
        }
    }, 
    "createPolyPlaneCtx": {
        "description": "", 
        "flags": {
            "attachToSubdivisionsAll": {
                "docstring": ""
            }, 
            "attachToSubdivisionsHeight": {
                "docstring": ""
            }, 
            "attachToSubdivisionsWidth": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsWidth": {
                "docstring": ""
            }, 
            "width": {
                "docstring": ""
            }
        }
    }, 
    "createPolyPlatonicSolidCtx": {
        "description": "", 
        "flags": {
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "sideLength": {
                "docstring": ""
            }, 
            "solidType": {
                "docstring": ""
            }
        }
    }, 
    "createPolyPrismCtx": {
        "description": "", 
        "flags": {
            "attachToNumSides": {
                "docstring": ""
            }, 
            "attachToSubdivisionsCap": {
                "docstring": ""
            }, 
            "attachToSubdivisionsHeight": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "length": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "numberOfSides": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "sideLength": {
                "docstring": ""
            }, 
            "subdivisionsCap": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }
        }
    }, 
    "createPolyPyramidCtx": {
        "description": "", 
        "flags": {
            "attachToSubdivisionsCap": {
                "docstring": ""
            }, 
            "attachToSubdivisionsHeight": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "numberOfSides": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "sideLength": {
                "docstring": ""
            }, 
            "subdivisionsDepth": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }
        }
    }, 
    "createPolySoccerBallCtx": {
        "description": "", 
        "flags": {
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "sideLength": {
                "docstring": ""
            }
        }
    }, 
    "createPolySphereCtx": {
        "description": "", 
        "flags": {
            "attachToSubdivisionsAll": {
                "docstring": ""
            }, 
            "attachToSubdivisionsAxis": {
                "docstring": ""
            }, 
            "attachToSubdivisionsHeight": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsWidth": {
                "docstring": ""
            }
        }
    }, 
    "createPolyTorusCtx": {
        "description": "", 
        "flags": {
            "attachToSectionRadius": {
                "docstring": ""
            }, 
            "attachToSubdivisionsAxis": {
                "docstring": ""
            }, 
            "attachToSubdivisionsHeight": {
                "docstring": ""
            }, 
            "axis": {
                "docstring": ""
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "doDragEdit": {
                "docstring": ""
            }, 
            "doSubdivisionsCapsEdit": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "sectionRadius": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsWidth": {
                "docstring": ""
            }, 
            "twist": {
                "docstring": ""
            }
        }
    }, 
    "createRenderLayer": {
        "description": "Create a new render layer. The render layer number will be assigned based on the first unassigned number not less than the base index number found in the render layer global parameters. Normally all objects and their descendants will be added to the new render layer but if '-noRecurse' is specified then only the objects themselves will be added. Only transforms and geometry will be added to the new render layer. ", 
        "flags": {
            "empty": {
                "docstring": "If set then create an empty render layer. The global flag or specified member list will take precidence over use of this flag."
            }, 
            "g": {
                "docstring": "If set then create a layer that contains all DAG objects in the scene. Any future objects created will also automatically become members of this layer. The global flag will take precidence over use of the empty flag or specified member list."
            }, 
            "makeCurrent": {
                "docstring": "If set then make the new render layer the current one."
            }, 
            "name": {
                "docstring": "Name of the new render layer being created."
            }, 
            "noRecurse": {
                "docstring": "If set then only add specified objects to the render layer. Otherwise all descendants will also be added."
            }, 
            "number": {
                "docstring": "Number for the new render layer being created.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "createSubdivRegion": {
        "description": "Creates a subdivision surface region based on the selection list. Once a selection region is created, only the components in the selection list or converted from the selection list will be displayed and selectible through the UI. ", 
        "flags": {}
    }, 
    "ctxAbort": {
        "description": "This command tells the current context to reset itself, losing what has been done so far. If a escape context has been set it then makes that context current. ", 
        "flags": {}
    }, 
    "ctxCompletion": {
        "description": "This command tells the current context to finish what it is doing and create any objects that is is working on. ", 
        "flags": {}
    }, 
    "ctxData": {
        "description": "", 
        "flags": {}
    }, 
    "ctxEditMode": {
        "description": "This command tells the current context to switch edit modes.It acts as a toggle. ", 
        "flags": {}
    }, 
    "ctxTraverse": {
        "description": "This command tells the current context to do a traversal.Some contexts will ignore this command. Individual contexts determine what up/down left/right mean. ", 
        "flags": {
            "down": {
                "docstring": "Move \"down\" as defined by the current context."
            }, 
            "left": {
                "docstring": "Move \"left\" as defined by the current context.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "right": {
                "docstring": "Move \"right\" as defined by the current context."
            }, 
            "up": {
                "docstring": "Move \"up\" as defined by the current context."
            }
        }
    }, 
    "currentCtx": {
        "description": "This command returns the currently selected tool context. ", 
        "flags": {}
    }, 
    "currentTime": {
        "description": "When given a time argument (with or without the -edit flag) this command sets the current global time. The model updates and displays at the new time, unless \"-update off\" is present on the command line. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "update": {
                "docstring": "change the current time, but do not update the world. Default value is true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "currentTimeCtx": {
        "description": "This command creates a context which may be used to change current time within the graph editor ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "currentUnit": {
        "description": "This command allows you to change the units in which you will work in Maya. There are three types of units: linear, angular and time. The current unit affects how all commands in Maya interpret their numeric values. For example, if the current linear unit is cm, then the command: move 5 -2 3; sphere -radius 4; will be interpreted as moving 5cm in X, -2cm in Y, 3cm in Z, and as creating a sphere with radius 4cm. Similarly, if the current time unit is Film (24 frames per second), then the command: currentTime 6; will be interpreted as setting the current time to frame 6 in the Film unit, which is 6/24 or 0.25 seconds. You can always override the unit of a particular numeric value to a command be specifying it one the command. For example, using the above examples: move 5m -2mm 3cm; sphere -radius 4inch; currentTime 6ntsc; would move the object 5 meters in X, -2 millimeters in Y, 3 centimeters in Z, create a sphere of radius 4 inches, and change the current time to 6 frames in the NTSC unit, which would be 0.2 seconds, or 4.8 frames in the current (Film) unit. ", 
        "flags": {
            "angle": {
                "docstring": "Set the current angular unit. Valid strings are:[deg | degree | rad | radian]When queried, returns a string which is the current angular unit"
            }, 
            "fullName": {
                "docstring": "A query only flag. When specified in conjunction with any of the -linear/-angle/-time flags, will return the long form of the unit. For example, mmand millimeterare the same unit, but the former is the short form of the unit name, and the latter is the long form of the unit name."
            }, 
            "linear": {
                "docstring": "Set the current linear unit. Valid strings are:[mm | millimeter | cm | centimeter | m | meter | km | kilometer | in | inch | ft | foot | yd | yard | mi | mile]When queried, returns a string which is the current linear unit"
            }, 
            "query": {
                "docstring": ""
            }, 
            "time": {
                "docstring": "Set the current time unit. Valid strings are:[hour | min | sec | millisec | game | film | pal | ntsc | show | palf | ntscf]When queried, returns a string which is the current time unit Note that there is no long form for any of the time units. The non-seconds based time units are interpreted as the following frames per second: game: 15 fpsfilm: 24 fpspal: 25 fpsntsc: 30 fpsshow: 48 fpspalf: 50 fpsntscf: 60 fps"
            }, 
            "updateAnimation": {
                "docstring": "An edit only flag. When specified in conjunction with the -time flag indicates that times for keys are not updated. By default when the current time unit is changed, the times for keys are modified so that playback timing is preserved. For example a key set a frame 12film is changed to frame 15ntsc when the current time unit is changed to ntsc, since they both represent a key at a time of 0.5 seconds. Specifying -updateAnimation false would leave the key at frame 12ntsc. Default is -updateAnimation true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "curve": {
        "description": "The curve command creates a new curve from a list of control vertices (CVs). A string is returned containing the pathname to the newly created curve. You can create a curve from points either in world space or object (local) space, either with weights or without. You can replace an existing curve by using the \"-r/replace\" flag. You can append a point to an existing curve by using the \"-a/append\" flag. To create a curve-on-surface, use the curveOnSurface command. To change the degree of a curve, use the rebuildCurve command. To change the of parameter range curve, use the rebuildCurve command. ", 
        "flags": {
            "append": {
                "docstring": "Appends point(s) to the end of an existing curve. If you use this flag, you must specify the name of the curve to append to, at the end of the command. (See examples below.)"
            }, 
            "bezier": {
                "docstring": "The created curve will be a bezier curve."
            }, 
            "degree": {
                "docstring": "The degree of the new curve. Default is 3. Note that you need (degree+1) curve points to create a visible curve span. eg. you must place 4 points for a degree 3 curve."
            }, 
            "editPoint": {
                "docstring": "The x, y, z position of an edit point. \"linear\" means that this flag can take values with units. This flag can not be used with the -point or the -pointWeight flags."
            }, 
            "knot": {
                "docstring": "A knot value in a knot vector. One flag per knot value. There must be (numberOfPoints + degree - 1) knots and the knot vector must be non-decreasing."
            }, 
            "name": {
                "docstring": ""
            }, 
            "objectSpace": {
                "docstring": "Points are in object, or \"local\" space. This is the default. You cannot specify both \"-os\" and \"-ws\" in the same command."
            }, 
            "periodic": {
                "docstring": "If on, creates a curve that is periodic. Default is off."
            }, 
            "point": {
                "docstring": "The x, y, z position of a point. \"linear\" means that this flag can take values with units."
            }, 
            "pointWeight": {
                "docstring": "The x,y,z and w values of a point, where the w is a weight value. A rational curve will be created if this flag is used. \"linear\" means that this flag can take values with units."
            }, 
            "replace": {
                "docstring": "Replaces an entire existing curve. If you use this flag, you must specify the name of the curve to replace, at the end of the command. (See examples below.)"
            }, 
            "worldSpace": {
                "docstring": "Points are in world space. The default is \"-os\". You cannot specify both \"-os\" and \"-ws\" in the same command.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "curveAddPtCtx": {
        "description": "The curveAddPtCtx command creates a new curve add points context, which adds either control vertices (CVs) or edit points to an existing curve. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "curveBezierCtx": {
        "description": "", 
        "flags": {
            "degree": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "manipMode": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "preserveShape": {
                "docstring": ""
            }, 
            "preserveShapeFraction": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "refit": {
                "docstring": ""
            }, 
            "selectMode": {
                "docstring": ""
            }, 
            "uniform": {
                "docstring": ""
            }
        }
    }, 
    "curveCVCtx": {
        "description": "The curveCVCtx command creates a new context for creating curves by placing control vertices (CVs). ", 
        "flags": {
            "bezier": {
                "docstring": ""
            }, 
            "degree": {
                "docstring": "valid values are 1, 2, 3, 5 or 7. Default is degree 3."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "multEndKnots": {
                "docstring": "Default is true. False means that the curve will not pass through the end control vertices (CVs)."
            }, 
            "name": {
                "docstring": ""
            }, 
            "preserveShape": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rational": {
                "docstring": ""
            }, 
            "refit": {
                "docstring": ""
            }, 
            "symmetry": {
                "docstring": ""
            }, 
            "uniform": {
                "docstring": "Default is true, which means uniform parameterization will be used. False means chord length parameterization.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "curveEPCtx": {
        "description": "The curveEPCtx command creates a new context for creating curves by placing edit points. ", 
        "flags": {
            "bezier": {
                "docstring": ""
            }, 
            "degree": {
                "docstring": "Curve degree. Valid values are 1, 2, 3, 5 or 7. Default is degree 3."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "preserveShape": {
                "docstring": ""
            }, 
            "preserveShapeFraction": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "refit": {
                "docstring": ""
            }, 
            "uniform": {
                "docstring": "Default is true, which means uniform parameterization will be used. False means chord length parameterization.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "curveEditorCtx": {
        "description": "The curveEditorCtx command creates a new NURBS editor context, which is used to edit a NURBS curve or surface. ", 
        "flags": {
            "direction": {
                "docstring": "Query the current direction of the tangent control. Always zero for the curve case. In the surface case, its 0 for the normal direction, 1 for U direction and 2 for V direction."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "relativeTangentSize": {
                "docstring": "Relative size of the tangent manipulator handle. Helps to adjust as the surface parameterization controls the size of the tangent, even if the shape of the surface remains the same. The default is 4.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "title": {
                "docstring": "The title for the tool."
            }
        }
    }, 
    "curveIntersect": {
        "description": "You must specify two curves to intersect. This command either returns the parameter values at which the given pair of curves intersect, or returns a dependency node that provides the intersection information. If you want to find the intersection of the curves in a specific direction you must use BOTH the \"-useDirection\" flag and the \"direction\" flag. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "direction": {
                "docstring": "The direction that the input curves are projected in before intersecting. This vector is only used if \"useDirection\" flag is true."
            }, 
            "directionX": {
                "docstring": ""
            }, 
            "directionY": {
                "docstring": ""
            }, 
            "directionZ": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": "The tolerance that the intersection is calculated with. For example, given two curves end-to-end, the ends must be within tolerance for an intersection to be returned.Default:0.001Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useDirection": {
                "docstring": "If true, use direction flag. The input curves are first projected in a specified direction and then intersected. If false, this command will only find true 3D intersections.Default:false"
            }
        }
    }, 
    "curveMoveEPCtx": {
        "description": "The curveMoveEPCtx command creates a new context for moving curve edit points using a manipulator. Edit points can only be moved one at a time. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "curveOnSurface": {
        "description": "The curve-on-surface command creates a new curve-on-surface from a list of control vertices (CVs). A string is returned containing the pathname to the newly created curve-on-surface. You can replace an existing curve by using the \"-r/replace\" flag. You can append points to an existing curve-on-surface by using the \"-a/append\" flag. See also the curve command, which describes how to query curve attributes. ", 
        "flags": {
            "append": {
                "docstring": "Appends point(s) to the end of an existing curve. If you use this flag, you must specify the name of the curve to append to, at the end of the command. (See examples below.)"
            }, 
            "degree": {
                "docstring": "The degree of the new curve. Default is 3. Note that you need degree+1 curve points to create a visible curve span, eg. you must place 4 points for a degree 3 curve."
            }, 
            "knot": {
                "docstring": "A knot value in a knot vector. One flag per knot value. There must be (numberOfPoints + degree - 1) knots and the knot vector must be non-decreasing."
            }, 
            "name": {
                "docstring": ""
            }, 
            "periodic": {
                "docstring": "If on, creates a curve that is periodic. Default is off.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "positionUV": {
                "docstring": "The uv position of a point."
            }, 
            "replace": {
                "docstring": "Replaces an entire existing curve. If you use this flag, you must specify the name of the curve to replace, at the end of the command. (See examples below.)"
            }
        }
    }, 
    "curveRGBColor": {
        "description": "This command creates, changes or removes custom curve colors, which are used to draw the curves in the Graph Editor. The custom curve names may contain the wildcards \"?\", which marches a single character, and \"\\*\", which matches any number of characters. These colors are part of the UI and not part of the saved data for a model. This command is not undoable. ", 
        "flags": {
            "hueSaturationValue": {
                "docstring": "Indicates that rgb values are really hsv values.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "list": {
                "docstring": "Writes out a list of all curve color names and their values."
            }, 
            "listNames": {
                "docstring": "Returns an array of all curve color names."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Removes the named curve color."
            }, 
            "resetToFactory": {
                "docstring": "Resets all the curve colors to their factory defaults."
            }, 
            "resetToSaved": {
                "docstring": "Resets all the curve colors to their saved values."
            }
        }
    }, 
    "curveSketchCtx": {
        "description": "The curveSketchCtx command creates a new curve sketch context, also known as the \"pencil context\". ", 
        "flags": {
            "degree": {
                "docstring": "Valid values are 1 or 3Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "customerInvolvementProgram": {
        "description": "", 
        "flags": {}
    }, 
    "cutKey": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.The cutKey command cuts curve segment hierarchies from specified targets and puts them in the clipboard. The pasteKey command applies these curves to other objects.The shape of the cut curve placed in the clipboard, and the effect of the cutKey command on the source animation curve depends on the cutKey \"-option\" specified. Each of these options below will be explained using an example. For all the explanations, let us assume that the source animation curve (from which keys will be cut) has 5 keyframes at times 10, 15, 20, 25, and 30.TbaseKeySetCmd.h cutKey -t \"12:22\" -option keysKeyframes at times 15 and 20 are removed. All other keys are unchanged.A 5-frame animation curve is placed into the keyset clipboard.cutKey -t \"12:22\" -option keysCollapseKeyframes at times 15 and 20 are removed. Shift all keys after time 20 to the left by 5 frames, preserving all their values.A 5-frame animation curve is placed into the keyset clipboard.cutKey -t \"12:22\" -option keysConnectKeyframes at times 15 and 20 are removed. Shift all keys after time 20 to the left by 5 frames, and place the key that used to be at time 25 at the value of the key that used to be at time 15.A 5-frame animation curve is placed into the keyset clipboard.cutKey -t \"12:22\" -option curveKeyframes at times 15 and 20 are removed. Keys are inserted at times 12 and 22.A 10-frame animation curve is placed into the keyset clipboard.cutKey -t \"12:22\" -option curveCollapseKeyframes at times 15 and 20 are removed. Keys are inserted at times 12 and 22. Shift all keys from time 22 to the left by 10 frames, preserving their values.A 10-frame animation curve is placed into the keyset clipboard.cutKey -t \"12:22\" -option curveConnectKeyframes at times 15 and 20 are removed. Keys are inserted at times 12 and 22. Shift all keys from time 22 to the left by 10 frames, and replace the key inserted at time 12 with the newly inserted key at time 22.A 10-frame animation curve is placed into the keyset clipboard.cutKey -t \"12:22\" -option areaCollapseKeyframes at times 15 and 20 are removed. Shift all keys from time 22 to the left by 10 frames, preserving their values.A 10-frame animation curve is placed into the keyset clipboard.", 
        "flags": {
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "clear": {
                "docstring": "Just remove the keyframes (i.e. do not overwrite the clipboard)"
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "option": {
                "docstring": "Option for how to perform the cutKey operation. Valid values for this flag are \"keys\", \"curve\", \"curveCollapse\", \"curveConnect\", \"areaCollapse\". The default cut option is: keys"
            }, 
            "selectKey": {
                "docstring": "Select the keyframes of curves which have had keys removedFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }
        }
    }, 
    "cycleCheck": {
        "description": "This command searches for plug cycles in the dependency graph. If a plug or node is selected then it searches for cycles that that plug or node is involved with. Plugs or nodes can also be passed as arguments. If the -all flag is used then the entire graph is searched. Normally the return value is a boolean indicating whether or not the given items were involved in a cycle. If the -list flag is used then the return value is the list of all plugs in cycles (involving the selected plug or node if any). Note that it is possible for evaluation cycles to occur even where no DG connections exist. Here are some examples: 1) Nodes with evaluation-time dependent connections: An example is expression nodes, because we cannot tell what an expression node is actually referring to until it is evaluated, and such evaluation-time dependent nodes may behave differently based on the context (e.g. time) they are evaluated at. If you suspect a cycle due to such a connection, the best way to detect the cycle is through manual inspection. 2) Cycles due to DAG hierarchy: noting that DAG nodes are implicitely connected through parenting, if a child DAG node connects an output into the input of a parent node, a cycle will exist if the plugs involved also affect each other. In order to enable detection of cycles involving the DAG, add the -dag flag to the command line. Note also that this command may incorrectly report a cycle on an instanced skeleton where some of the instances use IK. You will have to examine the reported cycle yourself to determine if it is truly a cycle or not. The evaluation time cycle checking will not report false cycles. ", 
        "flags": {
            "all": {
                "docstring": "search the entire graph for cycles instead of the selection list. (Note: if nothing is selected, -all is assumed)."
            }, 
            "children": {
                "docstring": "Do not consider cycles on the children, only the specified plugs"
            }, 
            "dag": {
                "docstring": "Also look for cycles due to relationships in the DAG. For each DAG node, the parenting connection on its children is also considered when searching for cycles."
            }, 
            "evaluation": {
                "docstring": "Turn on and off cycle detection during graph evaluation"
            }, 
            "firstCycleOnly": {
                "docstring": "When -list is used to return a plug list, the list may contain multiple cycles or partial cycles. When -firstCycleOnly is specified only the first such cycle (which will be a full cycle) is returned."
            }, 
            "firstPlugPerNode": {
                "docstring": "When -list is used to return a plug list, the list will typically contain multiple plugs per node (e.g. ... A.output B.input B.output C.input ...), reflecting internal \"affects\" relationships rather than external DG connections. When -firstPlugPerNode is specified, only the first plug in the list for each node is returned (B.input in the example)."
            }, 
            "lastPlugPerNode": {
                "docstring": "When -list is used to return a plug list, the list will typically contain multiple plugs per node (e.g. ... A.output B.input B.output C.input ...), reflecting internal \"affects\" relationships rather than external DG connections. When -lastPlugPerNode is specified, only the last plug in the list for each node is returned (B.output in the example).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "list": {
                "docstring": "Return all plugs involved in one or more cycles. If not specified, returns a boolean indicating whether a cycle exists."
            }, 
            "listSeparator": {
                "docstring": "When -list is used to return a plug list, the list may contain multiple cycles or partial cycles. Use -listSeparator to specify a string that will be inserted into the returned string array to separate the cycles."
            }, 
            "parents": {
                "docstring": "Do not consider cycles on the parents, only the specified plugs"
            }, 
            "query": {
                "docstring": ""
            }, 
            "secondary": {
                "docstring": "Look for cycles on related plugs as well as the specified plugs Default is \"on\" for the \"-all\" case and \"off\" for others"
            }, 
            "timeLimit": {
                "docstring": "Limit the search to the given amount of time"
            }
        }
    }, 
    "cylinder": {
        "description": "The cylinder command creates a new cylinder and/or a dependency node that creates one, and returns their names. ", 
        "flags": {
            "axis": {
                "docstring": "The primitive's axisAdvanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting surface: 1 - linear, 3 - cubicDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endSweep": {
                "docstring": "The angle at which to end the surface of revolution. Default is 2Pi radians, or 360 degrees.Default:6.2831853"
            }, 
            "heightRatio": {
                "docstring": "Ratio of \"height\" to \"width\"Default:2.0"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "pivot": {
                "docstring": "The primitive's pivot point"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "The radius of the objectDefault:1.0"
            }, 
            "sections": {
                "docstring": "The number of sections determines the resolution of the surface in the sweep direction. Used only if useTolerance is false.Default:8"
            }, 
            "spans": {
                "docstring": "The number of spans determines the resolution of the surface in the opposite direction.Default:1"
            }, 
            "startSweep": {
                "docstring": "The angle at which to start the surface of revolutionDefault:0"
            }, 
            "tolerance": {
                "docstring": "The tolerance with which to build the surface. Used only if useTolerance is trueDefault:0.01"
            }, 
            "useTolerance": {
                "docstring": "Use the specified tolerance to determine resolution. Otherwise number of sections will be used.Default:false"
            }
        }
    }, 
    "dagObjectCompare": {
        "description": "dagObjectCompare can be used to compare to compare objects based on: type - Currently supports transform nodes and shape nodesrelatives - Compares DAG objects' children and parentsconnections - Checks to make sure the two dags are connected to the same sources and destinationsattributes - Checks to make sure that the properties of active attributes are the same", 
        "flags": {
            "attribute": {
                "docstring": "Compare dag object attributes"
            }, 
            "bail": {
                "docstring": "Bail on first error or bail on category. Legal values are \"never\", \"first\", and \"category\"."
            }, 
            "connection": {
                "docstring": "Compare dag connections"
            }, 
            "namespace": {
                "docstring": "The baseline namespace"
            }, 
            "relative": {
                "docstring": "dag relatives"
            }, 
            "short": {
                "docstring": "Compress output to short form (not as verbose)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "type": {
                "docstring": "Compare based on dag object type"
            }
        }
    }, 
    "dagObjectHit": {
        "description": "", 
        "flags": {
            "cache": {
                "docstring": ""
            }, 
            "menu": {
                "docstring": ""
            }, 
            "multiple": {
                "docstring": ""
            }, 
            "targetSize": {
                "docstring": ""
            }
        }
    }, 
    "dagPose": {
        "description": "This command is used to save and restore the matrix information for a dag hierarchy. Specifically, the data stored will restore the translate, rotate, scale, scale pivot, rotate pivot, rotation order, and (for joints) joint order for all the objects on the hierarchy. Data for other attributes is not stored by this command. This command can also be used to store a bindPose for an object. When you skin an object, a dagPose is automatically created for the skin. ", 
        "flags": {
            "addToPose": {
                "docstring": "Allows adding the selected items to the dagPose."
            }, 
            "atPose": {
                "docstring": "Query whether the hierarchy is at same position as the pose. Names of hierarchy members that are not at the pose position will be returned. An empty return list indicates that the hierarchy is at the pose."
            }, 
            "bindPose": {
                "docstring": "Used to specify the bindPose for the selected hierarchy. Each hierarchy can have only a single bindPose, which is saved automatically at the time of a skin bind. The bindPose is used when adding influence objects, binding new skins, or adding flexors. Take care when modifying the bindPose with the -rs/-reset or -rm/-remove flags, since if the bindPose is ill-defined it can cause problems with subsequent skinning operations."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "g": {
                "docstring": "This flag can be used in conjunction with the restore flag to signal that the members of the pose should be restored to the global pose. The global pose means not only is each object locally oriented with respect to its parents, it is also in the same global position that it was at when the pose was saved. If a hierarchy's parenting has been changed since the time that the pose was saved, you may have trouble reaching the global pose."
            }, 
            "members": {
                "docstring": "Query the members of the specified pose. The pose should be specified using the selection list, the -bp/-bindPose or the -n/-name flag."
            }, 
            "name": {
                "docstring": "Specify the name of the pose. This can be used during create, restore, reset, remove, and query operations to specify the pose to be created or acted upon."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Remove the selected joints from the specified pose."
            }, 
            "reset": {
                "docstring": "Reset the pose on the selected joints. If you are resetting pose data for a bindPose, take care. It is appropriate to use the -rs/-reset flag if a joint has been reparented and/or appears to be exactly at the bindPose. However, a bindPose that is much different from the exact bindPose can cause problems with subsequent skinning operations."
            }, 
            "restore": {
                "docstring": "Restore the hierarchy to a saved pose. To specify the pose, select the pose node, or use the -bp/-bindPose or -n/-name flag."
            }, 
            "save": {
                "docstring": "Save a dagPose for the selected dag hierarchy. The name of the new pose will be returned."
            }, 
            "selection": {
                "docstring": "Whether or not to store a pose for all items in the hierarchy, or for only the selected items."
            }, 
            "worldParent": {
                "docstring": "Indicates that the selected pose member should be recalculated as if it is parented to the world. This is typically used when you plan to reparent the object to world as the next operation.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "date": {
        "description": "Returns information about current time and date. Use the predefined formats, or the -formatflag to specify the output format. ", 
        "flags": {
            "date": {
                "docstring": "Returns the current date. Format is YYYY/MM/DD"
            }, 
            "format": {
                "docstring": "Specifies a string defining how the date and time should be represented. All occurences of the keywords below will be replaced with the corresponding values: YYYYYYMMDDhhmmss KeywordBecomesCurrent year, using 4 digitsLast two digits of the current yearCurrent month, with leading 0 if necessaryCurrent day, with leading 0 if necessaryCurrent hour, with leading 0 if necessaryCurrent minute, with leading 0 if necessaryCurrent second, with leading 0 if necessaryFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "shortDate": {
                "docstring": "Returns the current date. Format is MM/DD"
            }, 
            "shortTime": {
                "docstring": "Returns the current time. Format is hh:mm"
            }, 
            "time": {
                "docstring": "Returns the current time. Format is hh:mm:ss"
            }
        }
    }, 
    "dbcount": {
        "description": "The dbcountcommand is used to print and manage a list of statistics collected for counting operations. These statistics are displayed as a list of hits on a particular location in code, with added reference information for pointers/strings/whatever. If -reset is not specified then statistics are printed. ", 
        "flags": {
            "enabled": {
                "docstring": "Set the enabled state of the counters ('on' to enable, 'off' to disable). Returns the list of all counters affected."
            }, 
            "file": {
                "docstring": "Destination file of the enabled count objects. Use the special names stdoutand stderrto redirect to your command window. As well, the special name msdevis available on NT to direct your output to the debug tab in the output window of Developer Studio."
            }, 
            "keyword": {
                "docstring": "Print only the counters whose name matches this keyword (default is all)."
            }, 
            "list": {
                "docstring": "List all available counters and their current enabled status. (The only thing you can do when counters are disabled.)"
            }, 
            "maxdepth": {
                "docstring": "Maximum number of levels down to traverse and report. 0 is the default and it means continue recursing as many times as are requested."
            }, 
            "quick": {
                "docstring": "Display only a summary for each counter type instead of the full details."
            }, 
            "reset": {
                "docstring": "Reset all counters back to 0 and remove all but the top level counters. Returns the list of all counters affected."
            }, 
            "spreadsheet": {
                "docstring": "Display in spreadsheet format instead of the usual nested braces. This will include a header row that contains 'Count Level1 Level2 Level3...', making the data suitable for opening directly in a spreadsheet table.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "dbmessage": {
        "description": "The dbmessagecommand is used to install monitors for certain message types, dumping debug information as they are sent so that the flow of messages can be examined. ", 
        "flags": {
            "file": {
                "docstring": "Destination file of the message monitoring information. Use the special names stdoutand stderrto redirect to your command window. As well, the special name msdevis available on NT to direct your output to the debug tab in the output window of Developer Studio. Default value is stdout.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "list": {
                "docstring": "List all available message types and their current enabled status."
            }, 
            "monitor": {
                "docstring": "Set the monitoring state of the message type ('on' to enable, 'off' to disable). Returns the list of all message types being monitored after the change in state."
            }, 
            "type": {
                "docstring": "Monitor only the messages whose name matches this keyword (default is all)."
            }
        }
    }, 
    "dbtrace": {
        "description": "", 
        "flags": {}
    }, 
    "debug": {
        "description": "", 
        "flags": {}
    }, 
    "debugNamespace": {
        "description": "", 
        "flags": {}
    }, 
    "debugVar": {
        "description": "", 
        "flags": {}
    }, 
    "defaultLightListCheckBox": {
        "description": "This command creates a checkBox that controls whether a shadingGroup is connected/disconnected from the defaultLightList. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": ""
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "shadingGroup": {
                "docstring": "The shading group that is to be connected/disconnected from the defaultLightList.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "defaultNavigation": {
        "description": "The defaultNavigation command defines default behaviours when creating or manipulating connections between nodes and when navigating between nodes via those connections. This command is primarily used by attribute editors. ", 
        "flags": {
            "connectToExisting": {
                "docstring": "Connect the destination (which is a node.attribute or simply node) to an existing source. If the source is specified (as node.attribute or simply as node), the command will proceed immediately. If the source is not specified, the user will be prompted to specify one. Once a source has been specified, a best guess will be made about what the user is trying to accomplish by connecting the two, based on the type of source and type of destination. The command will connect the nodes/attributes according to the best guess. The destination is specified using the destinationflag and the source specified using the sourceflag."
            }, 
            "createNew": {
                "docstring": "Create a new node and connect it to the node.attribute specified using the destinationflag."
            }, 
            "defaultAttribute": {
                "docstring": "Returns the name of the attribute to which a connectNodeToNode would connect, given the source(attribute) and destination(node) flags. Returns a string."
            }, 
            "defaultTraversal": {
                "docstring": "Returns the name of the node to which it would make the most sense to navigate to from the destination node.attribute specified. The destination is specified using the destinationflag. Returns a string."
            }, 
            "defaultWorkingNode": {
                "docstring": "Returns the name of the node which the user is most likely to want to work with if they are interested in the attributes of the destination node. The destination is specified using the destinationflag. Returns a string."
            }, 
            "delete": {
                "docstring": "Delete nodes with connections flowing into the node.attribute specified by the destinationflag."
            }, 
            "destination": {
                "docstring": "Specifies an existing destination attribute for a createNew or connectToExisting."
            }, 
            "disconnect": {
                "docstring": ""
            }, 
            "force": {
                "docstring": "If set to true, then an attempt to connect a source attribute to a destination attribute which already has a source will cause the existing source to be disconnected and the new source to be connected in its place. Default value is true."
            }, 
            "ignore": {
                "docstring": "Ignore any connections flowing into the node.attribute specified by the destinationflag."
            }, 
            "navigatorDecisionString": {
                "docstring": "This is your opportunity to pass the navigator a string that can help it decide what behaviour to execute.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "quiet": {
                "docstring": "If set to true, then under no circumstances should the user be prompted for more information. Default value is false."
            }, 
            "relatedNodes": {
                "docstring": "List nodes which are conceptually related to the node.attribute specified by the destination. Related nodes may include, but are not limited to, nodes which are directly or indirectly connected to the destination. The destination is specified using the destinationflag. Returns an array of strings."
            }, 
            "source": {
                "docstring": "Specifies an existing source attribute for a connectToExisting."
            }, 
            "unignore": {
                "docstring": "Stop ignoring any connections flowing into the node.attribute specified by the destinationflag."
            }
        }
    }, 
    "defineDataServer": {
        "description": "Connects to the specified data servername, creating a named device which then can be attached to device handlers. When the device is defined, it queries queries the server for data axis information. The \"CapChannels\" present are represented as axis in form \"channelName\".\"usage\" for scalar channels and \"channelName\".\"component\" for compound channels. See listInputDeviceAxesto list axis names. Note that undoing defineDataServer -d \"myDevice\" -s \"myServer\" does not break the connection with the data server until it cannot be redone. Executing any other command (sphere for example) will cause this to occur. Similarly, the command defineDataServer -d \"myDevice\" -u does not break the connection with the data server until it cannot be undone. Either flushUndo, or the 'defineDataServer' command falling\" off the end of the undo queue causes this to occur, and the connection. to be broken. No return value. ", 
        "flags": {
            "device": {
                "docstring": "specified the device name to be given to the server connection. device name must be unique or the command fails."
            }, 
            "server": {
                "docstring": "specifies the name of the server with which the define device connects, and can be specifiied in two ways name-- the name of the server socketServer names of the form nameconnect to the server socket on the localhost corresponding to name. If namedoes not begin with \"/\", then /tmp/nameis used. This is the default behavior of most servers. If namebegins with \"/\", namedenotes the full path to the socket.host:service- a udp service on the specified host.The servicecan be any one of a \"udp service name,\" a \"port number,\" or a named service of \"tcpmux,\" and they are found in that order. If hostis omitted, the localhost is used.In any case, if the server cannot be found, the device is not defined (created) and the command fails."
            }, 
            "undefine": {
                "docstring": "undefines (destroys) the dataServer device, closing the connection with the server.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "defineVirtualDevice": {
        "description": "This command defines a virtual device. Virtual devices act like real devices and are useful to manipulate/playback data when an command device is not connected to the computer. In query mode, return type is based on queried flag.", 
        "flags": {
            "axis": {
                "docstring": "Specifies the axis number of the channel. All children have their axis number determined by their parent's axis number and the width of the parent channel. If this flag is not used, the order of the channel determines the axis number."
            }, 
            "channel": {
                "docstring": "After a -create is started, channels may be added to the device definition. The channel string wil be the name of the channel being added to the device. The -channel flag must also be accompanied by the -usage flag and optionally by the -axis flag."
            }, 
            "clear": {
                "docstring": "The -clear option will end a device definition and throw away any defined channels."
            }, 
            "create": {
                "docstring": "Start defining a virtual device. If a device is currently being defined, the -create flag will produce an error."
            }, 
            "device": {
                "docstring": "The -device flag ends the device definition. All of the channels between the -create flag and the -device flag are added to the specified device. If that device already exists, the command will fail and the device should be redefined with another device name. To see the currently defined devices, use the listInputDevices command. The -device flag is also used with -undefine to undefine a virtual device."
            }, 
            "parent": {
                "docstring": "Specified the parent channel of the channel being defined. If the channel does not exist, or is an incompatible type, the command will fail."
            }, 
            "query": {
                "docstring": ""
            }, 
            "undefine": {
                "docstring": "Undefines the device specified with the -device flag."
            }, 
            "usage": {
                "docstring": "The -usage option is required for every -channel flag. It describes what usage type the defined channel is. The usage types are: unknownscalarposrotposRotquaternionposQuaternionrotXYZrotYZXrotZXYrotXZYrotYXZrotZYXposRotXYZposRotYZXposRotZXYposRotXZYposRotXZYposRotZYXposXposYposZrotXrotYrotZFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "deformer": {
        "description": "This command creates a deformer of the specified type. The deformer will deform the selected objects. ", 
        "flags": {
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "type": {
                "docstring": "Specify the type of deformer to create. This flag is required in create mode. Typically the type should specify a loaded plugin deformer. This command should typically not be used to create one of the standard deformers such as sculpt, lattice, blendShape, wire and cluster, since they have their own customized commands which perform useful specialized functionality.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "deformerWeights": {
        "description": "WARNING NOTE - THIS COMMAND IS PART OF THE BONUS TOOL AND ISN'T FULLY SUPPORTED YET.  Command to import and export deformer weights to and from a simple XML  file. The weight data is stored in a per-vertex fashion along with a  point cloudcorresponding to the vertices from the geometry input to  the deformer.  For example a cluster deformer would have the following information:  On import the weights are then mapped back to a specified deformer  based on the specified mapping method. Note that the geometry used to  perform the mapping association is not the visible shape but rather  the incoming geometry to the deformer. For example, in the case of a  skin cluster this would be the bind pose geometry. \t         ", 
        "flags": {
            "defaultValue": {
                "docstring": "Manually set the default value. Default values are values that are not written to file. For example, for blendShapes the default value is automatically set to 1.0 and these values are not written to disk. For skinClusters the value is 0.0. If you want to force all weights to be written to disk you can set a defaultValue = -1.0. \t\t\t \t\t  Flag can have multiple arguments, passed either as a tuple or a list. "
            }, 
            "deformer": {
                "docstring": "Specify the deformer whose weights should be exported or imported. \t\t\t \t\t  "
            }, 
            "edit": {
                "docstring": ""
            }, 
            "export": {
                "docstring": "Export the given deformer \t\t\t \t\t  "
            }, 
            "ignoreName": {
                "docstring": "Ignore the names of the layers on import, just use the order of the layers instead. This can be used for case that joint names have been changed. Leaving it on only name that match on import will be write to the deformer. \t\t\t \t\t  "
            }, 
            "im": {
                "docstring": "Import weights to the specified deformer. See the method flag for details on how the weights will be mapped to the destination deformer. \t\t\t \t\t  "
            }, 
            "method": {
                "docstring": "Specify the method used to map the weight during import. Valid values are: index, nearest, barycentricand over. The indexmethod uses the vertex index to map the weights onto the object. This is most useful when the destination object shares the same topology as the exported data. The nearestmethod finds the nearest vertex in the imported data set and sets the weight value to that value. This is best used when mapping a higher resolution mesh to a lower resolution. The barycentricmethod is only supported with polygon meshes. It finds the nearest triangle of the target geometry and rescales the weights by how close the source point is to the vertices. This is normally used with a coarse mesh being mapped to a high resolution mesh. The overmethod is similar to the indexmethod but the weights on the destination mesh are not cleared prior to mapping, so that unmatched indices keep their weights intact. \t\t\t \t\t  "
            }, 
            "path": {
                "docstring": "The path to the given file. Default to the current project. \t\t\t \t\t  "
            }, 
            "positionTolerance": {
                "docstring": "The position tolerance is use to determine the radius of search for nearest and barycenteric searches. This flag is only used with import. Defaults to a huge number. \t\t\t \t\t  "
            }, 
            "query": {
                "docstring": ""
            }, 
            "shape": {
                "docstring": "Specify the source shape. Export will write out all the deformers on the shape node into one file. \t\t\t \t\t  "
            }, 
            "weightTolerance": {
                "docstring": "The weight tolerance is used to decide if a given weight value is close enough to the default value that it does not need to be included. This flag is only used with export. The default value is .001. \t\t\t \t\t  "
            }, 
            "worldSpace": {
                "docstring": "For spatially based association methods (barycentric and nearest), the position should be based on the world space position rather then the local object space. \t\t\t \t\t  "
            }
        }
    }, 
    "delete": {
        "description": "This command is used to delete selected objects, or all objects, or objects specified along with the command. Flags are available to filter the type of objects that the command acts on. At times, more than just specified items will be deleted. For example, deleting two CVs in the same \"row\" on a NURBS surface will delete the whole row. ", 
        "flags": {
            "all": {
                "docstring": "Remove all objects of specified kind, in the scene. This flag is to be used in conjunction with the following flags."
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "channels": {
                "docstring": "Remove animation channels in the scene. Either all channels can be removed, or the scope can be narrowed down by specifying some of the above mentioned options."
            }, 
            "constraints": {
                "docstring": "Remove selected constraints and constraints attached to the selected nodes, or remove all constraints in the scene.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "constructionHistory": {
                "docstring": "Remove the construction history on the objects specified or selected."
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "expressions": {
                "docstring": "Remove expressions in the scene. Either all expressions can be removed, or the scope can be narrowed down by specifying some of the above mentioned options."
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "inputConnectionsAndNodes": {
                "docstring": "Break input connection to specified attribute and delete all unconnected nodes that are left behind. The graph will be traversed until a node that cannot be deleted is encountered."
            }, 
            "motionPaths": {
                "docstring": ""
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "staticChannels": {
                "docstring": "Remove static animation channels in the scene. Either all static channels can be removed, or the scope can be narrowed down by specifying some of the above mentioned options."
            }, 
            "timeAnimationCurves": {
                "docstring": "Modifies the -c/channels and -sc/staticChannels flags. When true, only channels connected to time-input animation curves (for instance, those created by 'setKeyframe' will be deleted. When false, no time-input animation curves will be deleted. Default: true."
            }, 
            "unitlessAnimationCurves": {
                "docstring": "Modifies the -c/channels and -sc/staticChannels flags. When true, only channels connected to unitless-input animation curves (for instance, those created by 'setDrivenKeyframe' will be deleted. When false, no unitless-input animation curves will be deleted. Default: true."
            }
        }
    }, 
    "deleteAttr": {
        "description": "This command is used to delete a dynamic attribute from a node or nodes. The attribute can be specified by using either the long or short name. Only one dynamic attribute can be deleted at a time. Static attributes cannot be deleted. Children of a compound attribute cannot be deleted. You must delete the complete compound attribute. This command has no edit capabilities. The only query ability is to list all the dynamic attributes of a node. In query mode, return type is based on queried flag.", 
        "flags": {
            "attribute": {
                "docstring": "Specify either the long or short name of the attribute.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "The name of the node."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "deleteAttrPattern": {
        "description": "After a while the list of attribute patterns could become cluttered. This command provides a way to remove patterns from memory so that only the ones of interest will show. ", 
        "flags": {
            "allPatterns": {
                "docstring": "If specified it means delete all known attribute patterns."
            }, 
            "patternName": {
                "docstring": "The name of the pattern to be deleted."
            }, 
            "patternType": {
                "docstring": "Delete all patterns of the given type.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "deleteExtension": {
        "description": "This command is used to delete an extension attribute from a node type. The attribute can be specified by using either the long or short name. Only one extension attribute can be deleted at a time. Children of a compound attribute cannot be deleted, you must delete the complete compound attribute. This command has no undo, edit, or query capabilities. ", 
        "flags": {
            "attribute": {
                "docstring": "Specify either the long or short name of the attribute."
            }, 
            "forceDelete": {
                "docstring": "If this flag is set and turned ON then data values for the extension attributes are all deleted without confirmation. If it's set and turned OFF then any extension attributes that have non-default values set on any node will remain in place. If this flag is not set at all then the user will be asked if they wish to preserve non-default values on this attribute.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "nodeType": {
                "docstring": "The name of the node type."
            }
        }
    }, 
    "deleteUI": {
        "description": "This command deletes UI objects such as windows and controls. Deleting a layout or window will also delete all of its children. If a flag is used then all objects being deleted must be of the specified type. This command may not be edited or queried. NOTE: it is recommended that the type flags be used to disambiguate different kinds of objects with the same name. ", 
        "flags": {
            "collection": {
                "docstring": "Object names for deletion are all radio or tool collections."
            }, 
            "control": {
                "docstring": "Object names for deletion are all controls."
            }, 
            "editor": {
                "docstring": "Object names for deletion are all editors."
            }, 
            "layout": {
                "docstring": "Object names for deletion are all layouts."
            }, 
            "menu": {
                "docstring": "Object names for deletion are all menus."
            }, 
            "menuItem": {
                "docstring": "Object names for deletion are all menu items."
            }, 
            "panel": {
                "docstring": "Object names for deletion are all panels."
            }, 
            "panelConfig": {
                "docstring": "Object names for deletion are panel configurations.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "radioMenuItemCollection": {
                "docstring": "Object names for deletion are all radio menu item collections."
            }, 
            "toolContext": {
                "docstring": "Object names for deletion are all tool contexts."
            }, 
            "uiTemplate": {
                "docstring": "Object names for deletion are all UI templates."
            }, 
            "window": {
                "docstring": "Object names for deletion are all windows."
            }
        }
    }, 
    "detachCurve": {
        "description": "The detachCurve command detaches a curve into pieces, given a list of parameter values. You can also specify which pieces to keep and which to discard using the \"-k\" flag. The names of the newly detached curve(s) is returned. If history is on, then the name of the resulting dependency node is also returned. You can use this command to open a periodic curve at a particular parameter value. You would use this command with only one \"-p\" flag. If you are specifying \"-k\" flags, then you must specify one, none or all \"-k\" flags. If you are specifying all \"-k\" flags, there must be one more \"-k\" flag than \"-p\" flags. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curveOnSurface": {
                "docstring": "If possible, create 2D curve as a resultFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "keep": {
                "docstring": "Whether or not to keep a detached piece. This multiattribute should be one element larger than the parameter multattribute.Default:trueAdvanced flags"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameter": {
                "docstring": "Parameter values to detach atDefault:0.0"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)"
            }
        }
    }, 
    "detachDeviceAttr": {
        "description": "This command detaches connections between device axes and node attributes. The command line arguments are the same as for the corresponding attachDeviceAttr except for the clutch argument which can not be used in this command. In query mode, return type is based on queried flag.", 
        "flags": {
            "all": {
                "docstring": "Delete all attachments on every device.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "attribute": {
                "docstring": "The attribute to detach. This flag must be used with the -d/device flag."
            }, 
            "axis": {
                "docstring": "The axis to detach. This flag must be used with the -d/device flag."
            }, 
            "device": {
                "docstring": "Delete the attachment for this device. If the -ax/axis flag is not used, all of the attachments connected to this device are detached."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selection": {
                "docstring": "Detaches selection attachments."
            }
        }
    }, 
    "detachSurface": {
        "description": "The detachSurface command detaches a surface into pieces, given a list of parameter values and a direction. You can also specify which pieces to keep and which to discard using the \"-k\" flag. The names of the newly detached surface(s) are returned. If history is on, the name of the resulting dependency node is also returned. You can only detach in either U or V (not both) with a single detachSurface operation. You can use this command to open a closed surface at a particular parameter value. You would use this command with only one \"-p\" flag. If you are specifying \"-k\" flags, then you must specify one, none or all \"-k\" flags. If you are specifying all \"-k\" flags, there must be one more \"-k\" flag than \"-p\" flags. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "direction": {
                "docstring": "Direction in which to detach: 0 - V direction, 1 - U directionDefault:1"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "keep": {
                "docstring": "Keep the detached pieces.Default:trueAdvanced flags"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameter": {
                "docstring": "Parameter at which to detach.Default:0.0"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "deviceEditor": {
        "description": "This creates an editor for creating/modifying attachments to input devices. ", 
        "flags": {
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "takePath": {
                "docstring": "The path used for writing/reading take data through the editor.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "deviceManager": {
        "description": "This command queriers the internal device manager for information on attached devices. In query mode, return type is based on queried flag.", 
        "flags": {
            "attachment": {
                "docstring": "Returns the plugs that a device and axis are attached to. Expects the -deviceIndex and axisIndex to be used in conjunction."
            }, 
            "axisCoordChanges": {
                "docstring": "Returns whether the axis coordinate changes. Expects the -deviceIndex and -axisIndex flags to be used in conjunction.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "axisIndex": {
                "docstring": "Used usually in conjunction with other flags, to indicate the index of the axis."
            }, 
            "axisName": {
                "docstring": "Returns the name of the axis. Expects the -deviceIndex and -axisIndex flags to be used in conjunction."
            }, 
            "axisOffset": {
                "docstring": "Returns the offset of the axis. Expects the -deviceIndex and -axisIndex flags to be used in conjunction."
            }, 
            "axisScale": {
                "docstring": "Returns the scale of the axis. Expects the -deviceIndex and -axisIndex flags to be used in conjunction."
            }, 
            "deviceIndex": {
                "docstring": "Used usually in conjunction with other flags, to indicate the index of the device."
            }, 
            "deviceNameFromIndex": {
                "docstring": "Returns the name of the device with the given index."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "numAxis": {
                "docstring": "Returns the number of axis this device has. Expects the -deviceIndex flag to be used."
            }, 
            "numDevices": {
                "docstring": "Returns the number of devices currently attached."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "devicePanel": {
        "description": "This command is now obsolete. It is included only for the purpose of file compatibility. It creates a blank panel. ", 
        "flags": {
            "control": {
                "docstring": ""
            }, 
            "copy": {
                "docstring": ""
            }, 
            "createString": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "docTag": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editString": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "init": {
                "docstring": ""
            }, 
            "isUnique": {
                "docstring": ""
            }, 
            "label": {
                "docstring": ""
            }, 
            "menuBarVisible": {
                "docstring": ""
            }, 
            "needsInit": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": ""
            }, 
            "popupMenuProcedure": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "replacePanel": {
                "docstring": ""
            }, 
            "tearOff": {
                "docstring": ""
            }, 
            "tearOffCopy": {
                "docstring": ""
            }, 
            "unParent": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": ""
            }
        }
    }, 
    "dgControl": {
        "description": "", 
        "flags": {}
    }, 
    "dgInfo": {
        "description": "This command prints information about the DG in a text-oriented manner. The scope of the information printed is the entire graph if the -all flag is used, the nodes/plugs on the command line if they were specified, and the selection list, in that order. Each plug on a connection will have two pieces of state information displayed together at the end of the line on which they are printed. CLEAN PROPis the normal state for a graph that has been successfully evaluated. It indicates that the plug value in the node's datablock is correct and that any successive changes to it (or values upstream from it) are propagated to all plugs depending on it (e.g. downstream connections or \"affected\" outputs).DIRTY BLOCKis the normal state for a plug whose upstream values have changed but no evaluation request has come through for that plug's value. The DIRTYpart indicates that the current value of the plug held in the datablock may or may not be correct, depending on how the upstream values affect it. Requesting it directly via a getAttrcommand or indirectly via a request for values downstream of it will trigger a DG evaluation of all upstream plugs. The BLOCKpart is an optimization that prevents excessive dirty flag propagation when many values are changing e.g. a frame change in an animated sequece. It means that any changes to values upstream from this plug will not send any further dirty messages to downstream/affected plugs.DIRTY PROPis a less common but still valid state for a plug whose upstream values have changed but no evaluation request has come through for that plug's value. Like the DIRTY BLOCKstate it will trigger an evaluaton when it's value is requested. Where it differs is that when another change comes through from an upstream plug this plug will (again) propagate the dirty message to all downstream/affected plugs. You will only see this state when the DG was not certain that all downstream plugs were notified of their dirty status the last time this plug was marked dirty itself (e.g. if the dirty propagation was intercepted by a node or the graph connections changed since the last dirty message).CLEAN BLOCKshould never be seen in a valid DG. This indicates that while the value of the plug is clean (i.e. valid) it will not propagate a dirty state when its value changes. That means downstream nodes will not be notified that the graph is changing and they will not evaluate properly. Recovering from this invalid state requires entering the command dgdirty -ato mark everything dirty and restart proper evaluation. (Think of this command as the CTL-ALT-DELof the DG world.)", 
        "flags": {
            "allNodes": {
                "docstring": "Use the entire graph as the context"
            }, 
            "connections": {
                "docstring": "Print the connection information"
            }, 
            "dirty": {
                "docstring": "Only print dirty/clean nodes/plugs/connections. Default is both"
            }, 
            "island": {
                "docstring": "Print detailed debug information about the island for each node. Note that this flag will typically generate a large amount of debug information, so it is recommended that the list of nodes passed to the command be brief when using the islandDetail flag. The information includes the full list of nodes in the island, as well as all islands connected to the island."
            }, 
            "nodes": {
                "docstring": "Print the specified nodes (or the entire graph if -all is used)"
            }, 
            "nonDeletable": {
                "docstring": "Include non-deletable nodes as well (normally not of interest)"
            }, 
            "outputFile": {
                "docstring": "Send the output to the file FILE instead of STDERRFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "propagation": {
                "docstring": "Only print propagating/not propagating nodes/plugs/connections. Default is both."
            }, 
            "short": {
                "docstring": "Print using short format instead of long"
            }, 
            "size": {
                "docstring": "Show datablock sizes for all specified nodes. Return value is tuple of all selected nodes (NumberOfNodes, NumberOfDatablocks, TotalDatablockMemory)"
            }, 
            "subgraph": {
                "docstring": "Print the subgraph affected by the node or plugs (or all nodes in the graph grouped in subgraphs if -all is used)"
            }, 
            "type": {
                "docstring": "Filter output to only show nodes of type NODETYPE"
            }
        }
    }, 
    "dgPerformance": {
        "description": "", 
        "flags": {}
    }, 
    "dgcontrol": {
        "description": "", 
        "flags": {
            "iomode": {
                "docstring": ""
            }
        }
    }, 
    "dgdebug": {
        "description": "", 
        "flags": {}
    }, 
    "dgdirty": {
        "description": "The dgdirtycommand is used to force a dependency graph dirty message on a node or plug. Used for debugging to find evaluation problems. If no nodes are specified then the current selection list is used. ", 
        "flags": {
            "allPlugs": {
                "docstring": "Ignore the selected or specified objects and dirty (or clean) all plugs.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "clean": {
                "docstring": "If this flag is set then the attributes are cleaned. Otherwise they are set to dirty."
            }, 
            "verbose": {
                "docstring": "Prints out all of the plugs being set dirty on stdout."
            }
        }
    }, 
    "dgeval": {
        "description": "The dgevalcommand is used to force a dependency graph evaluate of a node or plug. Used for debugging to find propagation problems. ", 
        "flags": {
            "src": {
                "docstring": ""
            }, 
            "verbose": {
                "docstring": "If this flag is used then the results of the evaluation(s) is/are printed on stdout. -src If specified then evaluate node outputs as well as inputs when evaluating an entire node. objectListNormally the selection list is used to determine which objects to evaluate, but you can add to the selection list by specifying which objects you want on the command line.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "dgfilter": {
        "description": "", 
        "flags": {}
    }, 
    "dgfootprint": {
        "description": "", 
        "flags": {}
    }, 
    "dgmodified": {
        "description": "The dgmodifiedcommand is used to find out which nodes in the dependency graph have been modified. This is mostly useful for fixing instances where file new asks you to save when no changes have been made to the scene. ", 
        "flags": {}
    }, 
    "dgstats": {
        "description": "", 
        "flags": {}
    }, 
    "dgtimer": {
        "description": "This command measures dependency graph node performance by managing timers on a per-node basis. Logically, each DG node has a timer associated with it which records the amount of real time spent in various operations on its plugs. The time measurement includes the cost of copying data to the node on behalf of the operation, MEL commands executed by an expression contained in an expression invoked by the node, and includes any wait time such as when a fileTexture node loads an image file from disk. Most DG operations are reported including compute, draw, and dirty propagation. The various operations we measure are called \"metrics\" and the types of timers are called \"timer types\". The various metrics are always measured when timing is on, but are only queried when specified via the -show and -hide flags. The metrics currently supported are listed in detail under the -show flag below. For each metric we support a standard set of timer types. There are three of these: \"self\" for self time (the time specific to the node and not its children), \"inclusive\" (time including children of the node), and \"count\" (number of operations of the given metric on the node). The timing mechanism which is used by dgtimeris built into the DG itself, thus ALL depend nodes can be timed and there is no need for programmers writing plug-ins using the OpenMaya API to add any special code in order for their nodes to be timed -- its all handled transparently. The dgtimercommand allows node timers to be turned on, off, reset to zero, and have their current value displayed, and these operations can be performed globally on all nodes or on a specific set of nodes defined by name, type or parentage. Note that all timer measurements are computed in \"real time\" (the same time measurement you get from a wristwatch) as opposed to \"CPU time\" (which only measures time when the processor is executing your code). All times are displayed in seconds. Use the -query flag to display the current timer values on a node,use -on to turn on timing,use -off to turn off timing,and -reset to reset timers to zero. To display the values measured during timing, there are two approaches. The first method is to use the -query flag can be used to report the information which has been measured. The second method is to use the query methods available on the OpenMaya class MFnDependencyNode (see the OpenMaya documentation for details). What follows is a description of what is generated via -query. The output is broken out into several sections and these are described as follows: SECTION 1:Section 1 of the dgtimer output contains global information. This section can be disabled via the -hoHeader flag. These values are reset whenever a global timer reset occurs (i.e. dgtimer -reset;is specified). The global values which are reported are: Total real time:the total wall-clock time since the last global timer reset. This is the actual time which has been spent as you might measure it measure it with your watch. On a multi-processing system, this value will always remain true to to real time (unlike userand systime).Total user time:the total time the CPU(s) spent processing Maya not including any system time since the last global timer reset.Total sys time:the total time the CPU(s) spent in operating system calls on behalf of Maya since the last global timer reset.Summary of each metric for all nodes:a summary of self and count for each metric that we measure:Real time in callbacksreports the self time and count for the \"callback\" metric.Real time in computereports the self time and count for the \"compute\" metric.Real time in dirty propagationreports the self time and count for the \"dirty\" metric.Real time in drawingreports the self time and count for the \"draw\" metric.Real time fetching data from plugsreports the self time and count for the \"fetch\" metric.Breakdown of select metrics in greater detail:a reporting of certain combinations of metrics that we measure:Real time in compute invoked from callbackreports the self time spent in compute when invoked either directly or indirectly by a callback.Real time in compute not invoked from callbackreports the self time spent in compute not invoked either directly or indirectly by a callback.SECTION 2:Section 2 of the dgtimer -query output contains per-node information. There is a header which describes the meaning of each column, followed by the actual per-node data, and this is ultimately followed by a footer which summarises the totals per column. Note that the data contained in the footer is the global total for each metric and will include any nodes that have been deleted since the last reset, so the value in the footer MAY exceed what you get when you total the individual values in the column. To prevent the header and footer from appearing, use the -noHeader flag to just display the per-node data. The columns which are displayed are as follows: Rank:The order of this node in the sorted list of all nodes, where the list is sorted by -sortMetric and -sortType flag values (if these are omitted the default is to sort by self compute time).ON:Tells you if the timer for that node is currently on or off. (With dgtimer, you have the ability to turn timing on and off on a per-node basis).Per-metric information:various columns are reported for each metric. The name of the metric is reported at in the header in capital letters (e.g. \"DRAW\"). The standard columns for each metric are:Self:The amount of real time (i.e. elapsed time as you might measure it with a stopwatch) spent performing the operation (thus if the metric is \"DRAW\", then this will be time spent drawing the node).Inclusive:The amount of real time (i.e. elapsed time as you might measure it with a stopwatch) spent performing the operation including any child operations that were invoked on behalf of the operation (thus if the metric is \"DRAW\", then this will be the total time taken to draw the node including any child operations).Count:The number of operations that occued on this node (thus if the metric is \"DRAW\", then the number of draw operations on the node will be reported).Sort informationif a column is the one being used to sort all the per-node dgtimer information, then that column is followed by a Percentand Cumulativecolumn which describe a running total through the listing. Note that \"-sortType none\" prevents these two columns from appearing and implicitely sorts on \"self\" time.After the per-metric columns, the node name and type are reported:TypeThe node type.NameThe name of the node. If the node is file referenced and you are using namespaces, the namespace will be included. You can also force the dagpath to be displayed by specifying the -uniqueName flag.Plug-in nameIf the node was implemented in an OpenMaya plug-in, the name of that plug-in is reported.SECTION 3:Section 3 of the dgtimer -query output describes time spent in callbacks. Note that section 3 only appears when the CALLBACK metric is shown (see the -show flag). The first part is SECTION 3.1 lists the time per callback with each entry comprising: The name of the callback, such as \"attributeChangedMsg\". These names are internal Maya names, and in the cases where the callback is available through the OpenMaya API, the API access to the callback is similarly named.The name is followed by a breakdown per callbackId. The callbackId is an identifying number which is unique to each client that is registered to a callback and can be deduced by the user, such as through the OpenMaya API. You can cross-reference by finding the same callbackId value listed in SECTIONs 3.1 and 3.3.Self time (i.e. real time spent within that callbackId type not including any child operations which occur while processing the callback).Percent (see the -sortType flag). Note that the percent values are listed to sum up to 100% for that callback. This is not a global percent.Cumulative (see the -sortType flag).Inclusive time (i.e. real time spent within that callbackId including any child operations).Count (number of times the callbackId was invoked).API lists \"Y\" if the callbackId was defined through the OpenMaya API, and \"N\" if the callbackId was defined internally within Maya.Node lists the name of the node this callbackId was associated with. If the callbackId was associated with more than one node, the string \"\\*multiple\\*\" is printed. If there was no node associated with the callbackId (or its a callback type in which the node is hard to deduce), the entry is blank.After the callbackId entries are listed, a dashed line is printed followed by a single line listing the self, inclusive and count values for the callback. Note that the percent is relative to the global callback time.At the bottom of SECTION 3.1 is the per-column total. The values printed match the summation at the bottom of the listing in section 2. Note that the values from SECTION 3.1 include any nodes that have been deleted since the last reset. The thresholding parameters (-threshold, -rangeLower, -rangeUpper and -maxDisplay) are honoured when generating the listing. The sorting of the rows and display of the Percent and Cumulative columns obeys the -sortType flag. As the listing can be long, zero entries are not displayed. The second part is SECTION 3.2 which lists the data per callbackId. As noted earlier, the callbackId is an identifying number which is unique to each client that is registered to a callback and can be deduced by the user, such as through the OpenMaya API. The entries in SECTION 3.2 appear as follows: CallbackId the numeric identifier for the callback. You can cross reference by finding the same callbackId value listed in SECTIONs 3.1 and 3.3.For each callbackId, the data is broken down per-callback:Callback the name of the callback, e.g. \"attributeChangedMsg\".Percent, Cumulative, Inclusive, Count, API and Node entries as described in SECTION 3.1.After the callback entries are listed for the callbackId, a dashed followed by a summary line is printed. The summary line lists the self, inclusive and count values for the callback. Note that the percent is relative to the global callback time.The third part is SECTION 3.3 which lists data per-callback per-node. The nodes are sorted based on the -sortType flag, and for each node, the callbacks are listed, also sorted based on the -sortType flag. As this listing can be long, zero entries are not displayed. An important note for SECTION 3.3 is that only nodes which still exist are displayed. If a node has been deleted, no infromation is listed. ", 
        "flags": {
            "combineType": {
                "docstring": "Causes all nodes of the same type (e.g. animCurveTA) to be combined in the output display."
            }, 
            "hide": {
                "docstring": "This flag is the converse of -show. As with -show, it is a query-only flag which can be specified multiple times. If you do specify -hide, we display all columns except those listed by the -hide flags."
            }, 
            "hierarchy": {
                "docstring": "Used to specify that a hierarchy of the dependency graph be affected, thus \"-reset -hierarchy -name ball\" will reset the timers on the node named \"ball\" and all of its descendents in the dependency graph."
            }, 
            "maxDisplay": {
                "docstring": "Truncates the display so that only the most expenive \"n\" entries are printed in the output display."
            }, 
            "name": {
                "docstring": "Used in conjunction with -reset or -query to specify the name of the node to reset or print timer values for. When querying a single timer, only a single line of output is generated (i.e. the global timers and header information is omitted). Note that one can force output to the script editor window via the \"-outputFile MEL\" option to make it easy to grab the values in a MEL script. Note: the -name and -type flag cannot be used together."
            }, 
            "noHeader": {
                "docstring": "Used in conjunction with -query to prevent any header or footer information from being printed. All that will be output is the per-node timing data. This option makes it easier to parse the output such as when you output the query to a file on disk using the -outputFileoption."
            }, 
            "outputFile": {
                "docstring": "Specifies where the output of timing or tracing is displayed. The flag takes a string argument which accepts three possible values: The name of a file on disk.Or the keyword \"stdout\", which causes output to be displayed on the terminal window (Linux and Macintosh), and the status window on Windows.Or the keyword \"MEL\", which causes output to be displayed in the Maya Script Editor (only supported with -query).The \"stdout\" setting is the default behaviour. This flag can be used with the -query flag as well as the -trace flag. When used with the -trace flag, any tracing output will be displayed on the destination specified by the -outputFile (or stdout if -outputFile is omitted). Tracing operations will continue to output to the destination until you specify the -trace and -outputFile flags again. When used with the -query flag, timing output will be displayed to the destination specified by the -outputFile (or \"stdout\" if -outputFile is omitted). Here are some examples of how to use the -query, -trace and -outputFile flags: Example: output the timing information to a single file on disk:dgtimer -on;                                       // Turn on timing create some animated scene content; play -wait;                                        // Play the scene through dgtimer -query -outputFile \"/tmp/timing.txt\"       // Output node timing information to a file on disk Example: output the tracing information to a single file on disk:dgtimer -on;                                       // Turn on timing create some animated scene content; dgtimer -trace on -outputFile \"/tmp/trace.txt\"     // Turn on tracing and output the results to file play -wait;                                        // Play the scene through; trace info goes to /tmp/trace.txt dgtimer -query;                                    // But the timing info goes to the terminal window play -wait;                                        // Play the scene again, trace info still goes to /tmp/trace.txt Example: two runs, outputting the trace information and timing information to separate files:dgtimer -on;                                       // Turn on timing create some animated scene content; dgtimer -trace on -outputFile \"/tmp/trace1.txt\"    // Turn on tracing and output the results to file play -wait;                                        // Play the scene through dgtimer -query -outputFile \"/tmp/query1.txt\"       // Output node timing information to another file dgtimer -reset; dgtimer -trace on -outputFile \"/tmp/trace2.txt\"    // Output tracing results to different file play -wait;                                        // Play the scene through dgtimer -query -outputFile \"/tmp/query2.txt\"       // Output node timing information to another file Tips and tricks:Outputting the timing results to the script editor makes it easy to use the results in MEL e.g. string $timing[] = `dgtimer -query -outputFile MEL`.It is important to note that the -outputFile you specify with -trace is totally independent from the one you specify with -query.If the file you specify already exists, Maya will empty the file first before outputting data to it (and if the file is not writable, an error is generated instead)."
            }, 
            "overhead": {
                "docstring": "Turns on and off the measurement of timing overhead. Under ordinary circumstances the amount of timing overhead is minimal compared with the events being measured, but in complex scenes, one might find the overhead to be measurable. By default this option is turned off. To enable it, specify \"dgtimer -overhead true\" prior to starting timing. When querying timing, the overhead is reported in SECTION 1.2 of the dgtimer output and is not factored out of each individual operation."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rangeLower": {
                "docstring": "This flag can be specified to limit the range of nodes which are displayed in a query, or the limits of the heat map with -updateHeatMap. The value is the lower percentage cutoff for the nodes which are processed. There is also a -rangeLower flag which sets the lower range limit. The default value is 0, meaning that all nodes with timing value below the upper range limit are considered."
            }, 
            "rangeUpper": {
                "docstring": "This flag can be specified to limit the range of nodes which are displayed in a query, or the limits of the heat map with -updateHeatMap. The value is the upper percentage cutoff for the nodes which are processed. There is also a -rangeLower flag which sets the lower range limit. The default value is 100, meaning that all nodes with timing value above the lower range limit are considered.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reset": {
                "docstring": "Resets the node timers to zero. By default, the timers on all nodes as well as the global timers are reset, but if specified with the -name or -type flags, only the timers on specified nodes are reset."
            }, 
            "returnCode": {
                "docstring": "This flag has been replaced by the more general -returnType flag. The -returnCode flag was unfortunately specific to the compute metric only. It exists only for backwards compatability purposes. It will be removed altogether in a future release. Here are some handy equivalences: To get the total number of nodes:OLD WAY: dgtimer -rc nodecount -q;// Result:325//NEW WAY: dgtimer -returnType total -sortType none -q;// Result:325//OLD WAY: dgtimer -rc count -q;// Result:1270//To get the sum of the compute count column:NEW WAY: dgtimer -returnType total -sortMetric compute -sortType count -q;// Result:1270//OLD WAY: dgtimer -rc selftime -q;// Result:0.112898//To get the sum of the compute self column:NEW WAY: dgtimer -returnType total -sortMetric compute -sortType self -q;// Result:0.112898//"
            }, 
            "returnType": {
                "docstring": "This flag specifies what the double value returned by the dgtimer command represents. By default, the value returned is the global total as displayed in SECTION 1 for the column we are sorting on in the per-node output (the sort column can be specified via the -sortMetric and -sortType flags). However, instead of the total being returned, the user can instead request the individual entries for the column. This flag is useful mainly for querying without forcing any output. The flag accepts the values \"total\", to just display the column total, or \"all\" to display all entries individually. For example, if you want to get the total of draw self time without any other output simply specify the following:dgtimer -returnType total -sortMetric draw -sortType self -threshold 100 -noHeader -query;// Result: 7718.01 // To instead get each individual entry, change the above query to:dgtimer -returnType all -sortMetric draw -sortType self -threshold 100 -noHeader -query;// Result: 6576.01 21.91 11.17 1108.92 // To get the inclusive dirty time for a specific node, use -name as well as -returnType all:dgtimer -name \"virginia\" -returnType all -sortMetric dirty -sortType inclusive -threshold 100 -noHeader -query;Note: to get the total number of nodes, use \"-sortType none -returnType total\". To get the on/off status for each node, use \"-sortType none -returnType all\"."
            }, 
            "show": {
                "docstring": "Used in conjunction with -query to specify which columns are to be displayed in the per-node section of the output. -show takes an argument, which can be \"all\" (to display all columns), \"callback\" (to display the time spent during any callback processing on the node not due to evaluation), \"compute\" (to display the time spent in the node's compute methods), \"dirty\" (to display time spent propagating dirtiness on behalf of the node), \"draw\" (to display time spent drawing the node), \"compcb\" (to display time spent during callback processing on node due to compute), and \"compncb\" (to display time spent during callback processing on node NOT due to compute). The -show flag can be used multiple times, but cannot be specified with -hide. By default, if neither -show, -hide, or -sort are given, the effective display mode is: \"dgtimer -show compute -query\"."
            }, 
            "sortMetric": {
                "docstring": "Used in conjunction with -query to specify which metric is to be sorted on when the per-node section of the output is generated, for example \"draw\" time. Note that the -sortType flag can also be specified to define which timer is sorted on: for example \"dgtimer -sortMetric draw -sortType count -query\" will sort the output by the number of times each node was drawn. Both -sortMetric and -sortType are optional and you can specify one without the other. The -sortMetric flag can only be specified at most once. The flag takes the following arguments: \"callback\" (to sort on time spent during any callback processing on the node), \"compute\" (to sort on the time spent in the node's compute methods), \"dirty\" (to sort on the time spent propagating dirtiness on behalf of the node), \"draw\" (to sort on time spent drawing the node), \"fetch\" (to sort on time spent copying data from the datablock), The default, if -sortMetric is omitted, is to sort on the first displayed column. Note that the sortMetric is independent of which columns are displayed via -show and -hide. Sort on a hidden column is allowed. The column selected by -sortMetric and -sortType specifies which total is returned by the dgtimer command on the MEL command line. This flag is also used with -updateHeatMap to specify which metric to build the heat map for."
            }, 
            "sortType": {
                "docstring": "Used in conjunction with -query to specify which timer is to be sorted on when the per-node section of the output is generated, for example \"self\" time. Note that the -sortMetric flag can also be specified to define which metric is sorted on: for example \"dgtimer -sortMetric draw -sortType count -query\" will sort the output by the number of times each node was drawn. Both -sortMetric and -sortType are optional and you can specify one without the other. The -sortType flag can be specified at most once. The flag takes the following arguments: \"self\" (to sort on self time, which is the time specific to the node and not its children), \"inclusive\" (to sort on the time including children of the node), \"count\" (to sort on the number of times the node was invoked). and \"none\" (to sort on self time, but do not display the Percent and Cumulative columns in the per-node display, as well as cause the total number of nodes in Maya to be returned on the command line). The default, if -sortType is omitted, is to sort on self time. The column selected by -sortMetric and -sortType specifies which total is returned by the dgtimer command on the MEL command line. The global total as displayed in SECTION 1 of the listing is returned. The special case of \"-sortType none\" causes the number of nodes in Maya to instead be returned. This flag is also used with -updateHeatMap to specify which metric to build the heat map for."
            }, 
            "threshold": {
                "docstring": "Truncates the display once the value falls below the threshold value. The threshold applies to whatever timer is being used for sorting. For example, if our sort key is self compute time (i.e. -sortMetric is \"compute\" and -sortType is \"self\") and the threshold parameter is 20.0, then only nodes with a compute self-time of 20.0 or higher will be displayed. (Note that -threshold uses absolute time. There are the similar -rangeUpper and -rangeLower parameters which specify a range using percentage)."
            }, 
            "timerOff": {
                "docstring": "Turns off node timing. By default, the timers on all nodes are turned off, but if specified with the -name or -type flags, only the timers on specified nodes are turned off. If the timers on all nodes become turned off, then global timing is also turned off as well."
            }, 
            "timerOn": {
                "docstring": "Turns on node timing. By default, the timers on all nodes are turned on, but if specified with the -name or -type flags, only the timers on specified nodes are turned on. The global timers are also turned on by this command. Note that turning on timing does NOT reset the timers to zero. Use the -reset flag to reset the timers. The idea for NOT resetting the timers is to allow the user to arbitrarily turn timing on and off and continue to add to the existing timer values."
            }, 
            "trace": {
                "docstring": "Turns on or off detailed execution tracing. By default, tracing is off. If enabled, each timeable operation is logged when it starts and again when it ends. This flag can be used in conjunction with -outputFile to specify where the output is generated to. The following example shows how the output is formatted:dgtimer:begin: compute 3 particleShape1Deformed particleShape1Deformed.lastPositionThe above is an example of the output when -trace is true that marks the start of an operation. For specific details on each field: the \"dgtimer:begin:\" string is an identifying marker to flag that this is a begin operation record. The second argument, \"compute\" in our example, is the operation metric. You can view the output of each given metric via \"dgtimer -q\" by specifying the -show flag. The integer which follows (3 in this case) is the depth in the operation stack, and the third argument is the name of the node (particleShape1Deformed). The fourth argument is specific to the metric. For \"compute\", it gives the name of the plug being computed. For \"callback\", its the internal Maya name of the callback. For \"dirty\", its the name of the plug that dirtiness is being propagated from.dgtimer:end: compute 3 particleShape1Deformed 0.000305685 0.000305685The above is the end operation record. The \"compute\", \"3\" and \"particleShapeDeformed\" arguments were described in the \"dgtimer:begin\" overview earlier. The two floating-point arguments are self time and inclusive time for the operation measured in seconds. The inclusive measure lists the total time since the matching \"dgtimer:begin:\" entry for this operation, while the self measure lists the inclusive time minus any time consumed by child operations which may have occurred during execution of the current operation. As noted elsewhere in this document, these two times are \"wall clock times\", measuring elapsed time including any time in which Maya was idle or performing system calls. Since dgtimer can measure some non-node qualities in Maya, such as global message callbacks, a \"-\" is displayed where the node name would ordinarily be displayed. The \"-\" means \"not applicable\"."
            }, 
            "type": {
                "docstring": "Used in conjunction with -reset or -query to specify the type of the node(s) (e.g. animCurveTA) to reset or print timer values for. When querying, use of the -combineType flag will cause all nodes of the same type to be combined into one entry, and only one line of output is generated (i.e. the global timers and header information is omitted). Note: the -name and -type flag cannot be used together."
            }, 
            "uniqueName": {
                "docstring": "Used to specify that the DAG nodes listed in the output should be listed by their unique names. The full DAG path to the object will be printed out instead of just the node name."
            }, 
            "updateHeatMap": {
                "docstring": "Forces Maya's heat map to rebuild based on the specified parameters. The heat map is an internal dgtimer structure used in mapping intensity values to colourmap entries during display by the HyperGraph Editor. There is one heat map shared by all editors that are using heat map display mode. Updating the heat map causes the timer values on all nodes to be analysed to compose the distribution of entries in the heat map. The parameter is the integer number of divisions in the map and should equal the number of available colours for displaying the heat map. This flag can be specified with the -rangeLower and -rangeUpper flags to limit the range of displayable to lie between the percentile range. The dgtimer command returns the maximum timing value for all nodes in Maya for the specified metric and type. Note: when the display range includes 0, the special zeroth (exactly zero) slot in the heat map is avilable."
            }
        }
    }, 
    "dimWhen": {
        "description": "This method attaches the named UI object (first argument) to the named condition (second argument) so that the object will be dimmed when the condition is in a particular state. This command will fail if the object does not exist. If the condition does not exist (yet), that's okay --- a placeholder will be used until such a condition comes into existence. The UI object should be one of two things, either a control or a menu item. ", 
        "flags": {
            "clear": {
                "docstring": "Remove the condition on the specified dimmable.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "false": {
                "docstring": "Dim the object when the condition is false."
            }, 
            "true": {
                "docstring": "Dim the object when the condition is true. (default)"
            }
        }
    }, 
    "directConnectPath": {
        "description": "", 
        "flags": {}
    }, 
    "directKeyCtx": {
        "description": "This command creates a context which may be used to directly manipulate keyframes within the graph editor ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "option": {
                "docstring": "Valid values are \"move,\" \"insert,\" \"over,\" and \"segmentOver.\" When you \"move\" a key, the key will not cross over (in time) any keys before or after it. When you \"insert\" a key, all keys before or after (depending upon the -timeChange value) will be moved an equivalent amount. When you \"over\" a key, the key is allowed to move to any time (as long as a key is not there already). When you \"segmentOver\" a set of keys (this option only has a noticeable effect when more than one key is being moved) the first key (in time) and last key define a segment (unless you specify a time range). That segment is then allowed to move over other keys, and keys will be moved to make room for the segment."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectedOnly": {
                "docstring": "Controls whether only selected curves/keys can be moved, or all.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "directionalLight": {
        "description": "The directionalLight command is used to edit the parameters of existing directionalLights, or to create new ones. The default behaviour is to create a new directionallight. ", 
        "flags": {
            "decayRate": {
                "docstring": "decay rate of the light (0-no decay, 1-slow, 2-realistic, 3-fast)"
            }, 
            "discRadius": {
                "docstring": "radius of the disc around the light"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": ""
            }, 
            "intensity": {
                "docstring": "intensity of the light (expressed as a percentage)"
            }, 
            "name": {
                "docstring": "specify the name of the light"
            }, 
            "position": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rgb": {
                "docstring": "color of the light (0-1)"
            }, 
            "rotation": {
                "docstring": ""
            }, 
            "shadowColor": {
                "docstring": "the shadow color"
            }, 
            "shadowDither": {
                "docstring": "dither the shadow"
            }, 
            "shadowSamples": {
                "docstring": "number of shadow samples."
            }, 
            "softShadow": {
                "docstring": "soft shadowFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useRayTraceShadows": {
                "docstring": "ray trace shadows"
            }
        }
    }, 
    "dirmap": {
        "description": "Use this command to map a directory to another directory. The first argument is the directory to map, and the second is the destination directory to map to. Directories must both be absolute paths, and should be separated with forward slashes ('/'). The mapping is case-sensitive on all platforms. This command can be useful when moving projects to another machine where some textures may not be contained in the Maya project, or when a texture archive moves to a new location. This command is not necessary when moving a (self-contained) project from one machine to another - instead copy the entire project over and set the Maya project to the new location. For one-time directory moves, if the command is enabled and the mapping configured correctly, when a scene is opened and saved the mapped locations will be reflected in the filenames saved with the file. To set up a permanent mapping the command should be enabled and the mappings set up in a script which is executed every time you launch Maya (userSetup.mel is sourced on startup). The directory mappings and enabled state are not preserved between Maya sessions. This command requires one \"main\" flag that specifies the action to take. Flags are:-[m|um|gmd|gam|cd|en]", 
        "flags": {
            "convertDirectory": {
                "docstring": "Convert a file or directory. Returns the name of the mapped file or directory, if the command is enabled. If the given string contains one of the mapped directories, the return value will have that substring replaced with the mapped one. Otherwise the given argument string will be returned. If the command is disabled the given argument is always returned. Checks are not made for whether the file or directory exists. If the given string is a directory it should have a trailing '/'.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "enable": {
                "docstring": "Enable directory mapping. Directory mapping is off when you start Maya. If enabled, when opening Maya scenes, file texture paths (and other file paths) will be converted when the scene is opened. The -cd flag only returns mapped directories when -enable is true. Query returns whether mapping has been enabled."
            }, 
            "getAllMappings": {
                "docstring": "Get all current mappings. Returns string array of current mappings in format: [redirect1, replacement1, ... redirectN, replacementN]"
            }, 
            "getMappedDirectory": {
                "docstring": "Get the mapped redirected directory. The given argument must exactly match the first string used with the -mapDirectory flag."
            }, 
            "mapDirectory": {
                "docstring": "Map a directory - the first argument is mapped to the second. Neither directory needs to exist on the local machine at the time of invocation."
            }, 
            "query": {
                "docstring": ""
            }, 
            "unmapDirectory": {
                "docstring": "Unmap a directory. The given argument must exactly match the argument used with the -mapDirectory flag."
            }
        }
    }, 
    "disable": {
        "description": "This command enables or disables the control passed as argument. ", 
        "flags": {
            "value": {
                "docstring": "If true, this command disables the control. If false, this command enables the control. Default value is true (disable)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "disconnectAttr": {
        "description": "Disconnects two connected attributes. First argument is the source attribute, second is the destination. ", 
        "flags": {
            "nextAvailable": {
                "docstring": "If the destination multi-attribute has set the indexMatters to be false, the command will disconnect the first matching connection. No index needs to be specified.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "disconnectJoint": {
        "description": "This command will break a skeleton at the selected joint and delete any associated handles. ", 
        "flags": {
            "attachHandleMode": {
                "docstring": "This flag is obsolete and no longer supported.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "deleteHandleMode": {
                "docstring": "Delete the handle on the associated joint."
            }
        }
    }, 
    "diskCache": {
        "description": "Command to create, clear, or close disk cache(s). In query mode, return type is based on queried flag.", 
        "flags": {
            "append": {
                "docstring": "Append at the end and not to flush the existing cache"
            }, 
            "cacheType": {
                "docstring": "Specifies the type of cache to overwrite. \"mcfp\" for particle playback cache, \"mcfi\" for particle initial cache. \"mcj\" for jiggle cache. This option is only activated during the cache creation."
            }, 
            "close": {
                "docstring": "Close the cache given the disk cache node name. If -eco/enabledCachesOnly is \"true\" only enabled disk cache nodes are affected."
            }, 
            "closeAll": {
                "docstring": "Close all disk cache files. If -eco/enabledCachesOnly is \"true\" only enabled disk cache nodes are affected."
            }, 
            "delete": {
                "docstring": "Delete the cache given the disk cache node name. If -eco/enabledCachesOnly is \"true\" only enabled disk cache nodes are affected."
            }, 
            "deleteAll": {
                "docstring": "Delete all disk cache files. If -eco/enabledCachesOnly is \"true\" only enabled disk cache nodes are affected."
            }, 
            "empty": {
                "docstring": "Clear the content of the disk cache with the given disk cache node name. If -eco/enabledCachesOnly is \"true\" only enabled disk cache nodes are affected."
            }, 
            "emptyAll": {
                "docstring": "Clear the content of all disk caches. If -eco/enabledCachesOnly is \"true\" only enabled disk cache nodes are affected."
            }, 
            "enabledCachesOnly": {
                "docstring": "When present, this flag restricts the -ea/emptyAll, so that only \"enabled\" disk caches (i.e., disk cache nodes with the \".enable\" attribute set to \"true\") are affected."
            }, 
            "endTime": {
                "docstring": "Specifies the end frame of the cache range."
            }, 
            "frameRangeType": {
                "docstring": "Specifies the type of frame range to use, namely \"Render Globals\", \"Time Slider\", and \"Start/End\". In the case of \"Time Slider\", startFrame and endFrame need to be specified. (This flag is now obsolete. Please use the -startTime and -endTime flags to specify the frame range explicitly.)"
            }, 
            "overSample": {
                "docstring": "Over sample if true. Otherwise, under sample."
            }, 
            "query": {
                "docstring": ""
            }, 
            "samplingRate": {
                "docstring": "Specifies how frequently to sample relative to each frame. When over-sampling (-overSample has been specified), this parameter determines how many times per frame the runup will be evaluated. When under-sampling (the default, when -overSample has not been specified), the runup will evaluate only once per srframes, where sris the value specified to this flag."
            }, 
            "startTime": {
                "docstring": "Specifies the start frame of the cache range."
            }, 
            "tempDir": {
                "docstring": "Query-only flag for the location of temporary diskCache files.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "dispatchGenericCommand": {
        "description": "", 
        "flags": {}
    }, 
    "displacementToPoly": {
        "description": "Command bakes geometry with displacement mapping into a polygonal object. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "findBboxOnly": {
                "docstring": "When used, only the bounding box scale for the displaced object is found.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "displayAffected": {
        "description": "Turns on/off the special coloring of objects that are affected by the objects that are currently in the selection list. If one of the curves in a loft were selected and this feature were turned on, then the lofted surface would be highlighted because it is affected by the loft curve. ", 
        "flags": {
            "query": {
                "docstring": ""
            }
        }
    }, 
    "displayColor": {
        "description": "This command changes or queries the display color for anything in the application that allows the user to set its color. The color is defined by a color index into either the dormant or active color palette. These colors are part of the UI and not part of the saved data for a model. This command is not undoable. In query mode, return type is based on queried flag.", 
        "flags": {
            "active": {
                "docstring": "Specifies the color index applies to active color palette. name Specifies the name of color to change. index The color index for the color."
            }, 
            "create": {
                "docstring": "Creates a new display color which can be queried or set. If is used only when saving color preferences."
            }, 
            "dormant": {
                "docstring": "Specifies the color index applies to dormant color palette. If neither of the dormant or active flags is specified, dormant is the default."
            }, 
            "list": {
                "docstring": "Writes out a list of all color names and their value."
            }, 
            "query": {
                "docstring": ""
            }, 
            "queryIndex": {
                "docstring": "Allows you to obtain a list of color names with the given color indices.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "resetToFactory": {
                "docstring": "Resets all display colors to their factory defaults."
            }, 
            "resetToSaved": {
                "docstring": "Resets all display colors to their saved values."
            }
        }
    }, 
    "displayCull": {
        "description": "This command is responsible for setting the display culling property of back faces of surfaces. In query mode, return type is based on queried flag.", 
        "flags": {
            "backFaceCulling": {
                "docstring": "Enable/disable culling of back faces.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "displayLevelOfDetail": {
        "description": "This command is responsible for setting the display level-of-detail for edit refreshes. If enabled, objects will draw with lower detail based on their distance from the camera. When disabled objects will display at full resolution at all times. This is not an undoable command In query mode, return type is based on queried flag.", 
        "flags": {
            "levelOfDetail": {
                "docstring": "Enable/disable level of detail.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "displayPref": {
        "description": "This command sets/queries the state of global display parameters. In query mode, return type is based on queried flag.", 
        "flags": {
            "activeObjectPivots": {
                "docstring": "Sets the display state for drawing pivots for active objects."
            }, 
            "displayAffected": {
                "docstring": "Turns on/off the special coloring of objects that are affected by the objects that are currently in the selection list. If one of the curves in a loft were selected and this feature were turned on, then the lofted surface would be highlighted because it is affected by the loft curve."
            }, 
            "displayGradient": {
                "docstring": "Set whether to display the background using a colored gradient as opposed to a constant background color.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "ghostFrames": {
                "docstring": "Sets the ghosting frame preferences: steps before, steps after and step size."
            }, 
            "maxHardwareTextureResolution": {
                "docstring": "Query the maximum allowable hardware texture resolution available on the current video card. This maximum can vary between different video cards and different operating systems."
            }, 
            "maxTextureResolution": {
                "docstring": "Sets the maximum hardware texture resolution to be used when creating hardware textures for display. The maximum will be clamped to the maximum allowable texture determined for the hardware at the time this command is invoked. Use the -maxHardwareTextureResolution to retrieve this maximum value. Existing hardware textures are not affected. Only newly created textures will be clamped to this maximum."
            }, 
            "purgeExistingTextures": {
                "docstring": "Purge any existing hardware textures. This will force a re-evaluation of hardware textures used for display, and thus may take some time to evaluate."
            }, 
            "query": {
                "docstring": ""
            }, 
            "regionOfEffect": {
                "docstring": "Turns on/off the display of the region of curves/surfaces that is affected by changes to selected CVs and edit points."
            }, 
            "shadeTemplates": {
                "docstring": "Turns on/off the display of templated surfaces as shaded in shaded display mode. If its off, templated surfaces appear in wireframe."
            }, 
            "textureDrawPixel": {
                "docstring": "Sets the display mode for drawing image planes. True for use of gltexture calls for perspective views. This flag should not normally be needed. Image Planes may display faster on Windows but can result in some display artifacts."
            }, 
            "wireframeOnShadedActive": {
                "docstring": "Sets the display state for drawing the wireframe on active shaded objects. Possible values for the string argument are \"full\", \"reduced\" and \"none\"."
            }
        }
    }, 
    "displayRGBColor": {
        "description": "This command changes or queries the display color for anything in the application that allows the user to set its color. These colors are part of the UI and not part of the saved data for a model. This command is not undoable. ", 
        "flags": {
            "create": {
                "docstring": "Creates a new RGB display color which can be queried or set. If is used only when saving color preferences. name Specifies the name of color to change."
            }, 
            "hueSaturationValue": {
                "docstring": "Indicates that rgb values are really hsv values. Upon query, returns the HSV valuses as an array of 3 floats. r g b The RGB values for the color. (Between 0-1)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "list": {
                "docstring": "Writes out a list of all RGB color names and their value."
            }, 
            "query": {
                "docstring": ""
            }, 
            "resetToFactory": {
                "docstring": "Resets all the RGB display colors to their factory defaults."
            }, 
            "resetToSaved": {
                "docstring": "Resets all the RGB display colors to their saved values."
            }
        }
    }, 
    "displaySmoothness": {
        "description": "This command is responsible for setting the display smoothness of NURBS curves and surfaces to either predefined or custom values. It also sets display modes for smoothness such as hulls and the hull simplification factors. At present, this command is NOT un-doable. In query mode, return type is based on queried flag.", 
        "flags": {
            "all": {
                "docstring": "Change smoothness for all curves and surfaces"
            }, 
            "boundary": {
                "docstring": "Display wireframe surfaces using only the boundaries of the surface Not fully implemented yet"
            }, 
            "defaultCreation": {
                "docstring": "The default values at creation (applies only -du, -dv, -pw, -ps)"
            }, 
            "divisionsU": {
                "docstring": "Number of isoparm divisions per span in the U direction. The valid range of values is [0,64]."
            }, 
            "divisionsV": {
                "docstring": "Number of isoparm divisions per span in the V direction. The valid range of values is [0,64]."
            }, 
            "full": {
                "docstring": "Display surface at full resolution - the default."
            }, 
            "hull": {
                "docstring": "Display surface using the hull (control points are drawn rather than surface knot points). This mode is a useful display performance improvement when modifying a surface since it doesn't require evaluating points on the surface."
            }, 
            "pointsShaded": {
                "docstring": "Number of points per surface span in shaded mode. The valid range of values is [1,64]."
            }, 
            "pointsWire": {
                "docstring": "Number of points per surface isoparm span or the number of points per curve span in wireframe mode. The valid range of values is [1,128]. Note: This is the only flag that also applies to nurbs curves."
            }, 
            "polygonObject": {
                "docstring": "Display the polygon objects with the given resolutionFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "renderTessellation": {
                "docstring": "Display using render tesselation parameters when in shaded mode."
            }, 
            "simplifyU": {
                "docstring": "Number of spans to skip in the U direction when in hull display mode."
            }, 
            "simplifyV": {
                "docstring": "Number of spans to skip in the V direction when in hull display mode."
            }
        }
    }, 
    "displayStats": {
        "description": "", 
        "flags": {
            "frameRate": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "displayString": {
        "description": "Assign a string value to a string identifier. Allows you define a string in one location and then refer to it by its identifier in many other locations. Formatted strings are also supported (NOTE however, this functionality is now provided in a more general fashion by the format command, use of format is recommended). You may embed up to 3 special character sequences ^1s, ^2s, and ^3s to perform automatic string replacement. The embedded characters will be replaced with the extra command arguments. See example section for more detail. Note the extra command arguments do not need to be display string identifiers. In query mode, return type is based on queried flag.", 
        "flags": {
            "delete": {
                "docstring": "This flag is used to remove an identifer string. The command will fail if the identifier does not exist."
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified identifier exists."
            }, 
            "keys": {
                "docstring": "List all displayString keys that match the identifier string. The identifier string may be a whole or partial key string. The command will return a list of all identifier keys that contain this identifier string as a substring.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replace": {
                "docstring": "Since a displayString command will fail if it tries to assign a new value to an existing identifer, this flag is required to allow updates to the value of an already-existing identifier. If the identifier does not already exist, a new identifier is added as if the -replace flag were not present."
            }, 
            "value": {
                "docstring": "The display string\\'s value. If you do not specify this flag when creating a display string then the value will be the same as the identifier."
            }
        }
    }, 
    "displaySurface": {
        "description": "This command toggles display options on the specified or active surfaces. Typically this command applies to NURBS or poly mesh surfaces and ignores other type of objects. ", 
        "flags": {
            "flipNormals": {
                "docstring": "flip normal direction on the surface"
            }, 
            "query": {
                "docstring": ""
            }, 
            "twoSidedLighting": {
                "docstring": "toggle if the surface should be considered two-sided. If it's single-sided, drawing and rendering may use single sided lighting and back face cull to improve performance.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "xRay": {
                "docstring": "toggle X ray mode (make surface transparent)"
            }
        }
    }, 
    "distanceDimContext": {
        "description": "Command used to register the distanceDimCtx tool. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "distanceDimension": {
        "description": "This command is used to create a distance dimension to display the distance between two specified points. ", 
        "flags": {
            "endPoint": {
                "docstring": "Specifies the point to measure distance to, from the startPoint.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "startPoint": {
                "docstring": "Specifies the point to start measuring distance from."
            }
        }
    }, 
    "doBlur": {
        "description": "The doBlur command will invoke the blur2d, which is a Maya stand-alone application to do 2.5 motion blur given the color image and the motion vector file. For a given input colorFile name, e.g. \"xxx.iff\", the output blurred image will be \"xxx_blur.iff\" in the same directory as the input colorFile. There is currently no control over the name of the output blurred image. ", 
        "flags": {
            "colorFile": {
                "docstring": "Name of the input color image to be blurred."
            }, 
            "length": {
                "docstring": "Scale applied on the motion vector. Ranges from 0 to infinity."
            }, 
            "memCapSize": {
                "docstring": ""
            }, 
            "sharpness": {
                "docstring": "Determines the shape of the blur filter. The higher the value, the narrower the filter, the sharper the blur. The lower the value, the wider the filter, the more spread out the blur. Ranges from 0 to infinity."
            }, 
            "smooth": {
                "docstring": "Filter size to smooth the blurred image. The higher the value, the more anti-aliased the alpha channel. Ranges from 1.0 to 5.0."
            }, 
            "smoothColor": {
                "docstring": "Whether to smooth the color or not."
            }, 
            "vectorFile": {
                "docstring": "Name of the input motion vector file.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "dockControl": {
        "description": "Create a dockable control, also known as tool palette or utility window. Dock controls are secondary windows placed in the dock area around the central control in a main window. Dock windows can be moved inside their current area, moved into new areas and floated (e.g. undocked). Dock control consists of a title bar and the content area. The titlebar displays the dock control window title, a float button and a close button. Depending on the state of the dock control, the float and close buttons may be either disabled or not shown at all. ", 
        "flags": {
            "allowedArea": {
                "docstring": "Areas where the dock control may be placed. Valid values are \"top\", \"left\", \"bottom\", \"right\" and \"all\". The default is \"all\"."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "area": {
                "docstring": "The initial dock area for this dock control. This is a required flag."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "content": {
                "docstring": "The name of the control that is the content of this dock control. This is a required flag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enablePopupOption": {
                "docstring": "Whether or not the menu option for the dock control in the UI Elements popup menu is enabled."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "floatChangeCommand": {
                "docstring": "The script executed when the floating state of the dock widget changes."
            }, 
            "floating": {
                "docstring": "Whether the dock widget is floating. A floating dock widget is presented to the user as an independent window \"on top\" of main window, instead of being docked in the main window."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The label text. The default label is the name of the control."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "r": {
                "docstring": "Whether the dock widget is visible and either floating or at the top of its dock widget area.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "dolly": {
        "description": "The dolly command moves a camera along the viewing direction in the world space. The viewing-direction and up-direction of the camera are not altered. There are two modes of operation: Relative mode: for a perspective camera, the camera is moved along its viewing direction, and the distance of travel is computed with respect to the current position of the camera in the world space. In relative mode, when the camera is moved, its COI is moved along with it, and is kept at the same distance, in front of the camera, as before applying the dolly operation. For orthographic camera, the viewing width of the camera is changed by scaling its ortho width by the new value specified on the command line. Absolute mode: for a perspective camera, the camera is moved along its viewing direction, to the distance that is computed with respect to the current position of the world center of interest (COI) of the camera. In the absolute mode, when the camera is moved, the COI of the camera is not moved with the camera, but it is fixed at its current location in space. For orthographic camera, the viewing width of the camera is changed by replacing its ortho width with the new value specified on the command line. This command may be applied to more than one cameras; objects that are not cameras are ignored. When no camera name supplied on the command line, this command is applied to all currently active cameras. The dolly command can be applied to either a perspective or an orthographic camera. ", 
        "flags": {
            "absolute": {
                "docstring": "This flag modifies the behavior of the distance and orthoScale flags. When used in conjunction with the distance flag, the distance argument specifies how far the camera's eye point should be set from the camera's center of interest. When used with the orthoScale flag, the orthoScale argument specifies the camera's new ortho width."
            }, 
            "distance": {
                "docstring": "Unit distance to dolly a perspective camera."
            }, 
            "dollyTowardsCenter": {
                "docstring": "This flag controls whether the dolly is performed towards the center of the view (if true), or towards the point where the user clicks (if false). By default, dollyTowardsCenter is on.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "orthoScale": {
                "docstring": "Scale to change the ortho width of an orthographic camera."
            }, 
            "relative": {
                "docstring": "This flag modifies the behavior of the distance and orthoScale flags. When used in conjunction with the distance flag, the camera eye and center of interest are both moved by the amount specified by the distance flag's argument. When used with the orthoScale flag, the orthoScale argument is used multiply the camera's ortho width.By default the relative flag is always on."
            }
        }
    }, 
    "dollyCtx": {
        "description": "This command can be used to create, edit, or query a dolly context. ", 
        "flags": {
            "alternateContext": {
                "docstring": "Set the ALT+LMB+MMB and ALT+CRL+LMB to refer to this context."
            }, 
            "boxDollyType": {
                "docstring": "Set the behavior of where the camera's center of interest is set to after the box dolly. In surfacemode, the center of interest will be snapped to the surface point at the center of the marquee. In bboxmode, the closest bounding box to the camera will be used. Bounding box mode will use the selection mask to determine which objects to include into the calculation."
            }, 
            "centerOfInterestDolly": {
                "docstring": "Set the translate the camera's center of interest. Left and right drag movements with the mouse will translate the center of interest towards or away respectively from the camera. The center of interest can be snapped to objects by using the left mouse button for selection. The default select mask will be used."
            }, 
            "dollyTowardsCenter": {
                "docstring": "Dolly towards center (if true), else dolly towards point where user clicks in the view.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "localDolly": {
                "docstring": "Dolly with respect to the camera's center of interest. The camera will not pass through the center of interest. Local dolly only applies to perspective cameras."
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "scale": {
                "docstring": "The sensitivity for dollying the camera."
            }, 
            "toolName": {
                "docstring": ""
            }
        }
    }, 
    "dopeSheetEditor": {
        "description": "Edit a characteristic of a dope sheet editor ", 
        "flags": {
            "autoFit": {
                "docstring": "on | off | tgl auto fit-to-view"
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "displayActiveKeyTangents": {
                "docstring": "on | off | tgl display tangents in the editor"
            }, 
            "displayActiveKeys": {
                "docstring": "on | off | tgl display tangents in the editor"
            }, 
            "displayInfinities": {
                "docstring": "on | off | tgl display infinities in the editor"
            }, 
            "displayKeys": {
                "docstring": "on | off | tgl display keyframes in the editor"
            }, 
            "displayTangents": {
                "docstring": "on | off | tgl display tangents in the editor"
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "hierarchyBelow": {
                "docstring": "display animation for objects hierarchically"
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "lookAt": {
                "docstring": "all | selected | currentTime fitView helpers"
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "outliner": {
                "docstring": "the name of the outliner which is associated with the dope sheet"
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "selectionWindow": {
                "docstring": "The selection area specified as left, right, bottom, top respectively.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "showScene": {
                "docstring": "display the scene summary object"
            }, 
            "showSummary": {
                "docstring": "display the summary object"
            }, 
            "showTicks": {
                "docstring": "display per animation tick divider in channel"
            }, 
            "snapTime": {
                "docstring": "none | integer | keyframe keyframe move snap in time"
            }, 
            "snapValue": {
                "docstring": "none | integer | keyframe keyframe move snap in values"
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "doubleProfileBirailSurface": {
        "description": "The arguments are 4 cuves called \"profile1\" \"profile2\" \"rail1\" \"rail2\". This command builds a railed surface by sweeping profile \"profile1\" along the two given rail curves \"rail1\", \"rail2\" until \"profile2\" is reached. By using the -blend control, the railed surface creation could be biased more towards one of the two profile curves. The curves ( both profiles and rails ) could also be surface curves ( isoparams, curve on surfaces ). If the profile curves are surface curves the surface constructed could be made tangent continuous to the surfaces underlying the profiles using the flags -tp1, -tp2 respectively. Current Limitation: Its necessary that the two profile curves intersect the rail curves for successful surface creation. ", 
        "flags": {
            "blendFactor": {
                "docstring": "A blend factor applied in between the two profiles. The amount of influence 'inputProfile1' has in the surface creation.Default:0.5"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "tangentContinuityProfile1": {
                "docstring": "Need tangent continuity across the input profile at inputProfile1.Default:false"
            }, 
            "tangentContinuityProfile2": {
                "docstring": "Need tangent continuity across the input curve at inputProfile2.Default:false"
            }, 
            "transformMode": {
                "docstring": "transform mode ( Non proportional, proportional ). Non proportional is default value.Default:0Advanced flags"
            }
        }
    }, 
    "dpBirailCtx": {
        "description": "", 
        "flags": {
            "activeNodes": {
                "docstring": ""
            }, 
            "autoCreate": {
                "docstring": ""
            }, 
            "bldProfileFirst": {
                "docstring": ""
            }, 
            "bldProfileLast": {
                "docstring": ""
            }, 
            "bldProfiles": {
                "docstring": ""
            }, 
            "bldRailOne": {
                "docstring": ""
            }, 
            "bldRailTwo": {
                "docstring": ""
            }, 
            "blendFactor": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "immediate": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": ""
            }, 
            "polygon": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": ""
            }, 
            "tangentContinuityProfile1": {
                "docstring": ""
            }, 
            "tangentContinuityProfile2": {
                "docstring": ""
            }, 
            "toolNode": {
                "docstring": ""
            }, 
            "transformMode": {
                "docstring": ""
            }
        }
    }, 
    "drag": {
        "description": "Drag exerts a friction, or braking force proportional to the speed of a moving object. If direction is not enabled, the drag acts opposite to the current velocity of the object. If direction is enabled, it acts opposite to the component of the velocity in the specified direction. The force is independent of the position of the affected object. The transform is the associated dependency node. Use connectDynamic to cause the field to affect a dynamic object. If fields are created, this command returns the names of each of the fields. If a field was queried, the results of the query are returned. If a field was edited, the field name is returned. If object names are provided or the active selection list is non-empty, the command creates a field for every object in the list and calls addDynamic to add it to the object. If the list is empty, the command defaults to -pos 0 0 0. Setting the -pos flag with objects named on the command line is an error. ", 
        "flags": {
            "attenuation": {
                "docstring": "Attentuation rate of field"
            }, 
            "directionX": {
                "docstring": "X-component of direction."
            }, 
            "directionY": {
                "docstring": "Y-component of direction."
            }, 
            "directionZ": {
                "docstring": "Z-component of direction"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "magnitude": {
                "docstring": "Strength of field."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which field is exerted. -1 indicates that the field has no maximum distance."
            }, 
            "name": {
                "docstring": "name of field"
            }, 
            "perVertex": {
                "docstring": "Per-vertex application. If this flag is set true, then each individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical copy of the force field. If this flag is set to false, then the force is exerted only from the geometric center of the set of points."
            }, 
            "position": {
                "docstring": "Position in space where you want to place a field. The gravity then emanates from this position in space rather than from an object. Note that you can both use -pos (creating a field at a position) and also provide object names."
            }, 
            "query": {
                "docstring": ""
            }, 
            "torusSectionRadius": {
                "docstring": ""
            }, 
            "useDirection": {
                "docstring": "Enable/disable direction. Drag will use -dx/-dy/-dz arguments if and only if this flag is set true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "volumeExclusion": {
                "docstring": ""
            }, 
            "volumeOffset": {
                "docstring": ""
            }, 
            "volumeShape": {
                "docstring": ""
            }, 
            "volumeSweep": {
                "docstring": ""
            }
        }
    }, 
    "dragAttrContext": {
        "description": "The dragAttrContext allows a user to manipulate the attributes of an object by using a virtual slider within the viewport. The virtual slider is used by dragging in a viewport with the middle mouse button. The speed at which the attributes are changed can be controlled by holding down the Ctrl key to slow it down and the Shift key to speed it up. ", 
        "flags": {
            "connectTo": {
                "docstring": "Specifies an attribute to which to connect the context. This is a multi-use flag, but all attributes used must be from one object."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": "Resets the list of attributes to which the context is connected.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "draggerContext": {
        "description": "The draggerContext allows the user to program the behavior of the mouse or an equivalent dragging device in MEL. ", 
        "flags": {
            "anchorPoint": {
                "docstring": "Anchor point (double array) where dragger was initially pressed."
            }, 
            "button": {
                "docstring": "Returns the current mouse button (1,2,3)."
            }, 
            "currentStep": {
                "docstring": "Current step (press-drag-release sequence) for dragger context. When queried before first press event happened, returns 0.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "cursor": {
                "docstring": "Cursor displayed while context is active. Valid values are: \"default\", \"hand\", \"crossHair\", \"dolly\", \"track\", and \"tumble\"."
            }, 
            "dragCommand": {
                "docstring": "Command called when mouse dragger is dragged."
            }, 
            "dragPoint": {
                "docstring": "Drag point (double array) current position of dragger during drag."
            }, 
            "drawString": {
                "docstring": "A string to be drawn at the current position of the pointer."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "finalize": {
                "docstring": "Command called when the tool is exited."
            }, 
            "helpString": {
                "docstring": ""
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "holdCommand": {
                "docstring": "Command called when mouse dragger is held."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "initialize": {
                "docstring": "Command called when the tool is entered."
            }, 
            "modifier": {
                "docstring": "Returns the current modifier type: ctrl, alt or none."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "plane": {
                "docstring": "Provide normal of projection plane (see -projection flag for details)."
            }, 
            "prePressCommand": {
                "docstring": "Command called when mouse dragger is pressed. It is called before pressCommand, so it can be used for initialization of context."
            }, 
            "pressCommand": {
                "docstring": "Command called when mouse dragger is pressed."
            }, 
            "projection": {
                "docstring": "Sets current projection of drag point. Valid types are: viewPlaneproject to view planeobjectViewPlaneproject to object plane (parallel to view plane)objectPlaneproject to specified plane defined by object location and normal (default) 0,1,0planeproject to specified plane defined by origin and normal (default) 0,1,0sketchPlaneproject to sketch planexAxisproject to closest point on X axisyAxisproject to closest point on Y axiszAxisproject to closest point on Z axisboundingSphereproject to closest point on object sphere boundsboundingBoxproject to closest point on object bounding box"
            }, 
            "query": {
                "docstring": ""
            }, 
            "releaseCommand": {
                "docstring": "Command called when mouse dragger is released."
            }, 
            "snapping": {
                "docstring": "Enable/disable snapping for dragger context."
            }, 
            "space": {
                "docstring": "Sets current space that coordinates are reported in. Types are: worldworld space (global)objectobject space (local)screenscreen space"
            }, 
            "stepsCount": {
                "docstring": "Number of steps (press-drag-release sequences) for dragger context. When combined with undoMode flag, several steps might be recorded as single undo action."
            }, 
            "undoMode": {
                "docstring": "Undo queue mode for the context actions. Acceptable values are: \"all\" default behaviour when every action that happens during dragger context activity is recorded as an individual undo chunk.\"step\" - all the actions that happen between each press and release are combined into one undo chunk.\"sequence\" - all the actions that happen between very first press and very last release are combined into single undo chunk. This works exactly the same as \"step\" for a single step dragger context."
            }
        }
    }, 
    "drawExtrudeFacetCtx": {
        "description": "", 
        "flags": {
            "degree": {
                "docstring": ""
            }, 
            "divisions": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "facesTogether": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "dropoffLocator": {
        "description": "This command adds one or more dropoff locators to a wire curve, one for each selected curve point. The dropoff locators can be used to provide localized tuning of the wire deformation about the curve point. The arguments are two floats, the envelope and percentage, followed by the wire node name and then by the curve point(s). ", 
        "flags": {}
    }, 
    "duplicate": {
        "description": "This command duplicates the given objects. If no objects are given, then the selected list is duplicated. The smart transform feature allows duplicate to transform newly duplicated objects based on previous transformations between duplications. Example: Duplicate an object and move it to a new location. Duplicate it again with the smart duplicate flag. It should have moved once again the distance you had previously moved it. Note: changing the selected list between smart duplications will cause the transform information to be deleted The upstream Nodes option forces duplication of all upstream nodes leading upto the selected objects.. Upstream nodes are defined as all nodes feeding into selected nodes. During traversal of Dependency graph, if another dagObject is encountered, then that node and all it's parent transforms are also duplicated. The inputConnections option forces the duplication of input connections to the nodes that are to be duplicated. This is very useful especially in cases where two nodes that are connected to each other are specified as nodes to be duplicated. In that situation, the connection between the nodes is also duplicated. See also:instance ", 
        "flags": {
            "inputConnections": {
                "docstring": "Input connections to the node to be duplicated, are also duplicated. This would result in a fan-out scenario as the nodes at the input side are not duplicated (unlike the -un option)."
            }, 
            "instanceLeaf": {
                "docstring": "instead of duplicating leaf DAG nodes, instance them."
            }, 
            "name": {
                "docstring": "name to give duplicated object(s)"
            }, 
            "parentOnly": {
                "docstring": "Duplicate only the specified DAG node and not any of its children.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "renameChildren": {
                "docstring": "rename the child nodes of the hierarchy, to make them unique."
            }, 
            "returnRootsOnly": {
                "docstring": "return only the root nodes of the new hierarchy. When used with upstreamNodes flag, the upstream nodes will be omitted in the result. This flag controls only what is returned in the output string[], and it does NOT change the behaviour of the duplicate command."
            }, 
            "smartTransform": {
                "docstring": "remembers last transformation and applies it to duplicated object(s)"
            }, 
            "upstreamNodes": {
                "docstring": "the upstream nodes leading upto the selected nodes (along with their connections) are also duplicated."
            }
        }
    }, 
    "duplicateCurve": {
        "description": "The duplicateCurve command takes a curve on a surface and and returns the 3D curve. The curve on a surface could be isoparam component, trimmed edge or curve on surface object. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "local": {
                "docstring": "Copy the transform of the surface and connect to the local space version instead."
            }, 
            "maxValue": {
                "docstring": ""
            }, 
            "mergeItems": {
                "docstring": ""
            }, 
            "minValue": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curve (where applicable)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "relative": {
                "docstring": ""
            }
        }
    }, 
    "duplicateSurface": {
        "description": "The duplicateSurface command takes a surface patch (face) and and returns the 3D surface. Connected patches are returned as a single surface. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "faceCountU": {
                "docstring": ""
            }, 
            "faceCountV": {
                "docstring": ""
            }, 
            "firstFaceU": {
                "docstring": ""
            }, 
            "firstFaceV": {
                "docstring": ""
            }, 
            "local": {
                "docstring": "Copy the transform of the surface and connect to the local space version instead.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "mergeItems": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable)"
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "dynCache": {
        "description": "Cache the current state of all particle shapes at the current time. ", 
        "flags": {}
    }, 
    "dynControl": {
        "description": "", 
        "flags": {
            "autoCreate": {
                "docstring": ""
            }, 
            "oversample": {
                "docstring": ""
            }, 
            "particleCache": {
                "docstring": ""
            }, 
            "particleLOD": {
                "docstring": ""
            }, 
            "particlesOn": {
                "docstring": ""
            }, 
            "rigidOn": {
                "docstring": ""
            }, 
            "seed": {
                "docstring": ""
            }, 
            "startTime": {
                "docstring": ""
            }, 
            "traceDepth": {
                "docstring": ""
            }
        }
    }, 
    "dynExport": {
        "description": "Export particle data to disk files. For cache export (-format cache), dynExport also sets three attributes of the current dynGlobals node. It sets the useParticleRenderCache attribute to true, and the min/maxFrameOfLastParticleRenderCache attributes to correspond to the min and max frames. Exported .pda or .pdb files are assigned a name of form object name.frame.extension, where extensionis \"pda\" or \"pdb.\" The naming convention for .pdc files is similar but does not use frame numbers, it uses a more precise representation of the time instead. By default, the pda and pdb formats export all per-particle attributes, and all integer or float type attributes except those which are hidden or not storable. (Exception: level of detail is not exported, by default) The pdc format exports all attributes which the particle object needs for its state cache. To specify only selected attributes, use the -atr flag (which is multi-use). In general, it is recommended not to use this flag with pdc type, since you need all the attributes in order for the cache to be useful. dynExport exports data for the current frame, or for a range of frames specified with -mnf and -mxf. If you are not already at the start frame, dynExport will run up the scene for you. VERY VERY IMPORTANT NOTE:If you use dynExport in -prompt mode, it does NOT automatically force evaluation of your objects. You must do this yourself from your script. The easiest way is to request each particle object's \"count\" attribute each frame. You must request the count attribute for each object you want to export, because their solvers run independently of one another. In interactive mode, objects WILL get evaluated automatically and you don't have to worry about any of this. When exporting a particle object whose particles are created from collisions involving particles in another particle object(s), you must make sure you simultaneously export all the particle objects involved in the dependency chain otherwise you will get an empty cache file. For non-per-particle attributes, pda and pdb formats write the identical value once for each particle. The following types of non-per-particle attributes can be exported: float, double, doubleLinear, doubleAngle, byte, short, long, enum. The first four are exported as \"Real\" (in PDB parlance), and the last four as \"Integer.\" In the pda and pdb formats, \"particleId\" and \"particleId0\" are exported as Integer, and are exported under the names \"id\" and \"id0\" respectively. All other attributes are exported under their long names. ", 
        "flags": {
            "allObjects": {
                "docstring": "Ignore the selection list and export all particle objects. If you also specify an object name, the -all flag will be ignored."
            }, 
            "attribute": {
                "docstring": "Name of attribute to be exported. If any specified object does not have one of the specified attributes, dynExport will issue an error and not do the export."
            }, 
            "format": {
                "docstring": "Desired format: \"binary\" (\"pdb\"), \"ascii\" (\"pda\"), or \"cache\" (\"pdc\").The pdc format is for use by the Maya particle system to cache particle data. The pda and pdb format options are intended for pipelines involving other software (for example, sending the data to some program written in-house); Maya cannot read pda or pdb files.There is no formal description of the PDB format, but the ExploreMe/particles/readpdb directory contains the source and Makefile for a small, simple C program called \"readpdb\" which reads it. Note that you must compile and run readpdb on the platform which you exported the files on.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "maxFrame": {
                "docstring": "Ending frame to be exported."
            }, 
            "minFrame": {
                "docstring": "Starting frame to be exported. The export operation will play the scene through from min frame to max frame as it exports."
            }, 
            "onlyUpdateParticles": {
                "docstring": ""
            }, 
            "overSampling": {
                "docstring": "OverSampling to be used during export."
            }, 
            "path": {
                "docstring": "This option allows you to specify a subdirectory of the workspace \"particles\" directory where you want the exported files to be stored. By default, files are stored in the workspace particles directory, i.e., -path is relative to that directory.Please Read This:This is a change from previous versions of Maya in which the path was relative to the workspace root directory.) You can set the \"particles\" directory anywhere you want using the project window or workspace -fr command. (In this way, you can use an absolute path for export).The -path flag cannot handle strings which include \"/\" or \"\\\", in other words, it lets you go down only one level in the directory hierarchy. If you specify a path which doesn't exist, the action will create it if possible; if it can't create the path it will warn you and fail. If you are using a project for which a particle data directory is not defined, dynExport will create a default one called \"particles\" and add it to your workspace."
            }
        }
    }, 
    "dynExpression": {
        "description": "This command describes an expression that belongs to the specified particle shape. The expression is a block of code of unlimited length with a C-like syntax that can perform conversions, mathematical operations, and logical decision making on any numeric attribute(s) or per-particle attribute(s) in the scene. One expression can read and alter any number of these attributes. Every particle shape in your scene has three expressions, one for the runtimeBeforeDynamics, one for the runtimeAfterDynamics and one for creation time. The create expression gets executed for every particle in the object whose age is 0.0. The runtime expression gets executed for each particle with an age greater then 0.0. Unlike expressions created with the expressioncommand, particle expressions always exist and are a part of the owning particle object's shape. They default to empty strings, but they are always there. Because of this, there is no need to use the '-e' flag. Every call to the dynExpression command is considered an edit by default. Per-particle attributes are those attributes of a particle shape that have a potentially different value for each particle in the object. Examples of these include positionand velocity. If this command is being sent by the command line or in a script, then the user should be sure to embed escaped newlines (\\n), tabs (\\t) for clarity when reading them in the expression editor. Also, quotes in an expression must be escaped (\\\") so that they are not confused by the system as the end of your string. When using the expression editor, these characters are escaped for you unless they are already within quotes. This type of expression is executed during the evaluation of the dynamics. If an output of the expression is requested before that, then the dynamics will be force to compute at that time. If dynamics is disabled, then these expressions will have no effect. ", 
        "flags": {
            "creation": {
                "docstring": "Tells the command that the string passed will be a creation expression for the particle shape. This means that this expression will be executed when a particle is emitted or at the beginning of the scene for existing particles."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "runtime": {
                "docstring": ""
            }, 
            "runtimeAfterDynamics": {
                "docstring": "Tells the command that the string passed will be a runtime expression for the particle shape. This expression will be executed after dynamics whenever a particle's age is greater then zero (0).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "runtimeBeforeDynamics": {
                "docstring": "Tells the command that the string passed will be a runtime expression for the particle shape. This expression will be executed before dynamics whenever a particle's age is greater then zero (0)."
            }, 
            "string": {
                "docstring": "Set the expression string. This is queriable with the -q/query flag and the -rbd/runtimeBeforeDynamics, the -rab/runtimeAfterDynamics or the -c/creation flag."
            }
        }
    }, 
    "dynGlobals": {
        "description": "This node edits and queries the attributes of the active dynGlobals node in the scene. There can be only one active node of this type. The active dynGlobals node is the first one that was created, either with a \"createNode\" command or by accessing/editing any of the attributes on the node through this command. ", 
        "flags": {
            "active": {
                "docstring": "This flag returns the name of the active dynGlobals node in the the scene. Only one dynGlobals node is active. It is the first on created. Any additional dynGlobals nodes will be ignored."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "listAll": {
                "docstring": "This flag will list all of the dynGlobals nodes in the scene.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "overSampling": {
                "docstring": "This flag will set the current overSampling value for all of the particle in the scene."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "dynPaintCtx": {
        "description": "", 
        "flags": {
            "brushDrag": {
                "docstring": ""
            }, 
            "brushMass": {
                "docstring": ""
            }, 
            "displayQuality": {
                "docstring": ""
            }, 
            "doProject": {
                "docstring": ""
            }, 
            "dragBrushSize": {
                "docstring": ""
            }, 
            "drawAsMesh": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "inputSamples": {
                "docstring": ""
            }, 
            "paintAtDepth": {
                "docstring": ""
            }, 
            "pixelMode": {
                "docstring": ""
            }, 
            "pressureMapping1": {
                "docstring": ""
            }, 
            "pressureMapping2": {
                "docstring": ""
            }, 
            "pressureMapping3": {
                "docstring": ""
            }, 
            "pressureMax1": {
                "docstring": ""
            }, 
            "pressureMax2": {
                "docstring": ""
            }, 
            "pressureMax3": {
                "docstring": ""
            }, 
            "pressureMin1": {
                "docstring": ""
            }, 
            "pressureMin2": {
                "docstring": ""
            }, 
            "pressureMin3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "sampleSeparation": {
                "docstring": ""
            }, 
            "setSelection": {
                "docstring": ""
            }, 
            "surfaceOffset": {
                "docstring": ""
            }, 
            "usePressure": {
                "docstring": ""
            }
        }
    }, 
    "dynPaintEditor": {
        "description": "Create a editor window that can be painted into ", 
        "flags": {
            "activeOnly": {
                "docstring": "For Scene mode, this determines if only the active strokes will be refreshed."
            }, 
            "autoSave": {
                "docstring": "For Canvas mode, this determines if the buffer will be saved to a disk file after every stroke. Good for painting textures and viewing the results in shaded display in the model view."
            }, 
            "camera": {
                "docstring": "Sets the name of the camera which the Paint Effects panel looks through."
            }, 
            "canvasMode": {
                "docstring": "Sets the Paint Effects panel into Canvas mode if true."
            }, 
            "canvasUndo": {
                "docstring": "Does a fast undo in Canvas mode. This is a special undo because we are not using any history when we paint in Canvas mode so we provide a single level undo for the Canvas."
            }, 
            "changeCommand": {
                "docstring": "Parameters: First string: commandSecond string: editorNameThird string: editorCmdFourth string: updateFuncCall the command when something changes in the editor The command should have this prototype :command(string $editor, string $editorCmd, string $updateFunc, int $reason)The possible reasons could be : 0: no particular reason1: scale color2: buffer (single/double)3: axis4: image displayed5: image saved in memory"
            }, 
            "clear": {
                "docstring": "Clears the buffer (if in Canvas mode) to the floating point values (R,G,B)."
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "currentCanvasSize": {
                "docstring": "In Query mode, this returns the (X,Y) resolution of the current canvas.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "displayAppearance": {
                "docstring": "Sets the display appearance of the model panel. Possible values are \"wireframe\", \"points\", \"boundingBox\", \"smoothShaded\", \"flatShaded\". This flag may be used with the -interactive and -default flags. Note that only \"wireframe\", \"points\", and \"boundingBox\" are valid for the interactive mode."
            }, 
            "displayFog": {
                "docstring": "For Scene mode, this determines if fog will be displayed in the Paint Effects panel when refreshing the scene. If fog is on, but this is off, fog will only be drawn on the strokes, not the rest of the scene."
            }, 
            "displayImage": {
                "docstring": "Set a particular image in the Editor Image Stack as the current Editor Image. Images are added to the Editor Image Stack using the \"si/saveImage\" flag."
            }, 
            "displayLights": {
                "docstring": "Sets the lighting for shaded mode. Possible values are \"selected\", \"active\", \"all\", \"default\"."
            }, 
            "displayStyle": {
                "docstring": "Set the mode to display the image. Valid values are: \"color\" to display the basic RGB image\"mask\" to display the mask channel\"lum\" to display the luminance of the image"
            }, 
            "displayTextures": {
                "docstring": "Turns on or off display of textures in shaded mode"
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "doubleBuffer": {
                "docstring": "Set the display in double buffer mode"
            }, 
            "drawAxis": {
                "docstring": ""
            }, 
            "drawContext": {
                "docstring": "Returns the name of the context."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fastUpdate": {
                "docstring": ""
            }, 
            "fileName": {
                "docstring": "This sets the file to which the canvas will be saved."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "iconGrab": {
                "docstring": "This puts the Paint Effects panel into Grab Icon mode where the user is expected to drag out a section of the screen to be made into an icon."
            }, 
            "loadImage": {
                "docstring": "load an image from disk and set it as the current Editor Image"
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "menu": {
                "docstring": "Sets the name of the script used to build a menu in the editor. The script takes the editor name as an argument."
            }, 
            "nbImages": {
                "docstring": "returns the number of images"
            }, 
            "newImage": {
                "docstring": "Starts a new image in edit mode, setting the resolution to the integer values (X,Y) and clearing the buffer to the floating point values (R,G,B). In Query mode, this returns the (X,Y) resolution of the current Image."
            }, 
            "paintAll": {
                "docstring": "Redraws the buffer in current refresh mode."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "query": {
                "docstring": ""
            }, 
            "redrawLast": {
                "docstring": "Redraws the last stroke again. Useful when it's brush has just changed. This feature does a fast undo and redraws the stroke again."
            }, 
            "refreshMode": {
                "docstring": "Sets the refresh mode to the specified value. 0 - Do not draw strokes on refresh, 1 - Redraw strokes in wireframe mode, 2 - Redraw strokes in final rendered mode."
            }, 
            "removeAllImages": {
                "docstring": "remove all the Editor Images from the Editor Image Stack"
            }, 
            "removeImage": {
                "docstring": "remove the current Editor Image from the Editor Image Stack"
            }, 
            "rollImage": {
                "docstring": "In Canvas mode, this rolls the image by the floating point values (X,Y). X and Y are between 0 (no roll) and 1 (full roll). A value of .5 rolls the image 50% (ie. the border moves to the center of the screen."
            }, 
            "saveAlpha": {
                "docstring": "For Canvas mode, this determines if the alpha will be saved when storing the canvas to a disk file."
            }, 
            "saveBumpmap": {
                "docstring": "Saves the current buffer as a bump map to the specified file."
            }, 
            "saveImage": {
                "docstring": "save the current Editor Image to memory. Saved Editor Images are stored in an Editor Image Stack. The most recently saved image is stored in position 0, the second most recently saved image in position 1, and so on... To set the current Editor Image to a previously saved image use the \"di/displayImage\" flag."
            }, 
            "scaleBlue": {
                "docstring": "Define the scaling factor for the blue component in the View. The default value is 1 and can be between -1000 to +1000"
            }, 
            "scaleGreen": {
                "docstring": "Define the scaling factor for the green component in the View. The default value is 1 and can be between -1000 to +1000"
            }, 
            "scaleRed": {
                "docstring": "Define the scaling factor for the red component in the View. The default value is 1 and can be between -1000 to +1000"
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "singleBuffer": {
                "docstring": "Set the display in single buffer mode"
            }, 
            "snapShot": {
                "docstring": "Takes a snapshot of the current camera view."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "swap": {
                "docstring": ""
            }, 
            "tileSize": {
                "docstring": "Sets the size of the tile for the hardware texture redraw of the display buffer."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "undoCache": {
                "docstring": "By default the last image is cached for undo. If this is set false, then undoing will be disabled in canvas mode and undo in scene mode will force a full refresh. Less memory will be used if this is set false before the first clear or refresh of the current scene."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "wrap": {
                "docstring": "For Canvas mode, should the buffer wrap in U, and V (respectively) when painting."
            }, 
            "writeImage": {
                "docstring": "write the current Editor Image to disk"
            }, 
            "zoom": {
                "docstring": "Zooms the Canvas image by the specified value."
            }
        }
    }, 
    "dynParticleCtx": {
        "description": "The particle context command creates a particle context. The particle context provides an interactive means to create particle objects. The particle context command also provides an interactive means to set the option values, through the Tool Property Sheet, for the \"particle\" command that the context will issue. In query mode, return type is based on queried flag.", 
        "flags": {
            "conserve": {
                "docstring": "Conservation of momentum control (between 0 and 1). For smaller values, the field will tend to erase any existing velocity the object has (in other words, will not conserve momentum from frame to frame). A value of 1 (the default) corresponds to the true physical law of conservation of momentum."
            }, 
            "cursorPlacement": {
                "docstring": "Use the cursor to place the lower left and upper right of the grid."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "grid": {
                "docstring": "Create a particle grid."
            }, 
            "gridSpacing": {
                "docstring": "Spacing between particles in the grid."
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "jitterRadius": {
                "docstring": "Max radius from the center to place the particle instances."
            }, 
            "lowerLeftX": {
                "docstring": "Lower left X position of the particle grid."
            }, 
            "lowerLeftY": {
                "docstring": "Lower left Y position of the particle grid."
            }, 
            "lowerLeftZ": {
                "docstring": "Lower left Z position of the particle grid."
            }, 
            "name": {
                "docstring": ""
            }, 
            "nucleus": {
                "docstring": "If set true then an nParticle is generated with a nucleus node connection. Otherwise a standard particle is created."
            }, 
            "numJitters": {
                "docstring": "Number of jitters (instances) per particle."
            }, 
            "particleName": {
                "docstring": "Particle name."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sketch": {
                "docstring": "Create particles in sketch mode."
            }, 
            "sketchInterval": {
                "docstring": "Interval between particles, when in sketch mode."
            }, 
            "textPlacement": {
                "docstring": "Use the textfields to specify the lower left and upper right of/ the grid."
            }, 
            "upperRightX": {
                "docstring": "Upper right X position of the particle grid."
            }, 
            "upperRightY": {
                "docstring": "Upper right Y position of the particle grid."
            }, 
            "upperZ": {
                "docstring": "Upper right Z position of the particle grid.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "dynPref": {
        "description": "This action modifies and queries the current state of \"autoCreate rigid bodies\", \"run up to current time\", and \"run up from\" (previous time or start time). In query mode, return type is based on queried flag.", 
        "flags": {
            "autoCreate": {
                "docstring": "If on, autoCreate rigid bodies."
            }, 
            "echoCollision": {
                "docstring": "If on, will cause particle systems to echo to the Script Editor the command that they are running for each particle collision event. If off, only the output of the command will be echoed.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "runupFrom": {
                "docstring": "If on, run up from previous time; if 2, run up from start time"
            }, 
            "runupToCurrentTime": {
                "docstring": "If on, run up the scene to current time"
            }, 
            "saveOnQuit": {
                "docstring": "If on, save the current values of preferences to userPrefs file."
            }, 
            "saveRuntimeState": {
                "docstring": "If on, runtime state as well as initial state of all particle objects will be saved to file. If off, only initial state will be saved."
            }
        }
    }, 
    "dynSelectCtx": {
        "description": "", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "dynTestData": {
        "description": "", 
        "flags": {
            "arrayAttrs": {
                "docstring": ""
            }, 
            "verbose": {
                "docstring": ""
            }
        }
    }, 
    "dynWireCtx": {
        "description": "", 
        "flags": {
            "brushDrag": {
                "docstring": ""
            }, 
            "brushMass": {
                "docstring": ""
            }, 
            "displayQuality": {
                "docstring": ""
            }, 
            "doProject": {
                "docstring": ""
            }, 
            "dragBrushSize": {
                "docstring": ""
            }, 
            "drawAsMesh": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "inputSamples": {
                "docstring": ""
            }, 
            "paintAtDepth": {
                "docstring": ""
            }, 
            "pixelMode": {
                "docstring": ""
            }, 
            "pressureMapping1": {
                "docstring": ""
            }, 
            "pressureMapping2": {
                "docstring": ""
            }, 
            "pressureMapping3": {
                "docstring": ""
            }, 
            "pressureMax1": {
                "docstring": ""
            }, 
            "pressureMax2": {
                "docstring": ""
            }, 
            "pressureMax3": {
                "docstring": ""
            }, 
            "pressureMin1": {
                "docstring": ""
            }, 
            "pressureMin2": {
                "docstring": ""
            }, 
            "pressureMin3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "sampleSeparation": {
                "docstring": ""
            }, 
            "setSelection": {
                "docstring": ""
            }, 
            "surfaceOffset": {
                "docstring": ""
            }, 
            "usePressure": {
                "docstring": ""
            }
        }
    }, 
    "dynamicLoad": {
        "description": "Dynamically load the DLL passed as argument. In query mode, return type is based on queried flag.", 
        "flags": {
            "query": {
                "docstring": ""
            }
        }
    }, 
    "editDisplayLayerGlobals": {
        "description": "Edit the parameter values common to all display layers. Some of these paremeters, eg. baseId and mergeType, are stored as preferences and some, eg. currentDisplayLayer, are stored in the file. ", 
        "flags": {
            "baseId": {
                "docstring": "Set base layer ID. This is the number at which new layers start searching for a unique ID."
            }, 
            "currentDisplayLayer": {
                "docstring": "Set current display layer; ie. the one that all new objects are added to."
            }, 
            "mergeType": {
                "docstring": "Set file import merge type. Valid values are 0, none, 1, by number, and 2, by name.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useCurrent": {
                "docstring": "Set whether or not to enable usage of the current display layer as the destination for all new nodes."
            }
        }
    }, 
    "editDisplayLayerMembers": {
        "description": "This command is used to query and edit membership of display layers. No equivalent 'remove' command is necessary since all objects must be in exactly one display layer. Removing an object from a layer can be accomplished by adding it to a different layer. ", 
        "flags": {
            "fullNames": {
                "docstring": "(Query only.) If set then return the full DAG paths of the objects in the layer. Otherwise return just the name of the object.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "noRecurse": {
                "docstring": "If set then only add selected objects to the display layer. Otherwise all descendants of the selected objects will also be added."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "editRenderLayerAdjustment": {
        "description": "This command is used to create, edit, and query adjustments to render layers. An adjustment allows different attribute values or connections to be used depending on the active render layer. ", 
        "flags": {
            "attributeLog": {
                "docstring": "Output all adjustments for the specified layer sorted by attribute name."
            }, 
            "layer": {
                "docstring": "Specified layer in which the adjustments will be modified. If not specified the active render layer will be used."
            }, 
            "nodeLog": {
                "docstring": "Output all adjustments for the specified layer sorted by node name.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Remove the specified adjustments from the render layer. If an adjustment is removed from the current layer, the specified plug will revert back to it's master value determined by the default render layer."
            }
        }
    }, 
    "editRenderLayerGlobals": {
        "description": "Edit the parameter values common to all render layers. Some of these paremeters, eg. baseId and mergeType, are stored as preferences and some, eg. currentRenderLayer, are stored in the file. ", 
        "flags": {
            "baseId": {
                "docstring": "Set base layer ID. This is the number at which new layers start searching for a unique ID."
            }, 
            "currentRenderLayer": {
                "docstring": "Set current render layer. This will will update the renderLayerManger and all DAG objects to identify them as members of the render layer. This flag may also be used in conjunction with \"useCurrent\" to automatically add new DAG objects to the active layer. The \"isCurrentRenderLayerChanging\" condition can be used to determine when the current layer is being changed and adjustments are being applied to the scene."
            }, 
            "enableAutoAdjustments": {
                "docstring": "Set whether or not to enable automatic creation of adjustments when certain attributes (ie. surface render stats, shading group assignment, or render settings) are changed."
            }, 
            "mergeType": {
                "docstring": "Set file import merge type. Valid values are 0, none, 1, by number, and 2, by name.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useCurrent": {
                "docstring": "Set whether or not to enable usage of the current render layer as the destination for all new nodes."
            }
        }
    }, 
    "editRenderLayerMembers": {
        "description": "This command is used to query and edit memberships to render layers. Only transform and geometry nodes may be members. At render time, all descendants of the members of a render layer will also be included in the render layer. ", 
        "flags": {
            "fullNames": {
                "docstring": "(Query only.) If set then return the full DAG paths of the objects in the layer. Otherwise return just the name of the object."
            }, 
            "noRecurse": {
                "docstring": "If set then only add selected objects to the render layer. Otherwise all descendants of the selected objects will also be added. This flag may be applied to adding or removing objects from the layer."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Remove the specified objects from the render layer.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "editor": {
        "description": "Edit the characteristic of an editor ", 
        "flags": {
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "editorTemplate": {
        "description": "The editorTemplate command allows the user to specify the conceptual layout of an attribute editor and leave the details of exactly which UI elements are used in the final result to the automatic dialog generation mechanism. ", 
        "flags": {
            "addAdskAssetControls": {
                "docstring": "Adds controls for dynamic attributes of adskMaterial nodes and organizes them in a layout according to the XML ui description specified in the asset library."
            }, 
            "addComponents": {
                "docstring": "This flag will add a frameLayout with a channel box which will display any selected components for the object."
            }, 
            "addControl": {
                "docstring": "The first argument is the name of the attribute for which you wish to add a control. You can assume that when the editor is created from the template, an appropriate type of control will be used. The second string argument is optional, and can be used to specify a command (or script) to be executed when the attribute is changed."
            }, 
            "addDynamicControl": {
                "docstring": "As -addControl with the exception that the attribute for which the control is to be created/attached is dynamic. [Note: -addControl will also work for dynamic attributes, but will not preserve their order in the attribute editor]."
            }, 
            "addExtraControls": {
                "docstring": "By default, if there are attributes of a node which you do not -addControl or -suppress, then controls will be created automatically and appended to the end of editor created from the template. This flag allows you to specify a particular place in the template for such controls to be automatically inserted. If dynamic attributes have not already been addressed with -addControl, they will also be placed here. A frameLayout will automatically be generated for you when you use this flag."
            }, 
            "addSeparator": {
                "docstring": "Adds a separator to the template."
            }, 
            "annotation": {
                "docstring": "This flag can only be used with the -addControl or the -addDynamicControl flags. The string will be used as an annotation on the controls created in the attribute editor."
            }, 
            "beginLayout": {
                "docstring": "Begins a layout in the template with the title specified by the string argument. Items between this flag and its corresponding -endLayout flag will be contained within the layout. You can assume that when the editor is created from the template, an appropriate type of layout will be used. (frameLayout)."
            }, 
            "beginNoOptimize": {
                "docstring": "Specifies that the layout of items between this flag and its corresponding -endNoOptimize flag is not to be optimized to minimize space."
            }, 
            "beginScrollLayout": {
                "docstring": "Begins a scrollLayout. Items between this flag and its corresponding -endScrollLayout flag will be contained within the layout."
            }, 
            "callCustom": {
                "docstring": "Specifies that at this point in the template when building the dialog, the procedure specified by the first argument is to be called to create some UI objects when a new node type is edited. The procedure specified by the second argument is to be called if an attribute editor already exists and another node of the same type is now to be edited. The replacing procedure should connect any controls created by the creating procedure to the equivalent attributes in the new node. A list of zero or more attributes specifies the attributes which the two procedures will involve. The procedures should have the signature: proc AEcustomNew(string attributeName1, string attributeName2) The number of attributes specified in the call should correspond to the number of attributes in the procedure signature."
            }, 
            "collapse": {
                "docstring": "This flag is only valid when used in conjunction with a -bl/beginLayout flag. It is used to specify the initial expand/collapse state of the layout. A true value will cause the layout to be collapsed upon creation, while a false value will expand the layout. The default is true (ie. collapsed)."
            }, 
            "debugMode": {
                "docstring": ""
            }, 
            "dimControl": {
                "docstring": "This flag is only useful AFTER a control has already been created (using the -addControl flag). The first argument is the node name and the second is the attribute whose control you wish to affect. The third argument is a boolean which specifies whether to dim (true) or undim (false) the associated control."
            }, 
            "endLayout": {
                "docstring": "Ends a layout in the template started by -beginLayout."
            }, 
            "endNoOptimize": {
                "docstring": "Ends a set of non-optimized items."
            }, 
            "endScrollLayout": {
                "docstring": "Ends a scrollLayout."
            }, 
            "extraControlsLabel": {
                "docstring": "By default the label is \"Extra Attributes\". Specify an alternate label or an empty string to hide the label. This flag must be used in conjuction with the -aec/addExtraControls flag."
            }, 
            "interruptOptimize": {
                "docstring": "Enforces a division between two sets of items whose layouts may be optimized."
            }, 
            "label": {
                "docstring": "This flag can only be used with the -addControl or the -addDynamicControl flags. And it must be specified FIRST. The string will override the name of the attribute that will be displayed in the attribute editor."
            }, 
            "listExtraAttributes": {
                "docstring": "List extra attributes.This flag is only useful AFTER a control has already been created (using the -addControl flag). The first argument is the node name."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "queryControl": {
                "docstring": "This flag is only useful AFTER a control has already been created (using the -addControl flag). The first argument is the node name and the second is the attribute whose control you wish to query. Note that in most cases, using this flag is identical to issuing a getAttr command, however, in the case of textFields (e.g. for message attributes), the text value currently being displayed will be returned, NOT the actual attribute value."
            }, 
            "queryLabel": {
                "docstring": "This flag is only useful AFTER a control has already been created (using the -addControl flag). The first argument is the node name and the second is the attribute whose control label you wish to query. In most cases this flag returns the same value as the attribute's nice name, but when a -label flag was present on the -addControl command that created the control, -queryLabel will return that value instead"
            }, 
            "queryName": {
                "docstring": "This flag is only useful AFTER a control has already been created (using the -addControl flag). The first argument is the node name and the second is the attribute whose control name you wish to query."
            }, 
            "removeControl": {
                "docstring": "This flag is only useful AFTER a control has already been created (using the -addControl flag). The first argument is the node name and the second is the attribute whose control you wish to remove."
            }, 
            "suppress": {
                "docstring": "Prevent a control for the attribute specified by the string argument from appearing in the editor created from the template."
            }
        }
    }, 
    "effector": {
        "description": "The effector command is used to set the name or hidden flag for the effector. The standard edit (-e) and query (-q) flags are used for edit and query functions. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "hide": {
                "docstring": "Specifies whether to hide drawing of effector if attached to a handle.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "Specifies the name of the effector."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "emit": {
        "description": "The emitaction allows users to add particles to an existing particle object without the use of an emitter. At the same time, it allows them to set any per-particle attribute for the particles that are created with the action.The particles created do not become a part of the initial state for the particle object, and will disappear when the scene is rewound unless they are saved into the initial state by the user explicitly. In addition, a particle object will accept particles from an emit action ONLY at frames greater than or equal to its start frame. For example, if you want to use the emit action to create particles at frame -5, you must set startFrame for that particle shape to -5 or less.Unlike many commands or actions, the emit action uses the order of its flags as important information as to how it works. The -objectand -positionflags can appear anywhere in the argument list. The -attributeand the value flags are interpreted based on their order. Any value flags after an -attribute flag and before the next -attribute flag will set the values for the attribute specified by the closest -attribute flag before them in the argument list. See the Examplessection below for more detail on how these flags work.Currently, no creation expression is executed for the new particles unless they are created from within a particle expression defined with the dynExpressioncommand or the Expression Editor. If you want any particular values put into the particles at the time they are created, then those values should be set using the -attribute, -vectorValue, and -floatValueflags. ", 
        "flags": {
            "attribute": {
                "docstring": "Specifies the attribute on the particle object that any value flags following it and before the next -attribute flag will be associated with. The same attribute can be specified later in the command to pick up where the first one left off. The attributes used must be per-particle attributes. This will accept both long and short names for the attributes. Note the per-particle attribute must already exist on the particle object prior to being specified via this command flag."
            }, 
            "floatValue": {
                "docstring": "Sets the float value to be used for the \"current\" attribute of the \"current\" particle. By current attribute, it is meant the attribute specified by the most recent -attribute flag. By current particle, it is meant the particle in the list of -position flags that corresponds to the number of values that have been set for the \"current\" attribute. If the current attribute is a vector-per-particle attribute, then the float value specified will be used for all three components of the vector.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "object": {
                "docstring": "This flag takes the name of a particleShape or the transform directly above it in the DAG as its parent. It specifies which object to add the particles to. This flag must be passed, as the selection list is ignored for this action."
            }, 
            "position": {
                "docstring": "Specifies the positions in the particle object's space (usually world space) where the particles are to be created. One particle is created for each occurence of this flag."
            }, 
            "vectorValue": {
                "docstring": "Sets the vector value to be used for the \"current\" attribute of the \"current\" particle. By current attribute, it is meant the attribute specified by the most recent -attribute flag. By current particle, it is meant the particle in the list of -position flags that corresponds to the number of values that have been set for the \"current\" attribute. If the current attribute is a float-per-particle attribute, then the length of the vector described by this flag will be used. The length is described as SQR( xVal2+ yVal2+ zVal2."
            }
        }
    }, 
    "emitter": {
        "description": "Creates an emitter object. If object names are provided or if objects are selected, applies the emitter to the named/selected object(s)in the scene. Particles will then be emitted from each. If no objects are named or selected, or if the -pos option is specified, creates a positional emitter. If an emitter was created, the command returns the name of the object owning the emitter, and the name of emitter shape. If an emitter was queried, the command returns the results of the query. Keyframeable attributes of the emitter node: rate, directionX, directionY, directionZ, minDistance, maxDistance, spread. ", 
        "flags": {
            "alongAxis": {
                "docstring": "Initial velocity multiplier in the direction along the central axis of the volume. See the diagrams in the documentation. Applies only to volume emitters."
            }, 
            "aroundAxis": {
                "docstring": "Initial velocity multiplier in the direction around the central axis of the volume. See the diagrams in the documentation. Applies only to volume emitters."
            }, 
            "awayFromAxis": {
                "docstring": "Initial velocity multiplier in the direction away from the central axis of the volume. See the diagrams in the documentation. Used only with the cylinder, cone, and torus volume emitters."
            }, 
            "awayFromCenter": {
                "docstring": "Initial velocity multiplier in the direction away from the center point of a cube or sphere volume emitter. Used only with the cube and sphere volume emitters."
            }, 
            "cycleEmission": {
                "docstring": "Possible values are \"none\" and \"frame.\" Cycling emission restarts the random number stream after a specified interval. This can either be a number of frames or a number of emitted particles. In each case the number is specified by the cycleInterval attribute. Setting cycleEmission to \"frame\" and cycleInterval to 1 will then re-start the random stream every frame. Setting cycleInterval to values greater than 1 can be used to generate cycles for games work."
            }, 
            "cycleInterval": {
                "docstring": "Specifies the number of frames or particles between restarts of the random number stream. See cycleEmission. Has no effect if cycleEmission is set to None."
            }, 
            "directionX": {
                "docstring": "x-component of emission direction. Used for directional emitters, and for volume emitters with directionalSpeed."
            }, 
            "directionY": {
                "docstring": "y-component of emission direction. Used for directional emitters, and for volume emitters with directionalSpeed."
            }, 
            "directionZ": {
                "docstring": "z-component of emission direction. Used for directional emitters, and for volume emitters with directionalSpeed."
            }, 
            "directionalSpeed": {
                "docstring": "For volume emitters only, adds a component of speed in the direction specified by the directionX, Y, and Z attributes. Applies only to volume emitters. Does not apply to other types of emitters."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which emission ends."
            }, 
            "minDistance": {
                "docstring": "Minimum distance at which emission starts."
            }, 
            "name": {
                "docstring": ""
            }, 
            "needParentUV": {
                "docstring": "If aNeedParentUV is true, compute parentUV value from each triangle or each line segment, then send out to the target particle object. You also need to add parentU and parentV attributes to the particle object to store these values."
            }, 
            "normalSpeed": {
                "docstring": "Normal speed multiple for point emission. For each emitted particle, multiplies the component of the velocity normal to the surface or curve by this amount. Surface and curve emitters only."
            }, 
            "position": {
                "docstring": "Positional emitter at world space location (x,y,z)."
            }, 
            "query": {
                "docstring": ""
            }, 
            "randomDirection": {
                "docstring": "Magnitude of a random component of the speed from volume emission."
            }, 
            "rate": {
                "docstring": "Rate at which particles emitted (can be non-integer). For point emission this is rate per point per unit time. For surface emission it is rate per square unit of area per unit time."
            }, 
            "scaleRateByObjectSize": {
                "docstring": "Applies to curve and surface emitters, only. If true, number of particles is determined by object size (area or length) times rate value. If false, object size is ignored and the rate value is used without modification. The former is the way Maya behaved prior to version 3.0.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "scaleSpeedBySize": {
                "docstring": "Indicates whether the scale of a volume emitter affects its velocity."
            }, 
            "speed": {
                "docstring": "Speed multiple. Multiplies the velocity of the emitted particles by this amount. Does not apply to volume emitters. For that emitter type, use directionalSpeed."
            }, 
            "speedRandom": {
                "docstring": "Identifies a range of random variation for the speed of each generated particle. If set to a non-zero value, speed becomes the mean value of the generated particles, whose speeds vary by a random amount up to plus or minus speedRandom/2. For example, speed 5 and speedRandom 2 will make the speeds vary between 4 and 6."
            }, 
            "spread": {
                "docstring": "Random spread (0-1), as a fraction of 90 degrees, along specified direction. Directional emitters only."
            }, 
            "tangentSpeed": {
                "docstring": "Tangent speed multiple for point emission. For each emitted particle, multiplies the component of the velocity tangent to the surface or curve by this amount. Surface and curve emitters only."
            }, 
            "torusSectionRadius": {
                "docstring": "Section radius for a torus volume. Applies only to torus. Similar to the section radius in the torus modelling primitive."
            }, 
            "type": {
                "docstring": "Type of emitter. The choices are omni | dir | direction | surf | surface | curve | curv. The default is omni. The full definition of these types are: omnidirectional point emitter, directional point emitter, surface emitter, or curve emitter."
            }, 
            "volumeOffset": {
                "docstring": "Volume offset of the emitter. Volume offset translates the emission volume by the specified amount from the actual emitter location. This is in the emitter's local space."
            }, 
            "volumeShape": {
                "docstring": "Volume shape of the emitter. Sets/edits/queries the field's volume shape attribute. If set to any value other than \"none\", determines a 3-D volume within which particles are generated. Values are: \"cube,\" \"sphere,\" \"cylinder,\" \"cone,\" \"torus.\""
            }, 
            "volumeSweep": {
                "docstring": "Volume sweep of the emitter. Applies only to sphere, cone, cylinder, and torus. Similar effect to the sweep attribute in modelling."
            }
        }
    }, 
    "enableDevice": {
        "description": "Sets (or queries) the device enable state for actions involving the device. -monitoraffects all assignInputDevice and attachDeviceAttr actions for the named device-recordcontrols if the device is recorded (by default) by a recordDevice action-apply channelName [channelName ... ]controls if data from the device channel is applied (by default) by applyTake to the param curves attached to the named channel.Disabling a channel for applyTake cause applyTake to ignore the enable state of all \"child\" channels -- treating them as disabled. In query mode, return type is based on queried flag.", 
        "flags": {
            "apply": {
                "docstring": "enable/disable \"applyTake\" for the specified channel(s)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "device": {
                "docstring": "specifies the device to change"
            }, 
            "enable": {
                "docstring": "enable (or disable) monitor/record/apply"
            }, 
            "monitor": {
                "docstring": "enables/disables visible update for the device (default)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "record": {
                "docstring": "enable/disable \"recordDevice\" device recording"
            }
        }
    }, 
    "encodeString": {
        "description": "This action will take a string and encode any character that would need to be escaped before being sent to some other command. Such characters include:double quotesnewlinestabs", 
        "flags": {}
    }, 
    "error": {
        "description": "The error command is provided so that the user can issue error messages from his/her scripts and control execution in the event of runtime errors. The string argument is displayed in the command window (or stdout if running in batch mode) after being prefixed with an error message heading and surrounded by //. The error command also causes execution to terminate with an error. Using error is like raising an exception because the error will propagate up through the call chain. You can use catch to handle the error from the caller side. If you don't want execution to end, then you probably want to use the warning command instead. ", 
        "flags": {
            "showLineNumber": {
                "docstring": "Obsolete. Will be deleted in the next version of Maya. Use the checkbox in the script editor that enables line number display instead.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "eval": {
        "description": "This function takes a string which contains MEL code and evaluates it using the MEL interpreter. The result is converted into a Python data type and is returned. If an error occurs during the execution of the MEL script, a Python exception is raised with the appropriate error message. ", 
        "flags": {}
    }, 
    "evalContinue": {
        "description": "", 
        "flags": {}
    }, 
    "evalDeferred": {
        "description": "This command takes the string it is given and evaluates it during the next available idle time. It is useful for attaching commands to controls that can change or delete the control. ", 
        "flags": {
            "evaluateNext": {
                "docstring": ""
            }, 
            "list": {
                "docstring": "Return a list of the command strings that are currently pending on the idle queue.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "lowestPriority": {
                "docstring": "Specified that the command to be executed should be deferred with the lowest priority. That is, it will be executed when no other idle events are scheduled."
            }
        }
    }, 
    "evalEcho": {
        "description": "", 
        "flags": {}
    }, 
    "event": {
        "description": "The event command assigns collision events to a particle object. Collision events are stored in multi-attributes in the particle shape. The event command returns the event name. ", 
        "flags": {
            "count": {
                "docstring": "Collision number (for each particle) to which this event applies. Zero (the default) indicates that it applies to all collisions."
            }, 
            "delete": {
                "docstring": "Delete the specified event."
            }, 
            "dieAtCollision": {
                "docstring": "Particle dies at the collision specified by \"count.\" If no count value is given, die at first collision."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "emit": {
                "docstring": "Emit n additional particles into the assigned target object. The original (colliding) particle survives as well, and remains in its original object. The new particles have age zero and mass equal to the emitting particle. They use the velocity inheritance parameter of the target object."
            }, 
            "idNumber": {
                "docstring": ""
            }, 
            "list": {
                "docstring": "List all events for the chosen shape, like this: event1Name event2Name ... If no shape identified, list all events for all shapes, like this: shape1Name event1Name shape2Name event2Name... Returns a string array."
            }, 
            "name": {
                "docstring": "Assign a name to an event you are creating, or identify an event you wish to edit, query, or delete. See examples."
            }, 
            "proc": {
                "docstring": "Specify a MEL proc to be called each time the event occurs. This must be a global proc with arguments as follows: global proc procName( string obj, int id, string objHit ); Arguments passed in are the name of the particle object, the id of the particle which collided, and the name of the object collided with. You can use particle -id -q to get values of the particle's attributes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "random": {
                "docstring": "Used with -split and -emit flags. If -random is set true and -split or -emit is set to n, then a random number of particles uniformly distributed between 1 and n will be created at the event."
            }, 
            "rename": {
                "docstring": "Assign a new name to an event you are editing. See examples."
            }, 
            "select": {
                "docstring": "This flag is obsolete. See the -name flag."
            }, 
            "split": {
                "docstring": "Colliding particle splits into specified number of new particles. These new particles become part of the assigned target object. If no target has been assigned, they become part of the same object. The new particles inherit the current age of the particle that split. They use the velocity inheritance parameter of the target object. If you set both emit and split, the event will do both: first emit new particles, then split the original one. This is a change from earlier versions where emit and split were mutually exclusive."
            }, 
            "spread": {
                "docstring": "Particles created at collision will spread out a random amount from the rebound direction of the colliding particle. The spread is specified as a fraction (0-1) of 90 degrees. If spread is set at 0 (the default) all the new particles created may coincide."
            }, 
            "target": {
                "docstring": "Target object for emitting or split particles. New particles created through the -emit or -split flags join this object."
            }
        }
    }, 
    "exactWorldBoundingBox": {
        "description": "This command figures out an exact-fit bounding box for the specified objects (or selected objects if none are specified) This bounding box is always in world space. ", 
        "flags": {
            "calculateExactly": {
                "docstring": ""
            }, 
            "ignoreInvisible": {
                "docstring": "Should the bounding box calculation include or exclude invisible objects?Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "exclusiveLightCheckBox": {
        "description": "This command creates a checkBox that controls a light's exclusive non-exclusive status. An exclusive light is one that is not hooked up to the default-light-list, thus it does not illuminate all objects be default. However an exclusive light can be linked to an object. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": ""
            }, 
            "light": {
                "docstring": "The light that is to be made exclusive/non-exclusive.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "exportEdits": {
        "description": "Use this command to export edits made in the scene to a separate file. The exported file can be subsequently imported to another scene. Edits may include: nodes, connections and reference edits such as value changes. The nodes that are included in the exported file will be based on the options used. At least one option flag which describes the set of target nodes to include in the exported file must be specified (e.g. 'selected', 'onReferenceNode'). Use the inclusion flags ('includeAnimation', 'includeShaders', 'includeNetwork') to specify which additional related nodes will be added to the export list. In export mode, when the command completes successfully, the name of the exported file will be returned. In query mode, this command will return information about the contents of the export file. No file export is performed in query mode. Currently query mode will return the list of nodes that will be considered for inclusion in the exported file based on the combination of options specified ", 
        "flags": {
            "editCommand": {
                "docstring": "This is a secondary flag used to indicate which type of reference edits should be considered by the command. If this flag is not specified all edit types will be included. This flag requires a string parameter. Valid values are: \"addAttr\", \"connectAttr\", \"deleteAttr\", \"disconnectAttr\", \"parent\", and \"setAttr\". In some contexts, this flag may be specified more than once to specify multiple edit types to consider."
            }, 
            "excludeHierarchy": {
                "docstring": "By default exporting passes all DAG parents and DAG history to the export file. To prevent any DAG relations not otherwise connected to the target nodes to be output, specify the -excludeHierarchy flag."
            }, 
            "excludeNode": {
                "docstring": "Prevent the node from being included in the list of nodes being exported. This flag is useful to exclude specific scene nodes that might otherwise be exported. In the case where more than one Maya node has the same name, you can specify the DAG path to uniquely identify the node."
            }, 
            "exportSelected": {
                "docstring": "The selected nodes and their connections to each other will be exported. Additionally, any dangling connections to non-exported nodes will be exported. Any default nodes (the internal nodes that Maya creates on startup) that are selected are skipped."
            }, 
            "force": {
                "docstring": "Force the export action to take place. This flag is required to overwrite an existing file."
            }, 
            "includeAnimation": {
                "docstring": "Additionally includes animation nodes and animation helper nodes associated with the target nodes being exported."
            }, 
            "includeConstraints": {
                "docstring": "Additionally include constraint-related nodes associated with the target nodes being exported."
            }, 
            "includeDeformers": {
                "docstring": "Additionally include deformer networks associated with the target nodes being exported."
            }, 
            "includeNetwork": {
                "docstring": "Additionally includes the network of nodes connected to the target nodes being exported."
            }, 
            "includeNode": {
                "docstring": "Additionally include the named node in the list of nodes being exported. In the case where more than one Maya node has the same name, you can specify the DAG path to uniquely identify the node."
            }, 
            "includeSetAttrs": {
                "docstring": "When using the -selected/-sel flag, if any of the selected nodes are referenced, also include/exclude any setAttr edits on those nodes. If used with the -onReferenceNode/-orn flag, include/exclude any setAttr edits on the reference."
            }, 
            "includeSetDrivenKeys": {
                "docstring": "Additionally include setDrivenKey-related nodes associated with the target nodes being exported."
            }, 
            "includeShaders": {
                "docstring": "Additionally include shaders associated with the target nodes being exported."
            }, 
            "onReferenceNode": {
                "docstring": "This is a secondary flag used to indicate that only those edits which are stored on the indicated reference node should be considered. This flag only supports multiple uses when specified with the \"exportEdits\" command.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selected": {
                "docstring": "Export will operate on the list of nodes currently selected. This flag differs from the exportSelected flag in that the selected nodes are not exported, only the edits on them, and any nodes found via the include flags the are used (such as includeAnimation, includeNetwork and so on)."
            }, 
            "type": {
                "docstring": "Set the type of the exported file. Valid values are \"editMA\" or \"editMB\". Note that this command respects the global \"defaultExtensions\" setting for file naming that is controlled with the file command defaultExtensions option. See the file command for more information."
            }
        }
    }, 
    "expression": {
        "description": "This command describes an expression that belongs to the current scene. The expression is a block of code of unlimited length with a C-like syntax that can perform conversions, mathematical operations, and logical decision making on any numeric attribute(s) in the scene. One expression can read and alter any number of numeric attributes. Theoretically, every expression in a scene can be combined into one long expression, but it is recommended that they are separated for ease of use and editing, as well as efficiency.If this command is being sent by the command line or in a script, then the user should be sure to embed escaped newlines (\\n), tabs (\\t) for clarity when reading them in the expression editor. Also, quotes in an expression must be escaped (\\\") so that they are not confused by the system as the end of your string. When using the expression editor, these characters are escaped for you unless they are already within quotes.Note, expressions that alter or use per-particle attributes of a particle shape should use the 'dynExpression' command. ", 
        "flags": {
            "alwaysEvaluate": {
                "docstring": "If this is TRUE (the default), then the expression will be evaluated whenever time changes regardless of whether the other inputs have changed, and an output is requested. If it is FALSE, then the expression will only be evaluated if one or more of the inputs changes and an output is requested. Note, if 'time' or 'frame' are inputs, then the expression will act as if this was set to TRUE."
            }, 
            "animated": {
                "docstring": ""
            }, 
            "attribute": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Sets the name of the dependency graph node to use for the expression"
            }, 
            "object": {
                "docstring": "Sets the \"default\" object for the expression. This allows the expression writer to not type the object name for frequently-used objects. See the examples below."
            }, 
            "query": {
                "docstring": ""
            }, 
            "shortNames": {
                "docstring": "When used with the -q/query flag, tells the command to return the expression with attribute names as short as possible. The default is to return the FULL attribute name, regardless of how the user entered it into the expression, including the object names. With this flag set, attribute names are returned as their short versions, and any attribute that belongs to the default object, if there is one specified, will not display the object's name."
            }, 
            "string": {
                "docstring": "Set the expression string"
            }, 
            "unitConversion": {
                "docstring": "Insert specified unit conversion nodes at creation: \"all\", \"none,\" or \"angularOnly.\" Default is \"all.\" For angularOnly, will insert unit conversion nodes only for angular attributes (allowing degrees-to-radians conversion). This is for performance tuning. If queried, returns the option used when the expression was created or last edited.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "expressionEditorListen": {
        "description": "Listens for messages for the Expression Editor, at its request, and communicates them to it. This action is for internal use only and should not be called by users. This action should be called only by the Expression Editor. ", 
        "flags": {
            "listenFile": {
                "docstring": "Listen for changes to the file argument.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "listenForAttr": {
                "docstring": "Listen for changes to the attributes of the node argument."
            }, 
            "listenForExpression": {
                "docstring": "Listen for changes to the named expression"
            }, 
            "listenForName": {
                "docstring": "Listen for name changes for the node argument."
            }, 
            "stopListenForAttr": {
                "docstring": "Stop listening for changes to the attributes of the node argument."
            }, 
            "stopListenForExpression": {
                "docstring": "Stop listening for changes to the named expression"
            }, 
            "stopListenForName": {
                "docstring": "Stop listening for name changes for the node argument."
            }
        }
    }, 
    "extendCurve": {
        "description": "This command extends a curve or creates a new curve as an extension ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curveOnSurface": {
                "docstring": "If possible, create 2D curve as a result"
            }, 
            "distance": {
                "docstring": "The distance to extend Used only for extendMethod is byDistance.Default:1"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "extendMethod": {
                "docstring": "The method with which to extend: 0 - based on distance, 2 - to a 3D pointDefault:0"
            }, 
            "extensionType": {
                "docstring": "The type of extension: 0 - linear, 1 - circular, 2 - extrapolateDefault:0"
            }, 
            "inputPoint": {
                "docstring": "The point to extend to (optional)"
            }, 
            "join": {
                "docstring": "If true, join the extension to original curveDefault:true"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "noChanges": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "pointX": {
                "docstring": "X of the point to extend toDefault:0"
            }, 
            "pointY": {
                "docstring": "Y of the point to extend toDefault:0"
            }, 
            "pointZ": {
                "docstring": "Z of the point to extend toDefault:0"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curveFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "removeMultipleKnots": {
                "docstring": "If true remove multiple knots at join Used only if join is true.Default:falseAdvanced flags"
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)"
            }, 
            "start": {
                "docstring": "Which end of the curve to extend. 0 - end, 1 - start, 2 - bothDefault:1"
            }
        }
    }, 
    "extendFluid": {
        "description": "", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "endD": {
                "docstring": ""
            }, 
            "endH": {
                "docstring": ""
            }, 
            "endW": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "startD": {
                "docstring": ""
            }, 
            "startH": {
                "docstring": ""
            }, 
            "startW": {
                "docstring": ""
            }
        }
    }, 
    "extendSurface": {
        "description": "This command extends a surface or creates a new surface as an extension. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "distance": {
                "docstring": "The distance to extend (for by distance only)Default:1Advanced flags"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "extendDirection": {
                "docstring": "Which parametric direction of the surface to extend ( 0 - U, 1 - V, 2 - both )Default:0"
            }, 
            "extendMethod": {
                "docstring": "The extend method (0 - distance)Default:0"
            }, 
            "extendSide": {
                "docstring": "Which end of the surface to extend ( 0 - end, 1 - start, 2 - both )Default:1"
            }, 
            "extensionType": {
                "docstring": "The type of extension (0 - tangent, 2 - extrapolate)Default:0"
            }, 
            "join": {
                "docstring": "Join extension to originalDefault:true"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "noChanges": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "extrude": {
        "description": "This command computes a surface given a profile curve and possibly a path curve. There are three ways to extrude a profile curve. The most basic method is called a \"distance\" extrude where direction and length are specified. No path curve is necessary in this case. The second method is called \"flat\" extrude. This method sweeps the profile curve down the path curve without changing the orientation of the profile curve. Finally, the third method is called \"tube\" extrude. This method sweeps a profile curve down a path curve while the profile curve rotates so that it maintains a relationship with the path curve. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degreeAlongLength": {
                "docstring": "Surface degree along the distance when a distance extrude is performedDefault:1"
            }, 
            "direction": {
                "docstring": "The direction in which to extrude. Use only for distance extrudeType and useProfileNormal off"
            }, 
            "directionX": {
                "docstring": "X of the directionDefault:0"
            }, 
            "directionY": {
                "docstring": "Y of the directionDefault:1"
            }, 
            "directionZ": {
                "docstring": "Z of the directionDefault:0"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "extrudeType": {
                "docstring": "The extrude type (distance-0, flat-1, or tube-2)Default:2"
            }, 
            "fixedPath": {
                "docstring": "If true, the resulting surface will be placed at the path curve. Otherwise, the resulting surface will be placed at the profile curve.Default:false"
            }, 
            "length": {
                "docstring": "The distance to extrude. Use only for distance extrudeTypeDefault:1"
            }, 
            "mergeItems": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "pivot": {
                "docstring": "The pivot point used for tube extrudeType"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curve"
            }, 
            "rebuild": {
                "docstring": "Rebuild the input curve(s) before using them in the operation. Use nurbsCurveRebuildPref to set the parameters for the conversion.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reverseSurfaceIfPathReversed": {
                "docstring": "If true, extrude type is tube (2) and path has been internally reversed then computed surface is reversed in the direction corresponding to the path.Default:false"
            }, 
            "rotation": {
                "docstring": "Amount to rotate the profile curve as it sweeps along the path curve.Default:0.0"
            }, 
            "scale": {
                "docstring": "Amount to scale the profile curve as it sweeps along the path curve.Default:1.0"
            }, 
            "subCurveSubSurface": {
                "docstring": "If true, curve range on the path will get applied to the resulting surface instead of cut before the extrude.Default:falseAdvanced flags"
            }, 
            "useComponentPivot": {
                "docstring": "Use closest endpoint of the path - 0, component pivot - 1 or the center of the bounding box of the profile - 2Default:0"
            }, 
            "useProfileNormal": {
                "docstring": "If true, use the profile curve normal for the direction in which to extrude. Use only for distance or tube extrudeType.Default:false"
            }
        }
    }, 
    "fcheck": {
        "description": "Invokes the fcheck program to display images in a separate window. ", 
        "flags": {}
    }, 
    "file": {
        "description": "Opening, importing, exporting, referencing, saving, or renaming a fileThis command needs a single main flag that specifies the action to take. Some of the main flags also take optional secondary flags to modify that action. The main flags are: creaeaneareaseresaesesnexfriirllrlocltfmfnewoopotpmtrrdirnrrrtsssasdxststxtypucurw-o/-open can be modified by the following secondary flags fladladlnrrnn-es/-exportSelected can be modified by the following secondary flags chchnconexpsh-r/-reference can be modified by the following secondary flags dnsdrgrglgnnsrfnrprsnssrfshdrnn-i/-import can be modified by the following secondary flags dnsdrgrgnprrardnrnnrprsns-n/-new and -s/-save can be modified by the following secondary flags f-er/exportAsReference can be modified by the following secondary flags nsrpr-ea/-exportAll and -es/-exportSelected can be modified by the following secondary flags fpr-ean/-exportAnim, -eas/-exportSelectedAnim can be modified by the following secondary flags f-ear/-exportAnimFromReference, -esa/-exportSelectedAnimFromReference can be modified by the following secondary flags frfnQuerying information about a fileThis command needs a single main query flag that specifies the query to take and then optional secondary flags to modify that query. The main query flags are: amfchchncondrerrexexnexpllocltfmfnsopotpmtpnsrrfnrplrprrtssdcshsnstxtypucw-dr/-deferReference can be modified by the following secondary flags rfn-exn/-expandName, -l/-list, -r/reference, -sn/sceneName can be modified by the following secondary flags unshnwcnQuerying file namesWhen querying a file name there are a number of ways to format the result: resolved vs. unresolved name:When a file is loaded into Maya (e.g. by opening or referencing it), the file path provided may not be complete. It could, for example, be a relative path (ex: \"scenes/myScene.ma\"), it could contain environment variables (ex: \"$PRODUCTION_DIR/myScene.ma\"), and it could even be a path which simply doesn't exist on the local disk. In each of these cases Maya goes through a number of steps resolve the path and find the file on disk. By default the 'file' command will return the resolved file name (e.g. the location from which Maya is actually reading the file), but if the -un/-unresolvedflag is used, the unresolved file (e.g. the one that was originally specified) will be returned. full vs. short name:By default the 'file' command will return the full path to a file, but if the -shn/-shortNameflag is used just the file name will be returned. with vs. without copy number:-wcn/-withoutCopyNumberflag is used the file name without the copy number will be returned. Additional DetailsThe file command usually expects a file name as its argument, if none is specified then the root scene is used.See the individual flag descriptions for details and limitations.", 
        "flags": {
            "activate": {
                "docstring": "This flag is obsolete."
            }, 
            "activeProxy": {
                "docstring": "This flag is intended for internal use by Maya during file referencing. It specifes which file is the active proxy when the file is loaded when used with the reference flag. It is also used to specify which file is the active proxy in the file referencing preload information when used with the referenceDepthInfo flag."
            }, 
            "add": {
                "docstring": "When used with selectAll it indicates that the specified items should be added to the active list without removing existing items from the active list."
            }, 
            "anyModified": {
                "docstring": "This is a query only flag. If any of the memory resident files require a save to be performed then 1 is returned."
            }, 
            "applyTo": {
                "docstring": "When importing or referencing an offline edit file, apply it to to the given reference (i.e. determine what maingets mapped to). So specify the reference node name. To apply the edit to nodes in the main scene (i.e. the root namespace) pass in \":\". Must be used with the file -i/-import or -r/-reference flags."
            }, 
            "asURI": {
                "docstring": "When used with a main query flag and the unresolvedName flag it indicates that the file names of all reference files returned will be URI. This URI may contain environment variables and may not exist on disk. If this flag is not present, the OS native file path will be returned."
            }, 
            "buildLoadSettings": {
                "docstring": "When used with the \"o/open\" flag it indicates that the specified file should be read for reference hierarchy information only. This information will be stored in temporary load settings under the name \"implicitLoadSettings\". When this flag is used the specified scene file will not be loaded: no objects/nodes will be created or modified. Note: most users will not need to use this flag or the \"implicitLoadSettings\" it builds. They can access the same functionality by setting the \"Selective Load\" option in the File Open Option Box."
            }, 
            "channels": {
                "docstring": "For use with exportSelected to specify whether attached channels should be included in the export."
            }, 
            "cleanReference": {
                "docstring": "Remove edits from the passed in reference node. The reference must be in an unloaded state. To remove a particular type of edit, use the editCommand flag. If no flag is specified, all edits will be removed."
            }, 
            "command": {
                "docstring": "Specifies the callback to execute before any file operation. This is an internal flag used only in the file format."
            }, 
            "compress": {
                "docstring": "When used with save, it will compress (gzip) the file on output."
            }, 
            "constraints": {
                "docstring": "For use with exportSelected to specify whether attached constraints should be included in the export."
            }, 
            "constructionHistory": {
                "docstring": "For use with exportSelected to specify whether attached construction history should be included in the export."
            }, 
            "copyNumberList": {
                "docstring": "When queried, this flag returns a string array containing a number that uniquely identifies each instance the file is used."
            }, 
            "defaultExtensions": {
                "docstring": "Use the default extensions to rename the files. This defaults to true, but is a persistent setting within a given session of Maya, meaning that if you set it to true or false, that value will continue to be used in subsequent file commands until a new value is set."
            }, 
            "defaultNamespace": {
                "docstring": "Use the default name space for import and referencing. This is an advanced option. If set, then on import or reference, Maya will attempt to place all nodes from the imported or referenced file directly into the root (default) name space, without invoking any name clash resolution algorithms. If the names of any of the new objects already exist in the root namespace, then errors will result. The user of this flag is responsible for creating a name clash resolution mechanism outside of Maya to avoid such errors. Note:This flag is intended only for use with custom file translators written through the API. Use at your own risk."
            }, 
            "deferReference": {
                "docstring": "When used in conjunction with the -reference flag, this flag determines if the reference is loaded, or if loading is deferred.C: The default is false.Q: When queried, this flag returns true if the reference is deferred, or false if the reference is not deferred. If this is used with -rfn/referenceNode, the -rfn flag must come before -q."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editCommand": {
                "docstring": "For use with cleanReference. Remove only this type of edit. Supported edits are: setAttr addAttr deleteAttr connectAttr disconnectAttr and parent"
            }, 
            "errorStatus": {
                "docstring": "Query the error status of the last file read. Returns true if and error occurred during the last file read."
            }, 
            "executeScriptNodes": {
                "docstring": "If true, allow the appropriate script nodes to execute. If false, do not allow any script node scripts to run.For more information, see the documentation for scriptnodes.Default: true."
            }, 
            "exists": {
                "docstring": "Query if the file exists. Returns true if the file exists."
            }, 
            "expandName": {
                "docstring": "This is a query only flag that can be used to query for the file path name of the file."
            }, 
            "exportAll": {
                "docstring": "Export everything into a single file. Returns the name of the exported file."
            }, 
            "exportAnim": {
                "docstring": "Export all animation nodes and animation helper nodes from all objects in the scene. The resulting animation export file will contain connections to objects that are not included in the animation file. As a result, importing/referencing this file back in will require objects of the same name to be present, else errors will occur. The -sns/swapNamespace flag is available for swapping the namespaces of given objects to another namespace. This use of namespaces can be used to re-purpose the animation file to multiple targets using a consistent naming scheme. The exportAnim flag will not export animation layers. For generalized file export of animLayers and other types of nodes, refer to the exportEdits command. Or use the Export Layers functionality."
            }, 
            "exportAnimFromReference": {
                "docstring": "Export the main scene animation nodes and animation helper nodes from all referenced objects. This flag, when used in conjunction with the -rfn/referenceNode flag, can be constrained to only export animation nodes from the specified reference file. See -ean/exportAnim flag description for details on usage of animation files."
            }, 
            "exportAsReference": {
                "docstring": "Export the selected objects into a reference file with the given name. The file is saved on disk during the process. Returns the name of the reference created."
            }, 
            "exportAsSegment": {
                "docstring": "This flag is obsolete."
            }, 
            "exportSelected": {
                "docstring": "Export the selected items into the specified file. Returns the name of the exported file."
            }, 
            "exportSelectedAnim": {
                "docstring": "Export all animation nodes and animation helper nodes from the selected objects in the scene. See -ean/exportAnim flag description for details on usage of animation files."
            }, 
            "exportSelectedAnimFromReference": {
                "docstring": "Export the main scene animation nodes and animation helper nodes from the selected referenced objects. This flag, when used in conjunction with the -rfn/referenceNode flag, can be constrained to only export animation nodes from the selected nodes of a specified reference file. See -ean/exportAnim flag description for details on usage of animation files."
            }, 
            "exportSelectedNoReference": {
                "docstring": "This flag is obsolete."
            }, 
            "exportUnloadedReferences": {
                "docstring": "Only effective when preserveReferences is used. When used with the exportAll flag, tells the exporter to include all unloaded references in the export. When used with the exportSelected flag, tells the exporter to include all unloaded proxy references that are related to any node in the selection."
            }, 
            "expressions": {
                "docstring": "For use with exportSelected to specify whether attached expressions should be included in the export."
            }, 
            "flushReference": {
                "docstring": "This flag will unload the reference file associated with the passed reference node, retaining all associated reference nodes and scene files. \\*\\* This option only works when using namespaces \\*\\*. More Details: This flag is primarily intended to be used as part of a custom asset management system. It can be used to defer loading of a reference which contains child references without losing information about those child references. Prior to reloading a flushed reference which contains child references, the 'createNode reference' lines should be manually removed from the children's Maya ASCII files. If this is not done, extra reference nodes will be created."
            }, 
            "force": {
                "docstring": "Force an action to take place. (new, open, save, remove reference)"
            }, 
            "groupLocator": {
                "docstring": "Used only with the -r and the -gr flag. Used to group the output of groupReference under a locator"
            }, 
            "groupName": {
                "docstring": "Used only with the -gr flag. Optionally used to set the name of the transform node that the imported/referenced items will be grouped under."
            }, 
            "groupReference": {
                "docstring": "Used only with the -r or the -i flag. Used to group all the imported/referenced items under a single transform."
            }, 
            "i": {
                "docstring": "Import the specified file. Returns the name of the imported file."
            }, 
            "ignoreVersion": {
                "docstring": "Used to open files with version greater or less than those officially supported. Data loss, data corruption or failure to open altogether are all possibilities, but as much as can be successfully read, will be. Must be used with the -o flag."
            }, 
            "importReference": {
                "docstring": "Remove the encapsulation of the reference around the data within the specified file. This makes the contents of the specified file part of the current scene and all references to the original file are lost. Returns the name of the reference that was imported."
            }, 
            "lastFileOption": {
                "docstring": "On query, returns the last option string used by the file command."
            }, 
            "lastTempFile": {
                "docstring": "When queried, this flag returns the temp file name used during file save. The temp file will be left in the same directory as the intended file name if the save fails."
            }, 
            "list": {
                "docstring": "List all files. Returns a string array of the names of all segment/reference files. Duplicates will be removed. So if a file is referenced more than once, and the -withoutCopyNumber flag is set, it will only be listed once. in the scene."
            }, 
            "loadAllDeferred": {
                "docstring": "This flag is obsolete, and has been replaced by the loadReferenceDepth flag. When used with the -open flag, determines if the -deferReference flag is respected when reading in the file. If true is passed, all of the references are loaded. If false is passed, the -deferReference flag is respected."
            }, 
            "loadAllReferences": {
                "docstring": "This flag is obsolete and has been replaced with the loadReferenceDepth flag. When used with the -open flag, this will cause all references to be loaded."
            }, 
            "loadNoReferences": {
                "docstring": "This flag is obsolete and has been replaced witht the loadReferenceDepth flag. When used with the -open flag, no references will be loaded. When used with -import, -reference or -loadReference flags, will load the top-most reference only."
            }, 
            "loadReference": {
                "docstring": "This flag loads a file and associates it with the passed reference node. If the reference node does not exist, the command will fail. If the file is already loaded, then this flag will reload the same file.If a file is not given, the command will load (or reload) the last used reference file."
            }, 
            "loadReferenceDepth": {
                "docstring": "Used to specify which references should be loaded. Valid types are \"all\", \"none\" and \"topOnly\", which will load all references, no references and top-level references only, respectively. Must be used with the -open, -import, -reference or -loadReference flags. When \"none\" is used with -loadReference, only path validation is performed. This can be used to replace a reference without triggering reload."
            }, 
            "loadReferencePreview": {
                "docstring": "This flag will perform a special preview-only load of a reference file. A preview-only reference file is not completely loaded, but instead is partially loaded so that certain information, such as nested references it contains, can be determined. Nested references that are previewed remain in a special preview-only state."
            }, 
            "loadSettings": {
                "docstring": "When used with the \"o/open\" flag this flag specifies which reference load settings should be used. Reference load settings specify which references should be brought in loaded and which unloaded. Those reference files that are brought in unloaded will usually not need to be read and interpreted by Maya. This can potentially reduce the time it takes Maya to load the whole scene. If no \"ls/loadSettings\" flag is specified, or the empty string (\"\") is used as the flag argument, the default load settings are used. The default load settings represent the state of all references when the file was last saved. The load settings \"implicitLoadSettings\" refer to the temporary load settings generated by the \"bls/buildLoadSettings\" flag and edited with the \"loadSettings\" command. Currently on the default and implicit load settings are supported."
            }, 
            "location": {
                "docstring": "Query the location of the given file name."
            }, 
            "lockContainerUnpublished": {
                "docstring": "Set the unpublised lock state for all containers in this file. This will not lock the attributes in the main scene directly, but any file that references this scene will have all its containers come in as unpublished locked."
            }, 
            "lockFile": {
                "docstring": "Lock or unlock the main scene. Any file referencing this scene will automatically lock all attributes and nodes. Also prevents reference edits from being saved to it from a parent file."
            }, 
            "lockReference": {
                "docstring": "Locks attributes and nodes from the referenced file."
            }, 
            "mapPlaceHolderNamespace": {
                "docstring": "Map a placeHolderNamespace to the given reference. Must be used with the file -i/-import, -r/-reference flags in create mode. The first string is the place holder namespace, including the angle brackets (ex: \"foo\"). The second string is the reference node whose namespace it should be mapped to (ex: \"refRN\"). If the namespace should be mapped to the root namespace, use \":\"."
            }, 
            "mergeNamespaceWithParent": {
                "docstring": "Used with the removeReference flag. When removing a file reference and its namespace, move the rest of the namespace content to parent namespace."
            }, 
            "mergeNamespaceWithRoot": {
                "docstring": "Used with the removeReference flag. When removing a file reference and its namespace, move the rest of the namespace content to root namespace."
            }, 
            "mergeNamespacesOnClash": {
                "docstring": "Used with the -import or -reference flag to prevent new namespaces from being created when namespaces of the same name already exist within Maya. For example, lets pretend a file being imported refers to \"ref:pSphere1\" and there is already a namespace called \"ref\" defined in Maya. If -mergeNamespacesOnClash is true, the existing ref namespace will be reused and pSphere1 will be moved into the existing namespace. If -mergeNamespacesOnClash is false, a new namespace will be created (in this case \"ref1\") and pShere1 moved into the ref1 namespace. The default value is false."
            }, 
            "modified": {
                "docstring": "Set the modified state of the file. A modified file will need to be saved before a new file is opened or created. Normally there is no need to edit this flag as the state of the file is updated automatically whenever an object is created or modified. If editing of the state is desired, it is done without use of the edit flag as covered in the example section below. In query mode, if the file has been modified 1 is returned. Otherwise 0 is returned."
            }, 
            "moveSelected": {
                "docstring": "This flag is obsolete."
            }, 
            "namespace": {
                "docstring": "The namespace name to use that will group all objects during importing and referencing. Change the namespace used to group all the objects from the specified referenced file. The reference must have been created with the \"Using Namespaces\" option, and must be loaded. Non-referenced nodes contained in the existing namespace will also be moved to the new namespace. The new namespace will be created by this command and can not already exist. The old namespace will be removed."
            }, 
            "newFile": {
                "docstring": "Initialize the scene. Returns untitled scene with default location."
            }, 
            "open": {
                "docstring": "Open the specified file. Returns the name of the opened file."
            }, 
            "options": {
                "docstring": "Set/query the currently set file options. File options are used while saving a maya file. The three file option flags supported are f, p, and v.f(legacy filepaths) indicates whether file paths should be written as URI, or as legacy format.It only can be 0 or 1.Setting f=1 indicates that the legacy format will be used. By default, or by setting f=0, URI format will be used.p(precision) defines the maya file IO's precision when saving the file. Only used by maya ascii file format.It is an integer value. The default value is 17.v(verbose) indicates whether long or short attribute names and command flags names are used when saving the file. Used by both maya ascii and maya binary file formats.It only can be 0 or 1.Setting v=1 indicates that long attribute names and command flag names will be used. By default, or by setting v=0, short attribute names will be used.The option format is \"flag1=XXX;flag2=XXX\". Maya uses the last flag value provided.Note:1. Use a semicolon(\";\") to separate several flags.2. No blank space(\" \") in option string."
            }, 
            "parentNamespace": {
                "docstring": "Returns the name(s) of a referenced file's parent namespaces."
            }, 
            "postSaveScript": {
                "docstring": "When used with the save flag, the specified script will be executed after the file is saved."
            }, 
            "preSaveScript": {
                "docstring": "When used with the save flag, the specified script will be executed before the file is saved."
            }, 
            "preserveName": {
                "docstring": "When used with compress, it will retain the regular extension rather than appending .gz."
            }, 
            "preserveReferences": {
                "docstring": "When used with the import/export flags this tells the importer/exporter to import/export references as references instead of copies of those references."
            }, 
            "preview": {
                "docstring": "Used in conjunction with any of the -exportXXX flags, causes Maya to return a list of the nodes that would be exported, without actually writing the exported file to disk."
            }, 
            "prompt": {
                "docstring": "This flag controls the display of file prompting dialogs. Some examples of file prompting dialogs include error messages that require user confirmation and missing file reference dialogs. Once this flag is used, every instance of the file command will use the last set value of this flag. Some interactive file operations may post dialogs even when the flag is set to false, but every scripted file command will not display any dialogs when this flag is set to false. The default value is true."
            }, 
            "proxyManager": {
                "docstring": "When a one or more proxy references are added to an existing file reference, the proxy manage node is used to define the proxies associated with that reference. This flag is used in conjunction with the activeProxy and proxyTag flag to specify the proxyManager of interest. This flag is also used to specify the proxyManager for a proxy reference in the file referencing preload information, when used in conjunction with the referenceDepthInfo flag."
            }, 
            "proxyTag": {
                "docstring": "This flag is intended for internal use only during file load or preload. Proxy tags are names you assign to proxy references to more easily manage the proxy references from the reference editor. Proxy tags are unique within a given proxy set. This flag must be used in conjunction with the proxyManager flag."
            }, 
            "query": {
                "docstring": ""
            }, 
            "reference": {
                "docstring": "Create a reference to the specified file. Returns the name of the file referenced.Query all file references from the specified file."
            }, 
            "referenceDepthInfo": {
                "docstring": "This flag is used to store reference loading preferences associated with a Maya ascii file (.ma). This flag is only useful during file I/O so users should not have any need to use this flag."
            }, 
            "referenceNode": {
                "docstring": "When queried, this flag returns the name of the reference node associated with the file. If the file is not a reference or does not have a reference node, an empty string is returned. In query mode, this flag can accept a value."
            }, 
            "removeDuplicateNetworks": {
                "docstring": "When set, Maya will remove imported networks if the same network is also detected in the current scene. This flag can only be used in conjunction with the import flag."
            }, 
            "removeReference": {
                "docstring": "Remove the given file reference from its parent. This will also Remove everything this file references. Returns the name of the file removed. If the reference is alone in its namespace, remove the namespace. If there are objects remaining in the namespace after the file reference is removed, by default, keep the remaining objects in the namespace. To merge the objects remaining in the namespace to the parent or root namespace, use flags mergeNamespaceWithParent or mergeNamespaceWithRoot. The empty file reference namespace is then removed. To forcibly delete all objects, use flag force. The empty file reference namespace is then removed."
            }, 
            "rename": {
                "docstring": "Rename the scene. Used mostly during save to set the saveAs name. Returns the new name of the scene."
            }, 
            "renameAll": {
                "docstring": "Only available with -import. If true, rename all newly-created nodes, not just those whose names clash with existing nodes. Only available with -import."
            }, 
            "renameToSave": {
                "docstring": "If true, the scene will need to be renamed before it can be saved. When queried this flag returns true if the scene must be renamed before it can be saved.The default is false."
            }, 
            "renamingPrefix": {
                "docstring": "The string to use as a prefix for all objects from this file. This flag has been replaced by -ns/namespace."
            }, 
            "renamingPrefixList": {
                "docstring": "This flag returns a list of all of the renaming prefixes used by the file."
            }, 
            "replaceName": {
                "docstring": "Define a search and replace string. Will apply search and replace to leaf node names. The search string can include namespaces and wild-cards, but will only apply to leaf nodes in a dag hierarchy. Intended for use with offline edits files. Must be used with file -import/-i or -reference/-r. If a nested reference also defines a substitution, it will become the active substitution table while loading the nested reference. Note: if used with the -edit/-e flag, the replacement will only be applied the next time the reference is loaded Examples: -replace \"\\*pCube1\" \"prop\" will change \"foo:pCube1\" to \"foo:prop\" and \"|A:pCube1|B:pCube1\" to \"|A:pCube1|prop\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "resetError": {
                "docstring": "Turn off any pre-existing global file errors."
            }, 
            "returnNewNodes": {
                "docstring": "Used to control the return value in open, import, loadReference, and reference operations. It will force file command to return a list of new nodes added to the current scene."
            }, 
            "save": {
                "docstring": "Save the specified file. Returns the name of the saved file."
            }, 
            "saveDiskCache": {
                "docstring": "This flag sets the saveAs option for Jiggle disk caches. The valid inputs are \"always\" - always copy a file texture to a new location, \"never\" - do not copy at all.C: The default is \"always\".Q: When queried it returns a string (\"always\", \"never\")."
            }, 
            "saveReference": {
                "docstring": "Save reference node edits and connections to reference file. This includes newly added history and animation, provided that these do not apply to any objects outside the reference being saved."
            }, 
            "saveReferencesUnloaded": {
                "docstring": "This flag can only be used in conjunction with the save flag. It specifies that the saved file will be saved with all references unloaded."
            }, 
            "saveTextures": {
                "docstring": "This flag sets the saveAs option for 3d Paint file textures. The valid inputs are \"always\" - always copy a file texture to a new location, \"unlessRef\" - copy only if this is not a referenced file texture, \"never\" - do not copy at all.C: The default is \"unlessRef\".Q: When queried it returns a string (\"always\", unlessRef\", \"never\")."
            }, 
            "sceneName": {
                "docstring": "return the name of the current scene."
            }, 
            "segment": {
                "docstring": "This flag is obsolete."
            }, 
            "selectAll": {
                "docstring": "Select all the components of this file as well as its child files. Note that the file specified must be one that is already opened in this Maya session. The default behaviour is to replace the existing selection. Use with the \"add\" flag to keep the active selection list."
            }, 
            "shader": {
                "docstring": "For use with exportSelected to specify whether attached shaders should be included in the export."
            }, 
            "sharedNodes": {
                "docstring": "This flag modifies the '-r/-reference' flag to indicate that certain types of nodes within that reference should be treated as shared nodes. All shared nodes will be placed in the default namespace. New copies of those nodes will not be created if a copy already exists in the default namespace, instead the shared node will be merged with the existing node. The specifics of what happens when two nodes are merged depends on the node type. In general attribute values will not be merged, meaning the values set on any existing shared nodes will be retained, and the values of the nodes being merged in will be ignored. The valid options are \"displayLayers\", \"shadingNetworks\", \"renderLayersByName\", and \"renderLayersById\". This flag is multi-use; it may be specified multiple times to for example, share both display layers and shading networks. Two shading networks will only be merged if they are identical: the network of nodes feeding into the shading group must be arranged identically with equivalent nodes have the same name and node type. Additionally if a network is animated or contains a DAG object or expression it will not be mergeable. This flag cannot be used in conjunction with -srf/sharedReferenceFile."
            }, 
            "sharedReferenceFile": {
                "docstring": "Can only be used in conjunction with the -r/reference flag and the -ns/namespace flag (there is no prefix support). This flag modifies the '-r/-reference' flag to indicate that all nodes within that reference should be treated as shared nodes. New copies of those nodes will not be created if a copy already exists. Instead, the shared node will be merged with the existing node. The specifics of what happens when two nodes are merged depends on the node type. This flag cannot be used in conjunction with -shd/sharedNodes."
            }, 
            "shortName": {
                "docstring": "When used with a main query flag it indicates that the file name returned will be the short name (i.e. just a file name without any directory paths). If this flag is not present, the full name and directory path will be returned."
            }, 
            "strict": {
                "docstring": "Set strict file path resolution. If true, all paths will be matched exactly, both relative and absolute. Relative paths will be considered relative to the project root directory. Must be used with the -open, -import, -importReference or -reference."
            }, 
            "swapNamespace": {
                "docstring": "Can only be used in conjunction with the -r/reference or -i/import flags. This flag will replace any occurrences of a given namespace to an alternate specified namespace. This namespace \"swap\" will occur as the file is referenced in. It takes in two string arguments. The first argument specifies the namespace to replace. The second argument specifies the replacement namespace. Use of this flag, implicitly enables the use of namespaces and cannot be used with deferReference."
            }, 
            "type": {
                "docstring": "Set the type of this file. By default this can be any one of: \"mayaAscii\", \"mayaBinary\", \"mel\", \"OBJ\", \"directory\", \"plug-in\", \"audio\", \"move\", \"EPS\", \"Adobe(R) Illustrator(R)\", \"image\" plug-ins may define their own types as well.Return a string array of file types that match this file."
            }, 
            "uiConfiguration": {
                "docstring": "Save the ui configuration with the scene in a uiConfiguration script node. (eg. panes, etc.) The current default is on and is set in initialStartup.mel."
            }, 
            "unloadReference": {
                "docstring": "This flag will unload the reference file associated with the passed reference node."
            }, 
            "unresolvedName": {
                "docstring": "When used with a main query flag it indicates that the file name returned will be unresolved (i.e. it will be the path originally specified when the file was loaded into Maya; this path may contain environment variables and may not exist on disk). If this flag is not present, the resolved name will be returned."
            }, 
            "usingNamespaces": {
                "docstring": "Returns boolean. Queries whether the specified reference file uses namespaces or renaming prefixes."
            }, 
            "withoutCopyNumber": {
                "docstring": "When used with a main query flag it indicates that the file name returned will not have a copy number appended to the end. If this flag is not present, the file name returned may have a copy number appended to the end."
            }, 
            "writable": {
                "docstring": "Query whether the given file is writable in the current scene. For main scene files this indicates writable to the file system by the current user. Files referenced by the main scene file are always not writable (referenced files are by nature read only). Files not present in the current scene always return false."
            }
        }
    }, 
    "fileBrowserDialog": {
        "description": "The fileBrowserDialog and fileDialog commands have now been deprecated. Both commands are still callable, but it is recommended that the fileDialog2 command be used instead. To maintain some backwards compatibility, both fileBrowserDialog and fileDialog will convert the flags/values passed to them into the appropriate flags/values that the fileDialog2 command uses and will call that command internally. It is not guaranteed that this compatibility will be able to be maintained in future versions so any new scripts that are written should use fileDialog2. See below for an example of how to change a script to use fileDialog2. ", 
        "flags": {
            "actionName": {
                "docstring": "Script to be called when the file is validated."
            }, 
            "dialogStyle": {
                "docstring": "0 for old style dialog1 for Windows 2000 style Explorer style2 for Explorer style with \"Shortcut\" tip at bottom"
            }, 
            "fileCommand": {
                "docstring": "The script to run on command action"
            }, 
            "fileType": {
                "docstring": "Set the type of file to filter. By default this can be any one of: \"mayaAscii\", \"mayaBinary\", \"mel\", \"OBJ\", \"directory\", \"plug-in\", \"audio\", \"move\", \"EPS\", \"Illustrator\", \"image\".plug-ins may define their own types as well."
            }, 
            "filterList": {
                "docstring": "Specify file filters. Used with dialog style 1 and 2. Each string should be a description followed by a comma followed by a semi-colon separated list of file extensions with wildcard."
            }, 
            "includeName": {
                "docstring": "Include the given string after the actionName in parentheses. If the name is too long, it will be shortened to fit on the dialog (for example, /usr/alias/commands/scripts/fileBrowser.mel might be shortened to /usr/...pts/fileBrowser.mel)"
            }, 
            "mode": {
                "docstring": "Defines the mode in which to run the file brower: 0 for read1 for write2 for write without paths (segmented files)4 for directories have meaning when used with the action+100 for returning short names"
            }, 
            "operationMode": {
                "docstring": "Enables the option dialog. Valid strings are: \"Import\"\"Reference\"\"SaveAs\"\"ExportAll\"\"ExportActive\""
            }, 
            "tipMessage": {
                "docstring": "Message to be displayed at the bottom of the style 2 dialog box."
            }, 
            "windowTitle": {
                "docstring": "Set the window title of a style 1 or 2 dialog boxFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "fileDialog": {
        "description": "The fileBrowserDialog and fileDialog commands have now been deprecated. Both commands are still callable, but it is recommended that the fileDialog2 command be used instead. To maintain some backwards compatibility, both fileBrowserDialog and fileDialog will convert the flags/values passed to them into the appropriate flags/values that the fileDialog2 command uses and will call that command internally. It is not guaranteed that this compatibility will be able to be maintained in future versions so any new scripts that are written should use fileDialog2. See below for an example of how to change a script to use fileDialog2. ", 
        "flags": {
            "application": {
                "docstring": "This is a \"Mac\" only flag. This brings up the dialog which selects only the application bundle."
            }, 
            "defaultFileName": {
                "docstring": "Set default file name. This flag is available under \"write\" mode"
            }, 
            "directoryMask": {
                "docstring": "This can be used to specify what directory and file names will be displayed in the dialog. If not specified, the current directory will be used, with all files displayed. The string may contain a path name, and must contain a wild-carded file specifier. (eg \"\\*.cc\" or \"/usr/u/\\*\") If just a path is specified, then the last directory in the path is taken to be a file specifier, and this will not produce the desired results."
            }, 
            "mode": {
                "docstring": "Defines the mode in which to run the file dialog: 0 for read1 for writeWrite mode can not be used in conjunction with the -application flag."
            }, 
            "title": {
                "docstring": "Set title text. The default value under \"write\" mode is \"Save As\". The default value under \"read\" mode is \"Open\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "fileDialog2": {
        "description": "This command provides a dialog that allows users to select files or directories. ", 
        "flags": {
            "cancelCaption": {
                "docstring": "If the dialogStyle flag is set to 2 then this provides a caption for the Cancel button within the dialog."
            }, 
            "caption": {
                "docstring": "Provide a title for the dialog."
            }, 
            "dialogStyle": {
                "docstring": "1 On Windows or Mac OS X will use a native style file dialog.2 Use a custom file dialog with a style that is consistent across platforms."
            }, 
            "fileFilter": {
                "docstring": "Provide a list of file type filters to the dialog. Multiple filters should be separated by double semi-colons. See the examples section."
            }, 
            "fileMode": {
                "docstring": "Indicate what the dialog is to return. 0 Any file, whether it exists or not.1 A single existing file.2 The name of a directory. Both directories and files are displayed in the dialog.3 The name of a directory. Only directories are displayed in the dialog.4 Then names of one or more existing files."
            }, 
            "fileTypeChanged": {
                "docstring": ""
            }, 
            "hideFileExtensions": {
                "docstring": ""
            }, 
            "okCaption": {
                "docstring": "If the dialogStyle flag is set to 2 then this provides a caption for the OK, or Accept, button within the dialog."
            }, 
            "optionsUICommit": {
                "docstring": ""
            }, 
            "optionsUICreate": {
                "docstring": ""
            }, 
            "optionsUIInit": {
                "docstring": ""
            }, 
            "returnFilter": {
                "docstring": "If true, the selected filter will be returned as the last item in the string array along with the selected files.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "selectFileFilter": {
                "docstring": "Specify the initial file filter to select. Specify just the begining text and not the full wildcard spec."
            }, 
            "selectionChanged": {
                "docstring": ""
            }, 
            "setProjectBtnEnabled": {
                "docstring": ""
            }, 
            "startingDirectory": {
                "docstring": "Provide the starting directory for the dialog."
            }
        }
    }, 
    "fileInfo": {
        "description": "fileInfo provides a mechanism for keeping information related to a Maya scene file. Each invocation of the command consists of a keyword/value pair, where both the keyword and the associated value are strings. The command may be invoked multiple times with different keywords. Maya emits this command several times into each file it creates, primarily to provide details such as which productization or packaging of the program was used (e.g \"Complete\", \"Unlimited\"), the specific version and build identification that was run, and the operating system on which it was run. Maya may make use of this information when present in files it reads. All keyword/value pairs defined by use of the fileInfo command are preserved when Maya saves the scene, whether to an ASCII or binary file. ", 
        "flags": {
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "If the remove flag is specified, the string following it is a keyword to remove from the list of fileInfo to be saved with the scene file.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "filletCurve": {
        "description": "The curve fillet command creates a fillet curve between two curves. If no objects are specified in the command line, then the first two active curves are used. The fillet created can be circular (with a radius) or freeform (with a type of tangent or blend). ", 
        "flags": {
            "bias": {
                "docstring": "Adjusting the bias value causes the fillet curve to be skewed to one of the input curves. Available only if blendControl is true.Default:0.0"
            }, 
            "blendControl": {
                "docstring": "If true then depth and bias can be controlled. Otherwise, depth and bias are not available options.Default:falseAdvanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "circular": {
                "docstring": "Curve fillet will be created as circular if true or freeform if false.Default:true"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curveParameter1": {
                "docstring": "Parameter where fillet curve will contact the primary input curve.Default:0.0"
            }, 
            "curveParameter2": {
                "docstring": "Parameter where fillet curve will contact the secondary input curve.Default:0.0"
            }, 
            "depth": {
                "docstring": "Adjusts the depth of the fillet curve. Available only if blendControl is true.Default:0.5"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "freeformBlend": {
                "docstring": "The freeform type is blend if true or tangent if false. Available if the fillet type is freeform.Default:false"
            }, 
            "join": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "The radius if creating a circular fillet.Default:1.0"
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "trim": {
                "docstring": ""
            }
        }
    }, 
    "filter": {
        "description": "Creates or modifies a filter node. Filter nodes are used by applyTake to modify recorded device data before assigning it to the param curves for the attached attributes. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name for created filterFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "type": {
                "docstring": "Filter type to create, One of:filterEulerEuler angle \"demangler\"filterResampleResamples input data at fixed output rate with several filtering optionsfilterSimplifyCombines groups of data points that are almost linear into lines segmentsfilterClosestSampleResamples input data a fixed output rate using the closest sample point"
            }
        }
    }, 
    "filterCurve": {
        "description": "The filterCurve command takes a list of anim curve and filters them. Currently only a Euler filter is supported. The Euler filter demangles discontinous rotation anim curves into smooth curves. ", 
        "flags": {
            "endTime": {
                "docstring": "Specify the end time of the section to filter. If not specified, the last key of the animation curve is used to define the end time.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "filter": {
                "docstring": "Specifies the filter type to use. The avalible filters are euler, simplify, and resample. By default euler is used."
            }, 
            "kernel": {
                "docstring": "The resample kernel is a decimation resampling filter used to resample dense data. It works on the keyframes and may not produce the desired results when used with sparse data. The resample filter converts from either uniform or non-uniform timestep input data samples to the specified uniform timeStep. Various time domain filters are available and are specified with the kernel flag which selects the resampling kernel applied to the keyframes on the animation curves. Kernel ValuesclosestClosest sample to output timestamplirpLinear interpolation between closest samplesboxBox filter: moving averagetriangleTriangle filter: (1 - |x|) weighted moving averagegaussian2Gaussian2 Filter: (2^(-2x\\*x)) weighted moving averagegaussian4Gaussian4 Filter: (2^(-4x\\*x)) weighted moving averageThis filter is onlytargeted at decimation resampling -- interpolation resampling is basically unsupported. If your output framerate is much higher than your input frame rate (approximate, as the input timestep is not assumed to be regular) the lirp and triangle will interpolate (usually) and the rest will either average, or use the closest sample (depending on the phase and frequency of the input). However this mode of operation may not give the expected result."
            }, 
            "maxTimeStep": {
                "docstring": "Simplify filter."
            }, 
            "minTimeStep": {
                "docstring": "Simplify filter."
            }, 
            "period": {
                "docstring": "Resample filter"
            }, 
            "startTime": {
                "docstring": "Specify the start time to filter. If not specified, then the first key in the animation curve is used to get the start time."
            }, 
            "timeTolerance": {
                "docstring": "Simplify filter."
            }, 
            "tolerance": {
                "docstring": "Simplify filter."
            }
        }
    }, 
    "filterExpand": {
        "description": "Based on selected components (or components specified on the command line), the command filters and/or expands the list given the options. Returns a string array containing all matching selection items. Selection masks are as follows: Object TypeMaskHandle0Nurbs Curves9Nurbs Surfaces10Nurbs Curves On Surface11Polygon12Locator XYZ22Orientation Locator23Locator UV24Control Vertices (CVs)28Edit Points30Polygon Vertices31Polygon Edges32Polygon Face34Polygon UVs35Subdivision Mesh Points36Subdivision Mesh Edges37Subdivision Mesh Faces38Curve Parameter Points39Curve Knot40Surface Parameter Points41Surface Knot42Surface Range43Trim Surface Edge44Surface Isoparms45Lattice Points46Particles47Scale Pivots49Rotate Pivots50Select Handles51Subdivision Surface68Polygon Vertex Face70NURBS Surface Face72Subdivision Mesh UVs73", 
        "flags": {
            "expand": {
                "docstring": "Each item is a single entity if this is true. Default is true."
            }, 
            "fullPath": {
                "docstring": "If this is true and the selection item is a DAG object, return its full selection path, instead of the name of the object only when this value is false. Default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "selectionMask": {
                "docstring": "Specify the selection mask"
            }
        }
    }, 
    "findKeyframe": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.This command will return the time (in current units) of the requested key. For the relative direction methods (next, previous) if -time is NOT specified they will use current time. If the specified object is not animated the command will return the current time. ", 
        "flags": {
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "curve": {
                "docstring": "Return a list of the existing curves driving the selected object or attributes. The which, index, floatRange, timeRange, and includeUpperBound flags are ignored when this flag is used.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }, 
            "timeSlider": {
                "docstring": "Get the next key time from the ticks displayed in the time slider. If this flag is set, then the -an/animation flag is ignored."
            }, 
            "which": {
                "docstring": "next | previous | first | last How to find the key"
            }
        }
    }, 
    "findType": {
        "description": "The findTypecommand is used to search upstream through a dependency subgraph on a certain node to find all nodes of the given type. These will be nodes that affect the given one. ", 
        "flags": {
            "deep": {
                "docstring": "Find all nodes of the given type instead of just the first."
            }, 
            "exact": {
                "docstring": "Match node types exactly instead of any in a node hierarchy."
            }, 
            "type": {
                "docstring": "Type of node to look for (e.g. \"transform\"). This flag is mandatory.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "fitBspline": {
        "description": "The fitBspline command fits the CVs from an input curve and and returns a 3D curve. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency nodeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": "Tolerance for the fit. The resulting curve will be kept within tolerance of the given points.Default:0.1Advanced flags"
            }
        }
    }, 
    "flagTest": {
        "description": "", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "floatRange": {
                "docstring": ""
            }, 
            "indexRange": {
                "docstring": ""
            }, 
            "multiUse": {
                "docstring": ""
            }, 
            "noReport": {
                "docstring": ""
            }, 
            "optionalQueryArgsFlag": {
                "docstring": ""
            }, 
            "pythonOptionalQueryArgsFlag": {
                "docstring": ""
            }, 
            "pythonQueryArgsFlag": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "queryArgsFlag": {
                "docstring": ""
            }, 
            "simpleFlag": {
                "docstring": ""
            }, 
            "stringArrayFlag": {
                "docstring": ""
            }, 
            "stringFlag": {
                "docstring": ""
            }, 
            "timeRange": {
                "docstring": ""
            }, 
            "tripleFloat": {
                "docstring": ""
            }
        }
    }, 
    "flexor": {
        "description": "This command creates a flexor. A flexor a deformer plus a set of driving attributes. For example, a flexor might be a sculpt object that is driven by a joint's x rotation and a cube's y position. ", 
        "flags": {
            "atBones": {
                "docstring": "Add a flexor at bones. Flexor will be added at each of the selected bones, or at all bones in the selected skeleton if the -ts flag is also specified."
            }, 
            "atJoints": {
                "docstring": "Add a flexor at joints. Flexor will be added at each of the selected joints, or at all joints in the selected skeleton if the -ts flag is specified."
            }, 
            "deformerCommand": {
                "docstring": "String representing underlying deformer command string."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "list": {
                "docstring": "List all possible types of flexors. Query mode only."
            }, 
            "name": {
                "docstring": "This flag is obsolete.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "noScale": {
                "docstring": "Do not auto-scale the flexor to the size of the nearby geometry."
            }, 
            "query": {
                "docstring": ""
            }, 
            "toSkeleton": {
                "docstring": "Specifies that flexors will be added to the entire skeleton rather than just to the selected joints/bones. This flag is used in conjunction with the -ab and -aj flags."
            }, 
            "type": {
                "docstring": "Specifies which type of flexor. To see list of valid types, use the \"flexor -query -list\" command."
            }
        }
    }, 
    "floatField": {
        "description": "Create a field control that accepts only float values and is bound by a minimum and maximum value. An invisible slider is attached to the field and accessed by holding down the Ctrl modifier key while pressing one of the mouse buttons. Dragging the invisible slider to the right with the middle mouse button increases the field value by the amount specified with the -s/stepflag, while dragging to the left decreases the value by the same amount. The left and right mouse buttons apply a factor of 0.1 and 10 to the step value. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the field changes. This command is not invoked when the value changes via the -v/valueflag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command executed when dragging in the field."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "The edit state of the field. By default, this flag is set to true and the field value may be changed by typing into it. If false then the field can not be changed interactively. However, you can change the field text with the -v/valueflag regardless of the state of the -ed/editableflag."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enterCommand": {
                "docstring": "Command executed when the keypad 'Enter' key is pressed."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Upper limit of the field."
            }, 
            "minValue": {
                "docstring": "Lower limit of the field."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "precision": {
                "docstring": "Number of digits to the right of the decimal place."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "receiveFocusCommand": {
                "docstring": "Command executed when the field receives focus.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "step": {
                "docstring": "Increment for the invisible slider. The field value will change by this amount when the invisible slider is dragged."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Value of the field."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "floatFieldGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a pre-packaged collection of label text and editable float fields. The label text is optional and one to four float fields can be created. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command string executed when the value of any of the fields changes."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command string executed when dragging the invisible slider in any of the fields."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enable1": {
                "docstring": ""
            }, 
            "enable2": {
                "docstring": ""
            }, 
            "enable3": {
                "docstring": ""
            }, 
            "enable4": {
                "docstring": "Enable state for the respective field.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "extraLabel": {
                "docstring": "If present on creation this specifies that there will be an extra label in the group. Sets the string to be label text to the right of fields."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "If present on creation this specifies that there will be a label to the left of the fields. Sets the string to be the label text."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfFields": {
                "docstring": "Set the number of fields on creation. One to four fields are available. The default is one field."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "precision": {
                "docstring": "Set the number of digits to the right of the decimal."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "step": {
                "docstring": "Set the delta of invisioSlider delta , the invisioSlider step is delta/10.0 in LMB , delta in MMB,delta\\*10.0 in RMB. Default is 10.0"
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Values for all fields."
            }, 
            "value1": {
                "docstring": ""
            }, 
            "value2": {
                "docstring": ""
            }, 
            "value3": {
                "docstring": ""
            }, 
            "value4": {
                "docstring": "Value for the respective field."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "floatScrollBar": {
        "description": "Create a scroll bar control that accepts only float values and is bound by a minimum and maximum value. The scroll bar displays a marker indicating the current value of the scroll bar relative to it's minimum and maximum values. Click and drag the marker or on the scroll bar itself to change the current value. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the value changes. This command is not invoked when the value changes via the -v/value flag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command executed when the value changes by dragging the scroll bar's value marker.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "horizontal": {
                "docstring": "Orientation of the slider. This flag is true by default which corresponds to a horizontally oriented slider."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "largeStep": {
                "docstring": "Larger increment for the scroll bar, ie. the increment used when the press is between the arrow button and the thumb."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Upper limit of the scroll bar."
            }, 
            "minValue": {
                "docstring": "Lower limit of the scroll bar."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "step": {
                "docstring": "Smaller increment for the scroll bar, ie. the increment used when the arrow buttons are pressed."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Value of the scroll bar."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "floatSlider": {
        "description": "Create a slider control that accepts only float values and is bound by a minimum and maximum value. The slider displays a marker indicating the current value of the slider relative to it's minimum and maximum values. Click and drag the marker or on the slider itself to change the current value. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the value changes. This command is not invoked when the value changes via the -v/value flag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command executed when the value changes by dragging the slider's value marker.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "horizontal": {
                "docstring": "Orientation of the slider. This flag is true by default which corresponds to a horizontally oriented slider."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Upper limit of the slider."
            }, 
            "minValue": {
                "docstring": "Lower limit of the slider."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "step": {
                "docstring": "The step value represents the amount the value will increase or decrease when you click either side of the slider."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Value of the slider."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "floatSlider2": {
        "description": "This command creates a float slider containing two handles. The two handles are arranged such that they cannot pass one another, thus handle 1 will always have a value less than or or equal to handle 2 when you adjust the values. Each handle may have a MEL command associated with it which is issued when the handle moves and thus can be used to update the values of plugs such as via a setAttr command. Each handle can also be associated with a float textfield to display the current value of the handle. Note: the floatSlider2 widget currently only supports vertical (columnLayout) orientation. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand1": {
                "docstring": "Command to be associated with handle 1 and issued whenever the value of the handle is changed (except when values are changed via the -hv/handleValue flag). An example command might be \"setAttr nurbsSphere1.tx\" and if handle 1 were to move to value 0.23 the slider would issue the command \"setAttr nurbsSphere1.tx 0.23;\"."
            }, 
            "changeCommand2": {
                "docstring": "Command to be associated with handle 2 and issued whenever the value of the handle is changed (except when values are changed via the -hv/handleValue flag). An example command might be \"setAttr nurbsSphere1.tx\" and if handle 2 were to move to value 0.23 the slider would issue the command \"setAttr nurbsSphere1.tx 0.23;\"."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maximum": {
                "docstring": "Maximum limit of the slider. The default value is 10.0. The maximum value occurs at the top(right) end of the slider unless -polarity was specified. Note: you cannot set the maximum value greater than or equal to the current minimum."
            }, 
            "minimum": {
                "docstring": "Minimum limit of the slider. The default value is 0.0. The minimum value occurs at the bottom end of the slider unless -polarity was specified. Note: you cannot set the minimum value greater than or equal to the current maximum."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "polarity": {
                "docstring": "Specifies the polarity of the slider. If 0 (the default), the minimum value (specified by the -minimum flag) occurs at the bottom end of the slider and maximum at the top(right), with values increasing as the slider handles are moved towards the upper end of the slider. If the polarity is specified as 1, the reverse behaviour occurs, with the maximum occurring at the bottom end, the mimimum occuring at the top(right) end and values decreasing as the handles are moved towards the upper end."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "positionControl1": {
                "docstring": "Set the name of the control (if any) which is associated with handle 1 of this slider. The control must be a \"floatField\". The control always displays the value of the handle, and is updated as the handle moves."
            }, 
            "positionControl2": {
                "docstring": "Set the name of the control (if any) which is associated with handle 2 of this slider. The control must be a \"floatField\". The control always displays the value of the handle, and is updated as the handle moves.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value1": {
                "docstring": "Value of handle 1. To ensure that handle 1 stays at or below handle 2, an error will occur if the value specified is too large. If you wish to set both handles simultaneously, use the -values flag."
            }, 
            "value2": {
                "docstring": "Value of handle 2. To ensure that handle 2 stays at or above handle 2, an error will occur if the value specified is too large. If you wish to set both handles simultaneously, use the -values flag."
            }, 
            "values": {
                "docstring": "Sets the value for handles 1 and 2 simulteneously. The first argument is applied to handle 1 and must be less than or equal to the second (handle 2) argument or an error will be issued."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "floatSliderButtonGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a float slider component with optional button and symbol buttons. TelfFloatSliderGrpCmd.cpp ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "buttonCommand": {
                "docstring": "Command string to be executed when the button is pressed."
            }, 
            "buttonLabel": {
                "docstring": "The button text."
            }, 
            "changeCommand": {
                "docstring": "Command string executed when the value of the slider changes. It will be executed only once after a drag of the slider."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command string executed repeatedly during a drag of the slider."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "extraLabel": {
                "docstring": "If present on creation this specifies that there will be an extra label appearing after the slider. Sets the string to be the text for the extra label."
            }, 
            "field": {
                "docstring": "Indicates whether the group will have an editable float field present that reflects the value of the slider."
            }, 
            "fieldMaxValue": {
                "docstring": "Maximum value that may be entered in the field. This value may be set to any value greater than the -max/maxValueflag. By default, it is equal to the -max/maxValueflag."
            }, 
            "fieldMinValue": {
                "docstring": "Minimum value that may be entered in the field. This value may be set to any value less than the -min/minValueflag. By default, it is equal to the -min/minValueflag."
            }, 
            "fieldStep": {
                "docstring": "Increment for the field."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "image": {
                "docstring": "Image displayed on the symbol button."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "If present on creation the group will have static text."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Maximum value for both the slider and the field."
            }, 
            "minValue": {
                "docstring": "Minimum value for both the slider and the field."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "precision": {
                "docstring": "Number of digits to the right of the decimal."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "sliderStep": {
                "docstring": "The slider step value represents the amount the value will increase or decrease when you click either side of the slider."
            }, 
            "step": {
                "docstring": "Increment for both the slider and field."
            }, 
            "symbolButtonCommand": {
                "docstring": "Command string executed when the symbol button is pressed."
            }, 
            "symbolButtonDisplay": {
                "docstring": "Visibility of the symbol button.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Value of the group."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "floatSliderGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a pre-packaged collection of controls containing a label text, an float field and a float slider. The text and field controls are optional. Editing or querying the field range values has no effect if the -f/fieldflag was not specified when the group was created. This group also allows you to enter values into the field outside of the slider range which is limited by the -min/minValueand -max/maxValueflags. To do this, use the -fmn/fieldMinValueand -fmx/fieldMaxValueflags to specify a greater range of values. Note that the command will not allow you to specify a -fmn/fieldMinValuegreater than the -min/minValuevalue nor a -fmx/fieldMaxValueless than the -max/maxValuevalue. If you do supply a larger field range with the -fmn/fieldMinValueand -fmx/fieldMaxValueflags then you will notice that entering a value in the field that is outside of the slider range will result in extending the slider range as well. For example, if you create a slider group with the following command: floatSliderGrp -min -10 -max 10 -fieldMinValue -100 -fieldMaxValue 100; Then you will be able to use the slider to select any value from -10 to 10. At the same time you will be able to enter into the field any value from -100 to 100. If you enter a value, say 20, then the new slider range will grow such that this value is now accessible through the slider as well. In fact, the new slider limit will become double of that what you entered. Note that the slider limits will never grow beyond the field limits, in other words if you entered the value 80 then the slider will be clipped to the field limit of 100 and not doubled to 160. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command string executed when the value of the slider changes. It will be executed only once after a drag of the slider."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command string executed repeatedly during a drag of the slider.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "extraLabel": {
                "docstring": "If present on creation this specifies that there will be an extra label appearing after the slider. Sets the string to be the text for the extra label."
            }, 
            "field": {
                "docstring": "Indicates whether the group will have an editable float field present that reflects the value of the slider."
            }, 
            "fieldMaxValue": {
                "docstring": "Maximum value that may be entered in the field. This value may be set to any value greater than the -max/maxValueflag. By default, it is equal to the -max/maxValueflag."
            }, 
            "fieldMinValue": {
                "docstring": "Minimum value that may be entered in the field. This value may be set to any value less than the -min/minValueflag. By default, it is equal to the -min/minValueflag."
            }, 
            "fieldStep": {
                "docstring": "Increment for the field."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "If present on creation the group will have static text."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Maximum value for both the slider and the field."
            }, 
            "minValue": {
                "docstring": "Minimum value for both the slider and the field."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "precision": {
                "docstring": "Number of digits to the right of the decimal."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "sliderStep": {
                "docstring": "The slider step value represents the amount the value will increase or decrease when you click either side of the slider."
            }, 
            "step": {
                "docstring": "Increment for both the slider and field."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Value of the group."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "flow": {
        "description": "The flow command creates a deformation lattice to `bend' the object that is animated along a curve of a motion path animation. The motion path animation has to have the follow option set to be on. ", 
        "flags": {
            "divisions": {
                "docstring": "This flag specifies the number of lattice slices in x,y,z.The default values are 2 5 2.When queried, it returns the TuInt32 TuInt32 TuInt32"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "localCompute": {
                "docstring": "This flag specifies whether or not to have local control over the object deformation.Default value: is on when the lattice is around the curve, and is off when the lattice is around the object.When queried, it returns a boolean"
            }, 
            "localDivisions": {
                "docstring": "This flag specifies the extent of the region of effect.Default values are 2 2 2.When queried, it returns the TuInt32 TuInt32 TuInt32"
            }, 
            "objectCentered": {
                "docstring": "This flag specifies whether to create the lattice around the selected object at its center, or to create the lattice around the curve.Default value is true.When queried, it returns a booleanFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "flowLayout": {
        "description": "This command creates a layout that arranges its children along a single line (either horizontal or vertical). Depending on the value of the -wrap boolean flag (default is false), if the layout's parent cannot fit all the children on one line, the children will either wrap onto the next line(s) or be truncated. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "columnSpacing": {
                "docstring": "Sets the space between children."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "vertical": {
                "docstring": "Whether the orientation of the layout is horizontal (default) or vertical."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "wrap": {
                "docstring": "When set to true, if the layout's parent cannot fit all the children in a single line, the children will wrap onto the next line(s). Default setting is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "fluidCacheInfo": {
        "description": "A command to get information about the fluids cache. Get the startFrame and resolution for InitialConditions. Get the endFrame as well for a playback cache. Note that for the playback cache, it will look at the current time (or last frame if the current time is past end of cache) In query mode, return type is based on queried flag.", 
        "flags": {
            "attribute": {
                "docstring": "Modifier to the \"hasData\" flag, used to query whether a cache has data (at the current time) for a specific fluid attribute. Valid attribute values are \"density\", \"velocity\", \"temperature\", \"fuel\", \"color\", \"coordinates\" (for texture coordinates), \"falloff\"."
            }, 
            "cacheTime": {
                "docstring": "Only valid with the -hasData flag. The time the -hasData flag uses when it queries the cache to see if there is data.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endFrame": {
                "docstring": "Returns end time of cache as float."
            }, 
            "hasCache": {
                "docstring": "Returns true if fluid has specified cache, false if not."
            }, 
            "hasData": {
                "docstring": "Queries whether a given cache has data in it at the time specified by the -time flag. (If not -time flag is present, -hasData assumes the current time.) When used with the \"attribute\" flag, indicates if data for the specified attribute exists in the cache. When used without the \"attribute\" flag, \"hasData\" indicates whether there is data in the cache for any of the valid fluid attributes."
            }, 
            "initialConditions": {
                "docstring": "Specifies the cache to be queried is the \"Initial Conditions\" cache."
            }, 
            "playback": {
                "docstring": "Specifies the cache to be queried is the \"Playback\" cache."
            }, 
            "query": {
                "docstring": ""
            }, 
            "resolution": {
                "docstring": "Returns cache resolution as float[]."
            }, 
            "startFrame": {
                "docstring": "Returns start time for cache as float."
            }
        }
    }, 
    "fluidEmitter": {
        "description": "Creates an emitter object. If object names are provided or if objects are selected, applies the emitter to the named/selected object(s)in the scene. Fluid will then be emitted from each. If no objects are named or selected, or if the -pos option is specified, creates a positional emitter. If an emitter was created, the command returns the name of the object owning the emitter, and the name of emitter shape. If an emitter was queried, the command returns the results of the query. ", 
        "flags": {
            "cycleEmission": {
                "docstring": "Possible values are \"none\" and \"frame.\" Cycling emission restarts the random number stream after a specified interval. This can either be a number of frames or a number of emitted particles. In each case the number is specified by the cycleInterval attribute. Setting cycleEmission to \"frame\" and cycleInterval to 1 will then re-start the random stream every frame. Setting cycleInterval to values greater than 1 can be used to generate cycles for games work."
            }, 
            "cycleInterval": {
                "docstring": "Specifies the number of frames or particles between restarts of the random number stream. See cycleEmission. Has no effect if cycleEmission is set to None."
            }, 
            "densityEmissionRate": {
                "docstring": "Rate at which density is emitted."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "fluidDropoff": {
                "docstring": "Fluid Emission Dropoff in volume"
            }, 
            "fuelEmissionRate": {
                "docstring": "Rate at which is emitted.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "heatEmissionRate": {
                "docstring": "Rate at which density is emitted."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which emission ends."
            }, 
            "minDistance": {
                "docstring": "Minimum distance at which emission starts."
            }, 
            "name": {
                "docstring": ""
            }, 
            "position": {
                "docstring": "Positional emitter at world space location (x,y,z)."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rate": {
                "docstring": "Rate at which particles emitted (can be non-integer). For point emission this is rate per point per unit time. For surface emission it is rate per square unit of area per unit time."
            }, 
            "torusSectionRadius": {
                "docstring": "Section radius for a torus volume. Applies only to torus. Similar to the section radius in the torus modelling primitive."
            }, 
            "type": {
                "docstring": "Type of emitter. The choices are omni | dir | direction | surf | surface | curve | curv. The default is omni. The full definition of these types are: omnidirectional point emitter, directional point emitter, surface emitter, or curve emitter."
            }, 
            "volumeOffset": {
                "docstring": "Volume offset of the emitter. Volume offset translates the emission volume by the specified amount from the actual emitter location. This is in the emitter's local space."
            }, 
            "volumeShape": {
                "docstring": "Volume shape of the emitter. Sets/edits/queries the field's volume shape attribute. If set to any value other than \"none\", determines a 3-D volume within which particles are generated. Values are: \"cube,\" \"sphere,\" \"cylinder,\" \"cone,\" \"torus.\""
            }, 
            "volumeSweep": {
                "docstring": "Volume sweep of the emitter. Applies only to sphere, cone, cylinder, and torus. Similar effect to the sweep attribute in modelling."
            }
        }
    }, 
    "fluidVoxelInfo": {
        "description": "Provides basic information about the mapping of a fluid voxel grid into world- or object space of the fluid. Use this command to determine the center point of a voxel, or to find the voxel containing a given point, among other things. ", 
        "flags": {
            "checkBounds": {
                "docstring": "If this flag is on, and the voxel index of a point that is out of bounds is requested, then we return nothing."
            }, 
            "inBounds": {
                "docstring": "Are the three ints representing the x, y, z indices of a voxel within the bounds of the fluid's voxel grid? True if yes, false if not. (For 2D fluids, pass in z=0 for the third argument. See examples.)"
            }, 
            "objectSpace": {
                "docstring": "Whether the queried value should be returned in object space (TRUE), or world space (FALSE, the default)."
            }, 
            "radius": {
                "docstring": "Modifier for the -voxel flag. Returns a list of index triples identifying voxels that fall within the given radius of the point specified by the -voxel flag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "voxel": {
                "docstring": "Returns array of three ints representing the x, y, z indices of the voxel within which the given point position is contained. If the checkBounds flag is on, and the point is out of bounds, we return nothing. Otherwise, even if the point is out of bounds, index values are returned. When combined with the -radius flag, returns an array of index triples representing a list of voxels within a given radius of the given point position."
            }, 
            "voxelCenter": {
                "docstring": "The center position of the specified voxels. Returns an array of floats (three for each of the indices in the query). (Valid only with the -xIndex, -yIndex, and -zIndex flags.)"
            }, 
            "xIndex": {
                "docstring": "Only return values for cells with this X index"
            }, 
            "yIndex": {
                "docstring": "Only return values for cells with this Y index"
            }, 
            "zIndex": {
                "docstring": "Only return values for cells with this Z index"
            }
        }
    }, 
    "flushIdleQueue": {
        "description": "", 
        "flags": {
            "resume": {
                "docstring": ""
            }
        }
    }, 
    "flushThumbnailCache": {
        "description": "", 
        "flags": {}
    }, 
    "flushUndo": {
        "description": "Removes everything from the undo queue, freeing up memory. ", 
        "flags": {}
    }, 
    "fontAttributes": {
        "description": "", 
        "flags": {
            "faceName": {
                "docstring": ""
            }, 
            "font": {
                "docstring": ""
            }, 
            "pitch": {
                "docstring": ""
            }, 
            "size": {
                "docstring": ""
            }, 
            "style": {
                "docstring": ""
            }, 
            "weight": {
                "docstring": ""
            }
        }
    }, 
    "fontDialog": {
        "description": "On Windows systems only, the command can be invoked with no flags; in this case it displays a font picking window, and returns the name of the font that the user picked. If the user picked no font, then an empty string is returned. ", 
        "flags": {
            "FontList": {
                "docstring": "This option is available on all platforms. No dialog is displayed; a list of all available font names is returned.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "formLayout": {
        "description": "This command creates a form layout control. A form layout allows absolute and relative positioning of the controls that are its immediate children. Controls have four edges: top, left, bottom and right. There are only two directions that children can be positioned in, right-left and up-down. The attach flags take the direction of an attachment from the argument that names the edge to attach (the second argument). Any or all edges of a child may be attached. There are six ways to attach them: Attach to Form - Attaches an edge to the relevant side of the form layout. Thus -attachForm button3 \"left\" will attach the left edge of the button to the left edge of the form.Attach to Opposite Side of Form - Attaches an edge relative to the furthest side of the form layout.Attach to Another Control - Attaches an edge to the closest edge of the other control named.Attach to Opposite Side of Another Control - Attaches an edge relative to the furthest side of another control.Attach to Position - Attaches an edge to a position on the form layout. The position is given as a fixed fraction of the -nd/numDivisions value and as this value defaults to 100 it is easiest to think of it as a percentage of the form's size.Attach to Nothing - Attaches an edge to nothing. The size of the child control will determine this edge's position.Each edge attachment may have an offset that acts to separate controls visually. There is no default positioning relationship so to have children appear in the form they must have at least one edge attached in each direction. Note:In the flag definitions the arguments follow these rules: controlmust be the name of an immediate child of the form layout.edgemust be one of \"top\", \"left\", \"bottom\", or \"right\".positionmay range from 0 to the number of divisions as specified with the -nd/numberOfDivisions flag and gives the fraction of the width of the form as a measurement. This normally means 0-100 so positionmay be thought of as a percentage.offsetis an integer value in pixels.These are multi-use flags so any number of attachments may be made in a single command. Note:Avoid making control attachments that form a loop in control dependencies. For example: window; string $form = `formLayout`; string $btn1 = `button`; string $btn2 = `button`; string $btn3 = `button`;formLayout -edit-attachControl $btn2 \"top\"   2 $btn1-attachControl $btn3 \"top\"   2 $btn2-attachControl $btn1 \"right\" 2 $btn3 $form;showWindow; $btn2 is attached to $btn1, $btn3 is attached to $btn2, and $btn1 is attached to $btn3. Thus, the placement of $btn1 is dependent on the placement of $btn3, which is dependent on the placement of $btn2, which is dependent on the placement of $btn1. The last control attachment will have created a loop in the dependencies. To prevent runtime errors, Maya will ignore this attachment and instead issue a warning that a cyclical control attachment has been detected in the script. Note:More information on formLayouts can be found in the online User-interface Creation manual. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "attachControl": {
                "docstring": "Arguments are: control, edge, offset, control Valid edge values are: \"top\" | \"bottom\" | \"left\" | \"right\". Attach a control to another control."
            }, 
            "attachForm": {
                "docstring": "Arguments are: control, edge, offset. Valid edge values are: \"top\" | \"bottom\" | \"left\" | \"right\". Attach the specified control to the form, offset by the specified amount."
            }, 
            "attachNone": {
                "docstring": "Arguments are: control, edge Valid edge values are: \"top\" | \"bottom\" | \"left\" | \"right\". Attach a control to nothing.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "attachOppositeControl": {
                "docstring": "Arguments are: control, edge, offset, control Valid edge values are: \"top\" | \"bottom\" | \"left\" | \"right\". Attach a control to the opposite side of another control."
            }, 
            "attachOppositeForm": {
                "docstring": "Arguments are: control, edge, offset. Valid edge values are: \"top\" | \"bottom\" | \"left\" | \"right\". Attach a control to the opposite side of the form."
            }, 
            "attachPosition": {
                "docstring": "Arguments are: control, edge, offset, position Valid edge values are: \"top\" | \"bottom\" | \"left\" | \"right\". Attach a control to a position in the form."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfDivisions": {
                "docstring": "Specify the number of horizontal and vertical divisions across the form. Value must be greater than 0."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "format": {
        "description": "This command takes a format string, where the format string contains format specifiers. The format specifiers have a number associated with them relating to which parameter they represent to allow for alternate ordering of the passed-in values for other languages by merely changing the format string ", 
        "flags": {
            "stringArg": {
                "docstring": "Specify the arguments for the format string.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "frameBufferName": {
        "description": "Returns the frame buffer name for a given renderPass renderLayer and camera combination. Optionally, this command can apply a name truncation algorithm so that the frameBuffer name will respect the maximum length imposed by the destination file format, if applicable. ", 
        "flags": {
            "autoTruncate": {
                "docstring": "use this flag to apply a name truncation algorithm so that the frameBuffer name will respect the maximum length imposed by the destination file format, if applicable.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "camera": {
                "docstring": "Specify a camera"
            }, 
            "renderLayer": {
                "docstring": "Specify a renderer layer"
            }, 
            "renderPass": {
                "docstring": "Specify a renderer pass"
            }
        }
    }, 
    "frameLayout": {
        "description": "This command creates frame layout control. A frame layout may draw a border around its child controls as well as a display a title. Frame layouts may also be collapsable. Collapsing a frame layout will make the child of the frame layout invisible and shrink the frame layout size. The frame layout may then be expanded to make its child visible. Note that the frame layout may have only one child control. If you wish to have more than one child inside a frame layout then you must use some other control layout as the immediate child of the frame layout. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "borderStyle": {
                "docstring": "Border style. Valid values are \"in\", \"out\", \"etchedIn\", or \"etchedOut\". \"in\" will make the frame appear sunk in. \"out\" will make the frame appear raised. \"etchedIn\" will make the border itself appear sunk in. Similary, \"etchedOut\" will make the border appear raised."
            }, 
            "borderVisible": {
                "docstring": "Visibility of the border."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "collapsable": {
                "docstring": "Collapsibility of the frame layout."
            }, 
            "collapse": {
                "docstring": "Collapse state of the frame layout."
            }, 
            "collapseCommand": {
                "docstring": "Command executed after the frame is collapsed."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandCommand": {
                "docstring": "Command executed after the frame is expanded."
            }, 
            "font": {
                "docstring": "The font for the frame label. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\"."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "Label string for the frame layout."
            }, 
            "labelAlign": {
                "docstring": ""
            }, 
            "labelIndent": {
                "docstring": "Indentation for the frame label."
            }, 
            "labelVisible": {
                "docstring": "Visibility of the frame label."
            }, 
            "labelWidth": {
                "docstring": ""
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "marginHeight": {
                "docstring": "Vertical distance between the frame and its children."
            }, 
            "marginWidth": {
                "docstring": "Horizontal distance between the frame and its children."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preCollapseCommand": {
                "docstring": "Command executed just before the frame is collapsed."
            }, 
            "preExpandCommand": {
                "docstring": "Command executed just before the frame is expanded.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "freeFormFillet": {
        "description": "This command creates a free form surface fillet across two surface trim edges or isoparms or curve on surface. The fillet surface creation has blend controls in the form of bias and depth. The bias value scales the tangents at the two ends across the two selected curves. The depth values controls the curvature of the fillet across the two selected curves. The default values of depth, bias are 0.5 and 0.5 respectively. ", 
        "flags": {
            "bias": {
                "docstring": "Bias value for filletDefault:0.5Advanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "depth": {
                "docstring": "Depth value for filletDefault:0.5"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)"
            }, 
            "positionTolerance": {
                "docstring": "C(0) Tolerance For Filleted Surface creationDefault:0.1"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curveFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "tangentTolerance": {
                "docstring": "G(1) continuity Tolerance For Filleted Surface creationDefault:0.1"
            }
        }
    }, 
    "geometryConstraint": {
        "description": "Constrain an object's position based on the shape of the target surface(s) at the closest point(s) to the object. A geometryConstraint takes as input one or more surface shapes (the targets) and a DAG transform node (the object). The geometryConstraint position constrained object such object lies on the surface of the target with the greatest weight value. If two targets have the same weight value then the one with the lowest index is chosen. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "layer": {
                "docstring": "Specify the name of the animation layer where the constraint should be added.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "Sets the name of the constraint node to the specified name. Default name is constrainedObjectName_constraintType"
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the listed target(s) from the constraint."
            }, 
            "targetList": {
                "docstring": "Return the list of target objects."
            }, 
            "weight": {
                "docstring": "Sets the weight value for the specified target(s). If not given at creation time, the default value of 1.0 is used."
            }, 
            "weightAliasList": {
                "docstring": "Returns the names of the attributes that control the weight of the target objects. Aliases are returned in the same order as the targets are returned by the targetList flag"
            }
        }
    }, 
    "getAttr": {
        "description": "This command returns the value of the named object's attribute. UI units are used where applicable. Currently, the types of attributes that can be displayed are: numeric attributesstring attributesmatrix attributesnumeric compound attributes (whose children are all numeric)vector array attributesdouble array attributesint32 array attributespoint array attributesdata component list attributesOther data types cannot be retrieved. No result is returned if the attribute contains no data. ", 
        "flags": {
            "asString": {
                "docstring": "This flag is only valid for enum attributes. It allows you to get the attribute values as strings instead of integer values. Note that the returned string value is dependent on the UI language Maya is running in (about -uiLanguage)."
            }, 
            "asURI": {
                "docstring": "This flag is only valid for attributes marked for use as a file name. It gets the attribute value as an URI instead of the OS native file path."
            }, 
            "caching": {
                "docstring": "Returns whether the attribute is set to be cached internally"
            }, 
            "channelBox": {
                "docstring": "Returns whether the attribute is set to show in the channelBox. Keyable attributes also show in the channel box."
            }, 
            "expandEnvironmentVariables": {
                "docstring": "Expand any environment variable and (tilde characters on UNIX) found in string attributes which are returned."
            }, 
            "keyable": {
                "docstring": "Returns the keyable state of the attribute."
            }, 
            "lock": {
                "docstring": "Returns the lock state of the attribute."
            }, 
            "multiIndices": {
                "docstring": "If the attribute is a multi, this will return a list containing all of the valid indices for the attribute.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "settable": {
                "docstring": "Returns 1 if this attribute is currently settable by setAttr, 0 otherwise. An attribute is settable if it's not locked and either not connected, or has only keyframed animation."
            }, 
            "silent": {
                "docstring": "When evaluating an attribute that is not a numeric or string value, suppress the error message saying that the data cannot be displayed. The attribute will be evaluated even though its data cannot be displayed. This flag does not suppress all error messages, only those that are benign."
            }, 
            "size": {
                "docstring": "Returns the size of a multi-attribute array. Returns 1 if non-multi."
            }, 
            "time": {
                "docstring": "Evaluate the attribute at the given time instead of the current time."
            }, 
            "type": {
                "docstring": "Returns the type of data to expect at the attribute."
            }
        }
    }, 
    "getClassification": {
        "description": "Returns the classification string for a given node type. Classification strings look like file pathnames (\"shader/reflective\" or \"texture/2D\", for example). Multiple classifications can be combined into a single compound classification string by joining the individual classifications with ':'. For example, the classification string \"shader/reflective:texture/2D\" means that the node is both a reflective shader and a 2D texture. The classification string is used to determine how rendering nodes are categorized in various UI, such as the Create Render Node and HyperShade windows: CategoryClassification String2D Textures\"texture/2d\"3D Textures\"texture/3d\"Env Textures\"texture/environment\"Surface Materials\"shader/surface\"Volumetric Materials\"shader/volume\"Displacement Materials\"shader/displacement\"Lights\"light\"General Utilities\"utility/general\"Color Utilities\"utility/colorParticle Utilities\"utility/particle\"Image Planes\"imageplane\"Glow\"postprocess/opticalFX\"", 
        "flags": {
            "satisfies": {
                "docstring": "Returns true if the given node type's classification satisfies the classification string which is passed with the flag. A non-compound classification string A is said to satisfy a non-compound classification string B if A is a subclassification of B (for example, \"shaders/reflective\" satisfies \"shaders\"). A compound classification string A satisfies a compound classification string B iff: every component of A satisfies at least one component of B andevery component of B is satisfied by at least one component of AHence, \"shader/reflective/phong:texture\" satisfies \"shader:texture\", but \"shader/reflective/phong\" does not satisfy \"shader:texture\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "getDefaultBrush": {
        "description": "The command returns the name of the default Paint Effects brush. ", 
        "flags": {}
    }, 
    "getFileList": {
        "description": "Returns a list of files matching an optional wildcard pattern. Note that this command works directly on raw system files and does not go through standard Maya file path resolution. ", 
        "flags": {
            "filespec": {
                "docstring": "wildcard specifier for search.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "folder": {
                "docstring": "return a directory listing"
            }
        }
    }, 
    "getFluidAttr": {
        "description": "Returns values of built-in fluid attributes such as density, velocity, etc., for individual grid cells or for all cells in the grid. ", 
        "flags": {
            "attribute": {
                "docstring": "Specifies the fluid attribute for which to display values. Valid attributes are \"force\", \"velocity\", \"density\", \"falloff\", \"fuel\", \"color\", and \"temperature\". (Note that getting force values is an alternate way of getting velocity values at one time step.)"
            }, 
            "lowerFace": {
                "docstring": "Only valid with \"-at velocity\". Since velocity values are stored on the edges of each voxel and not at the center, using voxel based indices to set velocity necessarily affects neighboring voxels. Use this flag to only set velocity components on the lower left three faces of a voxel, rather than all six.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "xIndex": {
                "docstring": "Only return values for cells with this X index"
            }, 
            "xvalue": {
                "docstring": "Only get the first component of the vector-valued attribute specified by the \"-at/attribute\" flag."
            }, 
            "yIndex": {
                "docstring": "Only return values for cells with this Y index"
            }, 
            "yvalue": {
                "docstring": "Only get the second component of the vector-valued attribute specified by the \"-at/attribute\" flag."
            }, 
            "zIndex": {
                "docstring": "Only return values for cells with this Z index"
            }, 
            "zvalue": {
                "docstring": "Only get the third component of the vector-valued attribute specified by the \"-at/attribute\" flag."
            }
        }
    }, 
    "getInputDeviceRange": {
        "description": "This command lists the minimum and maximum values the device axis can return. This value is the raw device values before any mapping is applied. If you don't specify an axis the values for all axes of the device are returned. ", 
        "flags": {
            "maxValue": {
                "docstring": "list only the maximum value of the axisFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "minValue": {
                "docstring": "list only the minimum value of the axis"
            }
        }
    }, 
    "getLastError": {
        "description": "", 
        "flags": {}
    }, 
    "getModifiers": {
        "description": "This command returns the current state of the modifier keys. The state of each modifier can be obtained by testing for the modifier's corresponding bit value in the return value. Shift is bit 1, Ctrl is bit 3, Alt is bit 4, and bit 5 is the 'Windows' key on Windows keyboards and the Command key on Mac keyboards. See the provided example for more details on testing for each modifier's bit value. ", 
        "flags": {}
    }, 
    "getModulePath": {
        "description": "Returns the module path for a given module name. ", 
        "flags": {
            "moduleName": {
                "docstring": "The name of the module whose path you want to retrieve.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "getPanel": {
        "description": "This command returns panel and panel configuration information. ", 
        "flags": {
            "allConfigs": {
                "docstring": "Return the names of the all panel configuration in a string array.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "allPanels": {
                "docstring": "Return the names of all the panels in a string array."
            }, 
            "allScriptedTypes": {
                "docstring": "Return the names of all types of scripted panels in a string array."
            }, 
            "allTypes": {
                "docstring": "Return the names of all types of panels, except scripted types in a string array."
            }, 
            "atPosition": {
                "docstring": "Return the name of the panel which contains the specified screen coordinates. An empty string is returned if there is no panel at those coordinates."
            }, 
            "configWithLabel": {
                "docstring": "Return the name of the panel configuration with the specified label text."
            }, 
            "containing": {
                "docstring": "Return the name of the panel containing the specified control. An empty string is returned if the specified control is not in any panel."
            }, 
            "invisiblePanels": {
                "docstring": "Return the names of all the invisible panels in a string array."
            }, 
            "scriptType": {
                "docstring": "Return the names of all scripted panels of the specified type in a string array."
            }, 
            "type": {
                "docstring": "Return the names of all panels of the specified type in a string array."
            }, 
            "typeOf": {
                "docstring": "Return the type of the specified panel."
            }, 
            "underPointer": {
                "docstring": "Return the name of the panel that the pointer is currently over. An empty string is returned if the pointer is not over any panel."
            }, 
            "visiblePanels": {
                "docstring": "Return the names of all the visible panels in a string array."
            }, 
            "withFocus": {
                "docstring": "Return the name of the panel that currently has focus. If no panel has focus then the last panel that had focus is returned."
            }, 
            "withLabel": {
                "docstring": "Return the name of the panel with the specified label text."
            }
        }
    }, 
    "getParticleAttr": {
        "description": "This action will return either an array of values, or the average value and maximum offset, for a specied per-particle attribute of a particle object or component. If a particle component is specified on the command line, values are returned for that component only. If an object name is given instead, values are returned for all particles in that object. If no object name is passed, but a particle object or component is selected, values are returned for the selection. If you list components, they must all be from the same particle object; the action ignores all objects after the first. Likewise if you list more than one object, the actiion will return values only for the first one. ", 
        "flags": {
            "array": {
                "docstring": "Tells the action whether you want a full array of data. If set true, the action returns an array of floats containing the values for all the specified particles. If set false (the default), the action returns the average value and the maximum offset from the average over the component. If the attribute is a vector attribute, the action returns six values: Average X, Average Y, Average Z, Maximum offset in X, Y, and Z of component.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "attribute": {
                "docstring": "Tells the action which attribute you want the value of. Must be a per-particle attribute."
            }, 
            "object": {
                "docstring": "This flag is obsolete. Instead of using it, please pass the name of the object and/or components you want on the command line. See the examples."
            }
        }
    }, 
    "getProcArguments": {
        "description": "", 
        "flags": {}
    }, 
    "getRenderDependencies": {
        "description": "Command to return dependencies of an image source. Image sources (such as render targets) can depend on other upstream image sources that result from renderings of 3D scene, or renderings of 2D compositing graphs. This command returns these dependencies, so that they can be analyzed and rendered. ", 
        "flags": {}
    }, 
    "getRenderTasks": {
        "description": "Command to return render tasks to render an image source. Image source can depend on upstream image sources that result from renderings of 3D scene, or 2D renderings (e.g. render targets). This command obtains the graph of image source render dependencies, and creates render tasks according to these dependencies. A render task has context, which can be camera, render layer, and resolution, or other, renderer-specific context. Because of image source overrides, the render task context depends on the path through the render dependency graph, with the most upstream override for a context item applied. As there can be multiple paths through a render dependency graph to a render dependency, there can be multiple render tasks for a given render dependency. ", 
        "flags": {
            "camera": {
                "docstring": "Camera node to use in the render context for the image source render task."
            }, 
            "renderLayer": {
                "docstring": "Render layer to use in the render context for the image source render task.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "glRender": {
        "description": "This command provides access to the Hardware Render Manager (HRM). There is one-and-only-one HRM in maya. The HRM controls the rendering performed in the hardware render buffer window. This command allows shell scripts, to modify the render state, and to initiate a render request. In query mode, return type is based on queried flag.", 
        "flags": {
            "accumBufferPasses": {
                "docstring": "Set the number of accum buffer render passes."
            }, 
            "alphaSource": {
                "docstring": "Control the alpha source when writing image files. Valid values include: off, alpha, red, green, blue, luminance, clamp, invClamp."
            }, 
            "antiAliasMethod": {
                "docstring": "Set the method used for anti-aliasing polygons: off, uniform, gaussian."
            }, 
            "cameraIcons": {
                "docstring": "Set display status of camera icons."
            }, 
            "clearClr": {
                "docstring": "Set the viewport clear color (0 - 1)."
            }, 
            "collisionIcons": {
                "docstring": "Set display status of collison model icons."
            }, 
            "crossingEffect": {
                "docstring": "Enable/disable image filtering with a convolution filter."
            }, 
            "currentFrame": {
                "docstring": "Returns the current frame being rendered."
            }, 
            "drawStyle": {
                "docstring": "Set the object drawing style: boundingBox, points, wireframe, flatShaded, smoothShaded."
            }, 
            "edgeSmoothness": {
                "docstring": "Controls the amount of edge smoothing. A value of 0.0 gives no smoothing, 1.0 gives default smoothing, and any other value scales the amount of default smoothing. Must enable the accumulation buffer."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "emitterIcons": {
                "docstring": "Set display status of emitter icons."
            }, 
            "fieldIcons": {
                "docstring": "Set display status of field icons."
            }, 
            "flipbookCallback": {
                "docstring": "Register a procedure to be called after the render sequence has completed. Used to build the flipbook pulldown menu. See the example section for more details about how to build this procedure."
            }, 
            "frameEnd": {
                "docstring": "Set the last frame to be rendered."
            }, 
            "frameIncrement": {
                "docstring": "Set the frame increment during rendering."
            }, 
            "frameStart": {
                "docstring": "Set the first frame to be rendered."
            }, 
            "fullResolution": {
                "docstring": "Enable/disable rendering to full image output resolution. Must set a valid image output resolution (-is)."
            }, 
            "grid": {
                "docstring": "Set display status of the grid."
            }, 
            "imageDirectory": {
                "docstring": "Set the directory for the image files."
            }, 
            "imageName": {
                "docstring": "Set the base name of the image files."
            }, 
            "imageSize": {
                "docstring": "Set the image output size. Takes width, height and aspect ratio. Pass 0,0,0 to use current port size. The image size must be equal to or greater then the viewport size. Large images will be tiled if full resolution rendering has been enabled (-fr/fullResolution)."
            }, 
            "lightIcons": {
                "docstring": "Set display status of light icons."
            }, 
            "lightingMode": {
                "docstring": "Set the lighting mode used for rendering: all, selected, default."
            }, 
            "lineSmoothing": {
                "docstring": "Enable/disable anti-aliased lines."
            }, 
            "offScreen": {
                "docstring": "When set, this toggle allow HRM to use an offscreen buffer to render the view. This allows HRM to work when the application is iconified, or obscured"
            }, 
            "query": {
                "docstring": ""
            }, 
            "renderFrame": {
                "docstring": "Render the current frame. Requires the name of the view in which to render."
            }, 
            "renderSequence": {
                "docstring": "Render the current frame sequence. Requires the name of the view in which to render."
            }, 
            "sharpness": {
                "docstring": "Control the sharpness level of the convolution filter."
            }, 
            "shutterAngle": {
                "docstring": "Set the shutter angle used for motion blur (0 - 1). A value of 0.0 gives no blurring, 0.5 gives correct blurring, and 1.0 gives continuous blurring. Must enable the accumulation buffer."
            }, 
            "textureDisplay": {
                "docstring": "Enable/disable texture map display."
            }, 
            "transformIcons": {
                "docstring": "Set display status of transform icons."
            }, 
            "useAccumBuffer": {
                "docstring": "Enable/disable the accumulation buffer."
            }, 
            "viewport": {
                "docstring": "Set the viewport size. Pass in the width, height and aspect ratio. This size will be used for all test rendering and image output size unless full resolution (-fr) has been set and a valid image output size (-is) has been set."
            }, 
            "writeDepthMap": {
                "docstring": "Enable/disable writing of zdepth to image files.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "glRenderEditor": {
        "description": "Create a glRender view. This is a special view used for hardware rendering. This command is used to create and reparent the view as needed to support panels. See the glRender command for controlling the specific behavior of the hardware rendering. In query mode, return type is based on queried flag.", 
        "flags": {
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "lookThru": {
                "docstring": "Specify which camera the glRender view should be using.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "viewCameraName": {
                "docstring": "Returns the name of the current camera used by the glRenderPanel. This is a query only flag."
            }
        }
    }, 
    "globalStitch": {
        "description": "This command computes a globalStitch of NURBS surfaces. There should be at least one NURBS surface. The NURBS surface(s) should be untrimmed. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "lockSurface": {
                "docstring": "Keep the NURBS surface at the specified multi index unchanged by the fitting.Default:falseAdvanced flags"
            }, 
            "maxSeparation": {
                "docstring": "Maximum separation that will still be stitchedDefault:0.1"
            }, 
            "modificationResistance": {
                "docstring": "Modification resistance weight for surface CVsDefault:1e-1"
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "object": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": ""
            }, 
            "sampling": {
                "docstring": "Sampling when stitching edgesDefault:1"
            }, 
            "stitchCorners": {
                "docstring": "Stitch corners of surfaces 0 - off 1 - closest point 2 - closest knotDefault:1"
            }, 
            "stitchEdges": {
                "docstring": "Stitch edges of surfaces 0 - off 1 - closest point 2 - matching paramsDefault:1"
            }, 
            "stitchPartialEdges": {
                "docstring": "Toggle on(off) partial edge stitchingDefault:false"
            }, 
            "stitchSmoothness": {
                "docstring": "Set type of smoothness of edge join 0 - off 1 - tangent 2 - normalDefault:0"
            }
        }
    }, 
    "goal": {
        "description": "Specifies the given objects as being goals for the given particle object. If the goal objects are geometry, each particle in the particle object will each try to follow or match its position to that of a certain vertex/CV/lattice point of the goal. If the goal object is another particle object, each particle will try to follow a paricle of the goal. In any other case, all the particles will try to follow the current location of the goal object's transform. You can get this latter behavior for a geometry or particle object too by using -utr true. The goal weight can be keyframed. It lives on the particle object to which the goal was added and is a multi-attribute. ", 
        "flags": {
            "goal": {
                "docstring": "This flag specifies string to be a goal of the particle object on the command line or the currently selected particle object. This flag can be used multiple times to specify multiple goals for a particle object. Query is for use by the attribute editor."
            }, 
            "index": {
                "docstring": "Returns array of multi-attribute indices for the goals. Intended for use by the Attribute Editor."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTransformAsGoal": {
                "docstring": "Use transform of specified object instead of the shape. Meaningful only for particle and geometry objects. Can only be passed once, applies to all objects passed with -g.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "weight": {
                "docstring": "This specifies the goal weight as a value from 0 to 1. A value of 0 means that the goal's position will have no effect on the particle object, while a weight of 1 will make the particle object try to follow the goal object exactly. This flag can only be passed once and sets the weight for every goal passed with the -g/-goal flag."
            }
        }
    }, 
    "grabColor": {
        "description": "This command changes the cursor and enters a modal state which will be exited by pressing a mouse button. The color component values of the pixel below the cursor at the time of the button press are returned. ", 
        "flags": {
            "hsvValue": {
                "docstring": "The 3 returned float values will specify the hue, saturation and value color components.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "rgbValue": {
                "docstring": "The 3 returned float values will specify the red, green and blue color components."
            }
        }
    }, 
    "gradientControl": {
        "description": "This command creates a control that displays the gradient attribute specified. The gradient attribute must be of the correct form and naming. It should be a multi attribute with each entry a compound composed of: Either a color compound or a float value (the control will automatically detect which and display a ramp or graph accordingly).A single float attribute for position.An enum for the interpolation types.Currently the routines to get the value of a ramp structure (with interpolation) are not available through MEL, which limits the use of this control by end users. The MEL command AEaddRampControl should be used to attach this control to an attribute from attribute editor templates. ", 
        "flags": {
            "adaptiveScaling": {
                "docstring": "Allow the ramp widget display to scale vertically to accommodate values greater than 1.0. True if adaptive scaling is enabled, false (the default) if not."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "attribute": {
                "docstring": "Specifies the name of the gradient attribute to control."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfControls": {
                "docstring": "Returns the number of controls in the ramp widget"
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "refreshOnRelease": {
                "docstring": "Define how updates are dispatched during interactive editing of the ramp widget. True causes updates to only dispatch after releasing the mouse button after editing. False (the default) causes updates to dispatch interactively during editing (e.g. while moving ramp curve points). Note that the global update mode, if set to \"on release\" can disable the effect of this option."
            }, 
            "selectedColorControl": {
                "docstring": "Specifies the name of a color control to edit the selected color."
            }, 
            "selectedInterpControl": {
                "docstring": "Specifies the name of an enum control to edit the selected interpolation."
            }, 
            "selectedPositionControl": {
                "docstring": "Specifies the name of a float slider to edit the selected position."
            }, 
            "staticNumberOfControls": {
                "docstring": "When 'true', this flag disables the creation/deletion of ramp entries (control points) via ramp widget interaction. Default is false."
            }, 
            "staticPositions": {
                "docstring": "When 'true', this flag disables the interactive modification of ramp entry positions. Default is false."
            }, 
            "upperLimitControl": {
                "docstring": "Specify the name of a text control which is updated with the current upper display limit for the ramp. This option is only effective when adaptiveScaling is specified."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "verticalLayout": {
                "docstring": "When 'true', this makes the control orient vertically rather than horizontally. The default is `false` or horizontal.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "gradientControlNoAttr": {
        "description": "This command creates a control for editing a ramp (2D control curve). The control attaches to an optionVar used to store and retrieve the encoded gradient control points stored in a string. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "asString": {
                "docstring": "Used to query and set the value of the ramp as a string of comma separated values"
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Specifies a command to be executed whenever the value of this ramp is modified. This option should not be used when specifying an optionVar."
            }, 
            "currentKey": {
                "docstring": "Returns the index of the currently selected key."
            }, 
            "currentKeyChanged": {
                "docstring": "Specifies a command to be executed whenever the selected key changes."
            }, 
            "currentKeyColorValue": {
                "docstring": "Get or set the color of the currently selected key. Only useful if the ramp is set to be a color ramp."
            }, 
            "currentKeyCurveValue": {
                "docstring": "Get or set the value of the currently selected key. Only useful if the ramp is set to be a curve ramp."
            }, 
            "currentKeyInterpValue": {
                "docstring": "Get or set the interpolation value for the current key."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Specifies a command to be executed while the ramp is being modified.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "optionVar": {
                "docstring": "Specifies the name of the option var used to store and retrieve the string value capturing the curve."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rampAsColor": {
                "docstring": "Sets whether the ramp should be viewed as a colour ramp or as a curve. Default is as a curve."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "valueAtPoint": {
                "docstring": "Used during query to specify the point at which to query the curve. "
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "graphDollyCtx": {
        "description": "This command can be used to create a dolly context for the graph editor. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "graphSelectContext": {
        "description": "This command can be used to create a selection context for the hypergraph editor. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "graphTrackCtx": {
        "description": "This command can be used to create a track context for the graph editor. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "gravity": {
        "description": "A gravity field simulates the Earth's gravitational force. It pulls objects in a fixed direction (generally downward) entirely independent of their position or mass. The transform is the associated dependency node. Use connectDynamic to cause the field to affect a dynamic object. If fields are created, this command returns the names of each of the fields. If a field was queried, the results of the query are returned. If a field was edited, the field name is returned. If object names are provided or the active selection list is non-empty, the command creates a field for every object in the list and calls addDynamic to add it to the object. If the list is empty, the command defaults to -pos 0 0 0. Setting the -pos flag with objects named on the command line is an error. The default for -dx -dy -dz is always the opposite of the current up direction. For example, if the current up direction is (0,1,0) (a standard Maya configuration), then the gravity default is -dx 0 -dy -1 -dz 0. The default for -a is 9.8. 9.8 meters per second squared happens to be standard Earth gravity, but in fact Maya interprets this value as centimeters per second squared. If we were to use it as meters per second squared then with default Maya units, your particles would vanish almost in the wink of an eye. If you want a different value, set it in the gravity option box. ", 
        "flags": {
            "attenuation": {
                "docstring": "Attentuation rate of field"
            }, 
            "directionX": {
                "docstring": "X-component of direction."
            }, 
            "directionY": {
                "docstring": "Y-component of direction."
            }, 
            "directionZ": {
                "docstring": "Z-component of directionFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "magnitude": {
                "docstring": "Strength of field."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which field is exerted. -1 indicates that the field has no maximum distance."
            }, 
            "name": {
                "docstring": "name of field"
            }, 
            "perVertex": {
                "docstring": "Per-vertex application. If this flag is set true, then each individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical copy of the force field. If this flag is set to false, then the force is exerted only from the geometric center of the set of points."
            }, 
            "position": {
                "docstring": "Position in space where you want to place a field. The gravity then emanates from this position in space rather than from an object. Note that you can both use -pos (creating a field at a position) and also provide object names."
            }, 
            "query": {
                "docstring": ""
            }, 
            "torusSectionRadius": {
                "docstring": ""
            }, 
            "volumeExclusion": {
                "docstring": ""
            }, 
            "volumeOffset": {
                "docstring": ""
            }, 
            "volumeShape": {
                "docstring": ""
            }, 
            "volumeSweep": {
                "docstring": ""
            }
        }
    }, 
    "grid": {
        "description": "This command changes the size and spacing of lines on the ground plane displayed in the perspective and orthographic views. This command lets you reset the ground plane, change its size and grid line spacing, grid subdivisions and display options. In query mode, return type is based on queried flag.", 
        "flags": {
            "default": {
                "docstring": "Used to specify/query default values."
            }, 
            "displayAxes": {
                "docstring": "Specify true to display the grid axes."
            }, 
            "displayAxesBold": {
                "docstring": "Specify true to accent the grid axes by drawing them with a thicker line."
            }, 
            "displayDivisionLines": {
                "docstring": "Specify true to display the subdivision lines between grid lines."
            }, 
            "displayGridLines": {
                "docstring": "Specify true to display the grid lines."
            }, 
            "displayOrthographicLabels": {
                "docstring": "Specify true to display the grid line numeric labels in the orthographic views."
            }, 
            "displayPerspectiveLabels": {
                "docstring": "Specify true to display the grid line numeric labels in the perspective view."
            }, 
            "divisions": {
                "docstring": "Sets the number of subdivisions between major grid lines. The default is 5. If the spacing is 5 units, setting divisions to 5 will cause division lines to appear 1 unit apart."
            }, 
            "orthographicLabelPosition": {
                "docstring": "The position of the grid's numeric labels in orthographic views. Valid values are \"axis\" and \"edge\"."
            }, 
            "perspectiveLabelPosition": {
                "docstring": "The position of the grid's numeric labels in perspective views. Valid values are \"axis\" and \"edge\"."
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": "Resets the ground plane to its default values"
            }, 
            "size": {
                "docstring": "Sets the size of the grid in linear units. The default is 12 units."
            }, 
            "spacing": {
                "docstring": "Sets the spacing between major grid lines in linear units. The default is 5 units."
            }, 
            "style": {
                "docstring": "This flag is obsolete and should not be used.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "toggle": {
                "docstring": "Turns the ground plane display off in all windows, including orthographic windows. Default is true."
            }
        }
    }, 
    "gridLayout": {
        "description": "This layout arranges children in a grid fashion where every cell in the grid is the same size. You may specify the number of rows and columns as well as the width and height of the grid cells. ", 
        "flags": {
            "allowEmptyCells": {
                "docstring": "Specify true if you want free positioning of the children in the layout and potentially leaving empty cells between children. Set to false if you want the children to always be packed together. The default is true."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "autoGrow": {
                "docstring": "Specify true if you want the grid layout size to grow as children are added. For example, if the grid layout has 2 columns and 2 rows then adding a fifth child will cause the grid to expand to 3 rows if this flag is true, otherwise the grid will remain the same size and the new child will be hidden from view until you expand the size of the grid using the appropriate flags. The default is true."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "cellHeight": {
                "docstring": "A positive non-zero integer value indicating the height of cells in the grid layout."
            }, 
            "cellWidth": {
                "docstring": "A positive non-zero integer value indicating the width of cells in the grid layout."
            }, 
            "cellWidthHeight": {
                "docstring": "Two positive non-zero integer values for indicating the width and height, respectively, of the cells in the grid layout."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "columnsResizable": {
                "docstring": "Specify true if you want the number of columns to adjust according to the width of the layout. Set to false if you want the number of columns to remain fixed when the width of the layout is changed. The default is false."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "gridOrder": {
                "docstring": "As opposed to the childArray flag, the gridOrder flag returns the children of the grid Layout in the order they are diplayed in the window."
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfColumns": {
                "docstring": "A positive non-zero integer value indicating the number of columns in the grid layout."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "numberOfRows": {
                "docstring": "A positive non-zero integer value indicating the number of rows in the grid layout."
            }, 
            "numberOfRowsColumns": {
                "docstring": "Two positive non-zero integer values for the number of rows and columns, respectively, in the grid layout."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "position": {
                "docstring": "Specify the name of a child control in the grid layout along with a 1-based integer value indicating the desired position of the child. Positions increase from left to right within a row and then wrap around to the next row increasing from top to bottom. For example, a grid layout with 3 columns and 2 rows has 6 visible positions where 1, 2 and 3 occupy the first row and 4, 5 and 6 occupy the second.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "group": {
        "description": "This command groups the specified objects under a new group and returns the name of the new group. If the -em flag is specified, then an empty group (with no objects) is created. If the -w flag is specified then the new group is placed under the world, otherwise if -p is specified it is placed under the specified node. If neither -w or -p is specified the new group is placed under the lowest common group they have in common. (or the world if no such group exists) If an object is grouped with another object that has the same name then one of the objects will be renamed by this command. ", 
        "flags": {
            "absolute": {
                "docstring": "preserve existing world object transformations (overall object transformation is preserved by modifying the objects local transformation) [default]"
            }, 
            "empty": {
                "docstring": "create an empty group (with no objects in it)"
            }, 
            "name": {
                "docstring": "Assign given name to new group node."
            }, 
            "parent": {
                "docstring": "put the new group under the given parent"
            }, 
            "relative": {
                "docstring": "preserve existing local object transformations (relative to the new group node)"
            }, 
            "useAsGroup": {
                "docstring": "Use the specified node as the group node. The specified node must be derived from the transform node and must not have any existing parents or children.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "world": {
                "docstring": "put the new group under the world"
            }
        }
    }, 
    "groupParts": {
        "description": "", 
        "flags": {}
    }, 
    "hardenPointCurve": {
        "description": "The hardenPointCurve command changes the knots of a curve given a list of control point indices so that the knot corresponding to that control point gets the specified multiplicity. Multiplicity of -1 is the universal value used for multiplicity equal to the degree of the curve.limitationsThe CV whose multiplicity is being raised needs to have its neighbouring CVs of multiplicity 1. How many neighbours depends on the degree of the curve and the difference in CV multiplicities before and after this operation. For example, if you're changing a CV of multiplicity 1 into a CV of multiplicity 3, you will need the 4 neighbouring CVs (2 on each side) to be of multiplicity 1. The CVs that do not satisfy that requirement will be ignored. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "multiplicity": {
                "docstring": "the required multiplicity of the curve knotDefault:-1Advanced flags"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "hardware": {
        "description": "Return description of the hardware available in the machine. ", 
        "flags": {
            "brdType": {
                "docstring": "Returns IP number identifying the CPU motherboard"
            }, 
            "cpuType": {
                "docstring": "Returns type of CPU"
            }, 
            "graphicsType": {
                "docstring": "Returns string identifying graphics hardware type"
            }, 
            "megaHertz": {
                "docstring": "Returns string identifying the speed of the CPU chip"
            }, 
            "numProcessors": {
                "docstring": "Returns string identifying the number of processorsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "hardwareRenderPanel": {
        "description": "This command creates, edit and queries hardware render panels which contain only a hardware render editor. ", 
        "flags": {
            "camera": {
                "docstring": "Query or edit the camera in a gl render panel.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "control": {
                "docstring": "Returns the top level control for this panel. Usually used for getting a parent to attach popup menus. CAUTION: panels may not have controls at times. This flag can return \"\" if no control is present."
            }, 
            "copy": {
                "docstring": "Makes this panel a copy of the specified panel. Both panels must be of the same type."
            }, 
            "createString": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the maya panel."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editString": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "glRenderEditor": {
                "docstring": "Query only. This flag returns the name of the gl render editor contained in the panel."
            }, 
            "init": {
                "docstring": "Initializes the panel's default state. This is usually done automatically on file -new and file -open."
            }, 
            "isUnique": {
                "docstring": "Returns true if only one instance of this panel type is allowed."
            }, 
            "label": {
                "docstring": "Specifies the user readable label for the panel."
            }, 
            "menuBarVisible": {
                "docstring": "Controls whether the menu bar for the panel is displayed."
            }, 
            "needsInit": {
                "docstring": "(Internal) On Edit will mark the panel as requiring initialization. Query will return whether the panel is marked for initialization. Used during file -new and file -open."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this panel."
            }, 
            "popupMenuProcedure": {
                "docstring": "Specifies the procedure called for building the panel's popup menu(s). The default value is \"buildPanelPopupMenu\". The procedure should take one string argument which is the panel's name."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replacePanel": {
                "docstring": "Will replace the specifed panel with this panel. If the target panel is within the same layout it will perform a swap."
            }, 
            "tearOff": {
                "docstring": "Will tear off this panel into a separate window with a paneLayout as the parent of the panel. When queried this flag will return if the panel has been torn off into its own window."
            }, 
            "tearOffCopy": {
                "docstring": "Will create this panel as a torn of copy of the specified source panel."
            }, 
            "unParent": {
                "docstring": "Specifies that the panel should be removed from its layout. This (obviously) cannot be used with query."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "headsUpDisplay": {
        "description": "This command creates a Heads-up Display (HUD) object which is placed in a 2D inactive overlay plane on the 3D viewport. It is to be used to provide hands-on information designated by a user script. The text string displayed on the viewport is formatted using the various flags of this command. The only mandatory flags, on creation are the section and block flags. Note if the preset OR command/trigger flags are not present, only a label will be drawn on the viewport. Upon creation of a HUD object, an ID number will be assigned to it. This can be used to remove the HUD object (-rid/removeID [int IDNumber]), if desired. Alternatively, HUD objects may be removed via their position (section and block), or their unique name. ", 
        "flags": {
            "allDescendants": {
                "docstring": "This flag can only be used in conjunction with the -ac/attributeChange flag. If it is specified, and the HUD is attached to a compound or multi attribute, then the HUD command will run due to changes to the specified attribute as well as changes to its descendants."
            }, 
            "allowOverlap": {
                "docstring": "Sets the Heads-Up Display to be visible regardless of overlapping section widths/limitations (see -s/section flag description for more details)."
            }, 
            "attachToRefresh": {
                "docstring": "Attaches the command to the refresh process. The script is then run each time an idle refresh is run and updates directly following it."
            }, 
            "attributeChange": {
                "docstring": "Runs the command when the named attribute changes value. The string must identify both the dependency node and the particular attribute. If the dependency node is deleted, this HUD is removed (even if the deletion is undoable)."
            }, 
            "block": {
                "docstring": "Denotes the individual block that the HUD will reside in, within a section. Each section is composed of a single column of blocks. The total number of blocks contained within each section is variable. The number of blocks that will be visible within each section is dependent on the size of blocks contained in each section and the current size of the window. Blocks begin enumerating from 0 and flexibly increase based on need. The resultant output string of each HUD is formatted within each block, using parameters defined by the formatting flags listed below (eg. justify, padding, labelWidth and dataWidth). The layout is shown in the following diagram: __________________________________________ |     |     |        |         |     |     | |  P  |  J  |   LW   |   DWX   |  J  |  P  | |_____|_____|________|_________|_____|_____| P = Sub-block of width, padding J = Justification of the entire block LW = Sub-block of width, labelWidth DWX = X number of sub-blocks of width, dataWidth, for X data elements. Block LayoutThe above diagram shows the layout of each block. The widths: padding, labelWidth and dataWidth are defined by their respective flags. To elaborate on the layout of the blocks, First the padding of the block is calculated. Then the two main sub-blocks (LW and DWX) in the above diagram, are justified and positioned together between the left and right margins of the block. The widths of the main sub-blocks are not variable based on it's contents. The only sub-block in the above diagram which is unique is the DWX sub-block which actually represents X number of sub-blocks, where X is the number of data elements returned by the command. Block PositioningBlocks on the top section begin from the top edge of the main viewport, while the bottom section begins from the bottom edge. Blocks are dynamically removed from visibility from the midpoint of the viewport. So, a relatively large block number will not draw to the viewport. Lastly, there can be at most one HUD occupying a block at any time. Trying to position a HUD in an occupied block will result in an error. Keep this in mind when positioning the HUD."
            }, 
            "blockAlignment": {
                "docstring": "Specifies the alignment of the block within its respective column. Available alignments are: \"center\", \"left\" and \"right\". The default alignment is \"left\"."
            }, 
            "blockSize": {
                "docstring": "Sets the height of each block. Available heights are: small, medium and large. In pixel measurements, each corresponds to a 20, 35 or 50 pixel height, respectively."
            }, 
            "command": {
                "docstring": "Specifies the procedure or script to run, in order to obtain the desired information. This must return a value or an array of values. A warning will be displayed if the command does not return a value. This flag MUST always be accompanied by a trigger flag (eg. a condition flag, an event flag, an attachToRefresh flag, etc.)."
            }, 
            "conditionChange": {
                "docstring": "A trigger which runs the command (to sample the data), when the named condition changes. The named condition must be pre-defined or a user defined boolean. To get a list of what conditions exist, use the -lc/listConditions flag."
            }, 
            "conditionFalse": {
                "docstring": "A trigger which runs the command (to sample the data), when the named condition becomes false. The named condition must be pre-defined or a user defined boolean. To get a list of what conditions exist, use the -lc/listConditions flag."
            }, 
            "conditionTrue": {
                "docstring": "A trigger which runs the command (to sample the data), when the named condition becomes true. The named condition must be pre-defined or a user defined boolean. To get a list of what conditions exist, use the -lc/listConditions flag."
            }, 
            "connectionChange": {
                "docstring": "Runs the command when the named attribute changes its connectivity. The string must identify both the dependency node and the particular attribute. If the dependency node is deleted, this HUD is removed (even if the deletion is undoable)."
            }, 
            "dataAlignment": {
                "docstring": "Specifies the alignment of the data blocks and the data text, within a HUD block. Available alignments are: \"left\" and \"right\". The default alignment is \"left\"."
            }, 
            "dataFontSize": {
                "docstring": "Sets the font size of the returned data. Available sizes are: small and large."
            }, 
            "dataWidth": {
                "docstring": "Specifies the pixel width of the virtual \"textbox\" which will hold a data value. For commands which return more than one value (ie. arrays), one of these \"textboxes\" will be created for each data element, each with this specified width. If the width of the data value exceeds the width of the \"textbox\", the data value will be truncated to fit within the dimensions of the \"textbox.\" (To see a layout of a block, see the description of the -block flag.)"
            }, 
            "decimalPrecision": {
                "docstring": "Sets the decimal precision of any floating point value returned by the command. The valid range of precision values are 1 to 8."
            }, 
            "disregardIndex": {
                "docstring": "This flag can only be used in conjunction with the -ac/attributeChange flag. If it is specified, and the HUD is attached to a multi (indexed) attribute, then the HUD command will run no matter which attribute in the multi changes."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "event": {
                "docstring": "Runs the command when the named event occurs. The named event, must be a pre-defined Maya event. To get a list of what events exist, use the -le/listEvents flag."
            }, 
            "exists": {
                "docstring": "This flag returns whether the given object exists in the Heads-Up Display layout. An object name must be supplied with this command. This flag cannot be combined with any other flag."
            }, 
            "getOption": {
                "docstring": "This flag will return the value of the option specified by the string. See setOption for a list of options Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "gridColor": {
                "docstring": "This flag specifies a color for the grid lines using the inactive color palette. Specifying an index number between 1 to 23 will select the corresponding color in the palette."
            }, 
            "label": {
                "docstring": "Text string that appears to the left of the desired information."
            }, 
            "labelFontSize": {
                "docstring": "Sets the font size of the label. Available sizes are: small and large."
            }, 
            "labelWidth": {
                "docstring": "Specifies the pixel width of the virtual \"textbox\" which will hold the label. The contents of this \"textbox\" will be left justified. If the width of the actual label exceeds the width of the \"textbox,\" the label will be truncated to fit within the dimensions of the \"textbox.\" (To see a layout of a block, see the description of the -block flag.)"
            }, 
            "lastOccupiedBlock": {
                "docstring": "Returns the block number of the last occupied block in a given section."
            }, 
            "layoutVisibility": {
                "docstring": "Sets the visibility of Heads-Up Display layout on and off. This does not modify individual visibilities of heads-up displays, but turns off the layout so that no heads-up displays will draw to screen. Personalized settings for the visibilities of HUDs are kept safe. This flag can only be used by itself, excepting edit and query."
            }, 
            "listConditions": {
                "docstring": "This flag will return a string array containing all names of the available conditions."
            }, 
            "listEvents": {
                "docstring": "This flag will return a string array containing all names of the available events."
            }, 
            "listHeadsUpDisplays": {
                "docstring": "This flag will return a string array containing all names of existing HUDs."
            }, 
            "listNodeChanges": {
                "docstring": "This flag will return a string array containing all names of the available node changes."
            }, 
            "listPresets": {
                "docstring": "This flag will return a string array containing all names of the available preset HUDs."
            }, 
            "name": {
                "docstring": "This flag only permits the EDITING of the name of the Heads-Up Display."
            }, 
            "nextFreeBlock": {
                "docstring": "Returns the block number of the next free block in a given section."
            }, 
            "nodeChanges": {
                "docstring": "Works only with selection based triggers (ie. \"SelectionChanged\" or \"SomethingSelected\"), otherwise this flag is ignored. This flag attaches the HUD script to execute on specific node changes of any selected node. This flag is used to set a nodeChange. In order to reset a nodeChange, use the -rnc/resetNodeChanges flag. To view a list of all available node changes, use the -lnc/listNodeChanges flag. The following is a list of available node changes and their function: attributeChange:  The script will be sensitive to any attribute changes in the currently                   selected nodes.  connectionChange: The script will be sensitive to any connection changes in the currently                   selected nodes.  instanceChange:   The script will be sensitive to any changes to an instance in the                   currently selected nodes. On query mode, this flag will return the values of all nodeChanges in pairs of values (the name of the nodeChange followed by its value). WARNING: (Performance Warning)          Attaching a nodeChange trigger to a selection based trigger can cause a large          performance drop, if the node change that is being watched is caused by the          HUD script itself.           With this said, an attempt should be made to keep the HUD command/script                  simple and limited to retrieving data. Changing an attribute, creating or                  modifying a connection or instance will all result in a performance drop. "
            }, 
            "padding": {
                "docstring": "Specifies the width of both the left and right margins of a block. Default value is 15 pixels."
            }, 
            "preset": {
                "docstring": "This setting is used to select certain pre-defined HUDs, some of which retrieve specific data, that is unobtainable through normal MEL commands or scripts. This flag is mutually exclusive from the command and trigger flag combination. However, presets can work with all other headsUpDisplay attribute flags (ie. block alignment, label, dataFontSize, etc.), unless otherwise specified below. To obtain a list of available presets, use the -lp/listPresets flag on this command. The following is a list of available presets and a description of each: cameraNamesThis will return the camera name that the view is looking through, in the data block, for each view that the HUD is drawing to.polyVertsThis will return three values in the data block, regarding the number of vertices that are visible by the camera. 1st Value: Represents the number of camera visible vertices, both active and inactive.2nd Value: Represents the number of camera visible vertices, on active objects only.3rd Value: Represents the number of camera visible vertices, that are active.polyEdgesThis will return three values in the data block, regarding the number of edges that are visible by the camera. The order of these three values are similar to the polyVerts preset.polyFacesThis will return three values in the data block, regarding the number of faces that are visible by the camera. The order of these three values are similar to the polyVerts preset.polyUVsThis will return three values in the data block, regarding the number of UVs that are visible by the camera. The order of these three values are similar to the polyVerts preset.polyTrianglesThis will return three values in the data block, regarding the number of triangles that are visible by the camera. The order of these three values are similar to the polyVerts preset.frameRateThis will return a single string carrying both the frame rate and the \"fps\" string in the data block. It updates on each refresh.viewAxisThis will draw the orientation of the grid axes within the HUD. It updates on each refresh. While this preset can take in all attribute flags, the only one which will have an effect are block attribute related flags (ie. block alignment and block size). The block dimensions of this preset are: blockSize - \"large\" and blockWidth - \"50\", which results in a 50x50 pixel region.distanceFromCameraThis will return in the data block the distance from the view's camera to the centre of the bounding box containing the selected objects in the view."
            }, 
            "query": {
                "docstring": ""
            }, 
            "refresh": {
                "docstring": "This flag forces the given Heads-Up Display element to refresh, updating the value displayed. This flag cannot be combined with any other flag."
            }, 
            "remove": {
                "docstring": "This command will remove a given HUD object, given a specified HUD name. This flag will override all other flags and is mutually exclusive from the other remove flags."
            }, 
            "removeID": {
                "docstring": "This command will remove a given HUD object, given a specified HUD ID number assigned to it at creation time. This flag will override all other flags and is mutually exclusive from the other remove flags."
            }, 
            "removePosition": {
                "docstring": "This command will remove the contents of a specific block location in the HUD layout. This flag will override all other flags and is mutually exclusive from the other remove flags. Syntax for this flag is: -removePosition/rp [section] [block]."
            }, 
            "resetNodeChanges": {
                "docstring": "This flag will reset a specificied nodeChange back to false. This flag only operates under the edit flag. See the description for the -nc/nodeChanges flag for further details."
            }, 
            "scriptResult": {
                "docstring": "This flag is only used in conjunction with the query flag. Calling a query on this flag returns the most recent result of the HUD."
            }, 
            "section": {
                "docstring": "Defines the section the HUD will appear in. There are 10 sections divided across the screen. Five columns and two rows make up the ten element matrix which divide the main viewport. Here is a visual layout of the sections. ________________________ |    |    |    |    |    | |    |    |    |    |    | | 0  | 1  | 2  | 3  | 4  | |    |    |    |    |    | |____|____|____|____|____| |    |    |    |    |    | |    |    |    |    |    | | 5  | 6  | 7  | 8  | 9  | |    |    |    |    |    | |____|____|____|____|____| Each section is denoted by a number from 0 to 9 as illustrated above. For example, if the second column of the top row was desired, the section would be defined as: -sec 1 To prevent HUD objects from displaying over each other and causing a clutter of letters, each row has a defined visibility precedence, where each section would have a visibility priority level. Depending on each priority level, when the screen space begins to shrink to a point where the section widths of a given row begin to collide, the HUD automatically compensates for this by removing the sections of least priority. These sections are made invisible and a warning is issued to inform the user of the removal. This continues until only the section of highest priority remains. For each row, the priorities are defined as follows. Using the top row as an example: Section 0, has the highest priority, followed by Section 4, making the outermost sections of highest priority. Next in the list is Section 2, and lastly Sections 1 and 3 are of the equal and least priority. This priority structure can be applied to the bottom row as well. The two outermost sections have the highest priority, followed by the middle section, and finally the remaining two sections are of lowest priority. This means that as the viewport gradually decreases in width to the point where sections in the top row begin to overlap, sections 1 and 3 will be removed from view first, followed by section 2, and finally section 4. A similar note is provided below for the block layout."
            }, 
            "setOption": {
                "docstring": "This flag will edit the option specified by the first string. Current options are: smpPolyCount - \"cage\" or \"smp\" - in smooth mesh preview, determines the poly count display"
            }, 
            "showGrid": {
                "docstring": "This flag will toggle the display of the grid lines of the HUD layout."
            }, 
            "visible": {
                "docstring": "Sets the visibility of the Heads-Up Display on and off."
            }
        }
    }, 
    "headsUpMessage": {
        "description": "This command draws a message in the 3d view. The message is automatically erased at the next screen refresh. ", 
        "flags": {
            "horizontalOffset": {
                "docstring": "If this flag is specified, the message will appear the specified distance (in pixels) to the right of the point. Otherwise, a default horizontal offset of 0 pixels is used.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "object": {
                "docstring": "If an object is specified, then the message is drawn just above the object's bounding-box centre point. If this flag is not specified, or the object is not found, then the message is centred in the current view."
            }, 
            "selection": {
                "docstring": "If this flag is specified, the message will be centred among the currently selected objects. This flag does nothing if the object flag is also specified."
            }, 
            "time": {
                "docstring": "If this flag is specified, the message will be displayed for a minimum of the given amount of time (in seconds). Otherwise a default time of 1.0 seconds is used."
            }, 
            "uvTextureEditor": {
                "docstring": ""
            }, 
            "verticalOffset": {
                "docstring": "If this flag is specified, the message will appear the specified distance (in pixels) above the point. Otherwise, a default vertical offset of 0 pixels is used."
            }, 
            "viewport": {
                "docstring": ""
            }
        }
    }, 
    "help": {
        "description": "With no arguments, help tells how to use help. If a command name is specified, help will return the quick help for that command. Other flags can be used to open the online documentation, or to list available commands based on a pattern. Pattern follows the following syntax: In query mode, return type is based on queried flag.", 
        "flags": {
            "documentation": {
                "docstring": "Use a browser to show the documentation associated with the single command name given. A pattern cannot be used with this flag. If no command name is specified, then this flag will go to the main documentation index."
            }, 
            "language": {
                "docstring": "Show the help for this command in the specified language. Valid values are \"mel\" and \"python\". The default is Mel. Used with the docflag."
            }, 
            "list": {
                "docstring": "List all the commands whose names match the regular expression. Pass the regular expression as the first argument to the command specified."
            }, 
            "popupDisplayTime": {
                "docstring": "Set the amount of time, in seconds, that the popup help will be displayed. The default is 4 seconds. This flag is mutually exclusive of the listand docflags."
            }, 
            "popupMode": {
                "docstring": "Turn on or off popup help mode. This flag is mutually exclusive of the listand docflags."
            }, 
            "popupPauseTime": {
                "docstring": "Set the amount of time, in milliseconds, before the popup help will be displayed. The default is 800 milliseconds. This flag is mutually exclusive of the listand docflags."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rolloverMode": {
                "docstring": "Turn on or off rollover help mode. This flag is mutually exclusive with the listand docflags.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "syntaxOnly": {
                "docstring": "When no other flag is specified, return only the syntax part of the quick help."
            }
        }
    }, 
    "helpLine": {
        "description": "This command creates a help line where tool help/hints are shown. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parentsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "hide": {
        "description": "The hidecommand is used to make objects invisible. If no flags are used, the objects specified, or the active objects if none are specified, will be made invisible. ", 
        "flags": {
            "allObjects": {
                "docstring": "make everything invisible (top level objects)"
            }, 
            "returnHidden": {
                "docstring": "hide objects, but also return list of hidden objects.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "hikGlobals": {
        "description": "Sets global HumanIK flags for the application. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "releaseAllPinning": {
                "docstring": "Sets the global release all pinning hik flag. When this flag is set, all pinning states are ignored.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "hilite": {
        "description": "Hilites/Unhilites the specifed object(s). Hiliting an object makes it possible to select the components of the object. If no objects are specified then the selection list is used. ", 
        "flags": {
            "replace": {
                "docstring": "Hilite the specified objects. Any objects previously hilited will no longer be hilited."
            }, 
            "toggle": {
                "docstring": "Toggle the hilite state of the specified objects.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "unHilite": {
                "docstring": "Remove the specified objects from the hilite list."
            }
        }
    }, 
    "hitTest": {
        "description": "The hitTestcommand hit-tests a point in the named control and returns a list of items underneath the point. The point is specified in pixels with the origin (0,0) at the top-left corner. This position is compatible with the coordinates provided by a drop-callback. The types of items that may be returned depends upon the specific control; not all controls currently support hit-testing. ", 
        "flags": {}
    }, 
    "hotBox": {
        "description": "This command controls parameters related to the hotBox menubar palette. When the command is invoked with no flags, the hotBox is popped up. In query mode, return type is based on queried flag.", 
        "flags": {
            "PaneOnlyMenus": {
                "docstring": "Sets a row of menus to be the only visible row."
            }, 
            "PaneToggleMenus": {
                "docstring": "Sets the visibilty of a row of menus to on or off."
            }, 
            "animationOnlyMenus": {
                "docstring": ""
            }, 
            "animationToggleMenus": {
                "docstring": ""
            }, 
            "clothOnlyMenus": {
                "docstring": ""
            }, 
            "clothToggleMenus": {
                "docstring": ""
            }, 
            "commonOnlyMenus": {
                "docstring": ""
            }, 
            "commonToggleMenus": {
                "docstring": ""
            }, 
            "customMenuSetsToggleMenus": {
                "docstring": ""
            }, 
            "displayCenterOnly": {
                "docstring": "Three different display styles are defined for the hotBox. It can be fully displayed (dh), display only the marking menu zones (dzo) or no display (dco) which means that the entire screen can be used to access the marking menus defined in the center zone."
            }, 
            "displayHotbox": {
                "docstring": ""
            }, 
            "displayStyle": {
                "docstring": "Returns a string that identifies the flag used to set the current display style. The results can be dh, dzo, or dco, depending on which style the hotBox is using at the moment."
            }, 
            "displayZonesOnly": {
                "docstring": ""
            }, 
            "dynamicsOnlyMenus": {
                "docstring": ""
            }, 
            "dynamicsToggleMenus": {
                "docstring": ""
            }, 
            "liveOnlyMenus": {
                "docstring": ""
            }, 
            "liveToggleMenus": {
                "docstring": ""
            }, 
            "menuSetOnly": {
                "docstring": ""
            }, 
            "menuSetToggle": {
                "docstring": ""
            }, 
            "noClickCommand": {
                "docstring": "The command to be executed if the hotBox is engaged and then disengaged within noClickDelay time units."
            }, 
            "noClickDelay": {
                "docstring": "If the hotBox is engaged and then disengaged within this time interval, then the noClickCommand is executed. The time interval is in seconds. The default value is 0.1."
            }, 
            "noClickPosition": {
                "docstring": "If a -noClickCommand has been specified then this flag will cause the X and Y screen coordinates of the mouse pointer to be appended as arguments to that command. The coordinates used are those of the pointer at the time when the hotbox command was initiated."
            }, 
            "noKeyPress": {
                "docstring": "Normally the hotbox is popped by a pressing a keyboard key. Use the nkpflag to pop the hotbox from a device other than the keyboard (still use the rlflag to unpop the hotbox)."
            }, 
            "polygonsOnlyMenus": {
                "docstring": ""
            }, 
            "polygonsToggleMenus": {
                "docstring": ""
            }, 
            "position": {
                "docstring": "Specify the screen position the hotbox should be centered at next time it is displayed. The default is the cursor position.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "release": {
                "docstring": "Action to be called on the release of the key which invoked the hotbox"
            }, 
            "renderingOnlyMenus": {
                "docstring": ""
            }, 
            "renderingToggleMenus": {
                "docstring": ""
            }, 
            "rmbPopups": {
                "docstring": "Enables/Disables a popup menu of the current function set. This popup menu appear when the right mouse button is pressed in the center zone of the hotbox."
            }, 
            "showAllToggleMenus": {
                "docstring": "Sets the visibility of all menus to on or off. When queried, will only return true if all menu rows are visible."
            }, 
            "surfacesOnlyMenus": {
                "docstring": ""
            }, 
            "surfacesToggleMenus": {
                "docstring": ""
            }, 
            "transparenyLevel": {
                "docstring": "The percentage of transparency, from 0 to 100. Currently, only the values 0, 25, 50, 75 and 100 are supported. Any other values will be rounded off to the nearest supported value."
            }, 
            "updateMenus": {
                "docstring": "Reloads the hotBox menus from the main menubar. This flag is used when the menus in the main menubar are modified, and the hotBox menus need to be refreshed."
            }
        }
    }, 
    "hotkey": {
        "description": "This command sets the single-key hotkeys for the entire application. In query mode, return type is based on queried flag.", 
        "flags": {
            "altModifier": {
                "docstring": ""
            }, 
            "autoSave": {
                "docstring": "If set to true then the hotkeys will always be saved when you quit. If false then the hotkeys are not saved unless \"savePrefs -hotkeys\" is used."
            }, 
            "commandModifier": {
                "docstring": "The Command key must be pressed to get the hotkey. This is only available on systems which have a separate command key. Note that if menu item accelerator keys are being used (menuItem -ke/keyEquivalent), then the accelerator key settings override the hotkey settings."
            }, 
            "ctrlModifier": {
                "docstring": "The Ctrl key must be pressed to get the hotkey. Note that if menu item accelerator keys are being used (menuItem -ke/keyEquivalent), then the accelerator key settings override the hotkey settings."
            }, 
            "factorySettings": {
                "docstring": "Resets the hotkeys back to the initial defaults."
            }, 
            "isModifier": {
                "docstring": "The hotkey is a modifier itself."
            }, 
            "keyShortcut": {
                "docstring": "Specify what key is being set. The key must be either a single ascii character (capital and lowercase can be set independently) or one of the keyword strings for the specialkeyboard characters. The valid keywords are:Up, Down, Right, Left,Home, End, Page_Up, Page_Down, InsertReturn, SpaceF1 to F12"
            }, 
            "name": {
                "docstring": "The name of the namedCommand object that will be executed when the key is pressed."
            }, 
            "pressCommandRepeat": {
                "docstring": "Specify true and the command may be repeated by executing the command repeatLast. This flag is false by default."
            }, 
            "query": {
                "docstring": ""
            }, 
            "releaseCommandRepeat": {
                "docstring": "Specify true and the command may be repeated by executing the command repeatLast. This flag is false by default.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "releaseName": {
                "docstring": "The name of the namedCommand object that will be executed when the key is released."
            }, 
            "sourceUserHotkeys": {
                "docstring": "This command reads the userHotkey file"
            }
        }
    }, 
    "hotkeyCheck": {
        "description": "This command checks if the given hotkey is mapped to a nameCommand object. If so, the annotation of the nameCommand object is returned. Otherwise an empty string is returned. ", 
        "flags": {
            "altModifier": {
                "docstring": "Specifies if the Alt key is pressed."
            }, 
            "commandModifier": {
                "docstring": "Specifies if the command key is pressed."
            }, 
            "ctrlModifier": {
                "docstring": "Specifies if the Ctrl key is pressed."
            }, 
            "isRepeatable": {
                "docstring": ""
            }, 
            "keyString": {
                "docstring": "The key to check."
            }, 
            "keyUp": {
                "docstring": "Specifies if the hotkey is on keyup or keydown (i.e. Release or Press).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "optionModifier": {
                "docstring": "Specifies if the option key is pressed."
            }, 
            "toBeRemovedInFutureMayaRelease": {
                "docstring": ""
            }
        }
    }, 
    "hudButton": {
        "description": "This command creates a Heads-up Display (HUD) button control which is placed in a 2D inactive overlay plane on the 3D viewport. It is to be used to provide hands-on interaction designated by a user script. The HUD button is derived from a generic HUD object and thus inherits a similar workflow. Although this command provides much of the same functionality as the headsUpDisplay command, it does not provide headsUpDisplay layout controls such as layoutVisibility, nextFreeBlock, lastOccupiedBlock, exists, remove, etc. To access that functionality, please use the headsUpDisplay command. This command is focused solely around the creation and management of HUD button controls. Similarly, all operations performed by this command are limited to HUDs that are button controls. The only mandatory flags, on creation are the section and block flags. Like the headsUpDisplay command, upon creation of a HUD button, an ID number will be assigned to it. This can be used to remove the HUD via the headsUpDisplay command (-rid/removeID [int IDNumber]), if desired. Alternatively, the headsUpDisplay command can remove HUD objects via their position (section and block), or their unique name. ", 
        "flags": {
            "allowOverlap": {
                "docstring": "Sets the Heads-Up Display to be visible regardless of overlapping section widths/limitations (see -s/section flag description for more details)."
            }, 
            "block": {
                "docstring": "Denotes the individual block that the HUD will reside in, within a section. Each section is composed of a single column of blocks. The total number of blocks contained within each section is variable. The number of blocks that will be visible within each section is dependent on the size of blocks contained in each section and the current size of the window. Blocks begin enumerating from 0 and flexibly increase based on need. For HUD buttons, the format differs from that of the standard HUD. The layout using parameters defined by the formatting flags listed below (eg. justify, padding, buttonWidth) is shown below: __________________________________ |     |     |          |     |     | |  P  |  J  |  Button  |  J  |  P  | |_____|_____|__________|_____|_____| P = Sub-block of width, padding J = Justification of the entire block Button = Sub-block of width, buttonWidth Block PositioningBlocks on the top section begin from the top edge of the main viewport, while the bottom section begins from the bottom edge. Blocks are dynamically removed from visibility from the midpoint of the viewport. So, a relatively large block number will not draw to the viewport. Lastly, there can be at most one HUD occupying a block at any time. Trying to position a HUD in an occupied block will result in an error. Keep this in mind when positioning the HUD."
            }, 
            "blockAlignment": {
                "docstring": "Specifies the alignment of the block within its respective column. Available alignments are: \"center\", \"left\" and \"right\". The default alignment is \"left\"."
            }, 
            "blockSize": {
                "docstring": "Sets the height of each block. Available heights are: small, medium and large. In pixel measurements, each corresponds to a 20, 35 or 50 pixel height, respectively."
            }, 
            "buttonShape": {
                "docstring": "Specifies the shape of the button. Available button shapes are: \"rectangle\" and \"roundRectangle\". The first will draw a rectangular button, while the latter is a rectangle with rounded edges."
            }, 
            "buttonWidth": {
                "docstring": "Specifies the width of the button."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "label": {
                "docstring": "Text label of the HUD button."
            }, 
            "labelFontSize": {
                "docstring": "Sets the font size of the label. Available sizes are: small and large."
            }, 
            "padding": {
                "docstring": "Specifies the width of both the left and right margins of a block. Default value is 15 pixels."
            }, 
            "pressCommand": {
                "docstring": "Specifies the procedure or script to run during a mouse click event."
            }, 
            "query": {
                "docstring": ""
            }, 
            "releaseCommand": {
                "docstring": "Specifies the procedure or script to run during a mouse release event.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "section": {
                "docstring": "Defines the section the HUD will appear in. There are 10 sections divided across the screen. Five columns and two rows make up the ten element matrix which divide the main viewport. Here is a visual layout of the sections. ________________________ |    |    |    |    |    | |    |    |    |    |    | | 0  | 1  | 2  | 3  | 4  | |    |    |    |    |    | |____|____|____|____|____| |    |    |    |    |    | |    |    |    |    |    | | 5  | 6  | 7  | 8  | 9  | |    |    |    |    |    | |____|____|____|____|____| Each section is denoted by a number from 0 to 9 as illustrated above. For example, if the second column of the top row was desired, the section would be defined as: -sec 1 To prevent HUD objects from displaying over each other and causing a clutter of letters, each row has a defined visibility precedence, where each section would have a visibility priority level. Depending on each priority level, when the screen space begins to shrink to a point where the section widths of a given row begin to collide, the HUD automatically compensates for this by removing the sections of least priority. These sections are made invisible and a warning is issued to inform the user of the removal. This continues until only the section of highest priority remains. For each row, the priorities are defined as follows. Using the top row as an example: Section 0, has the highest priority, followed by Section 4, making the outermost sections of highest priority. Next in the list is Section 2, and lastly Sections 1 and 3 are of the equal and least priority. This priority structure can be applied to the bottom row as well. The two outermost sections have the highest priority, followed by the middle section, and finally the remaining two sections are of lowest priority. This means that as the viewport gradually decreases in width to the point where sections in the top row begin to overlap, sections 1 and 3 will be removed from view first, followed by section 2, and finally section 4. A similar note is provided below for the block layout."
            }, 
            "visible": {
                "docstring": "Sets the visibility of the Heads-Up Display on and off."
            }
        }
    }, 
    "hudSlider": {
        "description": "This command creates a Heads-up Display (HUD) slider control which is placed in a 2D inactive overlay plane on the 3D viewport. It is to be used to provide hands-on interaction designated by a user script. The HUD slider is derived from a generic HUD object and thus inherits a similar workflow. Although this command provides much of the same functionality as the headsUpDisplay command, it does not provide headsUpDisplay layout controls such as layoutVisibility, nextFreeBlock, lastOccupiedBlock, exists, remove, etc. To access that functionality, please use the headsUpDisplay command. This command is focused solely around the creation and management of HUD sliders. Similarly, all operations performed by this command are limited to HUDs that are sliders. The only mandatory flags, on creation are the section and block flags. Like the headsUpDisplay command, upon creation of a HUD slider, an ID number will be assigned to it. This can be used to remove the HUD slider via the headsUpDisplay command (-rid/removeID [int IDNumber]), if desired. Alternatively, the headsUpDisplay command can remove HUD objects via their position (section and block), or their unique name. ", 
        "flags": {
            "allowOverlap": {
                "docstring": "Sets the Heads-Up Display to be visible regardless of overlapping section widths/limitations (see -s/section flag description for more details)."
            }, 
            "block": {
                "docstring": "Denotes the individual block that the HUD will reside in, within a section. Each section is composed of a single column of blocks. The total number of blocks contained within each section is variable. The number of blocks that will be visible within each section is dependent on the size of blocks contained in each section and the current size of the window. Blocks begin enumerating from 0 and flexibly increase based on need. For HUD sliders, the format differs from that of the standard HUD. The layout using parameters defined by the formatting flags listed below (eg. justify, padding, labelWidth, valueWidth) is shown below: __________________________________________________________________ |     |     |        |            |      |             |     |     | |  P  |  J  |   LW   |   Slider   |  IP  | SliderValue |  J  |  P  | |_____|_____|________|____________|______|_____________|_____|_____| P = Sub-block of width, padding J = Justification of the entire block LW = Sub-block of width, labelWidth Slider = Length of the slider SliderValue = Sub-block of width, valueWidth IP = Internal padding Block PositioningBlocks on the top section begin from the top edge of the main viewport, while the bottom section begins from the bottom edge. Blocks are dynamically removed from visibility from the midpoint of the viewport. So, a relatively large block number will not draw to the viewport. Lastly, there can be at most one HUD occupying a block at any time. Trying to position a HUD in an occupied block will result in an error. Keep this in mind when positioning the HUD."
            }, 
            "blockAlignment": {
                "docstring": "Specifies the alignment of the block within its respective column. Available alignments are: \"center\", \"left\" and \"right\". The default alignment is \"left\"."
            }, 
            "blockSize": {
                "docstring": "Sets the height of each block. Available heights are: small, medium and large. In pixel measurements, each corresponds to a 20, 35 or 50 pixel height, respectively."
            }, 
            "decimalPrecision": {
                "docstring": "Sets the decimal precision of any floating point value returned by the command. The valid range of precision values are 1 to 8."
            }, 
            "dragCommand": {
                "docstring": "Specifies the procedure or script to run during a mouse drag event."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "internalPadding": {
                "docstring": "Specifies the amount of padding between the internal elements of the HUD. For the hudSlider, this represents the padding between the slider bar and the slider value. The default padding is 10."
            }, 
            "label": {
                "docstring": "Text label of the HUD."
            }, 
            "labelFontSize": {
                "docstring": "Sets the font size of the label. Available sizes are: small and large."
            }, 
            "labelWidth": {
                "docstring": "Specifies the pixel width of the virtual \"textbox\" which will hold the label. The contents of this \"textbox\" will be left justified. If the width of the actual label exceeds the width of the \"textbox,\" the label will be truncated to fit within the dimensions of the \"textbox.\" (To see a layout of a block, see the description of the -block flag.)"
            }, 
            "maxValue": {
                "docstring": "Specify the maximum value of the slider. Note:Although this flag takes in a FLOAT as an argument, if the HUD type is \"int\", the value will be automatically converted internally to an integer."
            }, 
            "minValue": {
                "docstring": "Specify the minimum value of the slider. Note:Although this flag takes in a FLOAT as an argument, if the HUD type is \"int\", the value will be automatically converted internally to an integer."
            }, 
            "padding": {
                "docstring": "Specifies the width of both the left and right margins of a block. Default value is 15 pixels."
            }, 
            "pressCommand": {
                "docstring": "Specifies the procedure or script to run during a mouse click event."
            }, 
            "query": {
                "docstring": ""
            }, 
            "releaseCommand": {
                "docstring": "Specifies the procedure or script to run during a mouse release event.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "section": {
                "docstring": "Defines the section the HUD will appear in. There are 10 sections divided across the screen. Five columns and two rows make up the ten element matrix which divide the main viewport. Here is a visual layout of the sections. ________________________ |    |    |    |    |    | |    |    |    |    |    | | 0  | 1  | 2  | 3  | 4  | |    |    |    |    |    | |____|____|____|____|____| |    |    |    |    |    | |    |    |    |    |    | | 5  | 6  | 7  | 8  | 9  | |    |    |    |    |    | |____|____|____|____|____| Each section is denoted by a number from 0 to 9 as illustrated above. For example, if the second column of the top row was desired, the section would be defined as: -sec 1 To prevent HUD objects from displaying over each other and causing a clutter of letters, each row has a defined visibility precedence, where each section would have a visibility priority level. Depending on each priority level, when the screen space begins to shrink to a point where the section widths of a given row begin to collide, the HUD automatically compensates for this by removing the sections of least priority. These sections are made invisible and a warning is issued to inform the user of the removal. This continues until only the section of highest priority remains. For each row, the priorities are defined as follows. Using the top row as an example: Section 0, has the highest priority, followed by Section 4, making the outermost sections of highest priority. Next in the list is Section 2, and lastly Sections 1 and 3 are of the equal and least priority. This priority structure can be applied to the bottom row as well. The two outermost sections have the highest priority, followed by the middle section, and finally the remaining two sections are of lowest priority. This means that as the viewport gradually decreases in width to the point where sections in the top row begin to overlap, sections 1 and 3 will be removed from view first, followed by section 2, and finally section 4. A similar note is provided below for the block layout."
            }, 
            "sliderIncrement": {
                "docstring": "Specify the number of increments along the slider. If not specified or set to 0 or less, the slider will be linearly even and continuous from minValue to maxValue. Note:Although this flag takes in a FLOAT as an argument, if the HUD type is \"int\", the value will be automatically converted internally to an integer."
            }, 
            "sliderLength": {
                "docstring": "Specifies the length of the slider in pixels."
            }, 
            "type": {
                "docstring": "Specify the numeric type of the HUD. Available types are: \"float\" and \"int\"."
            }, 
            "value": {
                "docstring": "Set/Return the slider value if the HUD is a valid HUD slider. Note:Although this flag takes in a FLOAT as an argument, if the HUD type is \"int\", the value will be automatically converted internally to an integer."
            }, 
            "valueAlignment": {
                "docstring": "Specifies the alignment of the data blocks and the data text, within a HUD block. Available alignments are: \"left\" and \"right\". The default alignment is \"left\"."
            }, 
            "valueFontSize": {
                "docstring": "Sets the font size of the slider value. Available sizes are: small and large."
            }, 
            "valueWidth": {
                "docstring": "Specifies the pixel width of the virtual \"textbox\" which will hold the slider value. (To see a layout of a block, see the description of the -block flag.)"
            }, 
            "visible": {
                "docstring": "Sets the visibility of the Heads-Up Display on and off."
            }
        }
    }, 
    "hudSliderButton": {
        "description": "This command creates a Heads-up Display (HUD) slider button control which is placed in a 2D inactive overlay plane on the 3D viewport. It is to be used to provide hands-on interaction designated by a user script. The HUD slider button control is derived from a generic HUD object and thus inherits a similar workflow. Although this command provides much of the same functionality as the headsUpDisplay command, it does not provide headsUpDisplay layout controls such as layoutVisibility, nextFreeBlock, lastOccupiedBlock, exists, remove, etc. To access that functionality, please use the headsUpDisplay command. This command is focused solely around the creation and management of HUD slider button controls. Similarly, all operations performed by this command are limited to HUDs that are slider button controls. The only mandatory flags, on creation are the section and block flags. Like the headsUpDisplay command, upon creation of a HUD slider button, an ID number will be assigned to it. This can be used to remove the HUD slider via the headsUpDisplay command (-rid/removeID [int IDNumber]), if desired. Alternatively, the headsUpDisplay command can remove HUD objects via their position (section and block), or their unique name. ", 
        "flags": {
            "allowOverlap": {
                "docstring": "Sets the Heads-Up Display to be visible regardless of overlapping section widths/limitations (see -s/section flag description for more details)."
            }, 
            "block": {
                "docstring": "Denotes the individual block that the HUD will reside in, within a section. Each section is composed of a single column of blocks. The total number of blocks contained within each section is variable. The number of blocks that will be visible within each section is dependent on the size of blocks contained in each section and the current size of the window. Blocks begin enumerating from 0 and flexibly increase based on need. For HUD sliders, the format differs from that of the standard HUD. The layout using parameters defined by the formatting flags listed below (eg. justify, padding, labelWidth, valueWidth) is shown below: __________________________________________________________________________ |     |     |      |           |      |       |      |        |     |     | |  P  |  J  |  LW  |  Slider   |  IP  | Value |  IP  | Button |  J  |  P  | |_____|_____|______|___________|______|_______|______|________|_____|_____| P = Sub-block of width, padding J = Justification of the entire block LW = Sub-block of width, labelWidth Slider = Length of the slider SliderValue = Sub-block of width, valueWidth Button = Sub-block of width, buttonWidth IP = Internal Padding Block PositioningBlocks on the top section begin from the top edge of the main viewport, while the bottom section begins from the bottom edge. Blocks are dynamically removed from visibility from the midpoint of the viewport. So, a relatively large block number will not draw to the viewport. Lastly, there can be at most one HUD occupying a block at any time. Trying to position a HUD in an occupied block will result in an error. Keep this in mind when positioning the HUD."
            }, 
            "blockAlignment": {
                "docstring": "Specifies the alignment of the block within its respective column. Available alignments are: \"center\", \"left\" and \"right\". The default alignment is \"left\"."
            }, 
            "blockSize": {
                "docstring": "Sets the height of each block. Available heights are: small, medium and large. In pixel measurements, each corresponds to a 20, 35 or 50 pixel height, respectively."
            }, 
            "buttonLabel": {
                "docstring": "Text label of the HUD button."
            }, 
            "buttonLabelFontSize": {
                "docstring": "Sets the font size of the button label. Available sizes are: small and large."
            }, 
            "buttonPressCommand": {
                "docstring": "Specifies the procedure or script to run during a button mouse click event."
            }, 
            "buttonReleaseCommand": {
                "docstring": "Specifies the procedure or script to run during a button mouse release event.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "buttonShape": {
                "docstring": "Specifies the shape of the button. Available button shapes are: \"rectangle\" and \"roundRectangle\". The first will draw a rectangular button, while the latter is a rectangle with rounded edges."
            }, 
            "buttonWidth": {
                "docstring": "Specifies the width of the button."
            }, 
            "decimalPrecision": {
                "docstring": "Sets the decimal precision of any floating point value returned by the command. The valid range of precision values are 1 to 8."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "internalPadding": {
                "docstring": "Specifies the amount of padding between the internal elements of the HUD. For the hudSlider, this represents the padding between the slider bar and the slider value. The default padding is 10."
            }, 
            "maxValue": {
                "docstring": "Specify the maximum value of the slider. Note:Although this flag takes in a FLOAT as an argument, if the HUD type is \"int\", the value will be automatically converted internally to an integer."
            }, 
            "minValue": {
                "docstring": "Specify the minimum value of the slider. Note:Although this flag takes in a FLOAT as an argument, if the HUD type is \"int\", the value will be automatically converted internally to an integer."
            }, 
            "padding": {
                "docstring": "Specifies the width of both the left and right margins of a block. Default value is 15 pixels."
            }, 
            "query": {
                "docstring": ""
            }, 
            "section": {
                "docstring": "Defines the section the HUD will appear in. There are 10 sections divided across the screen. Five columns and two rows make up the ten element matrix which divide the main viewport. Here is a visual layout of the sections. ________________________ |    |    |    |    |    | |    |    |    |    |    | | 0  | 1  | 2  | 3  | 4  | |    |    |    |    |    | |____|____|____|____|____| |    |    |    |    |    | |    |    |    |    |    | | 5  | 6  | 7  | 8  | 9  | |    |    |    |    |    | |____|____|____|____|____| Each section is denoted by a number from 0 to 9 as illustrated above. For example, if the second column of the top row was desired, the section would be defined as: -sec 1 To prevent HUD objects from displaying over each other and causing a clutter of letters, each row has a defined visibility precedence, where each section would have a visibility priority level. Depending on each priority level, when the screen space begins to shrink to a point where the section widths of a given row begin to collide, the HUD automatically compensates for this by removing the sections of least priority. These sections are made invisible and a warning is issued to inform the user of the removal. This continues until only the section of highest priority remains. For each row, the priorities are defined as follows. Using the top row as an example: Section 0, has the highest priority, followed by Section 4, making the outermost sections of highest priority. Next in the list is Section 2, and lastly Sections 1 and 3 are of the equal and least priority. This priority structure can be applied to the bottom row as well. The two outermost sections have the highest priority, followed by the middle section, and finally the remaining two sections are of lowest priority. This means that as the viewport gradually decreases in width to the point where sections in the top row begin to overlap, sections 1 and 3 will be removed from view first, followed by section 2, and finally section 4. A similar note is provided below for the block layout."
            }, 
            "sliderDragCommand": {
                "docstring": "Specifies the procedure or script to run during a slider mouse drag event."
            }, 
            "sliderIncrement": {
                "docstring": "Specify the number of increments along the slider. If not specified or set to 0 or less, the slider will be linearly even and continuous from minValue to maxValue. Note:Although this flag takes in a FLOAT as an argument, if the HUD type is \"int\", the value will be automatically converted internally to an integer."
            }, 
            "sliderLabel": {
                "docstring": "Text label of the HUD slider."
            }, 
            "sliderLabelFontSize": {
                "docstring": "Sets the font size of the slider label. Available sizes are: small and large."
            }, 
            "sliderLabelWidth": {
                "docstring": "Specifies the pixel width of the virtual \"textbox\" which will hold the label. The contents of this \"textbox\" will be left justified. If the width of the actual label exceeds the width of the \"textbox,\" the label will be truncated to fit within the dimensions of the \"textbox.\" (To see a layout of a block, see the description of the -block flag.)"
            }, 
            "sliderLength": {
                "docstring": "Specifies the length of the slider in pixels."
            }, 
            "sliderPressCommand": {
                "docstring": "Specifies the procedure or script to run during a slider mouse click event."
            }, 
            "sliderReleaseCommand": {
                "docstring": "Specifies the procedure or script to run during a slider mouse release event."
            }, 
            "type": {
                "docstring": "Specify the numeric type of the HUD. Available types are: \"float\" and \"int\"."
            }, 
            "value": {
                "docstring": "Set/Return the slider value if the HUD is a valid HUD slider. Note:Although this flag takes in a FLOAT as an argument, if the HUD type is \"int\", the value will be automatically converted internally to an integer."
            }, 
            "valueAlignment": {
                "docstring": "Specifies the alignment of the data blocks and the data text, within a HUD block. Available alignments are: \"left\" and \"right\". The default alignment is \"left\"."
            }, 
            "valueFontSize": {
                "docstring": "Sets the font size of the slider value. Available sizes are: small and large."
            }, 
            "valueWidth": {
                "docstring": "Specifies the pixel width of the virtual \"textbox\" which will hold the slider value. (To see a layout of a block, see the description of the -block flag.)"
            }, 
            "visible": {
                "docstring": "Sets the visibility of the Heads-Up Display on and off."
            }
        }
    }, 
    "hwReflectionMap": {
        "description": "This command creates a hwReflectionMap node for having reflection on textured surfaces that currently have their boolean attribute displayHWEnvironment set to true. ", 
        "flags": {
            "backTextureName": {
                "docstring": "This flag specifies the file texture name for the back side of the cube.Default is noneWhen queried, this flag returns a string."
            }, 
            "bottomTextureName": {
                "docstring": "This flag specifies the file texture name for the bottom side of the cube.Default is noneWhen queried, this flag returns a string."
            }, 
            "cubeMap": {
                "docstring": "If on, the reflection of the textures is done using the cube mapping.Default is false. The reflection is done using sphere mapping.When queried, this flag returns a boolean."
            }, 
            "decalMode": {
                "docstring": "If on, the reflection color replaces the surface shading.Default is false. The reflection is multiplied to the surface shading.When queried, this flag returns a boolean."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "If on, enable the corresponding hwReflectionMap node.Default is false.When queried, this flag returns a boolean."
            }, 
            "frontTextureName": {
                "docstring": "This flag specifies the file texture name for the front side of the cube.Default is noneWhen queried, this flag returns a string."
            }, 
            "leftTextureName": {
                "docstring": "This flag specifies the file texture name for the left side of the cube.Default is noneWhen queried, this flag returns a string."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rightTextureName": {
                "docstring": "This flag specifies the file texture name for the right side of the cube.Default is noneWhen queried, this flag returns a string."
            }, 
            "sphereMapTextureName": {
                "docstring": "This flag specifies the file texture name for the sphere mapping option.Default is noneWhen queried, this flag returns a string.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "topTextureName": {
                "docstring": "This flag specifies the file texture name for the top side of the cube.Default is noneWhen queried, this flag returns a string."
            }
        }
    }, 
    "hwRender": {
        "description": "Renders an image or a sequence using the hardware rendering engine ", 
        "flags": {
            "acceleratedMultiSampleSupport": {
                "docstring": "This flag when used with query will return whether the graphics supports hardware accelerated multi-sampling."
            }, 
            "activeTextureCount": {
                "docstring": "This flag when used with query will return the number of textures that have been bound to the graphics by the hardware renderer."
            }, 
            "camera": {
                "docstring": "Specify the camera to use. Use the first available camera if the camera given is not found."
            }, 
            "currentFrame": {
                "docstring": "Render the current frame."
            }, 
            "currentView": {
                "docstring": "When turned on, only the current view will be rendered."
            }, 
            "edgeAntiAliasing": {
                "docstring": "Enables multipass rendering. Controls for the number of exposures rendered per frame are provided in the form of two associated flag arguments. The first specifies the sampling algorithm: 0 - Uniform Weighted Grid Sampling1 - Rotated Grid Super Sampling (RGSS)2 - Gaussian Weighted SamplingUse of a sampling method other than the others listed above, will result in use of the default sample method of Uniform Weighted Grid Sampling. The second argument specifies a number of samples to use. For each sampling algorithm there is a fixed set of sample counts available: 0 - Uniform Weighted Grid Sampling1 Sample3 Samples4 Samples5 Samples7 Samples9 Samples16 Samples25 Samples36 Samples1 - Rotated Grid Super Sampling (RGSS)1 Sample4 Samples5 Samples2 - Gaussian Weighted Sampling1 Sample3 Samples4 Samples5 Samples7 Samples9 Samples16 Samples25 Samples36 SamplesUsing a sampling count other than the allowable options for the given sampling method will result in using the default sample count of 5. The values passed via the command will override settings stored in the hardwareRenderGlobals node."
            }, 
            "fixFileNameNumberPattern": {
                "docstring": "This flag allows the user to take the hardwareRenderGlobals filename as the initial filename pattern, fix the frame number pattern in the filename in a unique way, returns the new filename pattern. This does not change the hardwareRenderGlobals's filename."
            }, 
            "frame": {
                "docstring": "Specify the frame to render."
            }, 
            "fullRenderSupport": {
                "docstring": "This flag may be used in the create or query context. In the create context, it will force the renderer to abort and not render any frames if the hardware is not fully supported. In the query context, it will return whether full quality rendering is supported on the current graphics system. Please see the graphics card qualification charts for an explanation of limited support."
            }, 
            "height": {
                "docstring": "The height flag pass the height to the hwRender command. If not used, the height is taken from the render globals settings."
            }, 
            "imageFileName": {
                "docstring": "This flag let people query the image name for a specified frame. The frame can be specified using the \"-frame\" flag. When no \"-frame\" is used, the current frame number is used."
            }, 
            "layer": {
                "docstring": "Render the specified render layer. Only this render layer will be rendered, regardless of the renderable attribute value of the render layer. The layer name will be appended to the output image file name. The specified render layer becomes the current render layer before rendering, and remains as current render layer after the rendering.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "limitedRenderSupport": {
                "docstring": "This flag when used with query will return whether limited rendering is supported on the current graphics system. Please see the graphics card qualification charts for the current definition of limited support."
            }, 
            "lowQualityLighting": {
                "docstring": "Disable lighting evaluation per pixel (fragment). Note: The values passed via the command will override settings stored in the hardware render globals node."
            }, 
            "noRenderView": {
                "docstring": "When turned on, the render view is not updated after image computation"
            }, 
            "notWriteToFile": {
                "docstring": "This flag is set to true if the user does not want to write the image to a file. It is set to false, otherwise. The default value of the flag is \"false\"."
            }, 
            "printGeometry": {
                "docstring": "Print the geomety objects as they get translated."
            }, 
            "query": {
                "docstring": ""
            }, 
            "renderHardwareName": {
                "docstring": "This flag will create a graphics context and return the name of the graphics hardware being used. The graphics hardware is determined by creating an off screen buffer and querying the GL_RENDERER string from OpenGL. If the off screen buffer cannot be created an empty string is returned."
            }, 
            "renderRegion": {
                "docstring": "The renderRegion flag pass the render region to the hwRender command. The parameters are 4 integers, indicating left right bottom top of the region."
            }, 
            "renderSelected": {
                "docstring": "Only renders the selected objects."
            }, 
            "textureResolution": {
                "docstring": "Specify the desired resolution of baked textures."
            }, 
            "width": {
                "docstring": "The width flag pass the width to the hwRender command. If not used, the width is taken from the render globals settings."
            }, 
            "writeAlpha": {
                "docstring": "Read the alpha channel of color buffer and return as tif file."
            }, 
            "writeDepth": {
                "docstring": "Read the depth buffer and return as tif file."
            }
        }
    }, 
    "hwRenderLoad": {
        "description": "Empty command used to force the dynamic load of HR render ", 
        "flags": {}
    }, 
    "hyperGraph": {
        "description": "The following is an overview of the basic features of the hypergraph. A more detailed description is given in the user manuals. The hypergraph provides the user with the ability to view and edit the maya scene graph. The hypergraph supports two types of graphs: the DAG or scene hierarchy and the dependency graph. The default view of the hypergraph editor is the DAG view. The user can show the dependency graph for a collection of nodes by first selecting the nodes and navigating to the dependency graph using one of the graph options. The user can save any view by setting a bookmark to that view. The user can also show previous views using the view options provided. The hypergraph supports a simple editing mechanism for editing hierarchy in the DAG view and connections in dependency graph view. In the DAG view, the user can reparent or reorder nodes in the graph using drag-and-drop. In the dependency graph view, the user can select connections and delete them or make new connections by dragging and dropping nodes or existing connections. The hypergraph supports two layout modes in the DAG view: automatic and freeform. In automatic mode, the graph nodes are automatically positioned according to the layout preferences. In freeform mode, the user can position nodes manually. The node position is saved in the scene. A background image can be placed behind DG or DAG in freeform mode. This can be used as a template for positioning nodes in a user-defined layout. Nodes in the DAG view can be expanded or collapsed. The state is saved in the scene. The performance of the graph drawing will increase as hierarchies are collapsed. In addition to hierachy relationships, the hypergraph can show expression, constraint and deformation relationships in the DAG. These can be enabled/disabled through the options provided. There are also additional filters for showing shape nodes and invisible nodes. The amount of detail show may affect the speed of the display of the graph. Most of the UI features of the hypergraph are addressable through the hypergraph command-line interface. The available command-line options are described in the next section. ", 
        "flags": {
            "addBookmark": {
                "docstring": "Create a bookmark for the current hypergraph view."
            }, 
            "addDependGraph": {
                "docstring": "Add a dependency graph starting at the named node to the view"
            }, 
            "addDependNode": {
                "docstring": "Add a dependency node to the dependency graph view"
            }, 
            "animateTransition": {
                "docstring": "Turns animate transitions off and on."
            }, 
            "attributeEditor": {
                "docstring": "Launches attribute editor on selected node."
            }, 
            "backward": {
                "docstring": ""
            }, 
            "bookmarkName": {
                "docstring": "Returns the bookmark name for the most recently created bookmark."
            }, 
            "breakConnectionCommand": {
                "docstring": ""
            }, 
            "clear": {
                "docstring": "Clears the current hypergraph view and deletes the graph UI. (see also -rebuild flag)"
            }, 
            "collapseContainer": {
                "docstring": "Collapses containers selected in DG graph."
            }, 
            "connectionDrawStyle": {
                "docstring": "Specify how connections between nodes should be drawn. Valid values are \"center\" (draws connection lines from the center of one node to the center of the other) and \"side\" (draws connection lines from the right side of the source node to the left side of the destination node). The default is \"center\". This flag does not apply to Hypershade graphs, which are always drawn with the \"side\" connection draw style."
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "currentEdge": {
                "docstring": ""
            }, 
            "currentNode": {
                "docstring": ""
            }, 
            "debug": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "deleteBookmark": {
                "docstring": "Delete the bookmark with the corresponding node name."
            }, 
            "dependGraph": {
                "docstring": "Displays dependency graph iterated from specified node."
            }, 
            "dependNode": {
                "docstring": "Displays dependency node in view."
            }, 
            "directoryPressCommand": {
                "docstring": ""
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "down": {
                "docstring": "Navigate down to the dependency graph containing the current selection. Shows upstream and downstream connections."
            }, 
            "downstream": {
                "docstring": "Show downstream dependency graph of selected node(s)."
            }, 
            "dragAndDropBehaviorCommand": {
                "docstring": "Mel proc called when a drag and drop onto a hyperGraph node has occurred. Proc signature is procName (string $editor, string $sourceNode, string $destinationNode)."
            }, 
            "dropNode": {
                "docstring": "Returns the name of the source node in a drag and drop connection, when called during processing of a drop."
            }, 
            "dropTargetNode": {
                "docstring": "Returns the name of the destination node in a drag and drop connection, when called during processing of a drop."
            }, 
            "edgeDblClickCommand": {
                "docstring": "Mel proc called when an edge is double clicked. Proc signature is procName (string $editor, string $edge)."
            }, 
            "edgeDimmedDblClickCommand": {
                "docstring": "Mel proc called when a dimmed edge is double clicked. Proc signature is procName (string $editor, string $edge)."
            }, 
            "edgeDropCommand": {
                "docstring": ""
            }, 
            "edgePressCommand": {
                "docstring": ""
            }, 
            "edgeReleaseCommand": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enableAutomaticLayout": {
                "docstring": "Rebuild the graph if a node is added or removed from the graph via drag and drop or dg messages. Default is true."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandContainer": {
                "docstring": "Expands containers selected in DG graph."
            }, 
            "feedbackGadget": {
                "docstring": "Returns the name of the current gadget."
            }, 
            "feedbackNode": {
                "docstring": "Returns the name of the current feedback or highlight node."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "filterDetail": {
                "docstring": "This flag is obsolete. Use the showConstraints, showExpressions, showDeformer, showInvisible, showShapes and showUnderworld flags instead."
            }, 
            "fitImageToHeight": {
                "docstring": "Changes position and scale of background image, so its height fits current editor view."
            }, 
            "fitImageToWidth": {
                "docstring": "Changes position and scale of background image, so its width fits current editor view."
            }, 
            "focusCommand": {
                "docstring": "Mel proc to be run when the mouse is clicked in the hyper graph. Primarily of use in setting the window focus."
            }, 
            "fold": {
                "docstring": "Folds (Collapses) selected object."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "forceRefresh": {
                "docstring": "Forces the hypergraph to refresh (redraw) its contents."
            }, 
            "forward": {
                "docstring": ""
            }, 
            "frame": {
                "docstring": "Frames the selected objects"
            }, 
            "frameBranch": {
                "docstring": "Frames the the branch from the selected node on downward."
            }, 
            "frameGraph": {
                "docstring": "Frames the entire graph."
            }, 
            "frameGraphNoRebuild": {
                "docstring": ""
            }, 
            "frameHierarchy": {
                "docstring": "Frames the hierarchy that contains the selected node."
            }, 
            "freeform": {
                "docstring": "Enable freeform layout mode."
            }, 
            "fromAttr": {
                "docstring": "Returns the name of the source attribute in a drag and drop connection, when called during processing of a drop."
            }, 
            "fromNode": {
                "docstring": ""
            }, 
            "getNodeList": {
                "docstring": "Returns a string array that represents a list of all the nodes in the graph."
            }, 
            "getNodePosition": {
                "docstring": "Returns the position of a specified node in x,y graph coords. This flag and its argument must be passed to the command before the -q flag (see examples). In query mode, this flag can accept a value."
            }, 
            "graphDescription": {
                "docstring": ""
            }, 
            "graphLayoutStyle": {
                "docstring": "Selects the graph layout style : \"circularLayout\"|\"hierarchicalLayout\"|\"orthogonalLayout\"|\"symmetricLayout\"|\"treeLayout\""
            }, 
            "graphType": {
                "docstring": "Returns the type name of the current graph in the view (either DAG or DG)."
            }, 
            "heatMapDisplay": {
                "docstring": ""
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "iconSize": {
                "docstring": "Set or query the icon size for this hyper graph editor. The currently allowed icon sizes are \"small\", \"medium\" and \"large\"."
            }, 
            "image": {
                "docstring": "Specify background image to be loaded from the project image directory."
            }, 
            "imageEnabled": {
                "docstring": "Enable display of a loaded background image (Freeform DAG view or DG view)"
            }, 
            "imageForContainer": {
                "docstring": "Specify that the following flags work on selected containers instead of the whole image: -imageScale,-imagePosition, fitImageToWidth, -fitImageToHeight, -image"
            }, 
            "imagePosition": {
                "docstring": "Position of the background image."
            }, 
            "imageScale": {
                "docstring": "Uniform scale of the background image."
            }, 
            "initializeScript": {
                "docstring": ""
            }, 
            "isHotkeyTarget": {
                "docstring": "For internal use."
            }, 
            "layout": {
                "docstring": "Perform an automatic layout on the graph."
            }, 
            "layoutSelected": {
                "docstring": "Perform an automatic layout on the selected object. \"circularLayout\"|\"hierarchicalLayout\"|\"orthogonalLayout\"|\"symmetricLayout\"|\"treeLayout\""
            }, 
            "layoutSubtree": {
                "docstring": ""
            }, 
            "limitGraphTraversal": {
                "docstring": ""
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "look": {
                "docstring": "Look at a coordinate in the graph view"
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "mergeConnections": {
                "docstring": "Merge groups of connections into 'fat' connections."
            }, 
            "navigateHome": {
                "docstring": "Navigate to the home (DAG) view."
            }, 
            "navup": {
                "docstring": ""
            }, 
            "newInputConnection": {
                "docstring": ""
            }, 
            "newOutputConnection": {
                "docstring": ""
            }, 
            "nextView": {
                "docstring": "Changes the view to the next DAG view."
            }, 
            "nodeConnectCommand": {
                "docstring": ""
            }, 
            "nodeDblClickCommand": {
                "docstring": ""
            }, 
            "nodeDropCommand": {
                "docstring": "Set the command to be called when a node is dropped in the hypergraph window."
            }, 
            "nodeMenuCommand": {
                "docstring": ""
            }, 
            "nodePressCommand": {
                "docstring": "Set the command to be called when the user presses a mouse button while the cursor is over a node in the hypergraph window."
            }, 
            "nodeReleaseCommand": {
                "docstring": "Set the command to be called when the user releases a mouse button while the cursor is over a node in the hypergraph window."
            }, 
            "opaqueContainers": {
                "docstring": "Sets expanded container background opacity."
            }, 
            "orientation": {
                "docstring": "Selects orientation style of graph: \"horiz\"|\"vert\""
            }, 
            "panView": {
                "docstring": ""
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "popupMenuScript": {
                "docstring": "Set the script to be called to register the popup menu with the control for this hypergraph. The script will be called with a string argument which gives the name of the hypergraph whose control the popup menu should be parented to."
            }, 
            "previousView": {
                "docstring": "Changes the view back to the previous DAG view."
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Limits the display of nodes to only those within the range. There are two float values expected, the first the lower threshold of the range and the second the upper threshold of the range. The values are absolute timing values, not percentages."
            }, 
            "rebuild": {
                "docstring": "Rebuilds graph"
            }, 
            "removeNode": {
                "docstring": "Removes the node identified by string from the graph."
            }, 
            "rename": {
                "docstring": "Pops up text field over selected object for renaming"
            }, 
            "resetFreeform": {
                "docstring": "Resets freeform position on all nodes."
            }, 
            "restoreBookmark": {
                "docstring": "Restore the view corresponding to the bookmark."
            }, 
            "scrollUpDownNoZoom": {
                "docstring": "Specify if we want to be in the scroll along y only with no free zooming mode. By default, hyper graph editor allows user to pan left and right."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "setNodePosition": {
                "docstring": "Sets the node identified by string to the (x,y) position in the window specified by the two floats. If the node is not in the graph than it will be added to the graph and then moved to the new position."
            }, 
            "showCachedConnections": {
                "docstring": ""
            }, 
            "showConstraints": {
                "docstring": "Show constraint relationships in the DAG."
            }, 
            "showDeformers": {
                "docstring": "Show deformer or geometry filter relationships in the DAG."
            }, 
            "showExpressions": {
                "docstring": "Show expression relationships in the DAG."
            }, 
            "showInvisible": {
                "docstring": "Show invisible nodes in the DAG."
            }, 
            "showRelationships": {
                "docstring": "Show relationship (message) connections."
            }, 
            "showShapes": {
                "docstring": "Show shape nodes in the DAG."
            }, 
            "showUnderworld": {
                "docstring": "Show underworld graphs in the DAG."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "toAttr": {
                "docstring": ""
            }, 
            "toNode": {
                "docstring": ""
            }, 
            "transitionFrames": {
                "docstring": "Specify te number of transition frames for animate transitions."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unfold": {
                "docstring": "Unfolds (expands) selected object."
            }, 
            "unfoldAll": {
                "docstring": "Unfolds everything under selected object."
            }, 
            "unfoldAllShapes": {
                "docstring": ""
            }, 
            "unfoldHidden": {
                "docstring": ""
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "updateNodeAdded": {
                "docstring": "Update graph when a new node is added to the database"
            }, 
            "updateSelection": {
                "docstring": "Update selection state in the graph when the selection state of database changes."
            }, 
            "upstream": {
                "docstring": "Show upstream dependency graph of selected node(s)."
            }, 
            "useDrawOverrideColor": {
                "docstring": ""
            }, 
            "useFeedbackList": {
                "docstring": "Use feedback or highlight list as the target selection when processing other hypergraph command-line options."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "viewOption": {
                "docstring": "Set or query the view option for this hyper graph editor. The currently allowed views are \"asIcons\" and \"asList\"."
            }, 
            "visibility": {
                "docstring": "Set the visible state of the selected node(s)."
            }, 
            "zoom": {
                "docstring": "Specify the zoom factor for animating transitionsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "hyperPanel": {
        "description": "This command creates, edit and queries hypergraph panels which contain only a hypergraph editor. ", 
        "flags": {
            "control": {
                "docstring": "Returns the top level control for this panel. Usually used for getting a parent to attach popup menus. CAUTION: panels may not have controls at times. This flag can return \"\" if no control is present."
            }, 
            "copy": {
                "docstring": "Makes this panel a copy of the specified panel. Both panels must be of the same type."
            }, 
            "createString": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the maya panel."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editString": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "hyperEditor": {
                "docstring": "This flag returns the name of the hypergraph editor contained by the panel.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "init": {
                "docstring": "Initializes the panel's default state. This is usually done automatically on file -new and file -open."
            }, 
            "isUnique": {
                "docstring": "Returns true if only one instance of this panel type is allowed."
            }, 
            "label": {
                "docstring": "Specifies the user readable label for the panel."
            }, 
            "menuBarVisible": {
                "docstring": "Controls whether the menu bar for the panel is displayed."
            }, 
            "needsInit": {
                "docstring": "(Internal) On Edit will mark the panel as requiring initialization. Query will return whether the panel is marked for initialization. Used during file -new and file -open."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this panel."
            }, 
            "popupMenuProcedure": {
                "docstring": "Specifies the procedure called for building the panel's popup menu(s). The default value is \"buildPanelPopupMenu\". The procedure should take one string argument which is the panel's name."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replacePanel": {
                "docstring": "Will replace the specifed panel with this panel. If the target panel is within the same layout it will perform a swap."
            }, 
            "tearOff": {
                "docstring": "Will tear off this panel into a separate window with a paneLayout as the parent of the panel. When queried this flag will return if the panel has been torn off into its own window."
            }, 
            "tearOffCopy": {
                "docstring": "Will create this panel as a torn of copy of the specified source panel."
            }, 
            "unParent": {
                "docstring": "Specifies that the panel should be removed from its layout. This (obviously) cannot be used with query."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "hyperShade": {
        "description": "Commands for shader editing in the hypergraph ", 
        "flags": {
            "assign": {
                "docstring": "Assign the specified shader node to renderable objects on the active list. The node can either be a shading group or the shader node attached to the shading group."
            }, 
            "clearWorkArea": {
                "docstring": "Push the current work area on to the stack and create a clear work area"
            }, 
            "collapse": {
                "docstring": "Hide the upstream nodes from the specified node."
            }, 
            "createNode": {
                "docstring": "Create a node of the specified type. This is called when a new rendering node is created using drag and drop from the image browser or from the RMB context sensitve menu on nodes in the Visor Create folders."
            }, 
            "dependGraphArea": {
                "docstring": "When setting a work area, and the work area doesn't already exist this flag inicates a new graph should be created that is either a depend graph or a folder view."
            }, 
            "downStream": {
                "docstring": "Show nodes downstream from the specified node"
            }, 
            "duplicate": {
                "docstring": "Duplicate upstream nodes. If the node is a shader make sure duplicate include the shading group if there is one"
            }, 
            "fixRenderSize": {
                "docstring": "If set to true dont rerender swatches when they change size as the user zooms"
            }, 
            "incremental": {
                "docstring": "Enable or disable incremental layout when making new nodes or connections"
            }, 
            "listDownstreamNodes": {
                "docstring": "List all the downstream render nodes from the specified nodes."
            }, 
            "listDownstreamShaderNodes": {
                "docstring": "List all the downstream shader nodes from the specified nodes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "listUpstreamNodes": {
                "docstring": "List all the upstream render nodes from the specified nodes."
            }, 
            "name": {
                "docstring": "Name for the work area created by this command"
            }, 
            "networks": {
                "docstring": "Do an incremental layout on all of the nodes in the current selection list and that are in the current work area."
            }, 
            "noSGShapes": {
                "docstring": "Display only shapes that are connected to nodes in the network other than a shading group."
            }, 
            "noShapes": {
                "docstring": "Display no shapes when graphing networks."
            }, 
            "noTransforms": {
                "docstring": "Display no transforms when graphing networks."
            }, 
            "objects": {
                "docstring": "Select the objects which are attached to the specified shader node. The shader node can be either the shading group or the shader attached to the shading group. When this flag's argument is the empty string, we will use the currently selected shder node as the input."
            }, 
            "renderCreateAndDrop": {
                "docstring": "Create a render node of the specified type and put user into drag and drop mode to place or connect it."
            }, 
            "reset": {
                "docstring": "Reset the Hypershade panel to its initial state. In particular delete all the work areas."
            }, 
            "resetGraph": {
                "docstring": "Reset the current graph. Typicly called prior to rebuilding a folder in a Hypershade view."
            }, 
            "resetSwatch": {
                "docstring": "For all selected nodes remove user defined swatches if the node has one"
            }, 
            "setAllowsRegraphing": {
                "docstring": "For internal use only."
            }, 
            "setWorkArea": {
                "docstring": "Set the work area to the existing named work ard"
            }, 
            "shaderNetwork": {
                "docstring": "Show the shader network for the specified material node. If the materials shading group has a displacement or volume map these will be shown. If not then the shading group wont be shown."
            }, 
            "shaderNetworks": {
                "docstring": "Show the shader network for all the objects on the selection list that have shaders."
            }, 
            "shaderNetworksSelectMaterialNodes": {
                "docstring": "Select the material nodes in the shader network for all the objects on the selection list that have shaders."
            }, 
            "snapShot": {
                "docstring": "Put hypergraph in snapshot mode. This is only for testing"
            }, 
            "uncollapse": {
                "docstring": "Unhide the upstream nodes from the specified node."
            }, 
            "upStream": {
                "docstring": "Show nodes upstream from the specified node"
            }, 
            "userDefinedLayout": {
                "docstring": "Enable or disable remembrance of user defined layouts. Default is disabled until this functionality is better tested."
            }, 
            "workAreaAddCmd": {
                "docstring": "Set the MEL procedure called when a new work area is added to HyperShade"
            }, 
            "workAreaDeleteCmd": {
                "docstring": "Set the MEL procedure called when a work area is deleted in HyperShade"
            }, 
            "workAreaSelectCmd": {
                "docstring": "Set the MEL procedure called when a work area is selected in HyperShade"
            }
        }
    }, 
    "iconTextButton": {
        "description": "This control supports up to 3 icon images and 4 different display styles. The icon image displayed is the one that best fits the current size of the control given its current style. This command creates an iconTextButton that can be displayed with different icons, with or without accompanying text label. When an argument is passed, it is used to give a name to the iconTextButton. ", 
        "flags": {
            "actionIsSubstitute": {
                "docstring": ""
            }, 
            "align": {
                "docstring": "The label alignment. Alignment values are \"left\", \"right\", and \"center\". By default, the label is aligned \"center\". Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "command": {
                "docstring": "Command executed when the control is pressed."
            }, 
            "commandRepeatable": {
                "docstring": "Set if the MEL command specified in the command flag should be repeatable or not. The \"g\" key, by default, is the shortcut to repeat the last executed command.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "disabledImage": {
                "docstring": "Image used when the button is disabled. Image size must be the same as the image specified with the i/imageflag. This is a Windows only flag."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "doubleClickCommand": {
                "docstring": "Command executed when the control is double clicked."
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "font": {
                "docstring": "The font for the text. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\"."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "handleNodeDropCallback": {
                "docstring": "Specify a script callback which is called when a node is dropped on the control. The name of the node being dropped will be passed to the function (python callable) or appended to the end (script) to form the command to be executed."
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "highlightImage": {
                "docstring": "Highlight image displayed while the cursor is over the control. Image size must be the same as the image specified with the -i/imageflag. This is a Windows only flag."
            }, 
            "image": {
                "docstring": "If you are not providing images with different sizes then you may use this flag for the control's image. If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "This control supports three icons. The icon that best fits the current size of the control will be displayed."
            }, 
            "imageOverlayLabel": {
                "docstring": "A short string, up to 5 characters, representing a label that will be displayed on top of the image."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The text that appears in the control."
            }, 
            "labelEditingCallback": {
                "docstring": "Specify a callback which is called after the user double clicks the label of the control to give it a new label. The new label string will be passed to the callback."
            }, 
            "labelOffset": {
                "docstring": "The label offset. Default is 0. Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "marginHeight": {
                "docstring": "The number of pixels above and below the control content. The default value is 1 pixel."
            }, 
            "marginWidth": {
                "docstring": "The number of pixels on either side of the control content. The default value is 1 pixel."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "overlayLabelBackColor": {
                "docstring": "The RGBA color of the shadow behind the label defined by imageOverlayLabel. Default is 25% transparent black: 0 0 0 .25"
            }, 
            "overlayLabelColor": {
                "docstring": "The RGB color of the label defined by imageOverlayLabel. Default is a light grey: .8 .8 .8"
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectionImage": {
                "docstring": "Image displayed while the control is selected. Image size must be the same as the image specified with the -i/imageflag. This is a Windows only flag."
            }, 
            "sourceType": {
                "docstring": "Sets the language type for the command script. Can only be used in conjunction with the c/command or dcc/doubleClickCommand flags. Valid values are \"mel\" (enabled by default), and \"python\"."
            }, 
            "style": {
                "docstring": "The draw style of the control. Valid styles are \"iconOnly\", \"textOnly\", \"iconAndTextHorizontal\", \"iconAndTextVertical\", and \"iconAndTextCentered\". (Note: \"iconAndTextCentered\" is only available on Windows). If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "iconTextCheckBox": {
        "description": "This control supports up to 3 icon images and 4 different display styles. The icon image displayed is the one that best fits the current size of the control given its current style. This command creates an iconTextCheckBox. ", 
        "flags": {
            "align": {
                "docstring": "The label alignment. Alignment values are \"left\", \"right\", and \"center\". By default, the label is aligned \"center\". Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the control's state is changed. Note that this flag should not be used in conjunction with onCommand and offCommand. That is, one should either use changeCommand and test the state of the control from inside the callback, or use onCommand and offCommand as separate callbacks."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "disabledImage": {
                "docstring": "Image used when the button is disabled. Image size must be the same as the image specified with the i/imageflag. This is a Windows only flag."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "font": {
                "docstring": "The font for the text. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\"."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "highlightImage": {
                "docstring": "Highlight image displayed while the cursor is over the control. Image size must be the same as the image specified with the -i/imageflag. This is a Windows only flag."
            }, 
            "image": {
                "docstring": "If you are not providing images with different sizes then you may use this flag for the control's image. If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "This control supports three icons. The icon that best fits the current size of the control will be displayed."
            }, 
            "imageOverlayLabel": {
                "docstring": "A short string, up to 5 characters, representing a label that will be displayed on top of the image."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The text that appears in the control."
            }, 
            "labelOffset": {
                "docstring": "The label offset. Default is 0. Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "marginHeight": {
                "docstring": "The number of pixels above and below the control content. The default value is 1 pixel."
            }, 
            "marginWidth": {
                "docstring": "The number of pixels on either side of the control content. The default value is 1 pixel."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "offCommand": {
                "docstring": "Command executed when the control is turned off."
            }, 
            "onCommand": {
                "docstring": "Command executed when the control is turned on."
            }, 
            "overlayLabelBackColor": {
                "docstring": "The RGBA color of the shadow behind the label defined by imageOverlayLabel. Default is 25% transparent black: 0 0 0 .25"
            }, 
            "overlayLabelColor": {
                "docstring": "The RGB color of the label defined by imageOverlayLabel. Default is a light grey: .8 .8 .8"
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectionHighlightImage": {
                "docstring": "Image displayed while the control is selected and the cursor is over the control. Image size must be the same as the image specified with the -i/imageflag. This is a Windows only flag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "selectionImage": {
                "docstring": "Image displayed while the control is selected. Image size must be the same as the image specified with the -i/imageflag. This is a Windows only flag."
            }, 
            "style": {
                "docstring": "The draw style of the control. Valid styles are \"iconOnly\", \"textOnly\", \"iconAndTextHorizontal\", \"iconAndTextVertical\", and \"iconAndTextCentered\". (Note: \"iconAndTextCentered\" is only available on Windows). If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Sets or returns the state of the control."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "iconTextRadioButton": {
        "description": "This control supports up to 3 icon images and 4 different display styles. The icon image displayed is the one that best fits the current size of the control given its current style. This command creates a iconTextRadioButton that is added to the most recently created iconTextRadioCollection unless the -cl/cluster flag is used. ", 
        "flags": {
            "align": {
                "docstring": "The label alignment. Alignment values are \"left\", \"right\", and \"center\". By default, the label is aligned \"center\". Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the control's state is changed. Note that this flag should not be used in conjunction with onCommand and offCommand. That is, one should either use changeCommand and test the state of the control from inside the callback, or use onCommand and offCommand as separate callbacks."
            }, 
            "collection": {
                "docstring": "To explicitly add the control to the specified collection."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "disabledImage": {
                "docstring": "Image used when the button is disabled. Image size must be the same as the image specified with the i/imageflag. This is a Windows only flag."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "font": {
                "docstring": "The font for the text. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\"."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "highlightImage": {
                "docstring": "Highlight image displayed while the cursor is over the control. Image size must be the same as the image specified with the -i/imageflag. This is a Windows only flag."
            }, 
            "image": {
                "docstring": "If you are not providing images with different sizes then you may use this flag for the control's image. If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "This control supports three icons. The icon that best fits the current size of the control will be displayed."
            }, 
            "imageOverlayLabel": {
                "docstring": "A short string, up to 5 characters, representing a label that will be displayed on top of the image."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The text that appears in the control."
            }, 
            "labelOffset": {
                "docstring": "The label offset. Default is 0. Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "marginHeight": {
                "docstring": "The number of pixels above and below the control content. The default value is 1 pixel."
            }, 
            "marginWidth": {
                "docstring": "The number of pixels on either side of the control content. The default value is 1 pixel."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "offCommand": {
                "docstring": "Command executed when the control is turned off."
            }, 
            "onCommand": {
                "docstring": "Command executed when the control is turned on."
            }, 
            "overlayLabelBackColor": {
                "docstring": "The RGBA color of the shadow behind the label defined by imageOverlayLabel. Default is 25% transparent black: 0 0 0 .25"
            }, 
            "overlayLabelColor": {
                "docstring": "The RGB color of the label defined by imageOverlayLabel. Default is a light grey: .8 .8 .8"
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "select": {
                "docstring": "Will set this button as the selected one."
            }, 
            "selectionHighlightImage": {
                "docstring": "Image displayed while the control is selected and the cursor is over the control. Image size must be the same as the image specified with the -i/imageflag. This is a Windows only flag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "selectionImage": {
                "docstring": "Image displayed while the control is selected. Image size must be the same as the image specified with the -i/imageflag. This is a Windows only flag."
            }, 
            "style": {
                "docstring": "The draw style of the control. Valid styles are \"iconOnly\", \"textOnly\", \"iconAndTextHorizontal\", \"iconAndTextVertical\", and \"iconAndTextCentered\". (Note: \"iconAndTextCentered\" is only available on Windows). If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "iconTextRadioCollection": {
        "description": "This command creates a cluster for iconTextRadioButtons. Clusters will be parented to the current default layout if no parent is specified with the -p/parent flag. As children of the layout they will be deleted when the layout is deleted. Clusters may also span more than one window if the -g/global flag is used. In this case the cluster has no parent so must be explicitly deleted with the 'deleteUI' command. ", 
        "flags": {
            "collectionItemArray": {
                "docstring": "Returns a string list giving the long names of all the items in this collection.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "disableCommands": {
                "docstring": "Allows a particular iconTextRadioButton in the collection to be selected without invoking the commands attached to the -cc/changeCommand, -onc/onCommand, or -ofc/offCommand flags. This flag is only meaningful when used in conjuction with the -edit and -select flags."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "gl": {
                "docstring": "Set the collection to have no parent layout. If the collection has a parent layout then it will be deleted with that layout, otherwise if it is specified to be global it must be explicitly deleted."
            }, 
            "numberOfCollectionItems": {
                "docstring": "Returns the number of items that are in this collection."
            }, 
            "parent": {
                "docstring": "Set the specified layout to be the parent layout of the cluster."
            }, 
            "query": {
                "docstring": ""
            }, 
            "select": {
                "docstring": "Select the specified collection item. If queried will return the name of the currently selected collection item."
            }, 
            "useTemplate": {
                "docstring": ""
            }
        }
    }, 
    "iconTextScrollList": {
        "description": "This command creates/edits/queries a text scrolling list. The list can be in single select mode where only one item at at time is selected, or in multi-select mode where many items may be selected. ", 
        "flags": {
            "allowMultiSelection": {
                "docstring": "Specify multi or single selection mode."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "append": {
                "docstring": "Add an item to the end of the list."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "deselectAll": {
                "docstring": "Deselect all items."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "doubleClickCommand": {
                "docstring": "Specify the command to be executed when an item is double clicked."
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragFeedbackVisible": {
                "docstring": ""
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "dropRectCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is hovering above the drop site. It returns the shape of the rectangle to be drawn to highlight the entry, if the control can receive the dropped data. The MEL version of the callback is of the form: global proc int[] callbackName(string $dropControl, int $x, int $y) The return value is an array of size 4, with the parameters, in order, being the left and top coordinates of the rectangle to be drawn, followed by the width and height. This functionality is currently only implemented in MEL.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editIndexed": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "itemAt": {
                "docstring": "Return the name of the item, if any, located at given point "
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfIcons": {
                "docstring": ""
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "numberOfRows": {
                "docstring": "Number of visible rows."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeAll": {
                "docstring": "Remove all items."
            }, 
            "selectCommand": {
                "docstring": "Specify the command to be executed when an item is selected."
            }, 
            "selectIndexedItem": {
                "docstring": ""
            }, 
            "selectItem": {
                "docstring": "Select the item that contains the specified text."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "visualRectAt": {
                "docstring": "Return the visual rectangle of the item, if any, located at given point. The result is a an array of 4 integers, in local coordinates, describing the rectangle, in the following order: left, top, width, height. "
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "iconTextStaticLabel": {
        "description": "This control supports up to 3 icon images and 4 different display styles. The icon image displayed is the one that best fits the current size of the control given its current style. This command creates an iconTextStaticLabel. ", 
        "flags": {
            "align": {
                "docstring": "The label alignment. Alignment values are \"left\", \"right\", and \"center\". By default, the label is aligned \"center\". Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "disabledImage": {
                "docstring": "Image used when the button is disabled. Image size must be the same as the image specified with the i/imageflag. This is a Windows only flag."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "font": {
                "docstring": "The font for the text. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "image": {
                "docstring": "If you are not providing images with different sizes then you may use this flag for the control's image. If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "This control supports three icons. The icon that best fits the current size of the control will be displayed."
            }, 
            "imageOverlayLabel": {
                "docstring": "A short string, up to 5 characters, representing a label that will be displayed on top of the image."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The text that appears in the control."
            }, 
            "labelOffset": {
                "docstring": "The label offset. Default is 0. Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "marginHeight": {
                "docstring": "The number of pixels above and below the control content. The default value is 1 pixel."
            }, 
            "marginWidth": {
                "docstring": "The number of pixels on either side of the control content. The default value is 1 pixel."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "overlayLabelBackColor": {
                "docstring": "The RGBA color of the shadow behind the label defined by imageOverlayLabel. Default is 25% transparent black: 0 0 0 .25"
            }, 
            "overlayLabelColor": {
                "docstring": "The RGB color of the label defined by imageOverlayLabel. Default is a light grey: .8 .8 .8"
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "style": {
                "docstring": "The draw style of the control. Valid styles are \"iconOnly\", \"textOnly\", \"iconAndTextHorizontal\", \"iconAndTextVertical\", and \"iconAndTextCentered\". (Note: \"iconAndTextCentered\" is only available on Windows). If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "ikHandle": {
        "description": "The handle command is used to create, edit, and query a handle within Maya. The standard edit (-e) and query (-q) flags are used for edit and query functions. If there are 2 joints selected and neither -startJoint nor -endEffector flags are not specified, then the handle will be created from the selected joints. If a single joint is selected and neither -startJoint nor -endEffector flags are specified, then the handle will be created with the selected joint as the end-effector and the start joint will be the top of the joint chain containing the end effector. The default values of the flags are: -name \"ikHandle#\"-priority 1-weight 1.0-positionWeight 1.0-solver \"ikRPsolver\"-forceSolver on-snapHandleFlagToggle on-sticky off-createCurve true-simplifyCurve true-rootOnCurve true-twistType linear-createRootAxis false-parentCurve true-snapCurve false-numSpans 1-rootTwistMode false.These attributes can be specified in creation mode, edited in edit mode (-e) or queried in query mode (-q). ", 
        "flags": {
            "autoPriority": {
                "docstring": "Specifies that this handle's priority is assigned automatically. The assigned priority will be based on the hierarchy distance from the root of the skeletal chain to the start joint of the handle."
            }, 
            "connectEffector": {
                "docstring": "This option is set to true as default, meaning that end-effector translate is connected with the endJoint translate."
            }, 
            "createCurve": {
                "docstring": "Specifies if a curve should automatically be created for the ikSplineHandle."
            }, 
            "createRootAxis": {
                "docstring": "Specifies if a root transform should automatically be created above the joints affected by the ikSplineHandle. This option is used to prevent the root flipping singularity on a motion path."
            }, 
            "curve": {
                "docstring": "Specifies the curve to be used by the ikSplineHandle. Joints will be moved to align with this curve. This flag is mandatory if you use the -freezeJoints option."
            }, 
            "disableHandles": {
                "docstring": "set given handles to full fk (ikBlend attribute = 0.0)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enableHandles": {
                "docstring": "set given handles to full ik (ikBlend attribute = 1.0)"
            }, 
            "endEffector": {
                "docstring": "Specifies the end-effector of the handle's joint chain. The end effector may be specified with a joint or an end-effector. If a joint is specified, an end-effector will be created at the same position as the joint and this new end-effector will be used as the end-effector."
            }, 
            "exists": {
                "docstring": "Indicates if the specified handle exists or not."
            }, 
            "forceSolver": {
                "docstring": "Forces the solver to be used everytime. It could also be known as animSticky. So, after you set the first key the handle is sticky."
            }, 
            "freezeJoints": {
                "docstring": "Forces the curve, specfied by -curve option, to align itself along the existing joint chain. When false, or unspecified, the joints will be moved to positions along the specified curve."
            }, 
            "jointList": {
                "docstring": "Returns the list of joints that the handle is manipulating."
            }, 
            "name": {
                "docstring": "Specifies the name of the handle."
            }, 
            "numSpans": {
                "docstring": "Specifies the number of spans in the automatically generated curve of the ikSplineHandle."
            }, 
            "parentCurve": {
                "docstring": "Specifies if the curve should automatically be parented to the parent of the first joint affected by the ikSplineHandle."
            }, 
            "positionWeight": {
                "docstring": "Specifies the position/orientation weight of a handle. This is used to compute the \"distance\" between the goal position and the end-effector position. A positionWeight of 1.0 computes the distance as the distance between positions only and ignores the orientations. A positionWeight of 0.0 computes the distance as the distance between the orientations only and ignores the positions. A positionWeight of 0.5 attempts to weight the distances equally but cannot actually compute this due to unit differences. Because there is no way to add linear units and angular units."
            }, 
            "priority": {
                "docstring": "Sets the priority of the handle. Logically, all handles with a lower number priority are solved before any handles with a higher numbered priority. (All handles of priority 1 are solved before any handles of priority 2 and so on.) Handle priorities must be ] 0."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rootOnCurve": {
                "docstring": "Specifies if the root is locked onto the curve of the ikSplineHandle."
            }, 
            "rootTwistMode": {
                "docstring": "Specifies whether the start joint is allowed to twist or not. If not, then the required twist is distributed over the remaining joints. This applies to all the twist types.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "setupForRPsolver": {
                "docstring": "If the flag is set and ikSolver is ikRPsolver, call RPRotateSetup for the new ikHandle. It is for ikRPsolver only."
            }, 
            "simplifyCurve": {
                "docstring": "Specifies if the ikSplineHandle curve should be simplified."
            }, 
            "snapCurve": {
                "docstring": "Specifies if the curve should automatically snap to the first joint affected by the ikSplineHandle."
            }, 
            "snapHandleFlagToggle": {
                "docstring": "Specifies that the handle position should be snapped to the end-effector position if the end-effector is moved by the user. Setting this flag on allows you to use forward kinematics to pose or adjust your skeleton and then to animate it with inverse kinematics."
            }, 
            "snapHandleToEffector": {
                "docstring": "All handles are immediately moved so that the handle position and orientation matches the end-effector position and orientation."
            }, 
            "solver": {
                "docstring": "Specifies the solver. The complete list of available solvers may not be known until run-time because some of the solvers may be implemented as plug-ins. Currently the only valid solver are ikRPsolver, ikSCsolver and ikSplineSolver."
            }, 
            "startJoint": {
                "docstring": "Specifies the start joint of the handle's joint chain."
            }, 
            "sticky": {
                "docstring": "Specifies that this handle is \"sticky\". Valid values are \"off\", \"sticky\", \"superSticky\". Sticky handles are solved when the skeleton is being manipulated interactively. If a character has sticky feet, the solver will attempt to keep them in the same position as the user moves the character's root. If they were not sticky, they would move along with the root."
            }, 
            "twistType": {
                "docstring": "Specifies the type of interpolation to be used by the ikSplineHandle. The interpolation options are \"linear\", \"easeIn\", \"easeOut\", and \"easeInOut\"."
            }, 
            "weight": {
                "docstring": "Specifies the handles weight in error calculations. The weight only applies when handle goals are in conflict and cannot be solved simultaneously. When this happens, a solution is computed that weights the \"distance\" from each goal to the solution by the handle's weight and attempts to minimize this value. The weight must be ]= 0."
            }
        }
    }, 
    "ikHandleCtx": {
        "description": "The ikHandle context command (ikHandleCtx) updates parameters of ikHandle tool. The options for the tool will be set to the flags that the user specifies. ", 
        "flags": {
            "autoPriorityH": {
                "docstring": "Specifies that this handle's priority is assigned automatically.C: The default is off.Q: When queried, this flag returns an int."
            }, 
            "createCurve": {
                "docstring": "Specifies if a curve should be automatically created for the ikSplineHandle. The flag is ignored in the ikHandleCtx.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "createRootAxis": {
                "docstring": "Specifies if a root transform should automatically be created above the joints affected by the ikSplineHandle. This option is used to prevent the root flipping singularity on a motion path. This flag is ignored in the ikHandleCtx.C: The default is off.Q: When queried, this flag returns an int."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "forceSolverH": {
                "docstring": "Specifies if the ikSolver is enabled for the ikHandle.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "numSpans": {
                "docstring": "Specifies the number of spans in the automatically generated curve of the ikSplineHandle. This flag is ignored in the ikHandleCtx.C: The default is 1.Q: When queried, this flag returns an int."
            }, 
            "parentCurve": {
                "docstring": "Specifies if the curve should automatically be parented to the parent of the first joint affected by the ikSplineHandle. The flag is ignored in the ikHandleCtx.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "poWeightH": {
                "docstring": "Specifies the position/orientation weight of the ikHandle.C: The default is 1.Q: When queried, this flag returns a float."
            }, 
            "priorityH": {
                "docstring": "Specifies the priority of the ikHandle.C: The default is 1.Q: When queried, this flag returns an int."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rootOnCurve": {
                "docstring": "Specifies if the root is locked onto the curve of the ikSplineHandle. This flag is ignored in the ikHandleCtx.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "rootTwistMode": {
                "docstring": "Specifies whether the start joint is allowed to twist or not. If not, then the required twist is distributed over the remaining joints. This applies to all the twist types. This flag is ignored in the ikHandleCtx.C: The default is off.Q: When queried, this flag returns an int.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "simplifyCurve": {
                "docstring": "Specifies if the ikSplineHandle curve should be simplified. This flag is ignored in the ikHandleCtx.C: The default is on.Q: When queried, this returns an int."
            }, 
            "snapCurve": {
                "docstring": "Specifies if the curve should automatically snap to the first joint affected by the ikSplineHandle. This flag is ignored in the ikHandleCtx.C: The default is off.Q: When queried, this flag returns an int."
            }, 
            "snapHandleH": {
                "docstring": "Specifies if the ikHandle snapping is on.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "solverTypeH": {
                "docstring": "Lists what ikSolver is being used. The ikSplineSolver may not be selected. To use an ikSplineSolver use the ikSplineHandleCtx command.C: The default solver is the default set by the user preferences.Q: When queried, this flag returns a string."
            }, 
            "stickyH": {
                "docstring": "Specifies if the ikHandle is sticky or not. Valid strings are \"sticky\" and \"off\".C: The default is \"off\".Q: When queried, this flag returns a string."
            }, 
            "twistType": {
                "docstring": "Specifies the type of interpolation to be used by the ikSplineHandle. This flag is ignored in the ikHandleCtx. The interpolation options are \"linear\", \"easeIn\", \"easeOut\", and \"easeInOut\".C: The default is \"linear\".Q: When queried, this flag returns a string."
            }, 
            "weightH": {
                "docstring": "Specifies the weight of the ikHandle.C: The default is 1.Q: When queried, this flag returns a float."
            }
        }
    }, 
    "ikHandleDisplayScale": {
        "description": "This action modifies and queries the current display size of ikHandle. The default display scale is 1.0. In query mode, return type is based on queried flag.", 
        "flags": {
            "query": {
                "docstring": ""
            }
        }
    }, 
    "ikSolver": {
        "description": "The ikSolver command is used to set the attributes for an IK Solver or create a new one. The standard edit (-e) and query (-q) flags are used for edit and query functions. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "epsilon": {
                "docstring": "max error"
            }, 
            "maxIterations": {
                "docstring": "Sets the max iterations for a solution"
            }, 
            "name": {
                "docstring": "Name of solver"
            }, 
            "query": {
                "docstring": ""
            }, 
            "solverType": {
                "docstring": "valid solverType (only ikSystem knows what is valid) for creation of a new solver (required)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "ikSplineHandleCtx": {
        "description": "The ikSplineHandle context command (ikSplineHandleCtx) updates parameters of ikSplineHandle tool. The options for the tool will be set to the flags the user specifies. ", 
        "flags": {
            "autoPriorityH": {
                "docstring": "Specifies that this handle's priority is assigned automatically.C: The default is off.Q: When queried, this flag returns an int."
            }, 
            "createCurve": {
                "docstring": "Specifies if a curve should be automatically created for the ikSplineHandle.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "createRootAxis": {
                "docstring": "Specifies if a root transform should automatically be created above the joints affected by the ikSplineHandle. This option is used to prevent the root flipping singularity on a motion path.C: The default is off.Q: When queried, this flag returns an int."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "forceSolverH": {
                "docstring": "Specifies if the ikSolver is enabled for the ikHandle.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "numSpans": {
                "docstring": "Specifies the number of spans in the automatically generated curve of the ikSplineHandle.C: The default is 1.Q: When queried, this flag returns an int."
            }, 
            "parentCurve": {
                "docstring": "Specifies if the curve should automatically be parented to the parent of the first joint affected by the ikSplineHandle.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "poWeightH": {
                "docstring": "Specifies the position/orientation weight of the ikHandle.C: The default is 1.Q: When queried, this flag returns a float."
            }, 
            "priorityH": {
                "docstring": "Specifies the priority of the ikHandle.C: The default is 1.Q: When queried, this flag returns an int."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rootOnCurve": {
                "docstring": "Specifies if the root is locked onto the curve of the ikSplineHandle.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "rootTwistMode": {
                "docstring": "Specifies whether the start joint is allowed to twist or not. If not, then the required twist is distributed over the remaining joints. This applies to all the twist types. C: The default is off.Q: When queried, this flag returns an int.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "simplifyCurve": {
                "docstring": "Specifies if the ikSplineHandle curve should be simplified.C: The default is on.Q: When queried, this returns an int."
            }, 
            "snapCurve": {
                "docstring": "Specifies if the curve should automatically snap to the first joint affected by the ikSplineHandle.C: The default is off.Q: When queried, this flag returns an int."
            }, 
            "snapHandleH": {
                "docstring": "Specifies if the ikHandle snapping is on. This flag is ignored for the ikSplineSolver.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "solverTypeH": {
                "docstring": "Lists what ikSolver is being used. For the ikSplineContext the solver can only be the ikSplineSolver and this flag is ignored.C: The default solver is the ikSplineSolver.Q: When queried, this flag returns a string."
            }, 
            "stickyH": {
                "docstring": "Specifies if the ikHandle is sticky or not. Valid strings are \"sticky\" and \"off\". This flag is ignored for the ikSplineSolver.C: The default is \"off\".Q: When queried, this flag returns a string."
            }, 
            "twistType": {
                "docstring": "Specifies the type of interpolation to be used by the ikSplineHandle.The interpolation options are \"linear\", \"easeIn\", \"easeOut\", and \"easeInOut\".C: The default is \"linear\".Q: When queried, this flag returns a string."
            }, 
            "weightH": {
                "docstring": "Specifies the weight of the ikHandle. This flag is ignored in the ikSplineHandleCtx.C: The default is 1.Q: When queried, this flag returns a float."
            }
        }
    }, 
    "ikSystem": {
        "description": "The ikSystem command is used to set the global snapping flag for handles and set the global solve flag for solvers. The standard edit (-e) and query (-q) flags are used for edit and query functions. ", 
        "flags": {
            "allowRotation": {
                "docstring": "Set true to allow rotation of an ik handle with keys set on translation.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "autoPriority": {
                "docstring": "set autoPriority for all ikHandles"
            }, 
            "autoPriorityMC": {
                "docstring": "set autoPriority for all multiChain handles"
            }, 
            "autoPrioritySC": {
                "docstring": "set autoPriority for all singleChain handles"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "list": {
                "docstring": "returns the solver execution order when in query mode(list of strings) changes execution order when in edit mode (int old position, int new position)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "snap": {
                "docstring": "Set global snapping"
            }, 
            "solve": {
                "docstring": "Set global solve"
            }, 
            "solverTypes": {
                "docstring": "returns a list of valid solverTypes ( query only )"
            }
        }
    }, 
    "ikSystemInfo": {
        "description": "This action modifies and queries the current ikSystem controls. In query mode, return type is based on queried flag.", 
        "flags": {
            "globalSnapHandle": {
                "docstring": "If this flag is off, all ikHandles will not be snapped.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "ikfkDisplayMethod": {
        "description": "The ikfkDisplayMethodcommand is used to specify how ik/fk blending should be shown In query mode, return type is based on queried flag.", 
        "flags": {
            "display": {
                "docstring": "Specify how ik/fk blending should be shown when the handle is selected. Possible choices are \"none\" (do not display any blending), \"ik\" (only show ik),\"fk\" (only show fk), and \"ikfk\" (show both ik and fk).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "illustratorCurves": {
        "description": "The illustratorCurves command creates NURBS curves from an input Adobe(R) Illustrator(R) file ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or offFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "illustratorFilename": {
                "docstring": "Input Adobe(R) Illustrator(R) file name"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result shapes, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "scaleFactor": {
                "docstring": "The scale factor"
            }, 
            "tolerance": {
                "docstring": ""
            }
        }
    }, 
    "image": {
        "description": "This command creates a static image for non-xpm files. Any image file format supported by the file texture node is supported by this command. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "image": {
                "docstring": "Sets the image given the file name.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "imagePlane": {
        "description": "The imagePlane command allows querying of various properties of an image plane and any movie in use by the image plane. The object passed to the command may either be an imagePlane node, or a camera, in which case the command uses the image plane attached to the camera (if any). If no object is passed in, the current selection is used. Currently, most queries work only on 64 bit Windows systems. ", 
        "flags": {
            "counter": {
                "docstring": "Query the 'counter' flag of the movie's timecode format. If this is true, the timecode returned by the -timeCode flag will be a simple counter. If false, the returned timecode will be an array of integers (hours, minutes, seconds, frames)."
            }, 
            "dropFrame": {
                "docstring": "Query the 'drop frame' flag of the movie's timecode format."
            }, 
            "frameDuration": {
                "docstring": "Query the frame duration of the movie's timecode format."
            }, 
            "negTimesOK": {
                "docstring": "Query the 'neg times OK' flag of the movie's timecode format."
            }, 
            "numFrames": {
                "docstring": "Query the whole number of frames per second of the movie's timecode format."
            }, 
            "query": {
                "docstring": ""
            }, 
            "quickTime": {
                "docstring": "Query whether the image plane is using a QuickTime movie."
            }, 
            "timeCode": {
                "docstring": "Query the timecode of the current movie frame.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "timeCodeTrack": {
                "docstring": "Query whether the movie on the image plane has a timecode track."
            }, 
            "timeScale": {
                "docstring": "Query the timescale of the movie's timecode format."
            }, 
            "twentyFourHourMax": {
                "docstring": "Query the '24 hour max' flag of the movie's timecode format."
            }
        }
    }, 
    "imageWindowEditor": {
        "description": "", 
        "flags": {
            "autoResize": {
                "docstring": ""
            }, 
            "changeCommand": {
                "docstring": ""
            }, 
            "clear": {
                "docstring": ""
            }, 
            "control": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "displayImage": {
                "docstring": ""
            }, 
            "displayStyle": {
                "docstring": ""
            }, 
            "docTag": {
                "docstring": ""
            }, 
            "doubleBuffer": {
                "docstring": ""
            }, 
            "drawAxis": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "filter": {
                "docstring": ""
            }, 
            "forceMainConnection": {
                "docstring": ""
            }, 
            "frameImage": {
                "docstring": ""
            }, 
            "frameRegion": {
                "docstring": ""
            }, 
            "highlightConnection": {
                "docstring": ""
            }, 
            "loadImage": {
                "docstring": ""
            }, 
            "lockMainConnection": {
                "docstring": ""
            }, 
            "mainListConnection": {
                "docstring": ""
            }, 
            "marquee": {
                "docstring": ""
            }, 
            "nbImages": {
                "docstring": ""
            }, 
            "panel": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "realSize": {
                "docstring": ""
            }, 
            "removeAllImages": {
                "docstring": ""
            }, 
            "removeImage": {
                "docstring": ""
            }, 
            "saveImage": {
                "docstring": ""
            }, 
            "scaleBlue": {
                "docstring": ""
            }, 
            "scaleGreen": {
                "docstring": ""
            }, 
            "scaleRed": {
                "docstring": ""
            }, 
            "selectionConnection": {
                "docstring": ""
            }, 
            "showRegion": {
                "docstring": ""
            }, 
            "singleBuffer": {
                "docstring": ""
            }, 
            "stateString": {
                "docstring": ""
            }, 
            "toggle": {
                "docstring": ""
            }, 
            "unParent": {
                "docstring": ""
            }, 
            "unlockMainConnection": {
                "docstring": ""
            }, 
            "updateMainConnection": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": ""
            }, 
            "writeImage": {
                "docstring": ""
            }
        }
    }, 
    "imfPlugins": {
        "description": "This command queries all the available imf plugins for its name, keyword or image file extension. Only one of the attributes (name, keyword or extension) can be queried at a time. If no flags are specified, this command returns a list of all available plugin names. ", 
        "flags": {
            "extension": {
                "docstring": "image file extension"
            }, 
            "keyword": {
                "docstring": "imf keyword"
            }, 
            "multiFrameSupport": {
                "docstring": "multi frame IO is supportedFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pluginName": {
                "docstring": "imf plugin name"
            }, 
            "query": {
                "docstring": ""
            }, 
            "readSupport": {
                "docstring": "read operation is supported"
            }, 
            "writeSupport": {
                "docstring": "write operation is supported"
            }
        }
    }, 
    "inheritTransform": {
        "description": "This command toggles the inherit state of an object. If this flag is off the object will not inherit transformations from its parent. In other words transformations applied to the parent node will not affect the object and it will act as though it is under the world. If the -p flag is specified then the object's transformation will be modified to compensate when changing the inherit flag so the object will not change its world-space location. In query mode, return type is based on queried flag.", 
        "flags": {
            "off": {
                "docstring": ""
            }, 
            "on": {
                "docstring": ""
            }, 
            "preserve": {
                "docstring": "preserve the objects world-space position by modifying the object(s) transformation matrix.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "toggle": {
                "docstring": "toggle the inherit state for the given object(s) (default if no flags are given) -on turn on inherit state for the given object(s) -off turn off inherit state for the given object(s)"
            }
        }
    }, 
    "insertJoint": {
        "description": "This command will insert a new joint under the given or selected joint. If the given joint has child joints, they will be reparented under the new inserted joint. The given joint(or selected joint) should not have skin attached. The command works on the selected joint. No options or flags are necessary. ", 
        "flags": {}
    }, 
    "insertJointCtx": {
        "description": "The command will create an insert joint context. The insert joint tool inserts joints into an existing chain of joints. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "insertKeyCtx": {
        "description": "This command creates a context which may be used to insert keys within the graph editor ", 
        "flags": {
            "breakdown": {
                "docstring": "Specifies whether or not to create breakdown keysFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "insertKnotCurve": {
        "description": "The insertKnotCurve command inserts knots into a curve given a list of parameter values. The number of knots to add at each parameter value and whether the knots are added or complemented can be specified. The name of the curve is returned. If construction history is on, the name of the resulting dependency node is also returned. An edit point will appear where you insert the knot. Also, the number of spans and CVs in the curve will increase in the area where the knot is inserted. You can insert up to \"degree\" knots at a curve parameter that isn't already an edit point. eg. for a degree three curve, you can insert up to 3 knots. Use this operation if you need more CVs in a local area of the curve. Use this operation (or \"hardenPoint\") if you want to create a corner in a curve. ", 
        "flags": {
            "addKnots": {
                "docstring": "Whether to add knots or complement. Complement means knots will be added to reach the specified number of knots.Default:true"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curveOnSurface": {
                "docstring": "If possible, create 2D curve as a resultFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "insertBetween": {
                "docstring": "If set to true, and there is more than one parameter value specified, the knots will get inserted at equally spaced intervals between the given parameter values, rather than at the parameter values themselves.Default:falseAdvanced flags"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "numberOfKnots": {
                "docstring": "How many knots to insert. At any point on the curve, there can be a maximum of \"degree\" knots.Default:1"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameter": {
                "docstring": "Parameter value(s) where knots are addedDefault:0.0"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)"
            }
        }
    }, 
    "insertKnotSurface": {
        "description": "The insertKnotSurface command inserts knots (aka isoparms) into a surface given a list of parameter values. The number of knots to add at each parameter value and whether the knots are added or complemented can be specified. The name of the surface is returned and if history is on, the name of the resulting dependency node is also returned. You must specify one, none or all number of knots with the \"-nk\" flag. eg. if you specify none, then the default (one) knot will be added at each specified parameter value. If you specify one \"-nk\" value then that number of knots will be added at each parameter value. Otherwise, you must specify the same number of \"-nk\" flags as \"-p\" flags, defining the number of knots to be added at each specified parameter value. You can insert up to \"degree\" knots at a parameter value that isn't already an isoparm. eg. for a degree 3 surface, you can insert up to 3 knots. Use this operation if you need more CVs in a local area of the surface. Use this operation if you want to create a corner in the surface. Note: A single insertKnotSurface command cannot insert in both directions at once; you must use two separate commands to do this. ", 
        "flags": {
            "addKnots": {
                "docstring": "Whether to add knots or complement. Complement means knots will be added to reach the specified number of knots.Default:true"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "direction": {
                "docstring": "Direction in which to insert knot: 0 - V direction, 1 - U directionDefault:1Advanced flags"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "insertBetween": {
                "docstring": "If set to true, and there is more than one parameter value specified, the knots will get inserted at equally spaced intervals between the given parameter values, rather than at the parameter values themselves.Default:false"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "numberOfKnots": {
                "docstring": "How many knots to insertDefault:1"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameter": {
                "docstring": "Parameter value(s) where knots are addedDefault:0.0"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "instance": {
        "description": "Instancing is a way of making the same object appear twice in the scene. This is accomplished by creation of a new transform node that points to an exisiting object. Changes to the transform are independent but changes to the \"instanced\" object affect all instances since the node is shared. If no objects are given, then the selected list is instanced. When an object is instanced a new transform node is created that points to the selected object. The smart transform feature allows instance to transform newly instanced objects based on previous transformations between instances. Example: Instance an object and move it to a new location. Instance it again with the smart transform flag. It should have moved once again the distance you had previously moved it. Note: changing the selected list between smart instances will cause the transform information to be deleted. It returns a list of the new objects created by the instance operation. See also:duplicate ", 
        "flags": {
            "leaf": {
                "docstring": "Instances leaf-level objects. Acts like duplicate except leaf-level objects are instanced."
            }, 
            "name": {
                "docstring": "Name to give new instanceFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "smartTransform": {
                "docstring": "Transforms instances item based on movements between transforms"
            }
        }
    }, 
    "instanceable": {
        "description": "Flags one or more DAG nodes so that they can (or cannot) be instanced. This command sets an internal state on the specified DAG nodes which is checked whenever Maya attempts an instancing operation. If no node names are provided on the command line then the current selection list is used. Sets are automatically expanded to their constituent objects. Nodes which are already instanced (or have children which are already instanced) cannot be marked as non-instancable. ", 
        "flags": {
            "allow": {
                "docstring": "Specifies the new instanceable state for the node. Specify true to allow the node to be instanceable, and false to prevent it from being instanced. The default is true (i.e. nodes can be instanced by default)."
            }, 
            "query": {
                "docstring": ""
            }, 
            "recursive": {
                "docstring": "Can be specified with the -allow flag in create or edit mode to recursively apply the -allow setting to all non-shape children of the selected node(s). To also affect shapes, also specify the -shape flag along with -recursive."
            }, 
            "shape": {
                "docstring": "Can be specified with the -allow flag in create or edit mode to apply the -allow setting to all shape children of the selected node(s). This flag can be specified in conjunction with the -recursive flag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "instancer": {
        "description": "This command is used to create a instancer node and set the proper attributes in the node. ", 
        "flags": {
            "addObject": {
                "docstring": "This flag indicates that objects specified by the -object flag will be added to the instancer node as instanced objects."
            }, 
            "cycle": {
                "docstring": "This flag sets or queries the cycle attribute for the instancer node. The options are \"none\" or \"sequential\". The default is \"none\"."
            }, 
            "cycleStep": {
                "docstring": "This flag sets or queries the cycle step attribute for the instancer node. This attribute indicates the size of the step in frames or seconds (see cycleStepUnit)."
            }, 
            "cycleStepUnits": {
                "docstring": "This flag sets or queries the cycle step unit attribute for the instancer node. The options are \"frames\" or \"seconds\". The default is \"frames\"."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "index": {
                "docstring": "This flag is used to query the name of the ith instanced object."
            }, 
            "levelOfDetail": {
                "docstring": "This flag sets or queries the level of detail of the instanced objects. The options are \"geometry\", \"boundingBox\", \"boundingBoxes\". The default is \"geometry\"."
            }, 
            "name": {
                "docstring": "This flag sets or queries the name of the instancer node."
            }, 
            "object": {
                "docstring": "This flag indicates which objects will be add/removed from the list of instanced objects. The flag is used in conjuction with the -add and -remove flags. If neither of these flags is specified on the command line then -add is assumed."
            }, 
            "objectPosition": {
                "docstring": "This flag queries the given objects position. This object can be any instanced object or sub-object."
            }, 
            "objectRotation": {
                "docstring": "This flag queries the given objects rotation. This object can be any instanced object or sub-object."
            }, 
            "objectScale": {
                "docstring": "This flag queries the given objects scale. This object can be any instanced object or sub-object."
            }, 
            "pointDataSource": {
                "docstring": "This flag is used to query the source node supply the data for the input points.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeObject": {
                "docstring": "This flag indicates that objects specified by the -object flag will be removed from the instancer node as instanced objects."
            }, 
            "rotationOrder": {
                "docstring": "This flag specifies the rotation order associated with the rotation flag. The options are XYZ, XZY, YXZ, YZX, ZXY, or ZYX. By default the attribute is XYZ."
            }, 
            "rotationUnits": {
                "docstring": "This flag specifies the rotation units associated with the rotation flag. The options are degrees or radians. By default the attribute is degrees."
            }, 
            "valueName": {
                "docstring": "This flag is used to query the value(s) of the array associated with the given name. If the -index flag is used in conjuction with this flag then the ith value will be returned. Otherwise, the entire array will be returned."
            }
        }
    }, 
    "intField": {
        "description": "Create a field control that accepts only integer values and is bound by a minimum and maximum value. An invisible slider is attached to the field and accessed by holding down the Ctrl modifier key while pressing one of the mouse buttons. Dragging the invisible slider to the right with the middle mouse button increases the field value by the amount specified with the -s/stepflag, while dragging to the left decreases the value by the same amount. The left and right mouse buttons apply a factor of 0.1 and 10 to the step value. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the value changes. This command is not invoked when the value changes via the -v/valueflag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command executed when the value changes by dragging the invisible slider."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "The edit state of the field. By default, this flag is set to true and the field value may be changed by typing into it. If false then the field is 'read only' and can not be typed into. The value of the field can always be changed with the -v/valueflag regardless of the state of the -ed/editableflag."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enterCommand": {
                "docstring": "Command executed when the keypad 'Enter' key is pressed."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Upper limit of the field."
            }, 
            "minValue": {
                "docstring": "Lower limit of the field."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "receiveFocusCommand": {
                "docstring": "Command executed when the field receives focus.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "step": {
                "docstring": "Increment for the invisible slider. The field value will change by this amount when the invisible slider is dragged."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Value of the field."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "intFieldGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a pre-packaged collection of label text and editable integer fields. The label text is optional and one to four fields can be created. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command string executed when the value of any of the fields changes."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command string executed when dragging the invisible slider in any of the fields."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enable1": {
                "docstring": ""
            }, 
            "enable2": {
                "docstring": ""
            }, 
            "enable3": {
                "docstring": ""
            }, 
            "enable4": {
                "docstring": "Enable state for the respective field.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "extraLabel": {
                "docstring": "If present on creation this specifies that there will be an extra label in the group. Sets the string to be label text to the right of fields."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "If present on creation this specifies that there will be a label to the left of the fields. Sets the string to be the label text."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfFields": {
                "docstring": "Set the number of fields on creation. One to four fields are available. The default is one field."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Values for all fields."
            }, 
            "value1": {
                "docstring": ""
            }, 
            "value2": {
                "docstring": ""
            }, 
            "value3": {
                "docstring": ""
            }, 
            "value4": {
                "docstring": "Value for the respective field."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "intScrollBar": {
        "description": "Create a scroll bar control that accepts only integer values and is bound by a minimum and maximum value. The scroll bar displays a marker indicating the current value of the scroll bar relative to it's minimum and maximum values. Click and drag the marker or on the scroll bar itself to change the current value. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the value changes. This command is not invoked when the value changes via the -v/value flag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command executed when the value changes by dragging the scroll bar's value marker.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "horizontal": {
                "docstring": "Orientation of the scroll bar. This flag is true by default which corresponds to a horizontally oriented scroll bar."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "largeStep": {
                "docstring": "Larger increment for the scroll bar, ie. the increment used when the press is between the arrow button and the thumb."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Upper limit of the scroll bar."
            }, 
            "minValue": {
                "docstring": "Lower limit of the scroll bar."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "step": {
                "docstring": "Smaller increment for the scroll bar, ie. the increment used when the arrow buttons are pressed."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Value of the scroll bar."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "intSlider": {
        "description": "Create a slider control that accepts only integer values and is bound by a minimum and maximum value. The slider displays a marker indicating the current value of the slider relative to it's minimum and maximum values. Click and drag the marker or on the slider itself to change the current value. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the value changes. This command is not invoked when the value changes via the -v/value flag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "Command executed when the value changes by dragging the slider's value marker.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "horizontal": {
                "docstring": "Orientation of the slider. This flag is true by default which corresponds to a horizontally oriented slider."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Upper limit of the slider."
            }, 
            "minValue": {
                "docstring": "Lower limit of the slider."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "step": {
                "docstring": "The step value represents the amount the value will increase or decrease when you click either side of the slider."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Value of the slider."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "intSliderGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a pre-packaged collection of controls containing a label text, an integer field and an integer slider. The text and field controls are optional. Editing or querying the field range values has no effect if the -f/fieldflag was not specified when the group was created. This group also allows you to enter values into the field outside of the slider range which is limited by the -min/minValueand -max/maxValueflags. To do this, use the -fmn/fieldMinValueand -fmx/fieldMaxValueflags to specify a greater range of values. Note that the command will not allow you to specify a -fmn/fieldMinValuegreater than the -min/minValuevalue nor a -fmx/fieldMaxValueless than the -max/maxValuevalue. If you do supply a larger field range with the -fmn/fieldMinValueand -fmx/fieldMaxValueflags then you will notice that entering a value in the field that is outside of the slider range will result in extending the slider range as well. For example, if you create a slider group with the following command: intSliderGrp -min -10 -max 10 -fieldMinValue -100 -fieldMaxValue 100; Then you will be able to use the slider to select any value from -10 to 10. At the same time you will be able to enter into the field any value from -100 to 100. If you enter a value, say 20, then the new slider range will grow such that this value is now accessible through the slider as well. In fact, the new slider limit will become double of that what you entered. Note that the slider limits will never grow beyond the field limits, in other words if you entered the value 80 then the slider will be clipped to the field limit of 100 and not doubled to 160. TelfBaseGrpCmd.cpp ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "The command string executed when the value of the slider changes. It will be executed only once after a drag of the slider."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dragCommand": {
                "docstring": "The command string executed repeatedly during a drag of the slider."
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "extraLabel": {
                "docstring": "If present on creation this specifies that there will be an extra label appearing after the slider. Sets the string to be the text for the extra label."
            }, 
            "field": {
                "docstring": "If true on creation the group will have an editable int field present that reflects the value of the slider."
            }, 
            "fieldMaxValue": {
                "docstring": "Maximum value that may be entered in the field. This value may be set to any value greater than the -max/maxValueflag. By default, it is equal to the -max/maxValueflag."
            }, 
            "fieldMinValue": {
                "docstring": "Minimum value that may be entered in the field. This value may be set to any value less than the -min/minValueflag. By default, it is equal to the -min/minValueflag."
            }, 
            "fieldStep": {
                "docstring": "Increment for the field."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "If present on creation the group will have static text. Returns a string on query."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "Sets the maximum value for both the slider and the field."
            }, 
            "minValue": {
                "docstring": "Sets the minimum value for both the slider and the field."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "sliderStep": {
                "docstring": "On Linux the slider step value represents the amount the value will increase or decrease when you click either side of the slider."
            }, 
            "step": {
                "docstring": "Increment for both the slider and field."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Value of the group.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "interactionStyle": {
        "description": "", 
        "flags": {
            "query": {
                "docstring": ""
            }, 
            "style": {
                "docstring": ""
            }
        }
    }, 
    "internalVar": {
        "description": "This command returns the values of internal variables. No modification of these variables is supported. ", 
        "flags": {
            "userAppDir": {
                "docstring": "Return the user application directory."
            }, 
            "userBitmapsDir": {
                "docstring": "Return the user bitmaps prefs directory."
            }, 
            "userMarkingMenuDir": {
                "docstring": "Return the user marking menu directory."
            }, 
            "userPrefDir": {
                "docstring": "Return the user preference directory."
            }, 
            "userPresetsDir": {
                "docstring": "Return the user presets directory."
            }, 
            "userScriptDir": {
                "docstring": "Return the user script directory."
            }, 
            "userShelfDir": {
                "docstring": "Return the user shelves directory."
            }, 
            "userTmpDir": {
                "docstring": "Return a temp directory. Will check for TMPDIR environment variable, otherwise will return the current directory."
            }, 
            "userWorkspaceDir": {
                "docstring": "Return the user workspace directory (also known as the projects directory).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "intersect": {
        "description": "The intersect command creates a curve on surface where all surfaces intersect with each other. By default, the curve on surface is created for both surfaces. However, by using the -fs flag, only the first surface will have a curve on surface. Also, the intersection curve can be created as a 3D curve rather than a curve on surface. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curveOnSurface": {
                "docstring": "If possible, create 2D curve as a resultFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "firstSurface": {
                "docstring": "creates a curve-on-surface on the first surface only or on all surfaces (default)"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": "Tolerance to fit to.Default:0.01Advanced flags"
            }
        }
    }, 
    "iprEngine": {
        "description": "Command to create or edit an iprEngine. A iprEngine is an object that watches for changes to shading networks and automatically reshades to generate an up-to-date image. ", 
        "flags": {
            "copy": {
                "docstring": "Copies the deep raster file, as well as its related files, to the new location.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "diagnostics": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "estimatedMemory": {
                "docstring": "Displays the estimated memory being used by IPR."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "iprImage": {
                "docstring": "Specify the ipr image to use."
            }, 
            "motionVectorFile": {
                "docstring": "Returns the name of the motion vector file used by IPR."
            }, 
            "object": {
                "docstring": "The objects to be tuned."
            }, 
            "query": {
                "docstring": ""
            }, 
            "region": {
                "docstring": "The coordinates of the region to be tuned. The integers are in the sequence left bottom right topor x1,y2 x2,y2"
            }, 
            "relatedFiles": {
                "docstring": "Returns the names for the related files, e.g, the non-glow-non-blur image, the motion vector file, and the depth-map files."
            }, 
            "releaseIprImage": {
                "docstring": "The ipr image should be released and memory should be freed."
            }, 
            "resolution": {
                "docstring": "The width and height of the ipr file."
            }, 
            "scanlineIncrement": {
                "docstring": "Set the scanline increment percentage. If the height of the region being update is 240 pixels, and the scanlineIncrement is 10% then the image will refresh blocks of 24 scanlines."
            }, 
            "showProgressBar": {
                "docstring": "Show progress bar during tuning."
            }, 
            "startTuning": {
                "docstring": "An ipr image has been specified and now changes to shading networks should force an image to be produced."
            }, 
            "stopTuning": {
                "docstring": "Tuning should cease but ipr image should not be closed."
            }, 
            "underPixel": {
                "docstring": "Get list of objects under the pixel sprcified."
            }, 
            "update": {
                "docstring": "Force an update."
            }, 
            "updateDepthOfField": {
                "docstring": "Force a refresh of depth-of-field."
            }, 
            "updateLightGlow": {
                "docstring": "Automatically update when light glow changes."
            }, 
            "updateMotionBlur": {
                "docstring": "Automatically update when 2.5D motion blur changes."
            }, 
            "updatePort": {
                "docstring": "The name of the port that is to be updated when pixel values are recomputed. (not currently supported)"
            }, 
            "updateShaderGlow": {
                "docstring": "Automatically update when shader glow changes."
            }, 
            "updateShading": {
                "docstring": "Automatically update shading."
            }, 
            "updateShadowMaps": {
                "docstring": "Force the shadow maps to be generated and an update to occur."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "isConnected": {
        "description": "The isConnectedcommand is used to check if two plugs are connected in the dependency graph. The return value is falseif they are not and trueif they are.The first string specifies the source plug to check for connection.The second one specifies the destination plug to check for connection. ", 
        "flags": {
            "ignoreUnitConversion": {
                "docstring": "In looking for connections, skip past unit conversion nodes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "isDirty": {
        "description": "The isDirtycommand is used to check if a plug is dirty. The return value is 0 if it is not and 1 if it is. If more than one plug is specified then the result is the logical \"or\" of all objects (ie. returns 1 if \\*any\\* of the plugs are dirty). ", 
        "flags": {
            "connection": {
                "docstring": "Check the connection of the plug (default).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "datablock": {
                "docstring": "Check the datablock entry for the plug."
            }
        }
    }, 
    "isTrue": {
        "description": "This commmand returns the state of the named condition. If the condition is true, it returns 1. Otherwise it returns 0. ", 
        "flags": {}
    }, 
    "isolateSelect": {
        "description": "This command turns on/off isolate select mode in a specified modeling view, specified as the argument. Isolate select mode is a display mode where the currently selected objects are added to a list and only those objects are displayed in the view. It allows for selective viewing of specific objects and object components. ", 
        "flags": {
            "addDagObject": {
                "docstring": "Add the specified object to the set of objects to be displayed in the view."
            }, 
            "addSelected": {
                "docstring": "Add the currently active objects to the set of objects to be displayed in the view."
            }, 
            "loadSelected": {
                "docstring": "Replace the objects being displayed with the currently active objects."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeSelected": {
                "docstring": "Remove the currently active objects to the set of objects to be displayed in the view."
            }, 
            "state": {
                "docstring": "Turns isolate select mode on/off."
            }, 
            "update": {
                "docstring": "Update the view's list of objects due to a change to the set of objects to be displayed.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "viewObjects": {
                "docstring": "Returns the name (if any) of the objectSet which contains the list of objects visible in the view if isolate select mode is on. If isolate select mode is off, an empty string is returned."
            }
        }
    }, 
    "itemFilter": {
        "description": "This command creates a named itemFilter object. This object can be attached to selectionConnection objects, or to editors, in order to filter the item lists going through them. Using union, intersection and difference filters, complex composite filters can be created. ", 
        "flags": {
            "byBin": {
                "docstring": "The filter will only pass items whose bin list contains the given string as a bin name.This is a multi-use flag.If more than one occurance of this flag is used in a single command, the filter will accept a node if it matches at least one of the given bins (in other words, a union or logical or of all given bins."
            }, 
            "byName": {
                "docstring": "The filter will only pass items whose names match the given regular expression string. This string can contain the special characters \\* and ?. '?' matches any one character, and '\\*' matches any substring."
            }, 
            "byScript": {
                "docstring": "The filter will run a MEL script named by the given string on each item name. Items will pass the filter if the script returns a non-zero value. The script name string must be the name of a proc whose signature is:global proc int procName( string $name )Note that if -secondScript is also used, it will always take precidence."
            }, 
            "byType": {
                "docstring": "The filter will only pass items whose typeName matches the given string. The typeName of an object can be found using the nodeTypecommand. This is a multi-use flag. If more than one occurance of this flag is used in a single command, the filter will accept a node if it matches at least one of the given types (in other words, a union or logical or of all given types."
            }, 
            "category": {
                "docstring": "A string for categorizing the filter."
            }, 
            "classification": {
                "docstring": "Internal use only. Indicates whether the filter is a built-in or user filter. The string argument is one of \"builtIn\" | \"user\" | \"other\"."
            }, 
            "clearByBin": {
                "docstring": "This flag will clear any existing bins associated with this filter."
            }, 
            "clearByType": {
                "docstring": "This flag will clear any existing typeNames associated with this filter."
            }, 
            "difference": {
                "docstring": "The filter will consist of the set difference of two other filters, whose names are the given strings. Items will pass this filter if and only if they pass the first filter but not the second filter."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "intersect": {
                "docstring": "The filter will consist of the intersection of two other filters, whose names are the given strings. Items will pass this filter if and only if they pass both of the contained filters."
            }, 
            "listBuiltInFilters": {
                "docstring": "Returns an array of all item filters with classification \"builtIn\"."
            }, 
            "listOtherFilters": {
                "docstring": "Returns an array of all item filters with classification \"other\"."
            }, 
            "listUserFilters": {
                "docstring": "Returns an array of all item filters with classification \"user\"."
            }, 
            "negate": {
                "docstring": "This flag can be used to cause the filter to invert itself, and reverse what passes and what fails."
            }, 
            "parent": {
                "docstring": "Optional. If specified, the filter's life-span is linked to that of the parent. When the parent goes out of scope, so does the filter. If not specified, the filter will exist until explicitly deleted."
            }, 
            "query": {
                "docstring": ""
            }, 
            "secondScript": {
                "docstring": "Can be used in conjunction with the -bs flag. The second script is for filtering whole lists at once, rather than individually. Its signature must be:global proc string[] procName( string[] $name )It should take in a list of items, and return a filtered list of items."
            }, 
            "text": {
                "docstring": "Defines an annotation string to be stored with the filter"
            }, 
            "union": {
                "docstring": "The filter will consist of the union of two other filters, whose names are the given strings. Items will pass this filter if they pass at least one of the contained filters."
            }, 
            "uniqueNodeNames": {
                "docstring": "Returns unique node names to script filters so there are no naming conflicts.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "itemFilterAttr": {
        "description": "This command creates a named itemFilterAttr object. This object can be attached to editors, in order to filter the attributes going through them. Using union and intersection filters, complex composite filters can be created. ", 
        "flags": {
            "byName": {
                "docstring": "The filter will only pass items whose names match the given regular expression string. This string can contain the special characters \\* and ?. '?' matches any one character, and '\\*' matches any substring."
            }, 
            "byNameString": {
                "docstring": "The filter will only pass items whose names match the given string. This is a multi-use flag which allows the user to specify several strings. The filter will pass items that match any of the strings."
            }, 
            "byScript": {
                "docstring": "The filter will run a MEL script named by the given string on each attribute name. Attributes will pass the filter if the script returns a non-zero value. The script name string must be the name of a proc whose signature is:global proc int procName( string $nodeName string $attrName )"
            }, 
            "classification": {
                "docstring": "Internal use only. Indicates whether the filter is a built-in or user filter. The string argument is one of \"builtIn\" | \"user\" | \"other\"."
            }, 
            "dynamic": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "hasCurve": {
                "docstring": "The filter will only pass attributes that are driven by animation curves."
            }, 
            "hasDrivenKey": {
                "docstring": "The filter will only pass attributes that are driven by driven keys"
            }, 
            "hasExpression": {
                "docstring": "The filter will only pass attributes that are driven by expressions"
            }, 
            "hidden": {
                "docstring": "The filter will only pass attributes that are hidden to the user"
            }, 
            "intersect": {
                "docstring": "The filter will consist of the intersection of two other filters, whose names are the given strings. Attributes will pass this filter if and only if they pass both of the contained filters."
            }, 
            "keyable": {
                "docstring": "The filter will only pass attributes that are keyable"
            }, 
            "listBuiltInFilters": {
                "docstring": "Returns an array of all attribute filters with classification \"builtIn\"."
            }, 
            "listOtherFilters": {
                "docstring": "Returns an array of all attribute filters with classification \"other\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "listUserFilters": {
                "docstring": "Returns an array of all attribute filters with classification \"user\"."
            }, 
            "negate": {
                "docstring": "This flag can be used to cause the filter to invert itself, and reverse what passes and what fails."
            }, 
            "parent": {
                "docstring": "This flag is no longer supported."
            }, 
            "published": {
                "docstring": "The filter will only pass attributes that are published on the container."
            }, 
            "query": {
                "docstring": ""
            }, 
            "readable": {
                "docstring": "The filter will only pass attributes that are readable (outputs)"
            }, 
            "scaleRotateTranslate": {
                "docstring": "The filter will show only SRT attributes: scale, rotate, translate and their children"
            }, 
            "secondScript": {
                "docstring": "Can be used in conjunction with the -bs flag. The second script is for filtering whole lists at once, rather than individually. Its signature must be:global proc string[] procName( string[] $nodeName string[] $attrName )It should take in a list of attributes, and return a filtered list of attributes."
            }, 
            "text": {
                "docstring": "Defines an annotation string to be stored with the filter"
            }, 
            "union": {
                "docstring": "The filter will consist of the union of two other filters, whose names are the given strings. Attributes will pass this filter if they pass at least one of the contained filters."
            }, 
            "writable": {
                "docstring": "The filter will only pass attributes that are writable (inputs)"
            }
        }
    }, 
    "itemFilterAttrOld": {
        "description": "", 
        "flags": {
            "byName": {
                "docstring": ""
            }, 
            "byScript": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "hasCurve": {
                "docstring": ""
            }, 
            "hasExpression": {
                "docstring": ""
            }, 
            "hidden": {
                "docstring": ""
            }, 
            "intersect": {
                "docstring": ""
            }, 
            "keyable": {
                "docstring": ""
            }, 
            "negate": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "readable": {
                "docstring": ""
            }, 
            "scaleRotateTranslate": {
                "docstring": ""
            }, 
            "secondScript": {
                "docstring": ""
            }, 
            "text": {
                "docstring": ""
            }, 
            "union": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": ""
            }, 
            "writable": {
                "docstring": ""
            }
        }
    }, 
    "itemFilterOld": {
        "description": "", 
        "flags": {
            "byName": {
                "docstring": ""
            }, 
            "byScript": {
                "docstring": ""
            }, 
            "byType": {
                "docstring": ""
            }, 
            "clearByType": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "intersect": {
                "docstring": ""
            }, 
            "negate": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "secondScript": {
                "docstring": ""
            }, 
            "text": {
                "docstring": ""
            }, 
            "union": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": ""
            }
        }
    }, 
    "itemFilterRender": {
        "description": "This command creates a named renderTypeFilter object. This object can be attached to selectionConnection objects, or to editors, in order to filter the renderType lists going through them. Using union and intersection filters, complex composite filters can be created. ", 
        "flags": {
            "anyTextures": {
                "docstring": "Pass texture objects if set to true. Value is false by default. To get all objects that are not textures then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "category": {
                "docstring": "A string for categorizing the filter."
            }, 
            "classification": {
                "docstring": "Internal use only. Indicates whether the filter is a built-in or user filter. The string argument is one of \"builtIn\" | \"user\" | \"other\"."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusiveLights": {
                "docstring": "Pass exclusive light objects if set to true. Value is false by default. To get all objects that are not exclusive lights then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "exists": {
                "docstring": ""
            }, 
            "lightSets": {
                "docstring": "Pass light set objects if set to true. Value is false by default. To get all objects that are not light sets then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "lights": {
                "docstring": "Pass light objects if set to true. Value is false by default. To get all objects that are not lights then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "linkedLights": {
                "docstring": "Pass linked light objects if set to true. Value is false by default. To get all objects that are not linked lights then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "listBuiltInFilters": {
                "docstring": "Returns an array of all item filters with classification \"builtIn\"."
            }, 
            "listOtherFilters": {
                "docstring": "Returns an array of all item filters with classification \"other\"."
            }, 
            "listUserFilters": {
                "docstring": "Returns an array of all item filters with classification \"user\"."
            }, 
            "negate": {
                "docstring": "This flag can be used to cause the filter to invert itself, and reverse what passes and what fails."
            }, 
            "nodeClassification": {
                "docstring": ""
            }, 
            "nonExclusiveLights": {
                "docstring": "Pass non-exclusive light objects if set to true. Value is false by default. To get all objects that are not non-exclusive lights then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "nonIlluminatingLights": {
                "docstring": "Pass non-illuminating light objects if set to true. Value is false by default. To get all objects that are not non-illuminating lights then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "parent": {
                "docstring": "Optional. If specified, the filter's life-span is linked to that of the parent. When the parent goes out of scope, so does the filter. If not specified, the filter will exist until explicitly deleted."
            }, 
            "postProcess": {
                "docstring": "Pass post process objects if set to true. Value is false by default. To get all objects that are not post processes then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "query": {
                "docstring": ""
            }, 
            "renderUtilityNode": {
                "docstring": "Pass render utility node objects if set to true. Value is false by default. To get all objects that are not render utility nodes then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "renderableObjectSets": {
                "docstring": "Pass renderable object sets if set to true. Value is false by default. To get all objects that are not renderable object sets then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "renderingNode": {
                "docstring": ""
            }, 
            "shaders": {
                "docstring": "Pass shader objects if set to true. Value is false by default. To get all objects that are not shaders then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "text": {
                "docstring": "Defines an annotation string to be stored with the filter"
            }, 
            "textures2d": {
                "docstring": "Pass 2D texture objects if set to true. Value is false by default. To get all objects that are not 2D textures then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "textures3d": {
                "docstring": "Pass 3D texture objects if set to true. Value is false by default. To get all objects that are not 3D textures then set this flag to true and use the -neg/negateflag to invert the result."
            }, 
            "texturesProcedural": {
                "docstring": "Pass procedural texture objects if set to true. Value is false by default. To get all objects that are not procedural textures then set this flag to true and use the -neg/negateflag to invert the result.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "itemFilterRenderOld": {
        "description": "", 
        "flags": {
            "anyTextures": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusiveLights": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "lights": {
                "docstring": ""
            }, 
            "linkedLights": {
                "docstring": ""
            }, 
            "negate": {
                "docstring": ""
            }, 
            "nonExclusiveLights": {
                "docstring": ""
            }, 
            "nonIlluminatingLights": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": ""
            }, 
            "postProcess": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "renderUtilityNode": {
                "docstring": ""
            }, 
            "shaders": {
                "docstring": ""
            }, 
            "text": {
                "docstring": ""
            }, 
            "textures2d": {
                "docstring": ""
            }, 
            "textures3d": {
                "docstring": ""
            }, 
            "texturesProcedural": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": ""
            }
        }
    }, 
    "itemFilterType": {
        "description": "This command queries a named itemFilter object. This object can be attached to selectionConnection objects, or to editors, in order to filter the item lists going through them. Using union and intersection filters, complex composite filters can be created. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "text": {
                "docstring": "Defines an annotation string to be stored with the filterFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "type": {
                "docstring": "Query the type of the filter object. Possible return values are: itemFilter, attributeFilter, renderFilter, or unknownFilter."
            }
        }
    }, 
    "itemFilterTypeOld": {
        "description": "", 
        "flags": {
            "defineTemplate": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "text": {
                "docstring": ""
            }, 
            "type": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": ""
            }
        }
    }, 
    "iterOnNurbs": {
        "description": "", 
        "flags": {}
    }, 
    "joint": {
        "description": "The joint command is used to create, edit, and query, joints within Maya. (The standard edit(-e) and query(-q) flags are used for edit and query functions). If the object is not specified, the currently selected object (dag object) will be used. Multiple objects are allowed only for the edit mode. The same edit flags will be applied on all the joints selected, except for -p without -r (set joint position in the world space). An ik handle in the object list is equivalent to the list of joints the ik handle commands. When -ch/children is present, all the child joints of the specified joints, including the joints implied by possible ik handles, will also be included. In the creation mode, a new joint will be created as a child of a selected transform or starts a hierarchy by itself if no transform is selected. An ik handle will be treated as a transform in the creation mode. The default values of the arguments are: -degreeOfFreedom xyz -name \"Joint#\" -position 0 0 0 -absolute -dof \"xyz\" -scale 1.0 1.0 1.0 -scaleCompensate true -orientation 0.0 0.0 0.0 -scaleOrientation 0.0 0.0 0.0 -limitX -360 360 -limitY -360 360 -limitZ -360 360 -angleX 0.0 -angleY 0.0 -angleZ 0.0 -stiffnessX 0.0 -stiffnessY 0.0 -stiffnessZ 0.0 -limitSwitchX no -limitSwitchY no -limitSwitchZ no -rotationOrder xyz Those arguments can be specified in the creation mode, editied in the edit mode (-e), or queried in the query mode (-q). ", 
        "flags": {
            "absolute": {
                "docstring": "The joint center position is in absolute world coordinates. (This is the default.)"
            }, 
            "angleX": {
                "docstring": "Set the x-axis angle. When queried, this flag returns a float."
            }, 
            "angleY": {
                "docstring": "Set the y-axis angle. When queried, this flag returns a float."
            }, 
            "angleZ": {
                "docstring": "Set the z-axis angle. When queried, this flag returns a float."
            }, 
            "assumePreferredAngles": {
                "docstring": "Meaningful only in the edit mode. It sets the joint angles to the corresponding preferred angles."
            }, 
            "automaticLimits": {
                "docstring": "Meaningful only in edit mode. It sets the joint to appropriate hinge joint with joint limits. It modifies the joint only if (a) it connects exactly to two joints (one parent, one child), (b) it does not lie on the line drawn between the two connected joints, and the plane it forms with the two connected joints is perpendicular to one of its rotation axes."
            }, 
            "children": {
                "docstring": "It tells the command to apply all the edit options not only to the selected joints, but also to their descendent joints in the DAG."
            }, 
            "component": {
                "docstring": "Use with the -position switch to position the joint relative to its parent (like -relative) but to compute new positions for all children joints so their world coordinate positions do not change."
            }, 
            "degreeOfFreedom": {
                "docstring": "Specifies the degrees of freedom for the IK. Valid strings consist of non-duplicate letters from x, y, and z. The letters in the string indicate what rotations are to be used by IK. The order a letter appear in the string does not matter. Examples are x, yz, xyz. When queried, this flag returns a string. Modifying dof will change the locking state of the corresponding rotation attributes. The rule is: if an rotation is turned into a dof, it will be unlocked if it is currently locked. When it is turned into a non-dof, it will be locked if it is not currently locked."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Does the named joint exist? When queried, this flag returns a boolean."
            }, 
            "limitSwitchX": {
                "docstring": "Use the limit the x-axis rotation? When queried, this flag returns a boolean."
            }, 
            "limitSwitchY": {
                "docstring": "Use the limit the y-axis rotation? When queried, this flag returns a boolean."
            }, 
            "limitSwitchZ": {
                "docstring": "Use the Limit the z-axis rotation? When queried, this flag returns a boolean."
            }, 
            "limitX": {
                "docstring": "Set lower and upper limits on the x-axis of rotation. Also turns on the joint limit. When queried, this flag returns 2 floats."
            }, 
            "limitY": {
                "docstring": "Set lower and upper limits on the y-axis of rotation. Also turns on the joint limit. When queried, this flag returns 2 floats."
            }, 
            "limitZ": {
                "docstring": "Set lower and upper limits on the z-axis of rotation. Also turns on the joint limit. When queried, this flag returns 2 floats."
            }, 
            "name": {
                "docstring": "Specifies the name of the joint. When queried, this flag returns a string."
            }, 
            "orientJoint": {
                "docstring": "The argument can be one of the following strings: xyz, yzx, zxy, zyx, yxz, xzy, none. It modifies the joint orientation and scale orientation so that the axis indicated by the first letter in the argument will be aligned with the vector from this joint to its first child joint. For example, if the argument is \"xyz\", the x-axis will point towards the child joint. The alignment of the remaining two joint orient axes are dependent on whether or not the -sao/-secondaryAxisOrient flag is used. If the -sao flag is used, see the documentation for that flag for how the remaining axes are aligned. In the absence of a user specification for the secondary axis orientation, the rotation axis indicated by the last letter in the argument will be aligned with the vector perpendicular to first axis and the vector from this joint to its parent joint. The remaining axis is aligned according the right hand rule. If the argument is \"none\", the joint orientation will be set to zero and its effect to the hierarchy below will be offset by modifying the scale orientation. The flag will be ignored if: A. the joint has non-zero rotations when the argument is not \"none\". B. the joint does not have child joint, or the distance to the child joint is zero when the argument is not \"none\". C. either flag -o or -so is set."
            }, 
            "orientation": {
                "docstring": "The joint orientation. When queried, this flag returns 3 floats."
            }, 
            "position": {
                "docstring": "Specifies the position of the center of the joint. This position may be relative to the joint's parent or in absolute world coordinates (see -r and -a below). When queried, this flag returns 3 floats."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Specifies the joint radius."
            }, 
            "relative": {
                "docstring": "The joint center position is relative to the joint's parent."
            }, 
            "rotationOrder": {
                "docstring": "The rotation order of the joint. The argument can be one of the following strings: xyz, yzx, zxy, zyx, yxz, xzy."
            }, 
            "scale": {
                "docstring": "Scale of the joint. When queried, this flag returns 3 floats."
            }, 
            "scaleCompensate": {
                "docstring": "It sets the scaleCompenstate attribute of the joint to the given argument. When this is true, the scale of the parent joint will be compensated before any rotation of this joint is applied, so that the bone to the joint is scaled but not the bones to its child joints. When queried, this flag returns an boolean."
            }, 
            "scaleOrientation": {
                "docstring": "Set the orientation of the coordinate axes for scaling. When queried, this flag returns 3 floats."
            }, 
            "secondaryAxisOrient": {
                "docstring": "The argument can be one of the following strings: xup, xdown, yup, ydown, zup, zdown, none. This flag is used in conjunction with the -oj/orientJoint flag. It specifies the scene axis that the second axis should align with. For example, a flag combination of \"-oj yzx -sao yup\"would result in the y-axis pointing down the bone, the z-axis oriented with the scene's positive y-axis, and the x-axis oriented according to the right hand rule."
            }, 
            "setPreferredAngles": {
                "docstring": "Meaningful only in the edit mode. It sets the preferred angles to the current joint angles."
            }, 
            "stiffnessX": {
                "docstring": "Set the stiffness (from 0 to 100.0) for x-axis. When queried, this flag returns a float."
            }, 
            "stiffnessY": {
                "docstring": "Set the stiffness (from 0 to 100.0) for y-axis. When queried, this flag returns a float."
            }, 
            "stiffnessZ": {
                "docstring": "Set the stiffness (from 0 to 100.0) for z-axis. When queried, this flag returns a float."
            }, 
            "zeroScaleOrient": {
                "docstring": "It sets the scale orientation to zero and compensate the change by modifing the translation and joint orientation for joint or rotation for general transform of all its child transformations. The flag will be ignored if the flag -so is set.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "jointCluster": {
        "description": "The joint cluster command adds high-level controls to manage the cluster percentage values on a bound skin around a joint. JointClusters are one way to create smooth bending behaviour on skin when joints rotate. .                a ---- aboveBound .    ____________a_________ .                a         \\ .     Joint1     a       Joint2 .   _____________a_______    \\ .                a       \\    \\     b  --- belowBound .                a        \\    \\  b .                          \\    b .                           \\ b  \\ .                           b\\    \\ .                         b   \\ Joint3  CVs/vertices between Joint1 and aaaaa (aboveBound) receive only translation/rotation/scale from Joint1. CVs vertices between aaaa and bbbb transition between translation/rotatation/scale from Joint1 and Joint2. CV2 beyand bbbbb (below bound) receive only translation/ rotation scale from Joint3. ", 
        "flags": {
            "aboveBound": {
                "docstring": "Specifies the where the drop-off begins in the direction of the bone above the joint. A value of 100 indicates the entire length of the bone. The default value is 10."
            }, 
            "aboveCluster": {
                "docstring": "Returns the name of the cluster associated with the bone above this joint."
            }, 
            "aboveDropoffType": {
                "docstring": "Specifies the type of percentage drop-off in the direction of the bone above this joint. Valid values are \"linear\", \"exponential\", \"sine\" and \"none\". Default is linear."
            }, 
            "aboveValue": {
                "docstring": "Specifies the drop-off percentage of the joint cluster in the direction of the bone above the cluster. A value of 100 indicates the entire length of the bone. The default value is 50."
            }, 
            "belowBound": {
                "docstring": "Specifies where the drop-off ends in the direction of the bone below the joint. A value of 100 indicates the entire length of the bone. The default value is 10."
            }, 
            "belowCluster": {
                "docstring": "Returns the name of the cluster associated with this joint."
            }, 
            "belowDropoffType": {
                "docstring": "Specifies the type of type of percentage drop-off in the direction of the bone below this joint. Valid values are \"linear\", \"exponential\", \"sine\" and \"none\". Default is linear."
            }, 
            "belowValue": {
                "docstring": "Specifies the drop-off percentage of the joint cluster in the direction of the joint below the cluster. A value of 100 indicates the entire length of the bone. The default value is 50."
            }, 
            "deformerTools": {
                "docstring": "Used to query for the helper nodes associated with the jointCluster."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "joint": {
                "docstring": "Specifies the joint that the cluster should act about."
            }, 
            "name": {
                "docstring": "This flag is obsolete.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "jointCtx": {
        "description": "The joint context command (jointCtx) updates the parameters of the joint tool. The options for the tool will be set by the flags the user specifies. ", 
        "flags": {
            "autoJointOrient": {
                "docstring": "Specifies the joint orientation. Valid string choices are permutations of the axes; \"none\", \"xyz\", \"yzx\", \"zxy\", \"xzy\", \"yxz\", \"zyx\". The first letter determines which axis is aligned with the bone.C: The default is \"xyz\".Q: When queried, this flag returns a string."
            }, 
            "autoPriorityH": {
                "docstring": "Specifies if the ikHandle's priority is assigned automatically.C: The default is off.Q: When queried, this flag returns an int."
            }, 
            "createIKHandle": {
                "docstring": "Enables the joint tool to create an ikHandle when the tool is completed.C: The default is off.Q: When queried, this flag returns an int."
            }, 
            "degreeOfFreedomJ": {
                "docstring": "Specifies the degrees of freedom for all of the joints created by the tool. Valid string choices are the free axes; \"x\", \"y\", \"z\", \"xy\", \"xz\", \"yz\", \"xyz\", and \"none\".C: The default is \"xyz\".Q: When queried, this flag returns a string."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "forceSolverH": {
                "docstring": "Specifies if the ikSolver for the ikHandle is enabled.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "jointAutoLimits": {
                "docstring": "Automatically computes the joint limits based on the kind of joint created.C: The default is off.Q: When queried, this flag returns an int."
            }, 
            "jointOrientationJ": {
                "docstring": "Sets the orientation of the joints created by the tool. If autoJointOrient in on, these values will be ignored.C: The default is 0 0 0.Q: When queried, this flag returns an array of three floats."
            }, 
            "largeBoneLength": {
                "docstring": "Specifies the length above which bones should be assigned the largeBoneRadius."
            }, 
            "largeBoneRadius": {
                "docstring": "Specifies the radius for bones whose length is above the largeBoneLength"
            }, 
            "poWeightH": {
                "docstring": "Specifies the position/orientation weight of the ikHandle.C: The default is 1.Q: When queried, this flag returns a float."
            }, 
            "priorityH": {
                "docstring": "Specifies the priority of the ikHandle.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scaleCompensateJ": {
                "docstring": "Specifies if scale compensate is enabled.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "scaleJ": {
                "docstring": "Sets the scale for the joints created by the tool.C: The default is 1 1 1.Q: When queried, this flag returns an array of three floats."
            }, 
            "scaleOrientationJ": {
                "docstring": "Sets the current value for the scale orientation. If autoJointOrient in on, these values will be ignored.C: The default is 0 0 0.Q: When queried, this flag returns an array of three floats."
            }, 
            "secondaryAxisOrient": {
                "docstring": "Specifies the orientation of the secondary rotate axis. Valid string choices are: \"xup\", \"xdown\", \"yup\", \"ydown\", \"zup\", \"zdown\", \"none\"."
            }, 
            "smallBoneLength": {
                "docstring": "Specifies the length below which bones should be assigned the smallBoneRadius."
            }, 
            "smallBoneRadius": {
                "docstring": "Specifies the radius for bones whose length is below the smallBoneLength.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "snapHandleH": {
                "docstring": "Sepcifies if snapping is enabled for the ikHandle.C: The default is on.Q: When queried, this flag returns an int."
            }, 
            "solverTypeH": {
                "docstring": "Sets the name of the solver to use with the ikHandle.C: The default is the solver set to the default in the user preferences.Q: When queried, this flag returns a string."
            }, 
            "stickyH": {
                "docstring": "Specifies if the ikHandle is sticky or not. If \"sticky\" is passed then the ikHandle will be sticky. If \"off\" is used then ikHandle stickiness will be turned off.C: The default is \"off\".Q: When queried, this flag returns a string."
            }, 
            "variableBoneSize": {
                "docstring": "Specifies whether or not variable bone length and radius settings should be used."
            }, 
            "weightH": {
                "docstring": "Specifies the weight of the ikHandle. The weight is relative to the other ikHandles in the scene.C: The default is 1.Q: When queried, this flag returns a float."
            }
        }
    }, 
    "jointDisplayScale": {
        "description": "This action modifies and queries the current display size of skelton joints. The joint display size is controlled by a scale factor; scale factor 1 puts the display size to its default, which is 1 in diameter. With the plain format, the float argument is the factor with respect to the default size. When -a/absolute is used, the float argument refers to the actual diameter of the joint display size. In query mode, return type is based on queried flag.", 
        "flags": {
            "absolute": {
                "docstring": "Interpret the float argument as the actual display size as opposed to the scale factor."
            }, 
            "ikfk": {
                "docstring": "Set the display size of ik/fk skeleton joints.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "jointLattice": {
        "description": "This command creates/edits/queries a jointLattice deformer. The name of the created/edited object is returned. Usually you would make use of this functionality through the higher level flexor command. ", 
        "flags": {
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "creasing": {
                "docstring": "Affects the bulging of lattice points on the inside of the bend. Positive/negative values cause the points to bulge outwards/inwards. Default value is 0.0. When queried, this flag returns a float."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "joint": {
                "docstring": "Specifies the joint which will be used to drive the bulging behaviours."
            }, 
            "lengthIn": {
                "docstring": "Affects the location of lattice points on the parent bone. Positive/negative values cause the points to move away/towards the joint. Changing this parameter also modifies the regions affected by the creasing, rounding and width parameters. Default value is 0.0. When queried, this flag returns a float."
            }, 
            "lengthOut": {
                "docstring": "Affects the location of lattice points on the child bone. Positive/negative values cause the points to move away/towards the joint. Changing this parameter also modifies the regions affected by the creasing, rounding and width parameters. Default value is 0.0. When queried, this flag returns a float."
            }, 
            "lowerBindSkin": {
                "docstring": "Specifies the node which is performing the bind skin operation on the geometry associated with the lower bone.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "lowerTransform": {
                "docstring": "Specifies which dag node is being used to rigidly transform the lower part of the lattice which this node is going to deform. If this flag is not specified an identity matrix will be assumed."
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "rounding": {
                "docstring": "Affects the bulging of lattice points on the outside of the bend. Positive/negative values cause the points to bulge outwards/inwards. Default value is 0.0. When queried, this flag returns a float."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "upperBindSkin": {
                "docstring": "Specifies the node which is performing the bind skin operation on the geometry associated with the upper bone."
            }, 
            "upperTransform": {
                "docstring": "Specifies which dag node is being used to rigidly transform the upper part of the lattice which this node is going to deform. If this flag is not specified an identity matrix will be assumed."
            }, 
            "widthLeft": {
                "docstring": "Affects the bulging of lattice points on the left side of the bend. Positive/negative values cause the points to bulge outwards/inwards. Default value is 0.0. When queried, this flag returns a float."
            }, 
            "widthRight": {
                "docstring": "Affects the bulging of lattice points on the right side of the bend. Positive/negative values cause the points to bulge outwards/inwards. Default value is 0.0. When queried, this flag returns a float."
            }
        }
    }, 
    "journal": {
        "description": "", 
        "flags": {
            "comment": {
                "docstring": ""
            }, 
            "flush": {
                "docstring": ""
            }, 
            "highPrecision": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "state": {
                "docstring": ""
            }
        }
    }, 
    "keyTangent": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.This command edits or queries tangent properties of keyframes in a keyset. It is also used to edit or query the default tangent type of newly created keyframes (see the setKeyframe command for more information on how to override this default). Tangents help manage the shape of the animation curve and affect the interpolation between keys. The tangent angle specifies the direction the curve will take as it leaves (or enters) a key. The tangent weight specifies how much influence the tangent angle has on the curve before the curve starts towards the next key. Maya internally represents tangents as x and y values. Refer to the API documentation for MFnAnimCurve for a description of the relationship between tangent angle and weight and the internal x and y values. ", 
        "flags": {
            "absolute": {
                "docstring": "Changes to tangent positions are NOT relative to the current position."
            }, 
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "g": {
                "docstring": "Required for all operations on the global tangent type. The global tangent type is used by the setKeyframe command when tangent types have not been specifically applied, except in combination with flags such as 'i/insert' which preserve the shape of the curve. It is also used when keys are set from the menu. The only flags that can appear on a keyTangent command with the 'g/global' flag are 'itt/inTangentType', 'ott/outTangentType' and 'wt/weightedTangents'."
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "inAngle": {
                "docstring": "New value for the angle of the in-tangent. Returns a float[] when queried."
            }, 
            "inTangentType": {
                "docstring": "Specify the in-tangent type. Valid values are \"spline,\" \"linear,\" \"fast,\" \"slow,\" \"flat,\" \"step,\" \"stepnext,\" \"fixed,\" \"clamped,\" \"plateau\" and \"auto\". Returns a string[] when queried."
            }, 
            "inWeight": {
                "docstring": "New value for the weight of the in-tangent. Returns a float[] when queried."
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "ix": {
                "docstring": "New value for the x-component of the in-tangent. This is a unit independent representation of the tangent component. Returns a float[] when queried."
            }, 
            "iy": {
                "docstring": "New value for the y-component of the in-tangent. This is a unit independent representation of the tangent component. Returns a float[] when queried."
            }, 
            "lock": {
                "docstring": "Lock a tangent so in and out tangents move together. Returns an int[] when queried."
            }, 
            "outAngle": {
                "docstring": "New value for the angle of the out-tangent. Returns a float[] when queried."
            }, 
            "outTangentType": {
                "docstring": "Specify the out-tangent type. Valid values are \"spline,\" \"linear,\" \"fast,\" \"slow,\" \"flat,\" \"step,\" \"stepnext,\" \"fixed,\" \"clamped,\" \"plateau\" and \"auto\". Returns a string[] when queried."
            }, 
            "outWeight": {
                "docstring": "New value for the weight of the out-tangent. Returns a float[] when queried."
            }, 
            "ox": {
                "docstring": "New value for the x-component of the out-tangent. This is a unit independent representation of the tangent component. Returns a float[] when queried."
            }, 
            "oy": {
                "docstring": "New value for the y-component of the out-tangent. This is a unit independent representation of the tangent component. Returns a float[] when queried."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Changes to tangent positions are relative to the current position."
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "stepAttributes": {
                "docstring": "The setKeyframe command will automatically set tangents for boolean and enumerated attributes to step. This flag mirrors this behavior for the keyTangent command. When set to false, tangents for these attributes will not be edited. When set to true (the default) tangents for these attributes will be edited.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }, 
            "weightLock": {
                "docstring": "Lock the weight of a tangent so it is fixed. Returns an int[] when queried. Note: weightLock is only obeyed within the graph editor. It is not obeyed when -inWeight/-outWeight are issued from a command."
            }, 
            "weightedTangents": {
                "docstring": "Specify whether or not the tangents on the animCurve are weighted Note: switching a curve from weightedTangents true to false and back to true again will not preserve fixed tangents properly. Use undo instead."
            }
        }
    }, 
    "keyframe": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.This command edits the time and/or value of keys of specified objects and/or parameter curves Unless otherwise specified by the -query flag, the command defaults to editing keyframes. ", 
        "flags": {
            "absolute": {
                "docstring": "Move amounts are absolute."
            }, 
            "adjustBreakdown": {
                "docstring": "When false, moving keys will not preserve breakdown timing, when true (the default) breakdowns will be adjusted to preserve their timing relationship."
            }, 
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "breakdown": {
                "docstring": "Sets the breakdown state for the key. Returns an integer. Default is false. The breakdown state of a key cannot be set in the same command as it is moved (i.e., via the -tc or -fc flags)."
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "eval": {
                "docstring": "Returns the value(s) of the animCurves when evaluated (without regard to input connections) at the times given by the -t/time or -f/float flags. Cannot be used in combination with other query flags, and cannot be used with time ranges (-t \"5:10\"). When no -t or -f flags appear on the command line, the evals are queried at the current time. Query returns a float[]."
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "floatChange": {
                "docstring": "How much (with -relative) or where (with -absolute) to move keys (on non-time-input animation curves) along the x (float) axis. Returns float[] when queried."
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "indexValue": {
                "docstring": "Query-only flag that returns an int for the key's index."
            }, 
            "keyframeCount": {
                "docstring": "Returns an int for the number of keys found for the targets."
            }, 
            "lastSelected": {
                "docstring": "When used in queries, this flag returns requested values for the last selected key.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "Returns the names of animCurves of specified nodes, attributes or keys."
            }, 
            "option": {
                "docstring": "Valid values are \"move,\" \"insert,\" \"over,\" and \"segmentOver.\" When you \"move\" a key, the key will not cross over (in time) any keys before or after it. When you \"insert\" a key, all keys before or after (depending upon the -timeChange value) will be moved an equivalent amount. When you \"over\" a key, the key is allowed to move to any time (as long as a key is not there already). When you \"segmentOver\" a set of keys (this option only has a noticeable effect when more than one key is being moved) the first key (in time) and last key define a segment (unless you specify a time range). That segment is then allowed to move over other keys, and keys will be moved to make room for the segment."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Move amounts are relative to a key's current position."
            }, 
            "selected": {
                "docstring": "When used in queries, this flag returns requested values for any active keys."
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "tickDrawSpecial": {
                "docstring": "Sets the special drawing state for this key when it is drawn as a tick in the timeline."
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }, 
            "timeChange": {
                "docstring": "How much (with -relative) or where (with -absolute) to move keys (on time-input animation curves) along the x (time) axis. Returns float[] when queried."
            }, 
            "valueChange": {
                "docstring": "How much (with -relative) or where (with -absolute) to move keys along the y (value) axis. Returns float[] when queried."
            }
        }
    }, 
    "keyframeOutliner": {
        "description": "This command creates/edits/queries a keyframe outliner control. ", 
        "flags": {
            "animCurve": {
                "docstring": "Name of the animation curve for which to display keyframes."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "display": {
                "docstring": "narrow | wide What columns to display. When \"narrow\", time and value will be displayed, when \"wide\" tangent information will be displayed as wellFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "keyframeRegionCurrentTimeCtx": {
        "description": "This command creates a context which may be used to change current time within the keyframe region of the dope sheet editor. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "keyframeRegionDirectKeyCtx": {
        "description": "This command creates a context which may be used to directly manipulate keyframes within the dope sheet editor ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "option": {
                "docstring": "Valid values are \"move,\" \"insert,\" \"over,\" and \"segmentOver.\" When you \"move\" a key, the key will not cross over (in time) any keys before or after it. When you \"insert\" a key, all keys before or after (depending upon the -timeChange value) will be moved an equivalent amount. When you \"over\" a key, the key is allowed to move to any time (as long as a key is not there already). When you \"segmentOver\" a set of keys (this option only has a noticeable effect when more than one key is being moved) the first key (in time) and last key define a segment (unless you specify a time range). That segment is then allowed to move over other keys, and keys will be moved to make room for the segment.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "keyframeRegionDollyCtx": {
        "description": "This command can be used to create a dolly context for the dope sheet editor. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "keyframeRegionInsertKeyCtx": {
        "description": "This command creates a context which may be used to insert keys within the keyframe region of the dope sheet editor ", 
        "flags": {
            "breakdown": {
                "docstring": "Specifies whether or not to create breakdown keysFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "keyframeRegionMoveKeyCtx": {
        "description": "This command creates a context which may be used to move keyframes within the keyframe region of the dope sheet editor ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "option": {
                "docstring": "Valid values are \"move,\" \"insert,\" \"over,\" and \"segmentOver\". Specifies the keyframe -option to use. When you \"move\" a key, the key will not cross over (in time) any keys before or after it. When you \"insert\" a key, all keys before or after (depending upon the -timeChange value) will be moved an equivalent amount. When you \"over\" a key, the key is allowed to move to any time (as long as a key is not there already). When you \"segmentOver\" a set of keys (this option only has a noticeable effect when more than one key is being moved) the first key (in time) and last key define a segment (unless you specify a time range). That segment is then allowed to move over other keys, and keys will be moved to make room for the segment.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "keyframeRegionScaleKeyCtx": {
        "description": "This command creates a context which may be used to scale keyframes within the keyframe region of the dope sheet editor ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scaleSpecifiedKeys": {
                "docstring": "Determines if only the specified keys should be scaled. If false, the non-selected keys will be adjusted during the scale. The default is true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "type": {
                "docstring": "rect | manip Specifies the type of scale manipulator to use"
            }
        }
    }, 
    "keyframeRegionSelectKeyCtx": {
        "description": "This command creates a context which may be used to select keyframes within the keyframe region of the dope sheet editor ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "keyframeRegionSetKeyCtx": {
        "description": "This command creates a context which may be used to set keys within the keyframe region of the dope sheet editor ", 
        "flags": {
            "breakdown": {
                "docstring": "Specifies whether or not to create breakdown keysFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "keyframeRegionTrackCtx": {
        "description": "This command can be used to create a track context for the dope sheet editor. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "keyframeStats": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates, edits, queries a keyframe stats control. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "animEditor": {
                "docstring": "The name of the animation editor which is associated with the control"
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "classicMode": {
                "docstring": ""
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "precision": {
                "docstring": "Controls the number of digits to the right of the decimal point that will be displayed for float-valued channels. Default is 3. Queried, returns an int."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "timeAnnotation": {
                "docstring": "Annotate the time field with an extra string value."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "valueAnnotation": {
                "docstring": "Annotate the value field with an extra string value.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "keyingGroup": {
        "description": "This command is used to manage the membership of a keying group. Keying groups allow users to effectively manage related keyframe data, allowing keys on attributes in the keying group to be set and edited as a single entity. ", 
        "flags": {
            "activator": {
                "docstring": "Sets the selected node(s) as activators for the given keying group. In query mode, returns list of objects that activate the given keying group"
            }, 
            "addElement": {
                "docstring": "Adds the list of items to the given set. If some of the items cannot be added to the set because they are in another set which is in the same partition as the set to edit, the command will fail."
            }, 
            "afterFilters": {
                "docstring": "Default state is false. This flag is valid in edit mode only. This flag is for use on sets that are acted on by deformers such as sculpt, lattice, blendShape. The default edit mode is to edit the membership of the group acted on by the deformer. If you want to edit the group but not change the membership of the deformer, set the flag to true."
            }, 
            "category": {
                "docstring": "Sets the keying group's category. This is what the global, active keying group filter will use to match.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "clear": {
                "docstring": "An operation which removes all items from the given set making the set empty."
            }, 
            "color": {
                "docstring": "Defines the hilite color of the set. Must be a value in range [-1, 7] (one of the user defined colors). -1 marks the color has being undefined and therefore not having any affect. Only the vertices of a vertex set will be displayed in this color."
            }, 
            "copy": {
                "docstring": "Copies the members of the given set to a new set. This flag is for use in creation mode only."
            }, 
            "edges": {
                "docstring": "Indicates the new set can contain edges only. This flag is for use in creation or query mode only. The default value is false."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editPoints": {
                "docstring": "Indicates the new set can contain editPoints only. This flag is for use in creation or query mode only. The default value is false."
            }, 
            "empty": {
                "docstring": "Indicates that the set to be created should be empty. That is, it ignores any arguments identifying objects to be added to the set. This flag is only valid for operations that create a new set."
            }, 
            "excludeDynamic": {
                "docstring": "When creating the keying group, exclude dynamic attributes."
            }, 
            "excludeRotate": {
                "docstring": "When creating the keying group, exclude rotate attributes from transform-type nodes."
            }, 
            "excludeScale": {
                "docstring": "When creating the keying group, exclude scale attributes from transform-type nodes."
            }, 
            "excludeTranslate": {
                "docstring": "When creating the keying group, exclude translate attributes from transform-type nodes. For example, if your keying group contains joints only, perhaps you only want to include rotations in the keying group."
            }, 
            "excludeVisibility": {
                "docstring": "When creating the keying group, exclude visibility attribute from transform-type nodes."
            }, 
            "facets": {
                "docstring": "Indicates the new set can contain facets only. This flag is for use in creation or query mode only. The default value is false."
            }, 
            "flatten": {
                "docstring": "An operation that flattens the structure of the given set. That is, any sets contained by the given set will be replaced by its members so that the set no longer contains other sets but contains the other sets' members."
            }, 
            "forceElement": {
                "docstring": "For use in edit mode only. Forces addition of the items to the set. If the items are in another set which is in the same partition as the given set, the items will be removed from the other set in order to keep the sets in the partition mutually exclusive with respect to membership."
            }, 
            "include": {
                "docstring": "Adds the list of items to the given set. If some of the items cannot be added to the set, a warning will be issued. This is a less strict version of the -add/addElement operation."
            }, 
            "intersection": {
                "docstring": "An operation that returns a list of items which are members of all the sets in the list."
            }, 
            "isIntersecting": {
                "docstring": "An operation which tests whether the sets in the list have common members."
            }, 
            "isMember": {
                "docstring": "An operation which tests whether all the given items are members of the given set."
            }, 
            "layer": {
                "docstring": "OBSOLETE. DO NOT USE."
            }, 
            "name": {
                "docstring": "Assigns string as the name for a new set. This flag is only valid for operations that create a new set."
            }, 
            "noSurfaceShader": {
                "docstring": "If set is renderable, do not connect it to the default surface shader. Flag has no meaning or effect for non renderable sets. This flag is for use in creation mode only. The default value is false."
            }, 
            "noWarnings": {
                "docstring": "Indicates that warning messages should not be reported such as when trying to add an invalid item to a set. (used by UI)"
            }, 
            "nodesOnly": {
                "docstring": "This flag is usable with the -q/query flag but is ignored if used with another queryable flags. This flag modifies the results of the set membership query such that when there are attributes (e.g. sphere1.tx) or components of nodes included in the set, only the nodes will be listed. Each node will only be listed once, even if more than one attribute or component of the node exists in the set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Removes the list of items from the given set."
            }, 
            "removeActivator": {
                "docstring": "Removes the selected node(s) as activators for the given keying group."
            }, 
            "renderable": {
                "docstring": "This flag indicates that a special type of set should be created. This type of set (shadingEngine as opposed to objectSet) has certain restrictions on its membership in that it can only contain renderable elements such as lights and geometry. These sets are referred to as shading groups and are automatically connected to the \"renderPartition\" node when created (to ensure mutual exclusivity of the set's members with the other sets in the partition). This flag is for use in creation or query mode only. The default value is false which means a normal set is created."
            }, 
            "setActiveFilter": {
                "docstring": "Sets the global, active keying group filter, which will affect activation of keying groups. Only keying groups with categories that match the filter will be activated. If the setActiveFilter is set to \"NoKeyingGroups\", keying groups will not be activated at all. If the setActiveFilter is set to \"AllKeyingGroups\", we will activate any keying group rather than just those with matching categories."
            }, 
            "size": {
                "docstring": "Use the size flag to query the length of the set."
            }, 
            "split": {
                "docstring": "Produces a new set with the list of items and removes each item in the list of items from the given set."
            }, 
            "subtract": {
                "docstring": "An operation between two sets which returns the members of the first set that are not in the second set."
            }, 
            "text": {
                "docstring": "Defines an annotation string to be stored with the set."
            }, 
            "union": {
                "docstring": "An operation that returns a list of all the members of all sets listed."
            }, 
            "vertices": {
                "docstring": "Indicates the new set can contain vertices only. This flag is for use in creation or query mode only. The default value is false."
            }
        }
    }, 
    "lassoContext": {
        "description": "Creates a context to perform selection via a \"lasso\". Use for irregular selection regions, where the \"marquee-style\" select of the \"selectContext\" is inappropriate. ", 
        "flags": {
            "drawClosed": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fastComponents": {
                "docstring": ""
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "lattice": {
        "description": "This command creates a lattice deformer that will deform the selected objects. If the object centered flag is used, the initial lattice will fit around the selected objects. The lattice will be selected when the command is completed. The lattice deformer has an associated base lattice. Only objects which are contained by the base lattice will be deformed by the lattice. ", 
        "flags": {
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "commonParent": {
                "docstring": "Group the base lattice and the deformed lattice under a common transform. This means that you can resize the lattice without affecting the deformation by resizing the common transform."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "divisions": {
                "docstring": "Set the number of lattice slices in x, y, z. Default is 2, 5, 2. When queried, this flag returns float float float. When you change the number of divisions, any tweaking or animation of lattice points must be redone."
            }, 
            "dualBase": {
                "docstring": "Create a special purpose ffd deformer node which accepts 2 base lattices. The default is off which results in the creation of a normal ffd deformer node. Intended for internal usage only.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "freezeMapping": {
                "docstring": "The base position of the geometries points is fixed at the time this flag is set. When mapping is frozen, moving the geometry with respect to the lattice will not cause the deformation to be recomputed."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "latticeReset": {
                "docstring": "Reset the lattice to match its base position. This will undo any deformations that the lattice is causing. The lattice will only deform points that are enclosed within the lattice's reset (base) position."
            }, 
            "ldivisions": {
                "docstring": "Set the number of local lattice slices in x, y, z."
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "objectCentered": {
                "docstring": "Centers the lattice around the selected object(s) or components. Default is off which centers the lattice at the origin."
            }, 
            "outsideFalloffDistance": {
                "docstring": "Set the falloff distance used when the setting for transforming points outside of the base lattice is set to 2. The distance value is a positive number which specifies the size of the falloff distance as a multiple of the base lattice size, thus a value of 1.0 specifies that only points up to the base lattice width/height/depth away are transformed. A value of 0.0 is equivalent to an outsideLattice value of 0 (i.e. no points outside the base lattice are transformed). A huge value is equivalent to transforming an outsideLattice value of 1 (i.e. all points are transformed)."
            }, 
            "outsideLattice": {
                "docstring": "Set the mode describing how points outside the base lattice are transformed. 0 (the default) specifies that no outside points are transformed. 1 specifies that all outside points are transformed, and 2 specifies that only those outside points which fall within the \"falloff distance\" (see the -ofd/outsideFalloffDistance flag) are transformed. When querying, the current setting for the lattice is returned."
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "position": {
                "docstring": "Used to specify the position of the newly created lattice."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "removeTweaks": {
                "docstring": "Remove any lattice deformations caused by moving lattice points. Translations/rotations and scales on the lattice itself are not removed."
            }, 
            "rotation": {
                "docstring": "Used to specify the initial rotation of the newly created lattice."
            }, 
            "scale": {
                "docstring": "Used to specify the initial scale of the newly created lattice."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }
        }
    }, 
    "latticeDeformKeyCtx": {
        "description": "This command creates a context which may be used to deform key frames with lattice manipulator. This context only works in the graph editor. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "envelope": {
                "docstring": "Specifies the influence of the lattice."
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "latticeColumns": {
                "docstring": "Specifies the number column points the lattice contains."
            }, 
            "latticeRows": {
                "docstring": "Specifies the number of rows the lattice contains."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scaleLatticePts": {
                "docstring": "Specifies if the selected lattice points should scale around the pick point. If this value is false the the default operation is 'move'Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "launch": {
        "description": "Launch the appropriate application to open the document specified. This command works only on the Macintosh and Windows platforms. ", 
        "flags": {
            "movie": {
                "docstring": "A movie file. The only acceptable movie file formats are MPEG, Quicktime, and Windows Media file. The file's name must end with .mpg, .mpeg, .wmv, .mov, or .qt."
            }, 
            "pdfFile": {
                "docstring": "A PDF (Portable Document Format) document. The file's name must end with .pdf."
            }, 
            "webPage": {
                "docstring": "A web page.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "launchImageEditor": {
        "description": "Launch the appropriate application to edit/view the image files specified. This command works only on the Macintosh and Windows platforms. ", 
        "flags": {
            "editImageFile": {
                "docstring": "If the file is a PSD, then the specified verison of Photoshop is launched, and the file is opened in it. If file is any other image type, then the preferred image editor is launched, and the file is opened in it."
            }, 
            "viewImageFile": {
                "docstring": "Opens up an Image editor to view images.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "layerButton": {
        "description": "Creates a layer bar button widget. This widget contains both the name of the layer to which it refers and a color swatch indicating it's color assignment. It is used primarily in the construction of the layerBar and layer Editor window, being the widget used for each layer in the respective lists. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": ""
            }, 
            "color": {
                "docstring": "Layer color, specified with normalized real numbers in R, G, B space."
            }, 
            "command": {
                "docstring": "Set the command to call on a single click."
            }, 
            "current": {
                "docstring": "Set this button to display as the current layer. The current layer is the one which the user has the option of adding all newly created objects into. NB: Setting the layer button to this state has no effect on the actual current layer."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "doubleClickCommand": {
                "docstring": "Set the command to call on a double click."
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "identification": {
                "docstring": "This is the integer identification number associated with the layer."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "Label text for the button."
            }, 
            "labelWidth": {
                "docstring": "Query the width of the label part so as to determine if button clicks are in the label part or the colour swatch part."
            }, 
            "layerState": {
                "docstring": "Describes the state of the layer. This may be one of normal, template, or reference."
            }, 
            "layerVisible": {
                "docstring": "Indicates whether the layer is visible or invisible."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "name": {
                "docstring": "Name of the layer."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "renameCommand": {
                "docstring": "Set the command to call when the layer gets renamed. The string '#1' will be substituted with the control's name and '#2' will be replaced with the layer's new name."
            }, 
            "select": {
                "docstring": "Set this button to display as a selected layer."
            }, 
            "transparent": {
                "docstring": "Indicate whether the layer color is visible or transparent."
            }, 
            "typeCommand": {
                "docstring": "Command that is called when the type indicator of the layer button is pressed.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "visibleCommand": {
                "docstring": "Command that is called when the visibility indicator of the layer button is pressed."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "layeredShaderPort": {
        "description": "This command creates a 3dPort that displays an image representing the layered shader node specified. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "node": {
                "docstring": "Specifies the name of the newLayeredShader node this port will represent."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectedColorControl": {
                "docstring": "Specifies the name of the UI-control that represents the currently selected layer's color."
            }, 
            "selectedTransparencyControl": {
                "docstring": "Specifies the name of the UI-control that represents the currently selected layer's transparency.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "layeredTexturePort": {
        "description": "This command creates a 3dPort that displays an image representing the layered texture node specified. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "node": {
                "docstring": "Specifies the name of the newLayeredTexture node this port will represent."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectedAlphaControl": {
                "docstring": "Specifies the name of the UI-control that represents the currently selected layer's alpha."
            }, 
            "selectedBlendModeControl": {
                "docstring": "Specifies the name of the UI-control that represents the currently selected layer's blend mode."
            }, 
            "selectedColorControl": {
                "docstring": "Specifies the name of the UI-control that represents the currently selected layer's color."
            }, 
            "selectedIsVisibleControl": {
                "docstring": "Specifies the name of the UI-control that represents the currently selected layer's visibility.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "layout": {
        "description": "This command allows you to edit or query the properties of any layout. The argument is the name of the layout. In query mode, return type is based on queried flag.", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "layoutDialog": {
        "description": "The layoutDialog command creates a modal dialog containing a formLayout with 100 divisions. The formLayout can be populated with arbitrary UI elements through use of the '-ui/-uiScript' flag. NOTE:A layoutDialog is not a window and certain UI elements will not function properly within it. In particular menuBars and panels containing menuBars should not be used with the layoutDialog. ", 
        "flags": {
            "backgroundColor": {
                "docstring": "The background color of the dialog. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0. (Windows only flag)"
            }, 
            "dismiss": {
                "docstring": "Dismiss the current layoutDialog. The specified string will be set as the result of the initial layoutDialog command."
            }, 
            "parent": {
                "docstring": "Specify the parent window for the dialog. The dialog will be centered on this window and raise and lower with it's parent. By default, the dialog is not parented to a particular window and is simply centered on the screen."
            }, 
            "title": {
                "docstring": "The dialog title."
            }, 
            "uiScript": {
                "docstring": "The specified MEL procedure name will be invoked to build the UI of the layoutDialog. This flag is required when creating a layoutDialog. The top-level control of a layoutDialog is a formLayout with 100 divisions. It can be accessed by calling 'setParent -q' at the beginning of the specified MEL procedure.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "license": {
        "description": "This command displays version information about the application if it is executed without flags. If one of the above flags is specified then the specified version information is returned. ", 
        "flags": {
            "borrow": {
                "docstring": "Borrow a network license"
            }, 
            "info": {
                "docstring": "Display license informationFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "isBorrowed": {
                "docstring": "Returns true if the current license is borrowed"
            }, 
            "isExported": {
                "docstring": "Return the cut string"
            }, 
            "isTrial": {
                "docstring": "Return the cut string"
            }, 
            "licenseMethod": {
                "docstring": "Return the current license method"
            }, 
            "productChoice": {
                "docstring": "Return the current product choice"
            }, 
            "r": {
                "docstring": "Return the cut string"
            }, 
            "showBorrowInfo": {
                "docstring": "Show the Borrow Information Dialog"
            }, 
            "showProductInfoDialog": {
                "docstring": "Show the Product Information Dialog"
            }, 
            "status": {
                "docstring": "Return the cut string"
            }
        }
    }, 
    "licenseCheck": {
        "description": "", 
        "flags": {
            "mode": {
                "docstring": ""
            }, 
            "type": {
                "docstring": ""
            }
        }
    }, 
    "lightList": {
        "description": "Add/Remove a relationship between an object and the current light. Soon to be replaced by the connect-attribute command. In query mode, return type is based on queried flag.", 
        "flags": {
            "add": {
                "docstring": "add object(s) to light list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "remove object(s) to light list.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "lightlink": {
        "description": "This command is used to make, break and query light linking relationships between lights/sets of lights and objects/sets of objects. If no make, break or query flag is specified and both lights and objects flags are present, the make flag is assumed to be specified. If no make, break or query flag is specified and only one of the lights and objects flags is present, the query flag is assumed to be specified. You can specify as many lights and objects as you like, using the multiuse -light and -object flags. A better way to perform light linking is to make sets of lights and sets of geometry. If you create a set which contains lights (such as the ceiling lights in your scene) and a set which contains geometry (such as the geometry of your character), you can then link the setcontaining lights with the setcontaining geometry in order to get those lights to illuminate those pieces of geometry. In addition, you can add and remove lights and geometry from their respective sets without having to make and break light links. ", 
        "flags": {
            "b": {
                "docstring": "The presence of this flag on the command indicates that the command is being invoked to break links between lights and renderable objects."
            }, 
            "hierarchy": {
                "docstring": "When querying, specifies whether the result should include the hierarchy of transforms above shapes linked to the queried light/object. The transforms considered part of the hierarchy do not include the transform immediately above the shape. Default is true."
            }, 
            "light": {
                "docstring": "The argument to the light flag specifies a node to be used by the command in performing the action as if the node is a light. This is a multiuse flag -- many light nodes can be specified in a single invocation of the lightlink command."
            }, 
            "make": {
                "docstring": "The presence of this flag on the command indicates that the command is being invoked to make links between lights and renderable objects."
            }, 
            "object": {
                "docstring": "The argument to the object flag specifies a node to be used by the command in performing the action as if the node is an object. This is a multiuse flag -- many object nodes can be specified in a single invocation of the lightlink command."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sets": {
                "docstring": "When querying, specifies whether the result should include sets linked to the queried light/object. Default is true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "shadow": {
                "docstring": ""
            }, 
            "shapes": {
                "docstring": "When querying, specifies whether the result should include shapes linked to the queried light/object. Default is true."
            }, 
            "transforms": {
                "docstring": "When querying, specifies whether the result should include transforms immediately above shapes linked to the queried light/object. Default is true."
            }, 
            "useActiveLights": {
                "docstring": ""
            }, 
            "useActiveObjects": {
                "docstring": ""
            }
        }
    }, 
    "linearPrecision": {
        "description": "This command controls the display of linear strings in the interface. (See the linearField command). Setting this affects any linear strings displayed afterwards, formatting them so they will show at most the specified number of digits after the decimal point. Allowed values are 0 through 6. In query mode, return type is based on queried flag.", 
        "flags": {
            "query": {
                "docstring": ""
            }
        }
    }, 
    "listAnimatable": {
        "description": "This command list the animatable attributes of a node. Command flags allow filtering by the current manipulator, or node type. ", 
        "flags": {
            "active": {
                "docstring": "This flag is obsolete and no longer supported."
            }, 
            "manip": {
                "docstring": "Return only those attributes affected by the current manip. If there is no manip active and any other flags are specified, output is the same as if the \"-manip\" flag were not present."
            }, 
            "manipHandle": {
                "docstring": "Return only those attributes affected by the current manip handle. If there is no manip handle active and any other flags are specified, output is the same as if the \"-manipHandle\" flag were not present."
            }, 
            "shape": {
                "docstring": "This flag is obsolete and no longer supported.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "type": {
                "docstring": "Instead of returning attributes, Return the types of nodes that are currently animatable."
            }
        }
    }, 
    "listAttr": {
        "description": "This command lists the attributes of a node. If no flags are specified all attributes are listed. ", 
        "flags": {
            "array": {
                "docstring": "only list array (not multi) attributes"
            }, 
            "caching": {
                "docstring": "only show attributes that are cached internally"
            }, 
            "category": {
                "docstring": "only show attributes belonging to the given category. Category string can be a regular expression."
            }, 
            "changedSinceFileOpen": {
                "docstring": "Only list the attributes that have been changed since the file they came from was opened. Typically useful only for objects/attributes coming from referenced files."
            }, 
            "channelBox": {
                "docstring": "only show non-keyable attributes that appear in the channelbox"
            }, 
            "connectable": {
                "docstring": "only show connectable attributes"
            }, 
            "extension": {
                "docstring": "list user-defined attributes for all nodes of this type (extension attributes)"
            }, 
            "fromPlugin": {
                "docstring": "only show attributes that were created by a plugin"
            }, 
            "hasData": {
                "docstring": "list only attributes that have data (all attributes except for message attributes)"
            }, 
            "hasNullData": {
                "docstring": "list only attributes that have null data. This will list all attributes that have data (see hasData flag) but the data value is uninitialized. A common example where an attribute may have null data is when a string attribute is created but not yet assigned an initial value. Similarly array attribute data is often null until it is initialized."
            }, 
            "inUse": {
                "docstring": "only show attributes that are currently marked as in use. This flag indicates that an attribute affects the scene data in some way. For example it has a non-default value or it is connected to another attribute. This is the general concept though the precise implementation is subject to change."
            }, 
            "keyable": {
                "docstring": "only show attributes that can be keyframed"
            }, 
            "leaf": {
                "docstring": "Only list the leaf-level name of the attribute. controlPoints[44].xValue would be listed as \"xValue\"."
            }, 
            "locked": {
                "docstring": "list only attributes which are locked"
            }, 
            "multi": {
                "docstring": "list each currently existing element of a multi-attribute"
            }, 
            "output": {
                "docstring": "List only the attributes which are numeric or which are compounds of numeric attributes."
            }, 
            "ramp": {
                "docstring": "list only attributes which are ramps"
            }, 
            "read": {
                "docstring": "list only attributes which are readable"
            }, 
            "readOnly": {
                "docstring": "List only the attributes which are readable and not writable."
            }, 
            "scalar": {
                "docstring": "only list scalar numerical attributes"
            }, 
            "scalarAndArray": {
                "docstring": "only list scalar and array attributes"
            }, 
            "settable": {
                "docstring": "list attribute which are settable"
            }, 
            "shortNames": {
                "docstring": "list short attribute names (default is to list long names)"
            }, 
            "string": {
                "docstring": "List only the attributes that match the other criteria AND match the string(s) passed from this flag. String can be a regular expression."
            }, 
            "unlocked": {
                "docstring": "list only attributes which are unlocked"
            }, 
            "usedAsFilename": {
                "docstring": "list only attributes which are designated to be treated as filenamesFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "userDefined": {
                "docstring": "list user-defined (dynamic) attributes"
            }, 
            "visible": {
                "docstring": "only show visible or non-hidden attributes"
            }, 
            "write": {
                "docstring": "list only attributes which are writable"
            }
        }
    }, 
    "listAttrPatterns": {
        "description": "Attribute patterns are plain text descriptions of an entire Maya attribute forest. (\"forest\" because there could be an arbitrary number of root level attributes, it's not restricted to having a single common parent though in general that practice is a good idea.) This command lists the various pattern types available, usually created via plugin, as well as any specific patterns that have already been instantiated. A pattern type is a thing that knows how to take some textual description of an attribute tree, e.g. XML or plaintext, and convert it into an attribute pattern that can be applied to any node or node type in Maya. ", 
        "flags": {
            "patternType": {
                "docstring": "If turned on then show the list of pattern types rather than actual instantiated patterns."
            }, 
            "verbose": {
                "docstring": "If turned on then show detailed information about the patterns or pattern types. The same list of instance or pattern names is returned as for the non-verbose case.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "listCameras": {
        "description": "Command to list all cameras. If no flags are given, both perspective and orthographic cameras will be displayed. This command returns an array of camera names. When the transform name uniquely identifies the camera it is used, otherwise the shape name will be returned. ", 
        "flags": {
            "orthographic": {
                "docstring": "Display all orthographic cameras.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "perspective": {
                "docstring": "Display all perspective cameras."
            }
        }
    }, 
    "listConnections": {
        "description": "This command returns a list of all attributes/objects of a specified type that are connected to the given object(s). If no objects are specified then the command lists the connections on selected nodes. ", 
        "flags": {
            "connections": {
                "docstring": "If true, return both attributes involved in the connection. The one on the specified object is given first. Default false."
            }, 
            "destination": {
                "docstring": "Give the attributes/objects that are on the \"destination\" side of connection to the given object. Default true."
            }, 
            "exactType": {
                "docstring": "When set to true, -t/type only considers node of this exact type. Otherwise, derived types are also taken into account."
            }, 
            "plugs": {
                "docstring": "If true, return the connected attribute names; if false, return the connected object names only. Default false;"
            }, 
            "shapes": {
                "docstring": "Actually return the shape name instead of the transform when the shape is \"selected\". Default false."
            }, 
            "skipConversionNodes": {
                "docstring": "If true, skip over unit conversion nodes and return the node connected to the conversion node on the other side. Default false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "source": {
                "docstring": "Give the attributes/objects that are on the \"source\" side of connection to the given object. Default true."
            }, 
            "type": {
                "docstring": "If specified, only take objects of a specified type."
            }
        }
    }, 
    "listDeviceAttachments": {
        "description": "This command lists the current set of device attachments. The listing is in the form of the commands required to recreate them. This includes both attachments and device mappings. ", 
        "flags": {
            "attribute": {
                "docstring": "specify the attribute attachments to list"
            }, 
            "axis": {
                "docstring": "specify the axis attachments to list"
            }, 
            "clutch": {
                "docstring": "List only attachment clutched with this button"
            }, 
            "device": {
                "docstring": "specify which device attachments to list"
            }, 
            "file": {
                "docstring": "Specify the name of the file to write out device attachments.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "selection": {
                "docstring": "This flag list only attachments on selection"
            }, 
            "write": {
                "docstring": "Write out device attachments to a file specified by the -f flag, is set. If -f is not set, it'll write out to a file named for the device."
            }
        }
    }, 
    "listHistory": {
        "description": "This command traverses backwards or forwards in the graph from the specified node and returns all of the nodes whose construction history it passes through. The construction history consists of connections to specific attributes of a node defined as the creators and results of the node's main data, eg. the curve for a Nurbs Curve node. For information on history connections through specific plugs use the \"listConnections\" command first to find where the history begins then use this command on the resulting node. ", 
        "flags": {
            "allConnections": {
                "docstring": "If specified, the traversal that searches for the history or future will not restrict its traversal across nodes to only dependent plugs. Thus it will reach all upstream nodes (or all downstream nodes for f/future)."
            }, 
            "allFuture": {
                "docstring": "If listing the future, list all of it. Otherwise if a shape has an attribute that represents its output geometry data, and that plug is connected, only list the future history downstream from that connection."
            }, 
            "allGraphs": {
                "docstring": "By default, the traversal will remain in the current graph. If this flag is set to true, the traversal will descend into subgraphs, and ascend into parent graphs."
            }, 
            "breadthFirst": {
                "docstring": "The breadth first traversal will return the closest nodes in the traversal first. The depth first traversal will follow a complete path away from the node, then return to any other paths from the node. Default is depth first."
            }, 
            "future": {
                "docstring": "List the future instead of the history."
            }, 
            "futureLocalAttr": {
                "docstring": "This flag allows querying of the local-space future-related attribute(s) on shape nodes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "futureWorldAttr": {
                "docstring": "This flag allows querying of the world-space future-related attribute(s) on shape nodes."
            }, 
            "groupLevels": {
                "docstring": "The node names are grouped depending on the level. 1 is the lead, the rest are grouped with it."
            }, 
            "historyAttr": {
                "docstring": "This flag allows querying of the attribute where history connects on shape nodes."
            }, 
            "interestLevel": {
                "docstring": "If this flag is set, only nodes whose historicallyInteresting attribute value is not less than the value will be listed. The historicallyInteresting attribute is 0 on nodes which are not of interest to non-programmers. 1 for the TDs, 2 for the users."
            }, 
            "leaf": {
                "docstring": "If transform is selected, show history for its leaf shape. Default is true."
            }, 
            "levels": {
                "docstring": "Levels deep to traverse. Setting the number of levels to 0 means do all levels. All levels is the default."
            }, 
            "pruneDagObjects": {
                "docstring": "If this flag is set, prune at dag objects."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "listInputDeviceAxes": {
        "description": "This command lists all of the axes of the specified input device. ", 
        "flags": {}
    }, 
    "listInputDeviceButtons": {
        "description": "This command lists all of the buttons of the specified input device specified as an argument. ", 
        "flags": {}
    }, 
    "listInputDevices": {
        "description": "This command lists all input devices that maya knows about. ", 
        "flags": {
            "free": {
                "docstring": ""
            }, 
            "primary": {
                "docstring": ""
            }, 
            "secondary": {
                "docstring": ""
            }
        }
    }, 
    "listNodeTypes": {
        "description": "Lists dependency node types satisfying a specified classification string. See the 'getClassification' command for a list of the standard classification strings. ", 
        "flags": {
            "exclude": {
                "docstring": "Nodes that satisfies this exclude classification will be filtered out.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "listRelatives": {
        "description": "This command lists parents and children of DAG objects. The flags -c/children, -ad/allDescendents, -s/shapes, -p/parent and -ap/allParents are mutually exclusive. Only one can be used in a command. When listing parents of objects directly under the world, the command will return an empty parent list. Listing parents of objects directly under a shape (underworld objects) will return their containing shape node in the list of parents. Listing parents of components of objects will return the object. When listing children, shape nodes will return their underworld objects in the list of children. Listing children of components of objects returns nothing. The -ni/noIntermediate flag works with the -s/shapes flag. It causes any intermediate shapes among the descendents to be ignored. ", 
        "flags": {
            "allDescendents": {
                "docstring": "Returns all the children, grand-children etc. of this dag node. If a descendent is instanced, it will appear only once on the list returned. Note that it lists grand-children before children."
            }, 
            "allParents": {
                "docstring": "Returns all the parents of this dag node. Normally, this command only returns the parent corresponding to the first instance of the object"
            }, 
            "children": {
                "docstring": "List all the children of this dag node (default)."
            }, 
            "fullPath": {
                "docstring": "Return full pathnames instead of object names."
            }, 
            "noIntermediate": {
                "docstring": "No intermediate objects"
            }, 
            "parent": {
                "docstring": "Returns the parent of this dag node"
            }, 
            "path": {
                "docstring": "Return a proper object name that can be passed to other commands."
            }, 
            "shapes": {
                "docstring": "List all the children of this dag node that are shapes (ie, not transforms)"
            }, 
            "type": {
                "docstring": "List all relatives of the specified type.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "listSets": {
        "description": "The listSets command is used to get a list of all the sets an object belongs to. To get sets of a specific type for an object use the type flag as well. To get a list of all sets in the scene then don't use an object in the command line but use one of the flags instead. ", 
        "flags": {
            "allSets": {
                "docstring": "Returns all sets in the scene."
            }, 
            "extendToShape": {
                "docstring": "When requesting a transform's sets also walk down to the shape immediately below it for its sets."
            }, 
            "object": {
                "docstring": "Returns all sets which this object is a member of.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "type": {
                "docstring": "Returns all sets in the scene of the given type: 1 - all rendering sets2 - all deformer sets"
            }
        }
    }, 
    "loadFluid": {
        "description": "A command to set builtin fluid attributes such as Density, Velocity, etc for all cells in the grid from the initial state cache In query mode, return type is based on queried flag.", 
        "flags": {
            "currentTime": {
                "docstring": "This flag is now obsolete. Move the cache clip in the Trax editor to view different frames of the playback cache."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "frame": {
                "docstring": "This flag is now obsolete. Move the cache clip in the Trax editor to view different frames of the playback cache.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "initialConditions": {
                "docstring": "load initial conditions cache"
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "loadPlugin": {
        "description": "Load plug-ins into Maya. The parameter(s) to this command are either the names or pathnames of plug-in files. The convention for naming plug-ins is to use a .so extension on Linux, a .mll extension on Windows and .bundle extension on Mac OS X. If no extension is provided then the default extension for the platform will be used. To load a Python plugin you must explicitly supply the '.py' extension. If the plugin was specified with a pathname then that is where the plugin will be searched for. If no pathname was provided then the current working directory (i.e. the one returned by Maya's 'pwd' command) will be searched, followed by the directories in the MAYA_PLUG_IN_PATH environment variable. When the plug-in is loaded, the name used in Maya's internal plug-in registry for the plug-in information will be the file name with the extension removed. For example, if you load the plug-in \"newNode.mll\" the name used in the Maya's registry will be \"newNode\". This value as well as that value with either a \".so\", \".mll\" or \".bundle\" extension can be used as valid arguments to either the unloadPlugin or pluginInfo commands. ", 
        "flags": {
            "addCallback": {
                "docstring": "Add a MEL or Python callback script to be called after a plug-in is loaded. For MEL, the procedure should have the following signature: global proc procedureName(string $pluginName). For Python, you may specify either a script as a string, or a Python callable object such as a function. If you specify a string, then put the formatting specifier \"%s\" where you want the name of the plug-in to be inserted. If you specify a callable such as a function, then the name of the plug-in will be passed as an argument."
            }, 
            "allPlugins": {
                "docstring": "Cause all plug-ins in the search path specified in MAYA_PLUG_IN_PATH to be loaded."
            }, 
            "name": {
                "docstring": "Set a user defined name for the plug-ins that are loaded. If the name is already taken, then a number will be added to the end of the name to make it unique."
            }, 
            "qObsolete": {
                "docstring": ""
            }, 
            "quiet": {
                "docstring": "Don't print a warning if you attempt to load a plug-in that is already loaded."
            }, 
            "removeCallback": {
                "docstring": "Removes a procedure which was previously added with -addCallback.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "loadPrefObjects": {
        "description": "This command loads preference dependency nodes from \"userPrefObjects.ma\", if it exists, from the user preference directory. ", 
        "flags": {}
    }, 
    "loadUI": {
        "description": "loadUI command allows loading of a user interface created in Trolltech Qt Designer.Some Qt classes have equivalents in Maya. If a widget's class is recognized, the Maya-equivelent will be created instead.Any dynamic properties on a widget which start with a '-' character will be treated as a MEL flag/value pair. Similarly, any which start with a '+' will be treated as a Python flag/value pair. Such pairs will be applied to the widget upon creation. ", 
        "flags": {
            "listTypes": {
                "docstring": "Returns the list of recognized UI types and their associated Maya command.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "uiFile": {
                "docstring": "Full path to a user interface file to load."
            }, 
            "uiString": {
                "docstring": "Load UI from a formated string."
            }, 
            "verbose": {
                "docstring": "Extra information about created controls will be printed."
            }, 
            "workingDirectory": {
                "docstring": "Sets the working directory, the loader looks for resources such as icons and resouce files in paths relative to this directory."
            }
        }
    }, 
    "lockNode": {
        "description": "Locks or unlocks one or more dependency nodes. A locked node is restricted in the following ways: It may not be deleted.It may not be renamed.Its parenting may not be changed.Attributes may not be added to or removed from it.Locked attributes may not be unlocked.Unlocked attributes may not be locked.Note that an unlocked attribute of a locked node may still have its value set, or connections to it made or broken. For more information on attribute locking, see the setAttrcommand. If no node names are specified then the current selection list is used. There are a few special behaviors when locking containers. Containers are automatically expanded to their constituent objects. When a container is locked, members of the container may not be unlocked and the container membership may not be modified. Containers may also be set to lock unpublished attributes. When in this state, unpublished member attributes may not have existing connections broken, new connections cannot be made, and values on unconnected attributes may not be modified. Parenting is allowed to change on members of locked containers that have been published as parent or child anchors. ", 
        "flags": {
            "ignoreComponents": {
                "docstring": "Normally, the presence of a component in the list of objects to be locked will cause the command to fail with an error. But if this flag is supplied then components will be silently ignored."
            }, 
            "lock": {
                "docstring": "Specifies the new lock state for the node. The default is true."
            }, 
            "lockUnpublished": {
                "docstring": "Used in conjunction with the lock flag. On a container, lock or unlock all unpublished attributes on the members of the container. For non-containers, lock or unlock unpublished attributes on the specified node.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "loft": {
        "description": "This command computes a skinned (lofted) surface passing through a number of NURBS curves. There must be at least two curves present. The NURBS curves may be surface isoparms, curve on surfaces, trimmed edges or polygon edges. ", 
        "flags": {
            "autoReverse": {
                "docstring": "If set to true, the direction of the curves for the loft is computed automatically. If set to false, the values of the multi-use reverse flag are used instead.Default:true"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "close": {
                "docstring": "If set to true, the resulting surface will be closed (periodic) with the start (end) at the first curve. If set to false, the surface will remain open.Default:false"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "createCusp": {
                "docstring": "Multi-use flag; each occurence of the flag refers to the matching curve in the loft operation; if the flag is set the particular profile will have a cusp (tangent break) in the resulting surface.Default:falseAdvanced flags"
            }, 
            "degree": {
                "docstring": "The degree of the resulting surfaceDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curve"
            }, 
            "rebuild": {
                "docstring": "Rebuild the input curve(s) before using them in the operation. Use nurbsCurveRebuildPref to set the parameters for the conversion.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reverse": {
                "docstring": "Multi-use flag; each occurence of the flag refers to the matching curve in the loft operation; if the flag is set the particular curve will be reversed before being used in the loft operation.Default:false"
            }, 
            "reverseSurfaceNormals": {
                "docstring": "If set, the surface normals on the output NURBS surface will be reversed. This is accomplished by swapping the U and V parametric directions.Default:false"
            }, 
            "sectionSpans": {
                "docstring": "The number of surface spans between consecutive curves in the loft.Default:1"
            }, 
            "uniform": {
                "docstring": "If set to true, the resulting surface will have uniform parameterization in the loft direction. If set to false, the parameterization will be chord length.Default:false"
            }
        }
    }, 
    "lookThru": {
        "description": "This command sets a particular camera to look through in a view. This command may also be used to view the negative z axis of lights or other DAG objects. The standard camera tools can then be used to place the object. Note: if there are multiple objects under the transform selected, cameras and lights take precedence. In query mode, return type is based on queried flag.", 
        "flags": {
            "farClip": {
                "docstring": "Used when setting clip far plane for a new look thru camera. Will not affect the attributes of an existing camera. Clip values must come before shape or view.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "nearClip": {
                "docstring": "Used when setting near clip plane for a new look thru camera. Will not affect the attributes of an existing camera. Clip values must come before shape or view."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "ls": {
        "description": "The lscommand returns the names (and optionally the type names) of objects in the scene. The most common use of lsis to filter or match objects based on their name (using wildcards) or based on their type. By default lswill match any object in the scene but it can also be used to filter or list the selected objects when used in conjunction with the -selection flag. If type names are requested, using the -showType flag, they will be interleaved with object names so the result will be pairs of object, typevalues. Internal nodes (for example itemFilter nodes) are typically filtered so that only scene objects are returned. However, using a wildcard will cause all the nodes matching the wild card to show up, including internal nodes. For example, ls \\*will list all nodes whether internal or not. When Maya is in relativeNames mode, the lscommand will return names relativeto the current namespace and ls \\*will list from the the current namespace. For more details, please refer to the -relativeNamesflag of the namespacecommand. ", 
        "flags": {
            "absoluteName": {
                "docstring": ""
            }, 
            "allPaths": {
                "docstring": "List all paths to nodes in DAG. This flag only works if -dagis also specified or if an object name is supplied."
            }, 
            "assemblies": {
                "docstring": "List top level transform Dag objects"
            }, 
            "cameras": {
                "docstring": "List camera shapes."
            }, 
            "containerType": {
                "docstring": "List containers with the specified user-defined type.This flag cannot be used in conjunction with the -type or -exactType flag."
            }, 
            "containers": {
                "docstring": "List containers. Includes both standard containers as well as other types of containers such as dagContainers.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dagObjects": {
                "docstring": "List Dag objects of any type. If object name arguments are passed to the command then this flag will list all Dag objects below the specified object(s)."
            }, 
            "dependencyNodes": {
                "docstring": "List dependency nodes. (including Dag objects)"
            }, 
            "exactType": {
                "docstring": "List all objects of the specified type, but notobjects that are descendents of that type. This flag can appear multiple times on the command line. Note: the type passed to this flag is the same type name returned from the -showType flag.This flag cannot be used in conjunction with the -type or -excludeType flag."
            }, 
            "excludeType": {
                "docstring": "List all objects that are not of the specified type. This flag can appear multiple times on the command line. Note: the type passed to this flag is the same type name returned from the -showType flag.This flag cannot be used in conjunction with the -type or -exactType flag."
            }, 
            "flatten": {
                "docstring": "Flattens the returned list of objects so that each component is identified individually."
            }, 
            "geometry": {
                "docstring": "List geometric Dag objects."
            }, 
            "ghost": {
                "docstring": "List ghosting objects."
            }, 
            "head": {
                "docstring": "This flag specifies the maximum number of elements to be returned from the beginning of the list of items. Note: each type flag will return at most this many items so if multiple type flags are specified then the number of items returned can be greater than this amount."
            }, 
            "hilite": {
                "docstring": "List objects that are currently hilited for component selection."
            }, 
            "intermediateObjects": {
                "docstring": "List only intermediate dag nodes."
            }, 
            "invisible": {
                "docstring": "List only invisible dag nodes."
            }, 
            "leaf": {
                "docstring": "List all leaf nodes in Dag. This flag is a modifier and must be used in conjunction with the -dag flag."
            }, 
            "lights": {
                "docstring": "List light shapes."
            }, 
            "live": {
                "docstring": "List objects that are currently live."
            }, 
            "lockedNodes": {
                "docstring": "Returns locked nodes, which cannot be deleted or renamed. However, their status may change."
            }, 
            "long": {
                "docstring": "Return full path names for Dag objects. By default the shortest unique name is returned."
            }, 
            "materials": {
                "docstring": "List materials or shading groups."
            }, 
            "modified": {
                "docstring": "When this flag is set, only nodes modified since the last save will be returned."
            }, 
            "noIntermediate": {
                "docstring": "List only non intermediate dag nodes."
            }, 
            "nodeTypes": {
                "docstring": "Lists all registered node types."
            }, 
            "objectsOnly": {
                "docstring": "When this flag is set only object names will be returned and components/attributes will be ignored."
            }, 
            "orderedSelection": {
                "docstring": "List objects and components that are currently selected in their order of selection. This flag depends on the value of the -tso/trackSelectionOrder flag of the selectPref command. If that flag is not enabled than this flag will return the same thing as the -sl/selection flag would."
            }, 
            "partitions": {
                "docstring": "List partitions."
            }, 
            "persistentNodes": {
                "docstring": "Returns persistent nodes, which are nodes that stay in the Maya session after a file new."
            }, 
            "planes": {
                "docstring": "List construction plane shapes."
            }, 
            "preSelectHilite": {
                "docstring": "List components that are currently hilited for pre-selection."
            }, 
            "readOnly": {
                "docstring": "Returns referenced nodes. Referenced nodes are read only. NOTE: Obsolete. Please use \"-referencedNodes\"."
            }, 
            "recursive": {
                "docstring": "When set to true, this command will look for name matches in all namespaces. When set to false, this command will only look for matches in namespaces that are requested (e.g. by specifying a name containing the ':'... \"ns1:pSphere1\")."
            }, 
            "referencedNodes": {
                "docstring": "Returns referenced nodes. Referenced nodes are read only."
            }, 
            "references": {
                "docstring": "List references associated with files. Excludes special reference nodes such as the sharedReferenceNode and unknown reference nodes."
            }, 
            "renderGlobals": {
                "docstring": "List render globals."
            }, 
            "renderQualities": {
                "docstring": "List named render qualities."
            }, 
            "renderResolutions": {
                "docstring": "List render resolutions."
            }, 
            "renderSetups": {
                "docstring": "Alias for -renderGlobals."
            }, 
            "selection": {
                "docstring": "List objects that are currently selected."
            }, 
            "sets": {
                "docstring": "List sets."
            }, 
            "shapes": {
                "docstring": "List shape objects."
            }, 
            "shortNames": {
                "docstring": "Return short attribute names. By default long attribute names are returned."
            }, 
            "showNamespace": {
                "docstring": "Show the namespace of each object after the object name This flag can not be used with showType together, you can choose only one of them"
            }, 
            "showType": {
                "docstring": "List the type of each object after its name."
            }, 
            "tail": {
                "docstring": "This flag specifies the maximum number of elements to be returned from the end of the list of items. Note: each type flag will return at most this many items so if multiple type flags are specified then the number of items returned can be greater than this amount"
            }, 
            "templated": {
                "docstring": "List only templated dag nodes."
            }, 
            "textures": {
                "docstring": "List textures."
            }, 
            "transforms": {
                "docstring": "List transform objects."
            }, 
            "type": {
                "docstring": "List all objects of the specified type. This flag can appear multiple times on the command line. Note: the type passed to this flag is the same type name returned from the -showType flag. Note: some selection items in Maya do not have a specific object/data type associated with them and will return \"untyped\" when listed with this flag.This flag cannot be used in conjunction with the -exactType or -excludeType flag."
            }, 
            "undeletable": {
                "docstring": "Returns nodes that cannot be deleted (which includes locked nodes). These nodes also cannot be renamed."
            }, 
            "untemplated": {
                "docstring": "List only un-templated dag nodes."
            }, 
            "visible": {
                "docstring": "List only visible dag nodes."
            }
        }
    }, 
    "lsThroughFilter": {
        "description": "List all objects in the world that pass a given filter. ", 
        "flags": {
            "item": {
                "docstring": "Run the filter on specified node(s), using the fast version of this command."
            }, 
            "nodeArray": {
                "docstring": "Fast version that runs an entire array of nodes through the filter at one time."
            }, 
            "reverse": {
                "docstring": "Only available in conjunction with nodeArray flag. Reverses the order of nodes in the returned arrays if true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "selection": {
                "docstring": "Run the filter on selected nodes only, using the fast version of this command."
            }, 
            "sort": {
                "docstring": "Only available in conjunction with nodeArray flag. Orders the nodes in the returned array. Current options are: \"byName\", \"byType\", and \"byTime\"."
            }
        }
    }, 
    "lsUI": {
        "description": "This command returns the names of UI objects. ", 
        "flags": {
            "cmdTemplates": {
                "docstring": "UI command templates created using ELF UI commands.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "collection": {
                "docstring": "Control collections created using ELF UI commands."
            }, 
            "contexts": {
                "docstring": "Tool contexts created using ELF UI commands."
            }, 
            "controlLayouts": {
                "docstring": "Control layouts created using ELF UI commands [e.g. formLayouts, paneLayouts, etc.]"
            }, 
            "controls": {
                "docstring": "Controls created using ELF UI commands. [e.g. buttons, checkboxes, etc]"
            }, 
            "dumpWidgets": {
                "docstring": "Dump all QT widgets used by Maya."
            }, 
            "editors": {
                "docstring": "All currently existing editors."
            }, 
            "head": {
                "docstring": "The parameter specifies the maximum number of elements to be returned from the beginning of the list of items. (Note: each flag will return at most this many items so if multiple flags are specified then the number of items returned will be greater than the value specified)."
            }, 
            "long": {
                "docstring": "Use long pathnames instead of short non-path names."
            }, 
            "menuItems": {
                "docstring": "Menu items created using ELF UI commands."
            }, 
            "menus": {
                "docstring": "Menus created using ELF UI commands."
            }, 
            "numWidgets": {
                "docstring": "Reports the number of QT widgets used by Maya."
            }, 
            "panels": {
                "docstring": "All currently existing panels."
            }, 
            "radioMenuItemCollections": {
                "docstring": "Menu item collections created using ELF UI commands."
            }, 
            "tail": {
                "docstring": "The parameter specifies the maximum number of elements to be returned from the end of the list of items. (Note: each flag will return at most this many items so if multiple flags are specified then the number of items returned will be greater than the value specified)."
            }, 
            "type": {
                "docstring": "List all objects of a certain type specified by the string argument. For example, \"window\", \"menu\", \"control\", or \"controlLayout\"."
            }, 
            "windows": {
                "docstring": "Windows created using ELF UI commands."
            }
        }
    }, 
    "makeIdentity": {
        "description": "The makeIdentity command is a quick way to reset the selected transform and all of its children down to the shape level by the identity transformation. You can also specify which of transform, rotate or scale is applied down from the selected transform. The identity transformation means: translate = 0, 0, 0rotate = 0, 0, 0scale = 1, 1, 1shear = 1, 1, 1If a transform is a joint, then the \"translate\" attribute may not be 0, but will be used to position the joints so that they preserve their world space positions. The translate flag doesn't apply to joints, since joints must preserve their world space positions. Only the rotate and scale flags are meaningful when applied to joints. If the -a/apply flag is true, then the transforms that are reset are accumulated and applied to the all shapes below the modified transforms, so that the shapes will not move. The pivot positions are recalculated so that they also will not move in world space. If this flag is false, then the transformations are reset to identity, without any changes to preserve position. ", 
        "flags": {
            "apply": {
                "docstring": "If this flag is true, the accumulated transforms are applied to the shape after the transforms are made identity, such that the world space positions of the transforms pivots are preserved, and the shapes do not move. The default is false."
            }, 
            "jointOrient": {
                "docstring": "If this flag is set, the joint orient on joints will be reset to align with worldspace."
            }, 
            "normal": {
                "docstring": "If this flag is set to 1, the normals on polygonal objects will be frozen. This flag is valid only when the -apply flag is on. If this flag is set to 2, the normals on polygonal objects will be frozen only if its a non-rigid transformation matrix. ie, a transformation that does not contain shear, skew or non-proportional scaling. The default behaviour is not to freeze normals.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "rotate": {
                "docstring": "If this flag is true, only the rotation is applied to the shape. The rotation will be changed to 0, 0, 0. If neither translate nor rotate nor scale flags are specified, then all (t, r, s) are applied."
            }, 
            "scale": {
                "docstring": "If this flag is true, only the scale is applied to the shape. The scale factor will be changed to 1, 1, 1. If neither translate nor rotate nor scale flags are specified, then all (t, r, s) are applied."
            }, 
            "translate": {
                "docstring": "If this flag is true, only the translation is applied to the shape. The translation will be changed to 0, 0, 0. If neither translate nor rotate nor scale flags are specified, then all (t, r, s) are applied. (Note: the translate flag is not meaningful when applied to joints, since joints are made to preserve their world space position. This flag will have no effect on joints.)"
            }
        }
    }, 
    "makeLive": {
        "description": "This commmand makes an object live. A live object defines the surface on which to create objects and to move object relative to. Only construction planes, nurbs surfaces and polygon meshes can be made live. The makeLive command expects one of these types of objects as an explicit argument. If no argument is explicitly specified, then there are a number of default behaviours based on what is currently active. The command will fail if there is more than one object active or the active object is not one of the valid types of objects. If there is nothing active, the current live object will become dormant. Otherwise, the active object will become the live object. ", 
        "flags": {
            "none": {
                "docstring": "If the -n/none flag, the live object will become dormant. Use of this flag causes any arguments to be ignored.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "makePaintable": {
        "description": "Make attributes of nodes paintable to Attribute Paint Tool. This command is used to register new attributes to the Attribute Paint tool as paintable. Once registered the attributes will be recognized by the Attribute Paint tool and the user will be able to paint them. In query mode, return type is based on queried flag.", 
        "flags": {
            "activate": {
                "docstring": "Activate / deactivate the given paintable attribute. Used to filter out some nodes in the attribute paint tool."
            }, 
            "activateAll": {
                "docstring": "Activate / deactivate all the registered paintable attributes. Used to filter out some nodes in the attribute paint tool.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "altAttribute": {
                "docstring": "Define an alternate attribute which will also receive the same values. There can be multiple such flags."
            }, 
            "attrType": {
                "docstring": "Paintable attribute type. Supported types: intArray, doubleArray, vectorArray, multiInteger, multiFloat, multiDouble, multiVector."
            }, 
            "clearAll": {
                "docstring": "Removes all paintable attribute definitions."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Make the attribute not paintable any more."
            }, 
            "shapeMode": {
                "docstring": "This flag controls how Artisan correlates the paintable node to a corresponding shape node. It is used for attributes of type multi of multi, where the first multi dimension corresponds to the shape index (i.e. cluster nodes). At present, only one value of this flag is supported: \"deformer\". By default this flag is an empty string, which means that there is a direct indexing (no special mapping required) of the attribute with respect to vertices on the shape."
            }, 
            "uiName": {
                "docstring": "UI name. Default is the attribute name."
            }
        }
    }, 
    "makeSingleSurface": {
        "description": "This command performs a stitch and tessellate operation ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "chordHeight": {
                "docstring": "Chord height is the absolute distance in OBJECT space which the center of a polygon edge can deviate from the actual center of the surface span. Only used if Format is General and if useChordHeight is true.Default:0.1"
            }, 
            "chordHeightRatio": {
                "docstring": "Chord height ratio is the ratio of the chord length of a surface span to the chord height. (This is a length to height ratio). 0 is a very loose fit. 1 is a very tight fit. (See also description of chord height.) Always used if Format is Standard Fit. Otherwise, only used if Format is General and useChordHeightRatio is true.Default:0.9"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "delta": {
                "docstring": "3D delta. Only used if Format is Standard Fit.Default:0.1"
            }, 
            "edgeSwap": {
                "docstring": "Edge swap. This attribute enables an algorithm which determines the optimal method with which to tessellate a quadrilateral into triangles. Only used if Format is General.Default:false"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "format": {
                "docstring": "Format: 0 - Triangle Count, 1 - Standard Fit, 2 - General, 3 - CVsDefault:1"
            }, 
            "fractionalTolerance": {
                "docstring": "Fractional tolerance. Only used if Format is Standard Fit.Default:0.01"
            }, 
            "matchNormalDir": {
                "docstring": "Only used when the format is CVs. Order the cvs so that the normal matches the direction of the original surface if set to true.Default:false"
            }, 
            "minEdgeLength": {
                "docstring": "Minimal edge length. Only used if Format is Standard Fit.Default:0.001"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "normalizeTrimmedUVRange": {
                "docstring": "This attribute is only applicable when a trimmed NURBS surface is used as the input surface. When true, the UV texture coordinates on the trimmed input surface are normalized and applied to the output surface as they are for the untrimmed version of the input surface. (The texture coordinates on the entire untrimmed surface are mapped to the entire output surface.) When false, the UV texture coordinates on the trimmed input surface are applied to the output surface as they are for the trimmed input surface. (Only the texture coordinates visible on the trimmed input surface are mapped to the output surface.)Default:true"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency nodeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "polygonCount": {
                "docstring": "The number of polygons to produce. Only used if Format is Triangle Count.Default:200"
            }, 
            "polygonType": {
                "docstring": "Polygon type: 0 - Triangles, 1 - QuadsDefault:0"
            }, 
            "query": {
                "docstring": ""
            }, 
            "stitchTolerance": {
                "docstring": "Stitch tolerance.Default:0.1"
            }, 
            "uNumber": {
                "docstring": "Initial number of isoparms in U. Used in conjunction with the uType attribute. Only used if Format is General.Default:3"
            }, 
            "uType": {
                "docstring": "Initial U type tessellation criteria (3 types). Type 0 - Per surface # of isoparms in 3D. This type places a specific number of iso-parametric subdivision lines across the surface, equally spaced in 3D space. Type 1 - Per surface # of isoparms. This type places a specific number of iso-parametric subdivision lines across the surface, equally spaced in parameter space. Type 2 - Per span # of isoparms. This type places a specific number of iso-parametric subdivision lines across each surface span, equally spaced in parameter space. (This is the closest option to the Alias Studio tessellation parameters.) This attribute is only used if Format is General.Default:3"
            }, 
            "useChordHeight": {
                "docstring": "True means use chord height. Only used if Format is General.Default:false"
            }, 
            "useChordHeightRatio": {
                "docstring": "True means use chord height ratio.Default:true"
            }, 
            "vNumber": {
                "docstring": "Initial number of isoparms in V. Used in conjunction with the vType attribute. Only used if Format is General.Default:3"
            }, 
            "vType": {
                "docstring": "Initial V type tessellation criteria (3 types). See description for the uType attribute. Only used if Format is General.Default:3"
            }
        }
    }, 
    "makebot": {
        "description": "The makebot command takes an image file and produces a block ordered texture (BOT) file, to be used for texture caching. If a relative pathname is specified for the input image file, project management rules apply. If a relative pathname is specified for the output BOT file, project management rules apply and gets put into the sourceImages directory. ", 
        "flags": {
            "checkdepends": {
                "docstring": "the BOT file should only be generated if it doesn't already exists, or if it is older than the source file"
            }, 
            "checkres": {
                "docstring": "the BOT file should only be generated if its resolution (maximum of width and height) is larger than the minimum value specified by the argument"
            }, 
            "input": {
                "docstring": "input image file"
            }, 
            "nooverwrite": {
                "docstring": "If -c and/or -r indicate that the BOT file should be generated but if already exists, then this flag will prevent the file from being overwritten"
            }, 
            "output": {
                "docstring": "output BOT file"
            }, 
            "verbose": {
                "docstring": "Makebot will provide feedback if this flag is specifiedFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "manipMoveContext": {
        "description": "This command can be used to create, edit, or query a move manip context. Note that the flags -s, -sv, -sr, -scr, -slp, -slf control the global behaviour of all move manip context. Changing one context independently is not allowed. Changing a context's behaviour using the above flags, will change all existing move manip context. ", 
        "flags": {
            "activeHandle": {
                "docstring": "Sets the default active handle for the manip. That is, the handle which should be initially active when the tool is activated. Values can be: 0 - X axis handle is active1 - Y axis handle is active2 - Z axis handle is active3 - Center handle (all 3 axes) is active (default)"
            }, 
            "activeHandleNormal": {
                "docstring": "0 - U axis handle is active1 - V axis handle is active2 - N axis handle is active ( default )3 - Center handle (all 3 axes) is activeapplicable only when the manip mode is 3."
            }, 
            "alignAlong": {
                "docstring": "Aligns active handle along vector."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editPivotMode": {
                "docstring": "Returns true manipulator is in edit pivot modeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "editPivotPosition": {
                "docstring": "Returns the current position of the edit pivot manipulator."
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "interactiveUpdate": {
                "docstring": "Value can be : true or false. This flag value is valid only if the mode is 3 i.e. move vertex normal."
            }, 
            "mode": {
                "docstring": "Translate mode: 0 - Object Space1 - Local Space2 - World Space (default)3 - Move Along Vertex Normal4 - Move Along Rotation Axis5 - Move Along Live Object Axis6 - Custom Axis Orientation"
            }, 
            "orientAxes": {
                "docstring": "Orients manipulator rotating around axes by specified angles"
            }, 
            "orientJoint": {
                "docstring": "Specifies the type of orientation for joint orientation. Valid options are: none, xyz, xzy, yxz, yzx, zxy, zyx."
            }, 
            "orientJointEnabled": {
                "docstring": "Specifies if joints should be reoriented when moved."
            }, 
            "orientTowards": {
                "docstring": "Orients active handle towards world point"
            }, 
            "position": {
                "docstring": "Returns the current position of the manipulator"
            }, 
            "postCommand": {
                "docstring": "Specifies a command to be executed when the tool is exited."
            }, 
            "postDragCommand": {
                "docstring": "Specifies a command and a node type. The command will be executed at the end of a drag when a node of the specified type is in the selection."
            }, 
            "preCommand": {
                "docstring": "Specifies a command to be executed when the tool is entered."
            }, 
            "preDragCommand": {
                "docstring": "Specifies a command and a node type. The command will be executed at the start of a drag when a node of the specified type is in the selection."
            }, 
            "preserveChildPosition": {
                "docstring": "When false, the children objects move when their parent is moved. When true, the worldspace position of the children will be maintained as the parent is moved. Default is false."
            }, 
            "preserveUV": {
                "docstring": "When false, the uvs are not changes to match the vertex edit. When true, the uvs are edited to project to new values to stop texture swimming as vertices are moved."
            }, 
            "query": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "reflectionAbout": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "reflectionAxis": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "reflectionTolerance": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "secondaryAxisOrient": {
                "docstring": "Specifies the global axis (in world coordinates) that should be used to should be used to align the second axis of the orientJointType triple. Valid options are xup, yup, zup, xdown, ydown, zdown, none."
            }, 
            "snap": {
                "docstring": "Value can be : true or false. Enable/Disable the discrete move. If set to true, the move manipulator of all the move contexts would snap at discrete points along the active handle during mouse drag. The interval between the points can be controlled using the 'snapValue' flag."
            }, 
            "snapComponentsRelative": {
                "docstring": "Value can be : true or false. If true, while snapping a group of CVs/Vertices, the relative spacing between them will be preserved. If false, all the CVs/Vertices will be snapped to the target point (is used during grid snap(hotkey 'x'), and point snap(hotkey 'v')) Depress the 'x' key before click-dragging the manip handle and check to see the behaviour of moving a bunch of CVs, with this flag ON and OFF."
            }, 
            "snapLiveFaceCenter": {
                "docstring": "Value can be : true or false. If true, while moving on the live polygon object, the move manipulator will snap to the face centers of the object."
            }, 
            "snapLivePoint": {
                "docstring": "Value can be : true or false. If true, while moving on the live polygon object, the move manipulator will snap to the vertices of the object."
            }, 
            "snapRelative": {
                "docstring": "Value can be : true or false. Applicable only when the snap is enabled. If true, the snapValue is treated relative to the original position before moving. If false, the snapValue is treated relative to the world origin. NOTE: If in local/object Space Mode, the snapRelative should be ON. Absolute discrete move is not supported in local/object mode."
            }, 
            "snapValue": {
                "docstring": "Applicable only when the snap is enabled. The manipulator of all move contexts would move in steps of 'snapValue'"
            }, 
            "tweakMode": {
                "docstring": ""
            }
        }
    }, 
    "manipMoveLimitsCtx": {
        "description": "Create a context for the translate limits manipulator. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "manipOptions": {
        "description": "Changes the global manipulator parameters In query mode, return type is based on queried flag.", 
        "flags": {
            "forceRefresh": {
                "docstring": "Force a refresh if there is any deferred evaluation."
            }, 
            "handleSize": {
                "docstring": "Sets the maximum handles size in pixels, for small handles"
            }, 
            "linePick": {
                "docstring": "Set the width of picking zone for long handles"
            }, 
            "lineSize": {
                "docstring": "Set the width of long handles (drawn as lines)"
            }, 
            "middleMouseRepositioning": {
                "docstring": ""
            }, 
            "pointSize": {
                "docstring": "Set the size of points (used to display previous states)"
            }, 
            "preselectHighlight": {
                "docstring": "Set whether manip handles should be highlighted when moving mouse.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "refreshMode": {
                "docstring": "Set the global refresh mode."
            }, 
            "relative": {
                "docstring": "All values are interpreted as multiplication factors instead of final values."
            }, 
            "rememberActiveHandle": {
                "docstring": ""
            }, 
            "scale": {
                "docstring": "Global scaling factor of all manipulators"
            }, 
            "showExtrudeSliders": {
                "docstring": ""
            }
        }
    }, 
    "manipRotateContext": {
        "description": "This command can be used to create, edit, or query a rotate manip context. ", 
        "flags": {
            "activeHandle": {
                "docstring": "Sets the default active handle for the manip. That is, the handle which should be initially active when the tool is activated. Values can be: 0 - X axis handle is active1 - Y axis handle is active2 - Z axis handle is active3 - View rotation handle (outer ring) is active (default)"
            }, 
            "centerTrackball": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editPivotMode": {
                "docstring": "Returns true manipulator is in edit pivot mode"
            }, 
            "editPivotPosition": {
                "docstring": "Returns the current position of the edit pivot manipulator."
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "mode": {
                "docstring": "Arcball mode (0 - Object Space (default), 1 - World Space)"
            }, 
            "position": {
                "docstring": "Returns the current position of the manipulator"
            }, 
            "postDragCommand": {
                "docstring": "Specifies a command and a node type. The command will be executed at the end of a drag when a node of the specified type is in the selection."
            }, 
            "preDragCommand": {
                "docstring": "Specifies a command and a node type. The command will be executed at the start of a drag when a node of the specified type is in the selection."
            }, 
            "preserveChildPosition": {
                "docstring": "When false, the children objects move when their parent is rotated. When true, the worldspace position of the children will be maintained as the parent is moved. Default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preserveUV": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "reflectionAbout": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "reflectionAxis": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "reflectionTolerance": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "snap": {
                "docstring": ""
            }, 
            "snapRelative": {
                "docstring": ""
            }, 
            "snapValue": {
                "docstring": ""
            }, 
            "tweakMode": {
                "docstring": ""
            }, 
            "useManipPivot": {
                "docstring": ""
            }, 
            "useObjectPivot": {
                "docstring": ""
            }
        }
    }, 
    "manipRotateLimitsCtx": {
        "description": "Create a context for the rotate limits manipulator. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "manipScaleContext": {
        "description": "This command can be used to create, edit, or query a scale manip context. ", 
        "flags": {
            "activeHandle": {
                "docstring": "Sets the default active handle for the manip. That is, the handle which should be initially active when the tool is activated. Values can be: 0 - X axis handle is active1 - Y axis handle is active2 - Z axis handle is active3 - Center handle (all axes) is active (default)"
            }, 
            "alignAlong": {
                "docstring": "Aligns active handle along vector."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editPivotMode": {
                "docstring": "Returns true manipulator is in edit pivot mode"
            }, 
            "editPivotPosition": {
                "docstring": "Returns the current position of the edit pivot manipulator."
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "mode": {
                "docstring": "Translate mode: 0 - Object Space1 - Local Space2 - World Space (default)3 - Move Along Vertex Normal4 - Move Along Rotation Axis5 - Move Along Live Object Axis6 - Custom Axis Orientation"
            }, 
            "orientAxes": {
                "docstring": "Orients manipulator rotating around axes by specified angles"
            }, 
            "orientTowards": {
                "docstring": "Orients active handle towards world point"
            }, 
            "position": {
                "docstring": "Returns the current position of the manipulator"
            }, 
            "postDragCommand": {
                "docstring": "Specifies a command and a node type. The command will be executed at the end of a drag when a node of the specified type is in the selection."
            }, 
            "preDragCommand": {
                "docstring": "Specifies a command and a node type. The command will be executed at the start of a drag when a node of the specified type is in the selection."
            }, 
            "preserveChildPosition": {
                "docstring": "When false, the children objects move when their parent is rotated. When true, the worldspace position of the children will be maintained as the parent is moved. Default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preserveUV": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "reflectionAbout": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "reflectionAxis": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "reflectionTolerance": {
                "docstring": "This flag is obsolete. Reflection is now managed as part of selection itself using the symmetricModeling command."
            }, 
            "snap": {
                "docstring": ""
            }, 
            "snapRelative": {
                "docstring": ""
            }, 
            "snapValue": {
                "docstring": ""
            }, 
            "useManipPivot": {
                "docstring": ""
            }, 
            "useObjectPivot": {
                "docstring": ""
            }
        }
    }, 
    "manipScaleLimitsCtx": {
        "description": "Create a context for the scale limits manipulator. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "marker": {
        "description": "The marker command creates one or two markers, on a motion path curve, at the specified time and location. The optionnal string argument is the parent object name.One can specify \"-pm -om\" option to create both, a position marker and an orientation marker.Since there is only one keyframe for each marker of the same type, no more than one marker of the same type with the same time value can exist.The default marker type is the position marker. The default time is the current time. ", 
        "flags": {
            "attach": {
                "docstring": "This flag specifies to attach the selected 3D position markers to their parent geometry."
            }, 
            "detach": {
                "docstring": "This flag specifies to detach the selected position markers from their parent geometry to the 3D space.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "frontTwist": {
                "docstring": "This flag specifies the amount of twist angle about the front vector for the marker.Default is 0.When queried, this flag returns a angle."
            }, 
            "orientationMarker": {
                "docstring": "This flag specifies creation of an orientation marker.Default is not set..When queried, this flag returns a boolean."
            }, 
            "positionMarker": {
                "docstring": "This flag specifies creation of a position marker.Default is set.When queried, this flag returns a boolean."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sideTwist": {
                "docstring": "This flag specifies the amount of twist angle about the side vector for the marker.Default is 0.When queried, this flag returns a angle."
            }, 
            "time": {
                "docstring": "This flag specifies the time for the marker.Default is the current time.When queried, this flag returns a time."
            }, 
            "upTwist": {
                "docstring": "This flag specifies the amount of twist angle about the up vector for the marker.Default is 0.When queried, this flag returns a angle."
            }, 
            "valueU": {
                "docstring": "This flag specifies the location of the position marker w.r.t. the parent geometry u parameterization.Default is the value at current time.When queried, this flag returns a linear."
            }
        }
    }, 
    "mateCtx": {
        "description": "", 
        "flags": {}
    }, 
    "melInfo": {
        "description": "This command returns the names of all global MEL procedures that are currently defined as a string array. The user can query the definition of each MEL procedure using the \"whatIs\" command. ", 
        "flags": {}
    }, 
    "memory": {
        "description": "Used to query essential statistics on memory availability and usage ", 
        "flags": {
            "debug": {
                "docstring": ""
            }, 
            "freeMemory": {
                "docstring": "Returns size of free memory"
            }, 
            "heapMemory": {
                "docstring": "Returns size of memory heap"
            }, 
            "kiloByte": {
                "docstring": "Defines the units to use for value displayed, kiloByte 1024"
            }, 
            "megaByte": {
                "docstring": "Defines the units to use for value displayed, megaByte 1024\\*1024"
            }, 
            "pageFaults": {
                "docstring": "Returns number of page faults"
            }, 
            "pageReclaims": {
                "docstring": "Returns number of page reclaims"
            }, 
            "physicalMemory": {
                "docstring": "Returns size of physical memory"
            }, 
            "summary": {
                "docstring": "Returns summary of memory usage"
            }, 
            "swapFree": {
                "docstring": "Returns size of free swap"
            }, 
            "swapLogical": {
                "docstring": "Returns size of logical swapFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "swapMax": {
                "docstring": "Returns maximum swap size"
            }, 
            "swapPhysical": {
                "docstring": "Returns size of physical swap"
            }, 
            "swapReserved": {
                "docstring": ""
            }, 
            "swapVirtual": {
                "docstring": "Returns size of virtual swap"
            }, 
            "swaps": {
                "docstring": "Returns number of swaps"
            }
        }
    }, 
    "menu": {
        "description": "This command creates a new menu and adds it to the default window's menubar if no parent is specified. The menu can be enabled/disabled. Note that this command may also be used on menu objects created using the command menuItem -sm/subMenu true. ", 
        "flags": {
            "allowOptionBoxes": {
                "docstring": "Deprecated. All menus now always allow option boxes. Indicate whether the menu will be able to support option box menu items."
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "deleteAllItems": {
                "docstring": "Delete all the items in this menu."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the menu.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "Enables/disables the menu."
            }, 
            "exists": {
                "docstring": ""
            }, 
            "familyImage": {
                "docstring": "The filename of the icon associated with the menu. This icon will be used if a menu item does not have an icon image defined."
            }, 
            "helpMenu": {
                "docstring": "Indicates that this menu is the help menu and will be the right most menu in the menu bar. On Unix systems the help menu is also right justified in the menu bar."
            }, 
            "itemArray": {
                "docstring": "Return string array of the menu item names."
            }, 
            "label": {
                "docstring": "The text that is displayed for the menu. If no label is supplied then the menuName will be used."
            }, 
            "mnemonic": {
                "docstring": "Set the Alt key to post that menu. The character specified must match the case of its corresponding character in the menu item text, but selection from the keyboard is case insensitive."
            }, 
            "numberOfItems": {
                "docstring": "Return number of items in the menu."
            }, 
            "parent": {
                "docstring": "Specify the window that the menu will appear in."
            }, 
            "postMenuCommand": {
                "docstring": "Specify a script to be executed when the menu is about to be shown."
            }, 
            "postMenuCommandOnce": {
                "docstring": "Indicate the -pmc/postMenuCommandshould only be invoked once. Default value is false, ie. the -pmc/postMenuCommandis invoked every time the menu is shown."
            }, 
            "query": {
                "docstring": ""
            }, 
            "tearOff": {
                "docstring": "Makes the menu tear-off-able."
            }, 
            "useTemplate": {
                "docstring": ""
            }, 
            "visible": {
                "docstring": ""
            }
        }
    }, 
    "menuBarLayout": {
        "description": "Create a layout containing a menu bar. The menu bar will appear and behave similar to any menu bar created with the 'window -menuBar true' command. Menus may be created with a menuBarLayout as their parent. Child controls are simply positioned to fill the menuBarLayout area beneath the menu bar consequently, some other layout should be used as the immediate child. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "menuArray": {
                "docstring": "Return a string array containing the names of the menus in the layout's menu bar."
            }, 
            "menuBarVisible": {
                "docstring": "Visibility of the menu bar."
            }, 
            "menuIndex": {
                "docstring": "Sets the index of a specified menu.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfMenus": {
                "docstring": "Return the number of menus attached to the layout's menu bar."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "menuEditor": {
        "description": "A menuEditor displays the contents of a popup menu and allows the menu's items to be edited. Menu items are represented by labelled icons which can be dragged around within the editor to change the menu's layout. Various objects can be dragged and dropped into the menuEditor to create new menu items: toolButtons from the shelf or toolbox, shelfButtons from the shelf, iconTextButtons with attached commands, and scripts from the command window. When editing a Marking Menu, the radial menu items correspond to 8 icons arranged in a circle within the menuEditor. Overflow items in the Marking Menu (or linear items in a normal menu) are displayed in a column below the radial items. To edit a submenu of a popup menu, a new menuEditor instance must be created (typically within its own window) and attached to its parent menuEditor. Some flags require the position of a menu item to be passed in as an argument. For these, positions are specified with a (string,int) pair, where the string corresponds to a radial position (possibily \"None\") and the int corresponds to a linear position (possibly equal to 0 for none). Radial positions are specified by one of (\"N\",0), (\"NE\",0), (\"E\",0), (\"SE\",0), (\"S\",0), (\"SW\",0), (\"W\",0) or (\"NW\",0). Overflow, or linear positions, are specified with (\"None\",i), where i is a 1-based index giving the position of the item within the overflow column.Note:This command in not meant to be called explicitly. It was created to support the Marking Menu editor. It is recommended that you use that editor to modify marking menus. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "cellHeight": {
                "docstring": "The height of the icons in the menuEditor."
            }, 
            "cellWidth": {
                "docstring": "The width of the icons in the menuEditor."
            }, 
            "cellWidthHeight": {
                "docstring": "The width and height of the icons in the menuEditor."
            }, 
            "checkBoxPresent": {
                "docstring": "This controls whether a menu item has a check box or not. The arguments are a flag indicating presence, followed by the position of the menu item. This flag is ignored if the menu item is a submenu item. If queried, an array of booleans is returned containing all the flags. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "checkBoxState": {
                "docstring": "The state of the check box associated with a menu item. The arguments are a flag indicating state, followed by the position of the menu item. This flag is ignored if the menu item does not have a check box. If queried, an array of booleans is returned containing all the flags. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "command": {
                "docstring": "The command or script executed by a menu item. The arguments are the command string or script name, followed by the position of the menu item. This flag is ignored if the menu item is a submenu item or a separator item. If queried, an array of strings is returned containing all the commands. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "delete": {
                "docstring": "Deletes the menu item at the given position, removing it from the menu. If the menu item has a submenu, and a sub-menuEditor is open and attached to it, then the sub-menuEditor's window and all its child menuEditor windows will be closed recursively."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "iconMenuCallback": {
                "docstring": "This is the name of a MEL callback procedure that is called to create the popup menus attached to icons in the menuEditor. The callback is called once for each newly created icon, and once each time an icon is moved within the menuEditor. Popup menus created by the callback should contain commands for editing the menu item associated with the icon. Operations accessible through the menu should include deletion of the item, editing of the item's label/command/image/checkbox/optionbox, creation of a submenu, and popping up a sub-menuEditor. The arguments to the callback must match this form: callbackProc(string $menuEditorName, string $parentIconName, string $menuTitle, string $radialPosition, int $overflowRow); The popup menu's parent should be $parentIconName. Note that when a sub-menuEditor is created, this flag need not be re-specified as it adopts a default value equal to the value of its parent menuEditor's -imc/iconMenuCallback flag."
            }, 
            "image": {
                "docstring": "The filename of the icon associated with a menu item. This icon is displayed by the menuEditor to represent the menu item. The arguments are the icon filename, followed by the position of the menu item. If queried, an array of strings is returned containing all the icon filenames. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The label of a menu item. The arguments are the label text, followed by the position of the menu item. If queried, an array of strings is returned containing all the labels. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "menuItemTypes": {
                "docstring": "This is a query only flag. Returns an array of strings indicating the type of contents in each cell of the menuEditor. Cells can be \"vacant\", or may contain a regular menu \"item\", or a \"separator\", or a \"submenu\" item. In each case, the corresponding string is returned. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "optionBoxCommand": {
                "docstring": "The command or script executed by a menu item's associated option box item. The arguments are the command string or script name, followed by the position of the menu item. This flag is ignored if the menu item does not have an associated option box item. If queried, an array of strings is returned containing all the commands. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "optionBoxPresent": {
                "docstring": "This controls whether a menu item has an associated option box item or not. The arguments are a flag indicating presence, followed by the position of the menu item. This flag is ignored if the menu item is a submenu item. If queried, an array of booleans is returned containing all the flags. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radioButtonPresent": {
                "docstring": "This controls whether a menu item has a radio button or not. The arguments are a flag indicating presence, followed by the position of the menu item. This flag is ignored if the menu item is a submenu item. If queried, an array of booleans is returned containing all the flags. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "radioButtonState": {
                "docstring": "The state of the radio button associated with a menu item. The arguments are a flag indicating state, followed by the position of the menu item. This flag is ignored if the menu item does not have a radio button. If queried, an array of booleans is returned containing all the flags. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "separator": {
                "docstring": "In edit mode this adds a separator to the menuEditor at the specified position. The parameters are the radialPosition and the overflowRow. If queried, an array of booleans is returned indicating if the item is a separator item. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items."
            }, 
            "style": {
                "docstring": "This is the style of icons within the menuEditor. Valid styles are \"iconOnly\", \"textOnly\", \"iconAndTextHorizontal\" and \"iconAndTextVertical\"."
            }, 
            "subMenuAt": {
                "docstring": "Creates a submenu item at the given position. A submenu item created within the radial portion of a menu will overwrite whatever item (if any) is currently at the given position. A submenu item created within the overflow (linear) portion of a menu will be inserted before the item currently at the given position."
            }, 
            "subMenuEditorWindow": {
                "docstring": "The name of the window which contains a sub-menuEditor. Only use when creatitg a sub-menuEditor. This window will automatically be closed if a parent menuEditor is closed or if a parent menu item is deleted."
            }, 
            "subMenuEditorsOpen": {
                "docstring": "This is a query only flag. Returns an array of booleans, each of which indicates if a sub-menuEditor is open and attached to the menu item in a particular cell. One boolean is returned for each cell in the menuEditor, even if the cell is vacant or contains a non-submenu item (false will be returned in both these cases). Only when a cell contains a submenu item can true possibily be returned. The first 8 entries of the array correspond to radial items (in order, \"N\", \"NE\", ... \"NW\"), and all later entries correspond to overflow (or linear) menu items.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "subMenuOf": {
                "docstring": "Attaches a sub-menuEditor to its parent menuEditor. Only use when creatitg a sub-menuEditor. The arguments are the name of the parent menuEditor, followed by the position of a submenu item within the parent. A submenu item must already exist within the parent at the given position. A submenu item cannot have multiple sub-menuEditors attached to it."
            }, 
            "topLevelMenu": {
                "docstring": "The popup menu to attach to the editor. All editing operations performed in the editor (i.e. inserting/deleting/moving an item) will be immediately reflected in this menu. This flag is ignored if the editor is a sub-menuEditor. The editor will update gracefully if the value of the flag is changed from its initial value."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "menuItem": {
        "description": "This command creates/edits/queries menu items. ", 
        "flags": {
            "allowOptionBoxes": {
                "docstring": "Deprecated. All menus and menu items always allow option boxes. In the case of submenu items this flag specifies whether the submenu will be able to support option box menu items. Always returns true."
            }, 
            "altModifier": {
                "docstring": "Specify this flag if the Alt modifier is part of the accelerator sequence."
            }, 
            "annotation": {
                "docstring": "Annotate the menu item with an extra string value."
            }, 
            "boldFont": {
                "docstring": "Specify if text should be bold. Only supported in menus which use the marking menu implementation. Default is false for Windows, and true for all other platforms.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "checkBox": {
                "docstring": "Creates a check box menu item. Argument specifies the check box value."
            }, 
            "collection": {
                "docstring": "To explicitly add a radio menu item to a radioMenuItemCollection."
            }, 
            "command": {
                "docstring": "Attaches a command/script that will be executed when the item is selected. Note this command is not executed when the menu item is in an optionMenucontrol."
            }, 
            "commandModifier": {
                "docstring": "Specify this flag if the command modifier is part of the accelerator sequence. This is only available on systems which have a separate command key."
            }, 
            "ctrlModifier": {
                "docstring": "Specify this flag if the Cntl modifier is part of the accelerator sequence."
            }, 
            "data": {
                "docstring": "Attaches a piece of user-defined data to the menu item."
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "divider": {
                "docstring": "Creates a divider menu item."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the menu item."
            }, 
            "dragDoubleClickCommand": {
                "docstring": "If the menu item is put on the shelf then this command will be invoked when the corresponding shelf object is double clicked."
            }, 
            "dragMenuCommand": {
                "docstring": "If the menu item is put on the shelf then this command will be invoked when the corresponding shelf object is clicked."
            }, 
            "echoCommand": {
                "docstring": "Specify whether the action attached with the c/commandflag should echo to the command output areas when invoked. This flag is false by default and must be specified with the c/commandflag."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "Enable state for the menu item. A disabled menu item is dimmed and unresponsive. An enabled menu item is selectable and has normal appearance."
            }, 
            "enableCommandRepeat": {
                "docstring": "This flag only affects menu items to which a command can be attached. Specify true and the command may be repeated by executing the command repeatLast. This flag is true by default for all items except for option box items."
            }, 
            "exists": {
                "docstring": ""
            }, 
            "familyImage": {
                "docstring": "Get the filename of the family icon associated with the menu. The family icon will be used for the shelf unless an icon is specified with the imageflag."
            }, 
            "image": {
                "docstring": "The filename of the icon associated with the menu item. If the menu containing the menu item is being edited with a menuEditor widget, then the menuEditor will use this icon to represent the menu item. This icon will be displayed on the shelf when the menu item is placed there."
            }, 
            "imageOverlayLabel": {
                "docstring": "Specify a short (5 character) text string to be overlayed on top of the icon associated with the menu item. This is primarily a mechanism for differentiating menu items that are using a Family icon due to the fact that an icon image had not been explicitly defined. The image overlay label will not be used if an icon image is defined for the menu item."
            }, 
            "insertAfter": {
                "docstring": "Specify After which item the new one will be placed. If this flag is not specified, item is added at the end of the menu. Use the empty string \"\" to insert before the first item of the menu.WARNING: This flag is known to cause problems with tear off menus. It is recommended that you do not use it with menus that are tear off enabled. In other words, the parent menu should not have its to/tearOff flag set."
            }, 
            "isCheckBox": {
                "docstring": "Returns true if the item is a check box item."
            }, 
            "isOptionBox": {
                "docstring": "Returns true if the item is an option box item."
            }, 
            "isRadioButton": {
                "docstring": "Returns true if the item is a radio button item."
            }, 
            "italicized": {
                "docstring": "Specify if text should be italicized. Only supported in menus which use the marking menu implementation. Default is false."
            }, 
            "keyEquivalent": {
                "docstring": "Specify the accelerator character. This character is combined with the modifier keys specified with the alt/altModifier, opt/optionModifier, ctl/ctlModifier, cmd/commandModifierand sh/shiftModifierto form the complete accelerator sequence that you can type to execute the menu item. Note that only regular menu items, radio menu items and check box menu items can have an accelerator."
            }, 
            "label": {
                "docstring": "The text that appears in the item."
            }, 
            "mnemonic": {
                "docstring": ""
            }, 
            "optionBox": {
                "docstring": "Indicates that the menu item will be an option box item. This item will appear to the right of the preceeding menu item."
            }, 
            "optionBoxIcon": {
                "docstring": "The filename of an icon to be used instead of the usual option box icon. The icon is searched for in the folder specified by the XBMLANGPATH environment variable. The icon can be any size, but will be resized to the standard 16x16 pixels when drawn."
            }, 
            "optionModifier": {
                "docstring": "Specify this flag if the Alt (or option) modifier is part of the accelerator sequence."
            }, 
            "parent": {
                "docstring": "Specify the menu that the item will appear in."
            }, 
            "postMenuCommand": {
                "docstring": "Specify a script to be executed when the submenu is about to be shown."
            }, 
            "postMenuCommandOnce": {
                "docstring": "Indicate the pmc/postMenuCommandshould only be invoked once. Default value is false, ie. the pmc/postMenuCommandis invoked everytime the sub menu is shown."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radialPosition": {
                "docstring": "The radial position of the menu item if it is in a Marking Menu. Radial positions are given in the form of a cardinal direction, and may be \"N\", \"NW\", \"W\", \"SW\", \"S\", \"SE\", \"E\" or \"NE\"."
            }, 
            "radioButton": {
                "docstring": "Creates a radio button menu item. Argument specifies the radio button value."
            }, 
            "shiftModifier": {
                "docstring": "Specify this flag if the Shift modifier is part of the accelerator sequence."
            }, 
            "sourceType": {
                "docstring": "Set the language type for a command script. Can only be used in conjunction with a command flag. Without this flag, commands are assumed to be the same language of the executing script. In query mode, will return the language of the specified command. Valid values are \"mel\" and \"python\"."
            }, 
            "subMenu": {
                "docstring": "Indicates that the item will have a submenu. Subsequent menuItems will be added to the submenu until setParent -menuis called. Note that a submenu item creates a menu object and consequently the menucommand may be used on the submenu item."
            }, 
            "tearOff": {
                "docstring": "For the case where the menu item is a sub menu this flag will make the sub menu tear-off-able. Note that this flag has no effect on the other menu item types."
            }, 
            "useTemplate": {
                "docstring": ""
            }
        }
    }, 
    "menuSet": {
        "description": "Create a menu set which is used to logically order menus for display in the main menu bar. Such menu sets can be edited and reordered dynamically. ", 
        "flags": {
            "addMenu": {
                "docstring": "Appends a menu onto the end of the current menu set."
            }, 
            "allMenuSets": {
                "docstring": "Returns an array of the all the menu set object names in use. Query returns string array."
            }, 
            "currentMenuSet": {
                "docstring": "The currently active menu set under which all operations affect (append, insert, remove, etc.). Query returns string."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns whether the specified menu set exists. This query flag supports string arguments. ie. menuSet -q -exists animationMenuSet; "
            }, 
            "hotBoxVisible": {
                "docstring": "Whether this menu set should be displayed in the hotbox as well as in the main menubar."
            }, 
            "insertMenu": {
                "docstring": "Inserts a menu into a specified index in the current menu set."
            }, 
            "label": {
                "docstring": "The label of the current menu set. Query returns string."
            }, 
            "menuArray": {
                "docstring": "An array of menu names (strings) in the current menu set. Query returns string array."
            }, 
            "moveMenu": {
                "docstring": "Moves a specified menu from the current menu set to a new position."
            }, 
            "moveMenuSet": {
                "docstring": "Moves a specified menu set to another index."
            }, 
            "numberOfMenuSets": {
                "docstring": "Number of menuSets in total. Query returns int."
            }, 
            "numberOfMenus": {
                "docstring": "The mumber of menus in the current menu set. Query returns int."
            }, 
            "permanent": {
                "docstring": "Whether this menu set can be removed.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeMenu": {
                "docstring": "Removes a specified menu from the current menu set."
            }, 
            "removeMenuSet": {
                "docstring": "Removes the specified menu set object from the list of all menu sets."
            }
        }
    }, 
    "menuSetPref": {
        "description": "Provides the functionality to save and load menuSets between sessions of Maya. For Internal Use Only! In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns whether the menuSet preferences file exists or not."
            }, 
            "force": {
                "docstring": "Forces a specified operation to continue even if errors are encountered (such as invalid preferences)."
            }, 
            "loadAll": {
                "docstring": "Loads all the menuSets from the preferences file only if the preferences version matches, or the -force flag is enabled. On successful load, of a prefs file, an empty string is returned, otherwise, a description of the problem encountered is returned."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeAll": {
                "docstring": "Removes all the menuSets from the preferences file (removes the whole file)."
            }, 
            "saveAll": {
                "docstring": "Saves all the current menuSets into the preferences file."
            }, 
            "saveBackup": {
                "docstring": "Saves a backup of the current menu set preferences file if one exists. This backup will be saved in the same location as the current preferences file."
            }, 
            "version": {
                "docstring": "The base version string which is saved out to file. It is also checked upon loading in order to indicate changes in the default prefs since the prefs were last saved out.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "meshIntersectTest": {
        "description": "", 
        "flags": {}
    }, 
    "messageLine": {
        "description": "This command creates a message line where tool feedback is shown. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parentsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "minimizeApp": {
        "description": "This command minimizes (iconifies) all of the application's windows into a single desktop icon. To restore the application click on the desktop icon. ", 
        "flags": {}
    }, 
    "mirrorJoint": {
        "description": "This command will duplicate a branch of the skeleton from the selected joint symmetrically about a plane in world space. There are three mirroring modes(xy-, yz-, xz-plane). ", 
        "flags": {
            "mirrorBehavior": {
                "docstring": "The mirrorBehavior flag is used to specify that when performing the mirror, the joint orientation axes should be mirrored such that equal rotations on the original and mirrored joints will place the skeleton in a mirrored position (symmetric across the mirroring plane). Thus, animation curves from the original joints can be copied to the mirrored side to produce a similar (but symmetric) behavior. When mirrorBehavior is not specified, the joint orientation on the mirrored side will be identical to the source side."
            }, 
            "mirrorXY": {
                "docstring": "mirror skeleton from the selected joint about xy-plane in world space."
            }, 
            "mirrorXZ": {
                "docstring": "mirror skeleton from the selected joint about xz-plane in world space."
            }, 
            "mirrorYZ": {
                "docstring": "mirror skeleton from the selected joint about yz-plane in world space."
            }, 
            "searchReplace": {
                "docstring": "After performing the mirror, rename the new joints by searching the name for the first specified string and replacing it with the second specified string.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "modelCurrentTimeCtx": {
        "description": "This command creates a context which may be used to change current time within the model views. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "percent": {
                "docstring": "Percent of the screen space that represents the full time slider range (default is 50%)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "modelEditor": {
        "description": "Create, edit or query a model editor. Note that some of the flags of this command may have different settings for normal mode and for interactive/playback mode. For example, a modelEditor can be set to use shaded mode normally, but to use wireframe during playback for greater speed. Some flags also support having defaults set so that new model editors will be created with those settings. ", 
        "flags": {
            "activeComponentsXray": {
                "docstring": "Turns on or off Xray mode for active components."
            }, 
            "activeOnly": {
                "docstring": "Sets whether only active objects should appear shaded in shaded display."
            }, 
            "activeView": {
                "docstring": "Sets this model editor to be the active view. Returns true if successful. On query this flag will return whether the view is the active view."
            }, 
            "addObjects": {
                "docstring": "This flag causes the objects contained within the selection connection to be added to the list of objects visible in the view (if viewSelected is true)."
            }, 
            "addSelected": {
                "docstring": "This flag causes the currently active objects to be added to the list of objects visible in the view (if viewSelected is true)."
            }, 
            "allObjects": {
                "docstring": "Turn on/off the display of all objects for the view of the model editor. This excludes NURBS, CVs, hulls, grids and manipulators."
            }, 
            "backfaceCulling": {
                "docstring": "Turns on or off backface culling for the whole view. This setting overrides the culling settings of individual objects. All objects draw in the view will be backface culled. When backface culling is turned on, surfaces becomes invisible in areas where the normal is pointing away from the camera."
            }, 
            "bufferMode": {
                "docstring": "Sets the graphic buffer mode. Possible values are \"single\" or \"double\"."
            }, 
            "bumpResolution": {
                "docstring": "Set the resolution for \"baked\" bump map textures when using the hardware renderer. The default value is 512, 512 respectively."
            }, 
            "camera": {
                "docstring": "Change or query the name of the camera in model editor."
            }, 
            "cameraName": {
                "docstring": "Set the name of the panel's camera transform and shape. The shape name is computed by appending the string \"Shape\" to the transform name. This flag may not be queried."
            }, 
            "cameraSet": {
                "docstring": ""
            }, 
            "cameraSetup": {
                "docstring": "Based on the model editor name passed in will returns a string list containing camera setups. A camera setup can contain one or more cameras which are associated with each other. Camera setups are defined as pairs of consecutive strings in the list. Each pair is comprised of: a string which identifies an active camera, and a string which defines a script to set up a given active camera. As many pairs of strings can be returned as the number of active cameras. If nothing is returned then it is assumed that no set up is required to activate a given camera."
            }, 
            "cameras": {
                "docstring": "Turn on/off the display of cameras for the view of the model editor."
            }, 
            "colorMap": {
                "docstring": "Queries the color map style for the model panel. Possible values are \"colorIndex\" and \"rgb\"."
            }, 
            "colorResolution": {
                "docstring": "Set the resolution for \"baked\" color textures when using the hardware renderer. The default value is 256, 256 respectively."
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "controlVertices": {
                "docstring": "Turn on/off the display of NURBS CVs for the view of the model editor."
            }, 
            "cullingOverride": {
                "docstring": "Set whether to override the culling attributes on objects when using the hardware renderer. The options are: \"none\" : Use the culling object attributes per object.\"doubleSided\" : Force all objects to be double sided.\"singleSided\": Force all objects to be single sided.The default value is \"none\"."
            }, 
            "default": {
                "docstring": "Causes this command to modify the default value of this setting. Newly created model editors will inherit the values. This flag may be used with the -interactive to set default interactive settings."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "deformers": {
                "docstring": "Turn on/off the display of deformer objects for the view of the model editor."
            }, 
            "dimensions": {
                "docstring": "Turn on/off the display of dimension objects for the view of the model editor."
            }, 
            "displayAppearance": {
                "docstring": "Sets the display appearance of the model panel. Possible values are \"wireframe\", \"points\", \"boundingBox\", \"smoothShaded\", \"flatShaded\". This flag may be used with the -interactive and -default flags. Note that only \"wireframe\", \"points\", and \"boundingBox\" are valid for the interactive mode."
            }, 
            "displayLights": {
                "docstring": "Sets the lighting for shaded mode. Possible values are \"selected\", \"active\", \"all\", \"default\", \"none\"."
            }, 
            "displayTextures": {
                "docstring": "Turns on or off display of textures in shaded mode"
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "dynamicConstraints": {
                "docstring": "Turn on/off the display of dynamicConstraints for the view of the model editor."
            }, 
            "dynamics": {
                "docstring": "Turn on/off the display of dynamics objects for the view of the model editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editorChanged": {
                "docstring": "An optional script callback which is called when the editors options have changed. This is useful in a situation where a scripted panel contains a modelEditor and wants to be notified when the contained editor changes its options."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "filteredObjectList": {
                "docstring": "For model editors with filtering on (either using an object filter, or isolate select), this flag returns a string list of the objects which are displayed in this editor. Note that this list does not take into account visibility (based on camera frustum or flags), it purely captures the objects which are considered when rendering the view."
            }, 
            "fluids": {
                "docstring": "Turn on/off the display of fluids for the view of the model editor."
            }, 
            "fogColor": {
                "docstring": "The color used for hardware fogging."
            }, 
            "fogDensity": {
                "docstring": "Determines the density of hardware fogging."
            }, 
            "fogEnd": {
                "docstring": "The end location of hardware fogging."
            }, 
            "fogMode": {
                "docstring": "This determines the drop-off mode for fog. The possibilities are: \"linear\" : linear drop-off\"exponent\" : exponential drop-off\"exponent2\" : squared exponential drop-off"
            }, 
            "fogSource": {
                "docstring": "Set the type of fog algorithm to use. If the argument is \"fragment\" (default) then fog is computed per pixel. If the argument is \"coordinate\" then if the geometry has specified vertex fog coordinates, and the OpenGL extension for vertex fog is supported by the graphics system, then fog is computed per vertex."
            }, 
            "fogStart": {
                "docstring": "The start location of hardware fogging."
            }, 
            "fogging": {
                "docstring": "Set whether hardware fogging is enabled or not."
            }, 
            "follicles": {
                "docstring": "Turn on/off the display of follicles for the view of the model editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "grid": {
                "docstring": "Turn on/off the display of the grid for the view of the model editor."
            }, 
            "hairSystems": {
                "docstring": "Turn on/off the display of hairSystems for the view of the model editor."
            }, 
            "handles": {
                "docstring": "Turn on/off the display of select handles for the view of the model editor."
            }, 
            "headsUpDisplay": {
                "docstring": "Sets whether the model panel will draw any enabled heads up display elements in this window (if true). Currently this requires the HUD elements to be globally enabled."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "hulls": {
                "docstring": "Turn on/off the display of NURBS hulls for the view of the model editor."
            }, 
            "ignorePanZoom": {
                "docstring": "Sets whether the model panel will ignore the 2D pan/zoom value to give an overview of the scene."
            }, 
            "ikHandles": {
                "docstring": "Turn on/off the display of ik handles and end effectors for the view of the model editor."
            }, 
            "imagePlane": {
                "docstring": "Turn on/off the display of image plane for the view"
            }, 
            "interactive": {
                "docstring": "Causes this command to modify the interactive refresh settings of the view. In this way it is possible to change the behavior of the model editor during playback for improved performance."
            }, 
            "interactiveBackFaceCull": {
                "docstring": ""
            }, 
            "interactiveDisableShadows": {
                "docstring": ""
            }, 
            "isFiltered": {
                "docstring": "Returns true for model editors with filtering applied to their view of the scene. This could either be an explicit object filter, or a display option such as isolate select which filters the objects that are displayed."
            }, 
            "jointXray": {
                "docstring": "Turns on or off Xray mode for joints."
            }, 
            "joints": {
                "docstring": "Turn on/off the display of joints for the view of the model editor."
            }, 
            "lights": {
                "docstring": "Turn on/off the display of lights for the view of the model editor."
            }, 
            "lineWidth": {
                "docstring": "Set width of lines for display"
            }, 
            "locators": {
                "docstring": "Turn on/off the display of locator objects for the view of the model editor."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "lowQualityLighting": {
                "docstring": "Set whether to use \"low quality lighting\" when using the hardware renderer. The default value is false."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "manipulators": {
                "docstring": "Turn on/off the display of manipulator objects for the view of the model editor."
            }, 
            "maxConstantTransparency": {
                "docstring": "Sets the maximum constant transparency. Setting this value remaps constant transparency values from the range [0.0, 1.0] to the range [0.0, maxConstantTransparency]. All transparency values are shifted linearly to the new range, so a fully transparency object (transparency 1.0) would appear with a transparency of maxConstantTransparency in the viewport, allowing highly transparent objects to be made visible. This flag only affects constant (non-textured) transparent objects."
            }, 
            "maximumNumHardwareLights": {
                "docstring": ""
            }, 
            "modelPanel": {
                "docstring": "Allows the created model editor to be embedded in the named model panel. Intended for use with custom model editors created via the API (i.e. the flag would be used on the derived MPxModelEditorCommand), though the flag may also be used on the base modelEditor command to restore a default Maya model editor to the panel. Note that the model editor previously owned by the panel is deleted."
            }, 
            "motionTrails": {
                "docstring": ""
            }, 
            "nCloths": {
                "docstring": "Turn on/off the display of nCloths for the view of the model editor."
            }, 
            "nParticles": {
                "docstring": "Turn on/off the display of nParticles for the view of the model editor."
            }, 
            "nRigids": {
                "docstring": "Turn on/off the display of nRigids for the view of the model editor."
            }, 
            "noUndo": {
                "docstring": "This flag prevents some viewport operations (such as isolate select) from being added to the undo queue."
            }, 
            "nurbsCurves": {
                "docstring": "Turn on/off the display of nurbs curves for the view of the model editor."
            }, 
            "nurbsSurfaces": {
                "docstring": "Turn on/off the display of nurbs surfaces for the view of the model editor."
            }, 
            "objectFilter": {
                "docstring": "Set or query the current object filter name. An object filter is required to have already been registered."
            }, 
            "objectFilterList": {
                "docstring": "Return a list of names of registered filters."
            }, 
            "objectFilterListUI": {
                "docstring": "Return a list of UI names of registered filters."
            }, 
            "objectFilterShowInHUD": {
                "docstring": "Sets whether or not to display the object filter UI name in the heads up display when an object filter is active. This string is concatenated with the camera name."
            }, 
            "objectFilterUI": {
                "docstring": "Query the current object filter UI name. The object filter is required to have already been registered."
            }, 
            "occlusionCulling": {
                "docstring": "Set whether to enable occlusion culling testing when using the hardware renderer. The default value is false."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "pivots": {
                "docstring": "Turn on/off the display of transform pivots for the view of the model editor."
            }, 
            "planes": {
                "docstring": "Turn on/off the display of sketch planes for the view of the model editor."
            }, 
            "polymeshes": {
                "docstring": "Turn on/off the display of polygon meshes for the view of the model editor."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeSelected": {
                "docstring": "This flag causes the currently active objects to be removed from the list of objects visible in the view (if viewSelected is true)."
            }, 
            "rendererList": {
                "docstring": "Query for a list of the internal names for renderers are available for usage with the 3d modeling viewport. The default list contains at least \"base_OpenGL_Renderer\", and \"hwRender_OpenGL_Renderer\", if supported. See rendererName for more details on these renderers. Any plugin viewport renderers will also appear in this list."
            }, 
            "rendererListUI": {
                "docstring": "Query for a list of the UI names renderers are available for usage with the 3d modeling viewport. The default list contains at the UI name for\"base_OpenGL_Renderer\", and possibly the UI name for \"hwRender_OpenGL_Renderer\" if it is support. Any plugin viewport renderer's UI names will also appear in this list. This list and the list returned from rendererList have a 1:1 correpsondance."
            }, 
            "rendererName": {
                "docstring": "Set or get the renderer used for the 3d modeling viewport. The default options for setting are: \"base_OpenGL_Renderer\" : The default OpenGL based renderer. \"hwRender_OpenGL_Renderer\" : The high quality hardware renderer. The default is \"base_OpenGL_Renderer\". The high quality renderer is only supported on certain hardware configurations. See the hardware qualification charts for more details."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "selectionHiliteDisplay": {
                "docstring": "Sets whether the model panel will draw any selection hiliting on the objects in this window."
            }, 
            "setSelected": {
                "docstring": "This flag causes the currently active objects to be the only objects visible in the view (if viewSelected is true)."
            }, 
            "shadingModel": {
                "docstring": ""
            }, 
            "shadows": {
                "docstring": "Turn on/off the display of hardware shadows in shaded mode."
            }, 
            "smallObjectCulling": {
                "docstring": ""
            }, 
            "smallObjectThreshold": {
                "docstring": ""
            }, 
            "smoothWireframe": {
                "docstring": "Turns on or off smoothing of wireframe lines and points"
            }, 
            "sortTransparent": {
                "docstring": "This flag turns on/off sorting of transparent objects during shaded mode refresh. Normally, objects are sorted according to their origin in camera space but when this flag is turned off they will be drawn according to their (depth-first traversal) order in the scene graph. This is a global flag that affects all model editors."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "stereoDrawMode": {
                "docstring": ""
            }, 
            "strokes": {
                "docstring": "Turn on/off the display of Paint Effects strokes for the view"
            }, 
            "subdivSurfaces": {
                "docstring": "Turn on/off the display of subdivision surfaces for the view of the model editor."
            }, 
            "textureAnisotropic": {
                "docstring": "Set whether to perform anisotropic texture filtering. Will work only if the anisotropic texture filtering extension is supported in OpenGL on the graphics system."
            }, 
            "textureCompression": {
                "docstring": ""
            }, 
            "textureDisplay": {
                "docstring": "Set the type of blending to use for textures. The blend is performed between the destination fragment and the texture fragment. The source is usually the material color. Argument options are: \"modulate\" : multiply the destination and texture fragment \"decal\" : overwrite the destination with the texture fragment"
            }, 
            "textureEnvironmentMap": {
                "docstring": ""
            }, 
            "textureHilight": {
                "docstring": "Set whether to show specular hilighting when the display is in shaded textured mode."
            }, 
            "textureMaxSize": {
                "docstring": "Set maximum texture size for hardware texturing. The integer value must be a power of 2. Recommended values are 128 or 256. If the value specified is larger than the OpenGL maximim textures size for the graphics hardware it will be clamped to the OpenGL size. If many large textures are used in a scene reducing this value improves performance. On Impact texture memory is pinned in RAM so using large textures can cause reliability and performance problems. Again reducing this value will help. Software rendering does not use this value. This flag is obsolete as of Maya 6.5. The maxTextureResolution/mtr argument on the displayPref command should be used instead."
            }, 
            "textureMemoryUsed": {
                "docstring": "Returns the total number of bytes used by all texture maps. This is typicly width\\*height\\*channels for all texture objects in the scene If the texture is mip mapped all mip map levels are included in the total though not never more than two level will be in use at one time"
            }, 
            "textureSampling": {
                "docstring": "Set the type of sampling to be used for texture display. The argument can be either: 1 : means to perform point sample2 : means to perform bilinear interpolation (default)"
            }, 
            "textures": {
                "docstring": "Turn on/off the display of texture objects for the view"
            }, 
            "transpInShadows": {
                "docstring": "Set whether to enable display of transparency in shadows when using the hardware renderer. The default value is false."
            }, 
            "transparencyAlgorithm": {
                "docstring": "Set the transparency algorithm. The options are: 1) \"frontAndBackCull\" : Two pass front and back culling technique.2) \"perPolygonSort\" : Draw transparent polygons in back-to-front order technique.transparency pptions 1) and 2) are supported by the hardware renderer. Options 1) is supported by the interactive modeling viewports. The default value is \"frontAndBackCull\"."
            }, 
            "twoSidedLighting": {
                "docstring": "Turns on or off two sided lighting. This may be used with the -default flag."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateColorMode": {
                "docstring": "Using this flag tells the model panel to check which color mode it should be in, and to switch accordingly. This flag may be used to update a model panel after a camera image plane has been added or removed."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useBaseRenderer": {
                "docstring": "Set whether to use the \"base\" renderer when using the hardware renderer and in \"interactive display mode\" (-useInteractiveMode) The default value is false."
            }, 
            "useColorIndex": {
                "docstring": "Sets whether the model panel will attempt to use color index mode when possible. Color index mode can provide a performance increase for point, bounding box, and wireframe display modes. This may be used with the -default flag."
            }, 
            "useDefaultMaterial": {
                "docstring": "Sets whether the model panel will draw all the shaded surfaces using the default material as opposed to using the material(s) currently assigned to the surfaces."
            }, 
            "useInteractiveMode": {
                "docstring": "Turns on or off the use of the special interaction settings during playback. This flag may be used with the -default flag."
            }, 
            "useRGBImagePlane": {
                "docstring": "Sets whether the model panel will be forced into RGB mode when there is an image plane attached to the panel's camera."
            }, 
            "useReducedRenderer": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "userNode": {
                "docstring": "Allows the user to associate a node name with the modelEditor. The value is automatically updated in the event the node is deleted or renamed."
            }, 
            "viewObjects": {
                "docstring": "Returns the name (if any) of the objectSet which contains the list of objects visible in the view if viewSelected is true and the list of objects being displayed does notcome from the active list."
            }, 
            "viewSelected": {
                "docstring": "This flag turns on/off viewing of selected objects. When the flag is set to true, the currently active objects are captured and used as the list of objects to view."
            }, 
            "viewType": {
                "docstring": "Returns a string indicating the type of the model editor. For the default model editor, returns the empty string. For custom model editor types created via the API, returns the same string as is returned via the method MPx3dModelView::viewType().Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "wireframeBackingStore": {
                "docstring": "Sets whether a backing store is used to optimization the drawing of active objects. This mode can provide a performance increase in wireframe mode for certain scenes."
            }, 
            "wireframeOnShaded": {
                "docstring": "Sets whether the model panel will draw the wireframe on all shaded objects (if true) or only for active objects (if false)."
            }, 
            "xray": {
                "docstring": "Turns on or off Xray mode. This may be used with the -default flag."
            }
        }
    }, 
    "modelPanel": {
        "description": "This command creates a panel consisting of a model editor. See the modelEditorcommand documentation for more information. ", 
        "flags": {
            "barLayout": {
                "docstring": "This flag returns the name of the layout which is the parent of the panels icon bar."
            }, 
            "camera": {
                "docstring": "Query or edit the camera in a modelPanel.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "control": {
                "docstring": "Returns the top level control for this panel. Usually used for getting a parent to attach popup menus. CAUTION: panels may not have controls at times. This flag can return \"\" if no control is present."
            }, 
            "copy": {
                "docstring": "Makes this panel a copy of the specified panel. Both panels must be of the same type."
            }, 
            "createString": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the maya panel."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editString": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "init": {
                "docstring": "Initializes the panel's default state. This is usually done automatically on file -new and file -open."
            }, 
            "isUnique": {
                "docstring": "Returns true if only one instance of this panel type is allowed."
            }, 
            "label": {
                "docstring": "Specifies the user readable label for the panel."
            }, 
            "menuBarVisible": {
                "docstring": "Controls whether the menu bar for the panel is displayed."
            }, 
            "modelEditor": {
                "docstring": "This flag returns the name of the model editor contained by the panel."
            }, 
            "needsInit": {
                "docstring": "(Internal) On Edit will mark the panel as requiring initialization. Query will return whether the panel is marked for initialization. Used during file -new and file -open."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this panel."
            }, 
            "popupMenuProcedure": {
                "docstring": "Specifies the procedure called for building the panel's popup menu(s). The default value is \"buildPanelPopupMenu\". The procedure should take one string argument which is the panel's name."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replacePanel": {
                "docstring": "Will replace the specifed panel with this panel. If the target panel is within the same layout it will perform a swap."
            }, 
            "tearOff": {
                "docstring": "Will tear off this panel into a separate window with a paneLayout as the parent of the panel. When queried this flag will return if the panel has been torn off into its own window."
            }, 
            "tearOffCopy": {
                "docstring": "Will create this panel as a torn of copy of the specified source panel."
            }, 
            "unParent": {
                "docstring": "Specifies that the panel should be removed from its layout. This (obviously) cannot be used with query."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "mouldMesh": {
        "description": "", 
        "flags": {}
    }, 
    "mouldSrf": {
        "description": "", 
        "flags": {}
    }, 
    "mouldSubdiv": {
        "description": "", 
        "flags": {}
    }, 
    "mouse": {
        "description": "This command allows to configure mouse. ", 
        "flags": {
            "enableScrollWheel": {
                "docstring": "Enable or disable scroll wheel support."
            }, 
            "mouseButtonTracking": {
                "docstring": "Set the number (1, 2 or 3) of mouse buttons to track.Note: this is only supported on Macintosh"
            }, 
            "mouseButtonTrackingStatus": {
                "docstring": "returns the current number of mouse buttons being tracked.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "scrollWheelStatus": {
                "docstring": "returns the current status of scroll wheel support."
            }
        }
    }, 
    "movIn": {
        "description": "Imports a .mov file into animation curves connected to the listed attributes. The attribute must be writable, since an animation curve will be created and connected to the attribute. If an animation curve already is connected to the attribute, the imported data is pasted onto that curve. The starting time used for the .mov file importation is the current time when the command is executed. Valid attribute types are numeric attributes; time attributes; linear attributes; angular attributes; compound attributes made of the types listed previously; and multi attributes composed of the types listed previously. If an unsuppoted attribute type is requested, the command will fail and no data will be imported. It is important that your user units are set to the same units used in the .mov file, otherwise linear and angular values will be incorrect. To export a .mov file, use the movOut command. ", 
        "flags": {
            "file": {
                "docstring": "The name of the .mov file. If no extension is used, a .mov will be added."
            }, 
            "startTime": {
                "docstring": "The default start time for importing the .mov file is the current time. The startTime option sets the starting time for the .mov data in the current time unit.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "movOut": {
        "description": "Exports a .mov file from the listed attributes. Valid attribute types are numeric attributes; time attributes; linear attributes; angular attributes; compound attributes made of the types listed previously; and multi attributes composed of the types listed previously. Length, angle, and time values will be written to the file in the user units. If an unsupported attribute type is requested, the action will fail. The .mov file may be read back into Maya using the movIn command. ", 
        "flags": {
            "comment": {
                "docstring": "If true, the attributes written to the .mov file will be listed in a commented section at the top of the .mov file. The default is false."
            }, 
            "file": {
                "docstring": "The name of the .mov file. If no extension is used, a .mov will be added."
            }, 
            "precision": {
                "docstring": "Sets the number of digits to the right of the decimal place in the .mov file.C: The default is 6.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "time": {
                "docstring": "The time range to save as a .mov file. The default is the current time range."
            }
        }
    }, 
    "move": {
        "description": "The move command is used to change the positions of geometric objects. The default behaviour, when no objects or flags are passed, is to do a absolute move on each currently selected object in the world space. The value of the coordinates are interpreted as being defined in the current linear unit unless the unit is explicitly mentioned. When using -objectSpace there are two ways to use this command. If numbers are typed without units then the internal values of the object are set to these values. If, on the other hand a unit is specified then the internal value is set to the equivalent internal value that represents that world-space distance. The -localSpace flag moves the object in its parent space. In this space the x,y,z values correspond directly to the tx, ty, tz channels on the object. The -rotatePivotRelative/-scalePivotRelative flags can be used with the -absolute flag to translate an object so that its pivot point ends up at the given absolute position. These flags will be ignored if components are specified. The -worldSpaceDistance flag is a modifier flag that may be used in conjunction with the -objectSpace/-localSpace flags. When this flag is specified the command treats the x,y,z values as world space units so the object will move the specified world space distance but it will move along the axis specified by the -objectSpace/-localSpace flag. The default behaviour, without this flag, is to treat the x,y,z values as units in object space or local space. In other words, the worldspace distance moved will depend on the transformations applied to the object unless this flag is specified. ", 
        "flags": {
            "absolute": {
                "docstring": "Perform an absolute operation."
            }, 
            "deletePriorHistory": {
                "docstring": ""
            }, 
            "localSpace": {
                "docstring": "Move in local space"
            }, 
            "moveX": {
                "docstring": "Move in X direction"
            }, 
            "moveXY": {
                "docstring": "Move in XY direction"
            }, 
            "moveXYZ": {
                "docstring": "Move in all directions (default)"
            }, 
            "moveXZ": {
                "docstring": "Move in XZ direction"
            }, 
            "moveY": {
                "docstring": "Move in Y direction"
            }, 
            "moveYZ": {
                "docstring": "Move in YZ direction"
            }, 
            "moveZ": {
                "docstring": "Move in Z direction"
            }, 
            "objectSpace": {
                "docstring": "Move in object space"
            }, 
            "orientJoint": {
                "docstring": "Default is xyz."
            }, 
            "parameter": {
                "docstring": "Move in parametric space"
            }, 
            "preserveChildPosition": {
                "docstring": ""
            }, 
            "preserveUV": {
                "docstring": "When true, UV values on translated components are projected along the translation in 3d space. For small edits, this will freeze the world space texture mapping on the object. When false, the UV values will not change for a selected vertices. Default is false."
            }, 
            "reflection": {
                "docstring": "To move the corresponding symmetric components also."
            }, 
            "reflectionAboutBBox": {
                "docstring": "Sets the position of the reflection axis at the geometry bounding box"
            }, 
            "reflectionAboutOrigin": {
                "docstring": "Sets the position of the reflection axis at the origin"
            }, 
            "reflectionAboutX": {
                "docstring": "Specifies the X=0 as reflection plane"
            }, 
            "reflectionAboutY": {
                "docstring": "Specifies the Y=0 as reflection plane"
            }, 
            "reflectionAboutZ": {
                "docstring": "Specifies the Z=0 as reflection plane"
            }, 
            "reflectionTolerance": {
                "docstring": "Specifies the tolerance to findout the corresponding reflected components"
            }, 
            "relative": {
                "docstring": "Perform a operation relative to the object's current position"
            }, 
            "rotatePivotRelative": {
                "docstring": "Move relative to the object's rotate pivot point."
            }, 
            "scalePivotRelative": {
                "docstring": "Move relative to the object's scale pivot point."
            }, 
            "secondaryAxisOrient": {
                "docstring": "Default is xyz.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "worldSpace": {
                "docstring": "Move in world space"
            }, 
            "worldSpaceDistance": {
                "docstring": "Move is specified in world space units"
            }
        }
    }, 
    "moveKeyCtx": {
        "description": "This command creates a context which may be used to move keyframes within the graph editor ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "moveFunction": {
                "docstring": "linear | power | constant. Specifies how the keys are dragged. The default move type is constant where all keys move the same amount as controlled by user movement. Power provides a fall-off function where the center of the drag moves the most and the keys around the drag move less.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "option": {
                "docstring": "Valid values are \"move,\" \"insert,\" \"over,\" and \"segmentOver.\" When you \"move\" a key, the key will not cross over (in time) any keys before or after it. When you \"insert\" a key, all keys before or after (depending upon the -timeChange value) will be moved an equivalent amount. When you \"over\" a key, the key is allowed to move to any time (as long as a key is not there already). When you \"segmentOver\" a set of keys (this option only has a noticeable effect when more than one key is being moved) the first key (in time) and last key define a segment (unless you specify a time range). That segment is then allowed to move over other keys, and keys will be moved to make room for the segment."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "moveVertexAlongDirection": {
        "description": "The command moves the selected vertex ( control vertex ) in the specified unit direction by the given magnitude. The vertex(ices) may also be moved in the direction of unit normal ( -n flag ). For NURBS surface vertices the direction of movement could also be either in tangent along U or tangent along V. The flags -n, -u, -v and -d are mutually exclusive, ie. the selected vertices can be all moved in only -n or -u or -v or -d. ", 
        "flags": {
            "direction": {
                "docstring": "move the vertex along the direction as specified. The direction is normalized."
            }, 
            "magnitude": {
                "docstring": "move by the specified magnitude in the direction vector.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "normalDirection": {
                "docstring": "move components in the direction of normal by the given magnitude at the respective components. The normal is 'normalized'."
            }, 
            "uDirection": {
                "docstring": "move components in the direction of tangent along U at the respective components where appropriate. The flag is ignored for polygons, NURBS curves. The u direction is normalized."
            }, 
            "uvNormalDirection": {
                "docstring": "move in the triad space [u,v,n] at the respective components by the specified displacements. The flag is ignored for polygons, NURBS curves."
            }, 
            "vDirection": {
                "docstring": "move components in the direction of tangent along V at the respective components where appropriate. The flag is ignored for polygons, NURBS curves."
            }
        }
    }, 
    "movieCompressor": {
        "description": "", 
        "flags": {
            "hardwareOptions": {
                "docstring": ""
            }, 
            "softwareOptions": {
                "docstring": ""
            }
        }
    }, 
    "movieInfo": {
        "description": "movieInfo provides a mechanism for querying information about movi files. ", 
        "flags": {
            "frameCount": {
                "docstring": "Query the number of frames in the movie file"
            }, 
            "height": {
                "docstring": "Query the height of the movieFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "width": {
                "docstring": "Query the width of the movie"
            }
        }
    }, 
    "mpBirailCtx": {
        "description": "", 
        "flags": {
            "activeNodes": {
                "docstring": ""
            }, 
            "autoCreate": {
                "docstring": ""
            }, 
            "bldProfileFirst": {
                "docstring": ""
            }, 
            "bldProfileLast": {
                "docstring": ""
            }, 
            "bldProfiles": {
                "docstring": ""
            }, 
            "bldRailOne": {
                "docstring": ""
            }, 
            "bldRailTwo": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "immediate": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": ""
            }, 
            "polygon": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": ""
            }, 
            "tangentContinuityProfile1": {
                "docstring": ""
            }, 
            "tangentContinuityProfile2": {
                "docstring": ""
            }, 
            "toolNode": {
                "docstring": ""
            }, 
            "transformMode": {
                "docstring": ""
            }
        }
    }, 
    "multiProfileBirailSurface": {
        "description": "The cmd creates a railed surface by sweeping the profiles using two rail curves. The two rails are the last two arguments. For examples, if 5 curves are specified, they will correspond to \"curve1\" \"curve2\" \"curve3\" \"rail1\" \"rail2\". In this case, the cmd creates a railed surface by sweeping the profile \"curve1\" to profile \"curve2\", profile \"curve2\" to profile \"curve3\" along the two rail curves \"rail1\", \"rail2\". There must be atleast 3 profile curves followed by the two rail curves. The profile curves must intersect the two rail curves. The constructed may be made tangent continuous to the first and last profile using the flags -tp1, -tp2 provided the profiles are surface curves i.e. isoparms, curve on surface or trimmed edge. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "tangentContinuityProfile1": {
                "docstring": "Tangent continuous across the first profile. The profile must be a surface curve.Default:false"
            }, 
            "tangentContinuityProfile2": {
                "docstring": "Tangent continuous across the last profile. The profile must be a surface curve.Default:false"
            }, 
            "transformMode": {
                "docstring": "transform mode ( Non proportional, proportional ). Non proportional is default value.Default:0Advanced flags"
            }
        }
    }, 
    "mute": {
        "description": "The mute command is used to disable and enable playback on a channel. When a channel is muted, it retains the value that it was at prior to being muted. ", 
        "flags": {
            "disable": {
                "docstring": "Disable muting on the channels"
            }, 
            "force": {
                "docstring": "Forceable disable of muting on the channels. If there are keys on the mute channel, the animation and mute node will both be removed. If this flag is not set, then mute nodes with animation will only be disabled.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "myTestCmd": {
        "description": "", 
        "flags": {}
    }, 
    "nBase": {
        "description": "Edits one or more nBase objects. Note that nBase objects include nCloth, nRigid and nParticle objects, but the options on this command do not currently apply to nParticle objects. ", 
        "flags": {
            "clearCachedTextureMap": {
                "docstring": "Clear the cached texture map for the specified attribute from the nBase.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "clearStart": {
                "docstring": "Indicates that start state should be cleared"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "stuffStart": {
                "docstring": "Indicates that current state should be stuffed into the start state"
            }, 
            "textureToVertex": {
                "docstring": "Transfer the texture map data for the specified attribute into the related per-vertex attribute."
            }
        }
    }, 
    "nParticle": {
        "description": "The nParticle command creates a new nParticle object from a list of world space points. If an nParticle object is created, the command returns the names of the new particle shape and its associated particle object dependency node. If an object was queried, the results of the query are returned. Per particle attributes can be queried using the particleId or the order of the particle in the particle array. If an object was edited, nothing is returned. ", 
        "flags": {
            "attribute": {
                "docstring": "Used in per particle attribute query and edit. Specifies the name of the attribute being queried or edited. "
            }, 
            "cache": {
                "docstring": "Turns caching on/off for the particle shape."
            }, 
            "conserve": {
                "docstring": "Conservation of momentum control (between 0 and 1). Specifies the fraction of the particle shape's existing momentum which is conserved from frame to frame. A value of 1 (the default) corresponds to true Newtonian physics, in which momentum is conserved."
            }, 
            "count": {
                "docstring": "Returns the number of particles in the object."
            }, 
            "deleteCache": {
                "docstring": "Deletes the particle shapes cache. This command is not undoable.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dynamicAttrList": {
                "docstring": "Returns a list of the dynamic attributes in the object."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "floatValue": {
                "docstring": "Used only in per particle attribute edit. Specifies that the edit is of a float attribute and must be followed by the new float value."
            }, 
            "gridSpacing": {
                "docstring": "Spacing between particles in the grid."
            }, 
            "inherit": {
                "docstring": "Inherit this fraction (0-1) of emitting object's velocity."
            }, 
            "jitterBasePoint": {
                "docstring": "Base point (center point) for jitters. The command will create one swatch of jitters for each base point. It will pair up other flags with base points in the order they are given in the command line. If not enough instances of the other flags are availble, the last one on the line with be used for all other instances of -jpb."
            }, 
            "jitterRadius": {
                "docstring": "Max radius from the center to place the particle instances."
            }, 
            "lowerLeft": {
                "docstring": "Lower left point of grid."
            }, 
            "name": {
                "docstring": "name of particle object"
            }, 
            "numJitters": {
                "docstring": "Number of jitters (instances) per particle."
            }, 
            "order": {
                "docstring": "Used in per particle attribute query and edit. Specifies the zero-based order (index) of the particle whose attribute is being queried or edited in the particle array. Querying the value of a per particle attribute requires the -attribute and -id or -order flags and their arguments to precede the -q flag. "
            }, 
            "particleId": {
                "docstring": "Used in per particle attribute query and edit. Specifies the id of the particle whose attribute is being queried or edited. Querying the value of a per particle attribute requires the -attribute and -id or -order flags and their arguments to precede the -q flag. "
            }, 
            "perParticleDouble": {
                "docstring": "Returns a list of the per-particle double attributes, excluding initial-state, cache, and information-only attributes."
            }, 
            "perParticleVector": {
                "docstring": "Returns a list of the per-particle vector attributes, excluding initial-state, cache, and information-only attributes."
            }, 
            "position": {
                "docstring": "World-space position of each particle."
            }, 
            "query": {
                "docstring": ""
            }, 
            "shapeName": {
                "docstring": "Specify the shape name used for geometry instancing. DO not confuse this with the -n flag which names the particle object."
            }, 
            "upperRight": {
                "docstring": "Upper right point of grid."
            }, 
            "vectorValue": {
                "docstring": "Used only in per particle attribute edit. Specifies that the edit is of a vector attribute and must be followed by all three float values for the vector."
            }
        }
    }, 
    "nameCommand": {
        "description": "This command creates a nameCommand object. Each nameCommand object can be connected to a hotkey. Thereafter, the nameCommand's command string will be executed whenever the hotkey is pressed (or released, as specified by the user). ", 
        "flags": {
            "annotation": {
                "docstring": "A description of the command."
            }, 
            "command": {
                "docstring": "The command that is executed when the nameCommand is invoked."
            }, 
            "data1": {
                "docstring": ""
            }, 
            "data2": {
                "docstring": ""
            }, 
            "data3": {
                "docstring": "These are optional, user-defined data strings that are attached to the nameCommand object. They can be edited or queried using the assignCommand command.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "default": {
                "docstring": "Indicate that this name command is a default command. Default name commands will not be saved to preferences."
            }, 
            "sourceType": {
                "docstring": "Sets the language type for the command script. Can only be used in conjunction with the -command flag. Valid values are \"mel\" (enabled by default), and \"python\"."
            }
        }
    }, 
    "nameField": {
        "description": "This command creates an editable field that can be linked to the name of a Maya object. The field will always show the name of the object. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "This command is executed when the field text is changed by the user."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "nameChangeCommand": {
                "docstring": "This command is executed when the name of the node changes. NOTE: this will be executed when the node name changes, whether or not the name-change originated with the user typing into the field. If you want to attach a command to be executed when the user types into the field, use the -cc/changeCommand flag."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "object": {
                "docstring": "Attaches the field to the named dage object, so that the field will always display the object's name."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "receiveFocusCommand": {
                "docstring": "Command executed when the field receives focus.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "namespace": {
        "description": "This command allows a namespace to be created or set or removed. A namespace is a simple grouping of objects under a given name. Namespaces are primarily used to resolve name-clash issues in Maya, where a new object has the same name as an existing object (from importing a file, for example). Using namespaces, you can have two objects with the same name, as long as they are contained in differenct namespaces. Namespaces are reminiscent of hierarchical structures like file systems where namespaces are analogous to directories and objects are analogous to files. The colon (':') character is the separator used to separate the names of namespaces and nodes instead of the slash ('/') or backslash ('\\') character. Namespaces can contain other namespaces as well as objects. Like objects, the names of namespaces must be unique within another namespace. Objects and namespaces can be in only one namespace. Namespace names and object names don't clash so a namespace and an object contained in another namespace can have the same name. There is an unnamed root namespace specified with a leading colon (':'). Any object not in a named namespace is in the root namespace. Normally, the leading colon is omitted from the name of an object as it's presence is implied. The presence of a leading colon is important when moving objects between namespaces using the 'rename' command. For the 'rename' command, the new name is relative to the current namespace unless the new name is fully qualified with a leading colon. Namespaces are created using the add/addNamespace flag. By default they are created under the current namespace. Changing the current namespace is done with -set/setNamespace flag. To reset the current namespace to the root namespace, use 'namespace -set \":\";'. Whenever an object is created, it is added to the current namespace. If the given name is qualified then any intervening namespaces which do not yet exist will be automatically created. For example, if the name of the new namespace is specified as \"A:B\" and the current namespace already has a child namespace named \"A\" then a new child namespace named \"B\" will be created under \"A\". But if the current namespace does not yet have a child named \"A\" then it will be created automatically. This applies regardless of the number of levels in the provided name (e.g. \"A:B:C:D\"). The -p/-parent flag can be used to explicitly specify the parent namespace under which the new one should be created, rather than just defaulting to the current namespace. If the name given for the new namespace is absolute (i.e. it begins with a colon, as in \":A:B\") then both the current namespace and the -parent flag will be ignored and the new namespace will be created under the root namespace. The relativeNamespace flag can be used to change the way node names are displayed in the UI and returned by the 'ls' command. Here are some specific details on how the return from the 'ls' command works in relativeNamespace mode: List all mesh objects in the scene:ls -type \"mesh\";The above command lists all mesh objects in the root and any child namespaces. In relative name lookup mode, all names will be displayed relative to the current namespace. When not in relative name lookup mode (the default behaviour in Maya), results are printed relative to the root namespace.Using a \"\\*\" wildcard:namespace -set myNS;ls -type \"mesh \"\\*\";In relative name lookup mode, the \"\\*\" will match to the current namespace and thus the ls command will list only those meshes defined within the current namespace (i.e. myNs). If relative name lookup is off (the default behaviour in Maya), names are root-relative and thus \"\\*\" matches the root namespace, with the net result being that only thoses meshes defined in the root namespace will be listed.You can force the root namespace to be listed when in relative name lookup mode by specifying \":\\*\" as your search pattern (i.e. ls -type mesh \":\\*\" which lists those meshes defined in the root namespace only). Note that you can also use \":\\*\" when relative name lookup mode is off to match the root if you want a consistent way to list the root.Listing child namespace contents:ls -type mesh \"\\*:\\*\";For an example to list all meshes in immediate child namespaces, use \"\\*:\\*\". In relative name lookup mode \"\\*:\\*\" lists those meshes in immediate child namespaces of the current namespaces. When not in relative name lookup mode, \"\\*:\\*\" lists meshes in namespaces one level below the root.Recursive listing of namespace contents:Example: ls -type mesh -recurse on \"\\*\"The -recurse flag is provided on the \"ls\" command to recursively traverse any child namespaces. In relative name lookup mode, the above example command will list all meshes in the current and any child namespaces of current. When not in relative name lookup mode, the above example command works from the root downwards and is thus equivalent to \"ls -type mesh\".", 
        "flags": {
            "absoluteName": {
                "docstring": "Command will return namespace values in absolute form if return value type is namespace. The absolute namespace name refers to the name started from root namespace name and prefix with \":\"."
            }, 
            "addNamespace": {
                "docstring": "Create a new namespace with the given name. Both qualified names (\"A:B\") and unqualified names (\"A\") are acceptable. If any of the higher-level namespaces in a qualified name do not yet exist, they will be created."
            }, 
            "collapseAncestors": {
                "docstring": "Delete all empty ancestors for the given namespace. Empty namespace refers to a namespace that does not contain any DAG objects or other nested namespacesFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "exists": {
                "docstring": "Returns true if the specified namespace exists, false if not."
            }, 
            "force": {
                "docstring": "Used with -mv/-moveNamespace to force the move operation to ignore name clashes."
            }, 
            "isRootNamespace": {
                "docstring": "Returns true if the specified namespace is root, false if not."
            }, 
            "moveNamespace": {
                "docstring": "Move the contents of the first namespace into the second namespace. Child namespaces will also be moved.Attempting to move a namespace containing referenced nodes will result in an error - use the 'file -e -namespace' command to change a reference namespace.If there are objects in the source namespace with the same name as objects in the destination namespace, an error will be issued. Use the '-force' flag to override this error - name clashes will be resolved by renaming the objects to ensure uniqueness."
            }, 
            "parent": {
                "docstring": "Used with the -add/-addNamespace or -ren/-rename to specifiy the parent of the new namespace. The full namespace parent path is required. When using -add/-addNamespace with an absolute name, -p/-parent will be ignored and the command will display a warning"
            }, 
            "query": {
                "docstring": ""
            }, 
            "recurse": {
                "docstring": "Can be used with the -exists flag to recursively look for the specified namespace"
            }, 
            "relativeNames": {
                "docstring": "Turns on relative name lookup, which causes name lookups within Maya to be relative to the current namespace. By default this is off, meaning that name lookups are always relative to the root namespace. Be careful turning this feature on since commands such as setAttr will behave differently. It is wise to only turn this feature on while executing custom procedures that you have written to be namespace independent and turning relativeNames off when returning control from your custom procedures. Note that Maya will turn on relative naming during file I/O. Although it is not recommended to leave relativeNames turned on, if you try to toggle the value during file I/O you may notice that the value stays \"on\" because Maya has already temporarily enabled it internally.When relativeNames are enabled, the returns provided by the 'ls' command will be relative to the current namespace. See the main description of this command for more details."
            }, 
            "removeNamespace": {
                "docstring": "Deletes the given namespace. The namespace must be empty for it to be deleted."
            }, 
            "rename": {
                "docstring": "Rename the first namespace to second namespace name. Child namespaces will also be renamed. Both names are relative to the current namespace. Use the -parent flag to specify a parent namespace for the renamed namespace. An error is issued if the second namespace name already exists."
            }, 
            "setNamespace": {
                "docstring": "Sets the current namespace."
            }
        }
    }, 
    "namespaceInfo": {
        "description": "\"This command displays information about a namespace. The target namespace can optionally be specified on the command line. If no namespace is specified, the command will display information about the current namespace. A namespace is a simple grouping of objects under a given name. Each item in a namespace can then be identified by its own name, along with what namespace it belongs to. Namespaces can contain other namespaces like sets, with the restriction that all namespaces are disjoint. Namespaces are primarily used to resolve name-clash issues in Maya, where a new object has the same name as an existing object (from importing a file, for example). Using namespaces, you can have two objects with the same name, as long as they are contained in different namespaces. Note that namespaces are a simple grouping of names, so they do not effect selection, the DAG, the Dependency Graph, or any other aspect of Maya. All namespace names are colon-separated. ", 
        "flags": {
            "absoluteName": {
                "docstring": "This flag modifies queries so that the namespace name returned will be an absolute name. The absolute name is the full namespace path, starting from the root namespace \":\" and including all parent namespaces. It cannot be used together with -shortName."
            }, 
            "currentNamespace": {
                "docstring": "Display the name of the current namespace; this flag can not be used with specific namespace together."
            }, 
            "dagPath": {
                "docstring": "This flag modifies the '-ls/-listNamespace' and '-lod\\-listOnlyDependencyNodes flags to indicate that the names of any dag objects returned will include as much of the dag path as is necessary to make the names unique. If this flag is not present, the names returned will not include any dag paths."
            }, 
            "internal": {
                "docstring": "This flag used together with listOnlyDependencyNodes. When this flag is set, the returned list will include internal nodes (for example itemFilters) that are not listed by default.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "isRootNamespace": {
                "docstring": "Returns true if the namespace is root(\":\"), false if not."
            }, 
            "listNamespace": {
                "docstring": "List the contents of the namespace."
            }, 
            "listOnlyDependencyNodes": {
                "docstring": "List all dependency nodes in the namespace."
            }, 
            "listOnlyNamespaces": {
                "docstring": "List all namespaces in the namespace."
            }, 
            "parent": {
                "docstring": "Display the parent of the namespace. By default, the list returned will not include internal nodes (such as itemFilters). To include the internal nodes, use the -internal flag."
            }, 
            "recurse": {
                "docstring": "Can be specified with -listNamespace, -listOnlyNamespaces or -listOnlyDependencyNode to cause the listing to recursively include any child namespaces of the namespaces;"
            }, 
            "shortName": {
                "docstring": "This flag modifies the '-p/-parent' and '-cur\\-currentNamespace' flags to indicate that the name returned will be the base name of the namespace. If the flag is not present, the names returned are full path of the namespace, including its parent paths and base name It cannot be used together with -absoluteName."
            }
        }
    }, 
    "newton": {
        "description": "A Newton field pulls an object towards the exerting object with force dependent on the exerting object's mass, using Newton's universal law of gravitation. The transform is the associated dependency node. Use connectDynamic to cause the field to affect a dynamic object. If fields are created, this command returns the names of each of the fields. If a field was queried, the results of the query are returned. If a field was edited, the field name is returned. If object names are provided or the active selection list is non-empty, the command creates a field for every object in the list and calls addDynamic to add it to the object. If the list is empty, the command defaults to -pos 0 0 0. Setting the -pos flag with objects named on the command line is an error. ", 
        "flags": {
            "attenuation": {
                "docstring": "Attentuation rate of field"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "magnitude": {
                "docstring": "Strength of field."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which field is exerted. -1 indicates that the field has no maximum distance."
            }, 
            "minDistance": {
                "docstring": "Minimum distance at which field is exerted. Distance is in the denominator of the field force equation. Setting md to a small positive number avoids bizarre behavior when the distance gets extremely small.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "name of field"
            }, 
            "perVertex": {
                "docstring": "Per-vertex application. If this flag is set true, then each individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical copy of the force field. If this flag is set to false, then the froce is exerted only from the geometric center of the set of points."
            }, 
            "position": {
                "docstring": "Position in space where you want to place a field. The newton then emanates from this position in space rather than from an object. Note that you can both use -pos (creating a field at a position) and also provide object names."
            }, 
            "query": {
                "docstring": ""
            }, 
            "torusSectionRadius": {
                "docstring": ""
            }, 
            "volumeExclusion": {
                "docstring": ""
            }, 
            "volumeOffset": {
                "docstring": ""
            }, 
            "volumeShape": {
                "docstring": ""
            }, 
            "volumeSweep": {
                "docstring": ""
            }
        }
    }, 
    "nodeCast": {
        "description": "Given two nodes, a source node of type A and a target node of type B, where type A is either type B or a sub-type of B, this command will replace the target node with the source node. That is, all node connections, DAG hierarchy and attribute values on the target node will be removed from the target node and placed on the source node. This operation will fail if either object is referenced, locked or if the nodes do not share a common sub-type. This operation is atomic. If the given parameters fail, then the source and target nodes will remain in their initial state prior to execution of the command. IMPORTANT: the command will currently ignore instance connections and instance objects. It will also ignore reference nodes. ", 
        "flags": {
            "copyDynamicAttrs": {
                "docstring": "If the target node contains any dynamic attributes that are not defined on the source node, then create identical dynamic attricutes on the source node and copy the values and connections from the target node into them.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "disableAPICallbacks": {
                "docstring": "add comment"
            }, 
            "disableScriptJobCallbacks": {
                "docstring": "add comment"
            }, 
            "disconnectUnmatchedAttrs": {
                "docstring": "If the node that is being swapped out has any connections that do not exist on the target node, then indicate if the connection should be disconnected. By default these connections are not removed because they cannot be restored if the target node is swapped back with the source node."
            }, 
            "force": {
                "docstring": "Forces the command to do the node cast operation even if the nodes do not share a common base object. When this flag is specified the command will try to do the best possible attribute matching when swapping the command. It is notrecommended to use the '-swapValues/sv' flag with this flag."
            }, 
            "swapNames": {
                "docstring": "Swap the names of the nodes. By default names are not swapped."
            }, 
            "swapValues": {
                "docstring": "Indicates if the commands should exchange attributes on the common attributes between the two nodes. For example, if the nodes are the same base type as a transform node, then rotate, scale, translate values would be copied over."
            }
        }
    }, 
    "nodeEditor": {
        "description": "This command creates/edits/queries a nodeEditor editor. The optional argument is the name of the control. ", 
        "flags": {
            "addNewNodes": {
                "docstring": "New nodes should be added to the graph, default is on."
            }, 
            "addNode": {
                "docstring": "Adds a specified node to the graph. Passing an empty string means the current model selection will be added to the graph."
            }, 
            "additiveGraphingMode": {
                "docstring": "When enabled the graphing will add node networks to the existing graph instead of replacing it."
            }, 
            "allAttributes": {
                "docstring": "Attributes should not be filtered out of the graph, default is off."
            }, 
            "allNodes": {
                "docstring": "Nodes should not be filtered out of the graph, default is off."
            }, 
            "beginNewConnection": {
                "docstring": "Begin a new interactive connection at the given attribute."
            }, 
            "breakSelectedConnections": {
                "docstring": "Break the selected attribute connections."
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "createInfo": {
                "docstring": "Creates or modifies a hyperGraphInfo network to save the state of the editor."
            }, 
            "createNodeCommand": {
                "docstring": "Specifies a function to be used to create nodes through the editor. The function will be passed the name of the chosen node type. This is used by the tab-create workflow. By default createNodeis used."
            }, 
            "cycleHUD": {
                "docstring": "Change the HUD to the next state."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "dotFormat": {
                "docstring": "In query mode:Get the graph information in DOT format. The flag argument specifies a file path to write to.If \"-\" is supplied, the data is returned as a string, otherwise the size in bytes of the written file is returned.In edit mode:Sets the positions of nodes in the graph from a Graphviz output file in plainformat. Only the node position, width and height information is used.If the argument starts with \"graph \", it will be treated as the plain data instead of a filename. "
            }, 
            "downstream": {
                "docstring": "Include nodes which are downstream of the root nodes."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "extendToShapes": {
                "docstring": "Include child shapes for each selected transform."
            }, 
            "feedbackConnection": {
                "docstring": "Returns a description of the feedback connection(s) in the editor view, if any. The connection(s) will be returned as a list of strings, which are pairs of plugs for each connection."
            }, 
            "feedbackNode": {
                "docstring": "Returns the name of the feedback node in the editor view, if any."
            }, 
            "feedbackPlug": {
                "docstring": "Returns the name of the feedback plug (attribute) in the editor view, if any."
            }, 
            "feedbackType": {
                "docstring": "Returns the most specific type of the feedback item in the editor view, if any. Will be one of \"plug\", \"node\", \"connection\" or an empty string. Use the other feedback\\* flags to query the item description."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "filterCreateNodeTypes": {
                "docstring": "Specifies a function to be used to filter the list of node types which appear in the inline-creation menu (tab key). The function should accept one string array argument and return a string array."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "frameAll": {
                "docstring": "Frame all the contents of the node editor."
            }, 
            "frameModelSelection": {
                "docstring": "Frame the current model selection."
            }, 
            "frameSelected": {
                "docstring": "Frame the selected contents of the node editor."
            }, 
            "graphSelectedConnections": {
                "docstring": "Graph the nodes connected by the selected attribute connections."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "hudMessage": {
                "docstring": "Display the given message on the editor HUD. The flag arguments are (message, type, duration), where type is:upper-left corner.top center.upper-right corner.Duration 0 means the message stays until removed. Duration 0 means it stays for that number of seconds.An empty message erases whatever is currently displayed for the given type."
            }, 
            "ignoreAssets": {
                "docstring": "Do not display asset contents as subgraphs, instead show asset-related nodes as normal nodes, default is off."
            }, 
            "island": {
                "docstring": "Graph DG islands instead of dependency nodes."
            }, 
            "layout": {
                "docstring": "Perform an automatic layout of the graph."
            }, 
            "layoutCommand": {
                "docstring": "Specifies a function to override the default action when a graph layout is required. The function will be passed the name of editor. The function should arrange the nodes in the graph."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "nodeViewMode": {
                "docstring": "Sets the attribute view mode of selected nodes in the active scene. Mode values are: \"simple\" (no attributes displayed), \"connected\" (connected attributes only), and \"all\" (all interesting attributes displayed)."
            }, 
            "panView": {
                "docstring": "Pan the view by the given amount. Arguments of 0 0 will reset the view translation."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "pinSelectedNodes": {
                "docstring": "Pins or unpins the selected nodes."
            }, 
            "popupMenuScript": {
                "docstring": "Set the script to be called to register the popup menu with the control for this editor. The script will be called with a string argument which gives the name of the editor whose control the popup menu should be parented to."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeNode": {
                "docstring": "Removes a node from the graph. An empty string indicates that currently selected nodes should be removed."
            }, 
            "renameNode": {
                "docstring": "Rename a node in the graph. Depending on the zoom level of the view, an edit field will either appear on the node item or in a popup dialog to allow the new name to be entered."
            }, 
            "restoreInfo": {
                "docstring": "Restores the editor state corresponding to supplied hyperGraphInfo node."
            }, 
            "rootNode": {
                "docstring": "Add a node name as a root node of the graph. Passing an empty string clears the current root node list. When queried, returns the list of current root nodes."
            }, 
            "rootsFromSelection": {
                "docstring": "Specify that the root nodes for the graph should taken from the currently active selection."
            }, 
            "scaleView": {
                "docstring": "Scales the graph view by the given factor. An argument of zero means reset to default."
            }, 
            "selectAll": {
                "docstring": "Select all items in the graph."
            }, 
            "selectConnectionNodes": {
                "docstring": "Select the nodes connected by the selected attribute connections."
            }, 
            "selectFeedbackConnection": {
                "docstring": "Select the feedback connection(s) in the editor view, if any."
            }, 
            "selectNode": {
                "docstring": "Select a node in the graph. Passing an empty string clears the current selection. When queried, returns the list of currently selected nodes."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "setAsDefaultWidth": {
                "docstring": "Sets the size of the given node (in node editor) as the defaultFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "settingsChangedCallback": {
                "docstring": "Specifies a function to be called whenever settings for the node editor get changed."
            }, 
            "shaderNetworks": {
                "docstring": "Graph the shader network for all the objects on the selection list that have shaders."
            }, 
            "showAllNodeAttributes": {
                "docstring": "Display all attributes for the given node, not just primary attributes."
            }, 
            "showSGShapes": {
                "docstring": "Show shapes which are connected to the network through a shading group."
            }, 
            "showShapes": {
                "docstring": "Show shape nodes."
            }, 
            "showTransforms": {
                "docstring": "Show transforms."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "syncedSelection": {
                "docstring": "Keep the graph selection in sync with the model selection."
            }, 
            "toggleSwatchSize": {
                "docstring": "Toggles the swatch size of the given node between small and large."
            }, 
            "toolTipCommand": {
                "docstring": "Specifies a function to override the tooltip that is displayed for a node. The function will be passed the name of the node under the cursor, and should return a text string to be displayed. A simple HTML 4 subset is supported."
            }, 
            "traversalDepthLimit": {
                "docstring": "Specify the maximum number of edges which will be followed from any root node when building the graph. A negative value means unlimited. Default is unlimited."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "upstream": {
                "docstring": "Include nodes which are upstream of the root nodes."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "nodeGrapher": {
        "description": "", 
        "flags": {}
    }, 
    "nodeIconButton": {
        "description": "This control supports up to 3 icon images and 4 different display styles. The icon image displayed is the one that best fits the current size of the control given its current style. This command creates a button that can be displayed with different icons, with or without a text label. If the button is drag and dropped onto other controls (e.g., HyperShade), the command will be executed and the return string will be used as the name of a dropped node. ", 
        "flags": {
            "align": {
                "docstring": "The label alignment. Alignment values are \"left\", \"right\", and \"center\". By default, the label is aligned \"center\". Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "command": {
                "docstring": "Command executed when the control is pressed. The command should return a string which will be used to facilitate node drag and drop.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "disabledImage": {
                "docstring": "Image used when the button is disabled. Image size must be the same as the image specified with the i/imageflag. This is a Windows only flag."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "font": {
                "docstring": "The font for the text. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\"."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "image": {
                "docstring": "If you are not providing images with different sizes then you may use this flag for the control's image. If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "This control supports three icons. The icon that best fits the current size of the control will be displayed."
            }, 
            "imageOverlayLabel": {
                "docstring": "A short string, up to 5 characters, representing a label that will be displayed on top of the image."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The text that appears in the control."
            }, 
            "labelOffset": {
                "docstring": "The label offset. Default is 0. Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "marginHeight": {
                "docstring": "The number of pixels above and below the control content. The default value is 1 pixel."
            }, 
            "marginWidth": {
                "docstring": "The number of pixels on either side of the control content. The default value is 1 pixel."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "overlayLabelBackColor": {
                "docstring": "The RGBA color of the shadow behind the label defined by imageOverlayLabel. Default is 25% transparent black: 0 0 0 .25"
            }, 
            "overlayLabelColor": {
                "docstring": "The RGB color of the label defined by imageOverlayLabel. Default is a light grey: .8 .8 .8"
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "style": {
                "docstring": "The draw style of the control. Valid styles are \"iconOnly\", \"textOnly\", \"iconAndTextHorizontal\", \"iconAndTextVertical\", and \"iconAndTextCentered\". (Note: \"iconAndTextCentered\" is only available on Windows). If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "nodeOutliner": {
        "description": "The nodeOutliner command creates, edits and queries an outline control that shows dependency nodes and their attributes. Compound attributes are further expandable to show their children. Additional configure flags allow multi selection, customizable commands to issue upon selection, and showing connections (and connectability) to a single input attribute. There are also the abilities to add/remove/replace nodes through the command line interface, and drag/add. In some configurations, dragging a connected attribute of a node will load the node at the other end of the connection. There is a right mouse button menu and a flag to attach a command to it. The menu is used to list the specific connections of a connected attribute. Clicking over any spot but the row of a connected attribute will show an empty menu. By default, there is no command attached to the menu. In query mode, return type is based on queried flag.", 
        "flags": {
            "addCommand": {
                "docstring": "Command executed when the node outliner adds something. String commands use substitution of the term %node for whatever is added, eg, if you want to print the object added, the command should be \"print(\\\"%node \\\\n\\\")\". Callable python objects are passed the node name."
            }, 
            "addObject": {
                "docstring": "add the given object to the display"
            }, 
            "annotation": {
                "docstring": ""
            }, 
            "attrAlphaOrder": {
                "docstring": "Specify how attributes are to be sorted. Current recognised values are \"default\" for no sorting and \"ascend\" to sort attributes from 'a' to ''z' and \"descend\" to sort from 'z' to 'a'. Notes: a) this only applies to top level attributes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "backgroundColor": {
                "docstring": ""
            }, 
            "connectivity": {
                "docstring": "Takes an attribute argument (\"nodeName.attributeName\"), dims any attributes that can't connect to the given, and highlights any attributes already connected"
            }, 
            "currentSelection": {
                "docstring": "Retruns a string array containing what is currently selected"
            }, 
            "dc": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "docTag": {
                "docstring": ""
            }, 
            "dragCallback": {
                "docstring": ""
            }, 
            "dropCallback": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": ""
            }, 
            "enableBackground": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "fullPathName": {
                "docstring": ""
            }, 
            "height": {
                "docstring": ""
            }, 
            "isObscured": {
                "docstring": ""
            }, 
            "lastClickedNode": {
                "docstring": ""
            }, 
            "lastMenuChoice": {
                "docstring": "Returns the text of the most recent menu selection."
            }, 
            "longNames": {
                "docstring": "Controls whether long or short attribute names will be used in the interface. Note that this flag is ignored if the niceNamesflag is set. Default is short names. Queried, returns a boolean."
            }, 
            "manage": {
                "docstring": ""
            }, 
            "menuCommand": {
                "docstring": "Attaches the given command to each item in the popup menu."
            }, 
            "menuMultiOption": {
                "docstring": "Sets whether a menu option labelled \"next available\" will appear as the first option on any multi-attribute's right mouse button menu. Defaults to True."
            }, 
            "multiSelect": {
                "docstring": "Allow multiSelect; more than one thing to be selected at a time"
            }, 
            "niceNames": {
                "docstring": "Controls whether the attribute names will be displayed in a more user-friendly, readable way. When this is on, the longNames flag is ignored. When this is off, attribute names will be displayed either long or short, according to the longNames flag. Default is on. Queried, returns a boolean."
            }, 
            "noConnectivity": {
                "docstring": "Reset the node outliner to not show any connectivity, ie, redraw all rows normally."
            }, 
            "nodesDisplayed": {
                "docstring": "Returns a string array containing the list of nodes showing in the node Outliner"
            }, 
            "numberOfPopupMenus": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": ""
            }, 
            "popupMenuArray": {
                "docstring": ""
            }, 
            "pressHighlightsUnconnected": {
                "docstring": "Sets whether clicking on an unconnected plug will select it or not. Default is True."
            }, 
            "preventOverride": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "redraw": {
                "docstring": ""
            }, 
            "redrawRow": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "remove the given object from the display"
            }, 
            "removeAll": {
                "docstring": "remove all objects from the display"
            }, 
            "replace": {
                "docstring": "replace what's displayed with the given objects"
            }, 
            "selectCommand": {
                "docstring": "Command issued by selecting. Different from the cflag in that this command will only be issued if something is selected."
            }, 
            "showConnectedOnly": {
                "docstring": "show (true) or hide (false) only attributes that are connected matching input/output criteria"
            }, 
            "showHidden": {
                "docstring": "show (true) or hide (false) UI invisible attributes that match the input/output criteria"
            }, 
            "showInputs": {
                "docstring": "show only UI visible attributes that can be connected to"
            }, 
            "showNonConnectable": {
                "docstring": "show (true) or hide (false) non connectable attributes that match the input/output criteria"
            }, 
            "showNonKeyable": {
                "docstring": "show (true) or hide (false) non keyframeable (animatable) attributes that match the input/output criteria"
            }, 
            "showOutputs": {
                "docstring": "show only UI visible attributes that can be connected from"
            }, 
            "showPublished": {
                "docstring": "Show only published attributes for an asset or a member of an asset. This flag is ignored on nodes not related to assets."
            }, 
            "showReadOnly": {
                "docstring": "show only read only attributes attributes that can be connected from"
            }, 
            "useTemplate": {
                "docstring": ""
            }, 
            "visible": {
                "docstring": ""
            }, 
            "visibleChangeCommand": {
                "docstring": ""
            }, 
            "width": {
                "docstring": ""
            }
        }
    }, 
    "nodePreset": {
        "description": "Command to save and load preset settings for a node. This command allows you to take a snapshot of the values of all attributes of a node and save it to disk as a preset with user specified name. Later the saved preset can be loaded and applied onto a different node of the same type. The end result is that the node to which the preset is applied takes on the same values as the node from which the preset was generated had at the time of the snapshot. ", 
        "flags": {
            "attributes": {
                "docstring": "A white space separated string of the named attributes to save to the preset file. If not specified, all attributes will be stored.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "custom": {
                "docstring": "Specifies a MEL script for custom handling of node attributes that are not handled by the general save preset mechanism (ie. multis, dynamic attributes, or connections). The identifiers #presetName and #nodeName will be expanded before the script is run. The script must return an array of strings which will be saved to the preset file and issued as commands when the preset is applied to another node. The custom script can query #nodeName in determining what should be saved to the preset, or issue commands to query the selected node in deciding how the preset should be applied."
            }, 
            "delete": {
                "docstring": "Deletes the existing preset for the node specified by the first argument with the name specified by the second argument."
            }, 
            "exists": {
                "docstring": "Returns true if the node specified by the first argument already has a preset with a name specified by the second argument. This flag can be used to check if the user is about to overwrite an existing preset and thereby provide the user with an opportunity to choose a different name."
            }, 
            "isValidName": {
                "docstring": "Returns true if the name consists entirely of valid characters for a preset name. Returns false if not. Because the preset name will become part of a file name and part of a MEL procedure name, some characters must be disallowed. Only alphanumeric characters and underscore are valid characters for the preset name."
            }, 
            "list": {
                "docstring": "Lists the names of all presets which can be loaded onto the specified node."
            }, 
            "load": {
                "docstring": "Sets the settings of the node specified by the first argument according to the preset specified by the second argument. Any attributes on the node which are the destinations of connections or whose children (multi children or compound children) are destinations of connections will not be changed by the preset."
            }, 
            "save": {
                "docstring": "Saves the current settings of the node specified by the first argument to a preset of the name specified by the second argument. If a preset for that node with that name already exists, it will be overwritten with no warning. You can use the -exists flag to check if the preset already exists. If an attribute of the node is the destination of a connection, the value of the attribute will not be written as part of the preset."
            }
        }
    }, 
    "nodeTreeLister": {
        "description": "This command creates/edits/queries the node tree lister control. nodeTreeLister is a treeLister, but items are assumed to have commands which return dependency node names. Dragging from the results pane is supported. The optional argument is the name of the control. ", 
        "flags": {
            "addFavorite": {
                "docstring": "Add an item path to the favorites folder. The item path does not have to actually be in the tree."
            }, 
            "addItem": {
                "docstring": "Add an item to the control. The arguments are item-path,icon path,command where item-path is the path from the root of the tree to the item's name icon path is the icon displayed in the results list command is the script which is executed when the item is LMB clicked"
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "clearContents": {
                "docstring": "Clears the contents of the control."
            }, 
            "collapsePath": {
                "docstring": "Collapse a path in the tree."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "executeItem": {
                "docstring": "Execute the command associated with an item."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandPath": {
                "docstring": "Expand a path in the tree."
            }, 
            "expandToDepth": {
                "docstring": "Expand the tree to the given depth."
            }, 
            "favoritesCallback": {
                "docstring": "This script is called whenever a favorite is added or removed. It is passed two arguments: The item's path and a boolean indicating if it is being added to favorites (True) or removed (False)."
            }, 
            "favoritesList": {
                "docstring": "Returns the list of favorite items."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "itemScript": {
                "docstring": "Returns the language and script command of the passed item path as a two-element list, the first element is the string \"MEL\" or \"Python\" and the second is the command script. Note that items with Python callable commands will be returned as strings. "
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeFavorite": {
                "docstring": "Remove an item from favorites. Accepts the full favorite path or the tail of the full path."
            }, 
            "removeItem": {
                "docstring": "Remove an item path."
            }, 
            "resultsPathUnderCursor": {
                "docstring": "Returns the path to the result (right-pane) item under the mouse cursor. Returns an empty string if there is no such item."
            }, 
            "selectPath": {
                "docstring": "Select a path in the tree.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "nodeType": {
        "description": "This command returns a string which identifies the given node's type. When no flags are used, the unique type name is returned. This can be useful for seeing if two nodes are of the same type. When the apiflag is used, the MFn::Type of the node is returned. This can be useful for seeing if a plug-in node belongs to a given class. The apiflag cannot be used in conjunction with any other flags. When the derivedflag is used, the command returns a string array containing the names of all the currently known node types which derive from the node type of the given object. When the inheritedflag is used, the command returns a string array containing the names of all the base node types inherited by the the given node. If the isTypeNameflag is present then the argument provided to the command is taken to be the name of a node type rather than the name of a specific node. This makes it possible to query the hierarchy of node types without needing to have instances of each node type. ", 
        "flags": {
            "apiType": {
                "docstring": "Return the MFn::Type value (as a string) corresponding to the given node. This is particularly useful when the given node is defined by a plug-in, since in this case, the MFn::Type value corresponds to the underlying proxy class. This flag cannot be used in combination with any of the other flags."
            }, 
            "derived": {
                "docstring": "Return a string array containing the names of all the currently known node types which derive from the type of the specified node."
            }, 
            "inherited": {
                "docstring": "Return a string array containing the names of all the base node types inherited by the specified node."
            }, 
            "isTypeName": {
                "docstring": "If this flag is present, then the argument provided to the command is the name of a node type rather than the name of a specific node.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "nonLinear": {
        "description": "This command creates a functional deformer of the specified type that will deform the selected objects. The deformer consists of three nodes: The deformer driver that gets connected to the history of the selected objects, the deformer handle transform that controls position and orientation of the axis of the deformation and the deformer handle that maintains the deformation parameters. The type of the deformer handle shape created depends on the specified type of the deformer. The deformer handle will be positioned at the center of the selected objects' bounding box and oriented to match the orientation of the leading object in the selection list. The deformer handle transform will be selected when the command is completed. The nonLinear command has some flags which are specific to the nonLinear type specified with the -type flag. The flags correspond to the primary keyable attributes related to the specific type of nonLinear node. For example, if the type is \"bend\", then the flags \"-curvature\", \"-lowBound\" and \"-highBound\" may be used to initialize, edit or query those attribute values on the bend node. Examples of this are covered in the example section below. ", 
        "flags": {
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "autoParent": {
                "docstring": "Parents the deformer handle under the selected object's transform. This flag is valid only when a single object is selected."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "commonParent": {
                "docstring": "Creates a new transform and parents the selected object and the deformer handle under it. This flag is valid only when a single object is selected."
            }, 
            "defaultScale": {
                "docstring": "Sets the scale of the deformation handle to 1. By default the deformation handle is scaled to the match the largest dimension of the selected objects' bounding box. [deformerFlags] The attributes of the deformer handle shape can be set upon creation, edited and queried as normal flags using either the long or the short attribute name. e.g.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "type": {
                "docstring": "Specifies the type of deformation. The current valid deformation types are: bend, twist, squash, flare, sine and wave"
            }
        }
    }, 
    "nop": {
        "description": "", 
        "flags": {}
    }, 
    "normalConstraint": {
        "description": "Constrain an object's orientation based on the normal of the target surface(s) at the closest point(s) to the object. A normalConstraint takes as input one or more surface shapes (the targets) and a DAG transform node (the object). The normalConstraint orients the constrained object such that the aimVector (in the object's local coordinate system) aligns in world space to combined normal vector. The upVector (again the the object's local coordinate system) is aligned in world space with the worldUpVector. The combined normal vector is a weighted average of the normal vector for each target surface at the point closest to the constrained object. ", 
        "flags": {
            "aimVector": {
                "docstring": "Set the aim vector. This is the vector in local coordinates that points at the target. If not given at creation time, the default value of (1.0, 0.0, 0.0) is used."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "layer": {
                "docstring": "Specify the name of the animation layer where the constraint should be added."
            }, 
            "name": {
                "docstring": "Sets the name of the constraint node to the specified name. Default name is constrainedObjectName_constraintType"
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the listed target(s) from the constraint."
            }, 
            "targetList": {
                "docstring": "Return the list of target objects."
            }, 
            "upVector": {
                "docstring": "Set local up vector. This is the vector in local coordinates that aligns with the world up vector. If not given at creation time, the default value of (0.0, 1.0, 0.0) is used."
            }, 
            "weight": {
                "docstring": "Sets the weight value for the specified target(s). If not given at creation time, the default value of 1.0 is used."
            }, 
            "weightAliasList": {
                "docstring": "Returns the names of the attributes that control the weight of the target objects. Aliases are returned in the same order as the targets are returned by the targetList flag"
            }, 
            "worldUpObject": {
                "docstring": "Set the DAG object use for worldUpType \"object\" and \"objectrotation\". See worldUpType for greater detail. The default value is no up object, which is interpreted as world space."
            }, 
            "worldUpType": {
                "docstring": "Set the type of the world up vector computation. The worldUpType can have one of 5 values: \"scene\", \"object\", \"objectrotation\", \"vector\", or \"none\". If the value is \"scene\", the upVector is aligned with the up axis of the scene and worldUpVector and worldUpObject are ignored. If the value is \"object\", the upVector is aimed as closely as possible to the origin of the space of the worldUpObject and the worldUpVector is ignored. If the value is \"objectrotation\" then the worldUpVector is interpreted as being in the coordinate space of the worldUpObject, transformed into world space and the upVector is aligned as closely as possible to the result. If the value is \"vector\", the upVector is aligned with worldUpVector as closely as possible and worldUpMatrix is ignored. Finally, if the value is \"none\" no twist calculation is performed by the constraint, with the resulting \"upVector\" orientation based previous orientation of the constrained object, and the \"great circle\" rotation needed to align the aim vector with its constraint. The default worldUpType is \"vector\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "worldUpVector": {
                "docstring": "Set world up vector. This is the vector in world coordinates that up vector should align with. See -wut/worldUpType (below)for greater detail. If not given at creation time, the default value of (0.0, 1.0, 0.0) is used."
            }
        }
    }, 
    "nurbsBoolean": {
        "description": "This command performs a boolean operation. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "nsrfsInFirstShell": {
                "docstring": "The number of selection items comprising the first shell."
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "operation": {
                "docstring": "Type of Boolean operation.Default:0"
            }, 
            "query": {
                "docstring": ""
            }, 
            "smartConnection": {
                "docstring": "Look for any of the selection items having a boolean operation as history.Default is true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "tolerance": {
                "docstring": "fitting tolerance.Default:0.01Advanced flags"
            }
        }
    }, 
    "nurbsCopyUVSet": {
        "description": "This is only a sample command for debugging purposes, which makes a copy of the implicit st parameterization on a nurbs surface to be the 1st explicit uvset. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "nurbsCube": {
        "description": "The nurbsCube command creates a new NURBS Cube made up of six planes. It creates an unit cube with center at origin by default. ", 
        "flags": {
            "axis": {
                "docstring": "The primitive's axisAdvanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting surface. 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - hepticDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "heightRatio": {
                "docstring": "Ratio of \"height\" to \"width\"Default:1.0"
            }, 
            "lengthRatio": {
                "docstring": "Ratio of \"length\" to \"width\"Default:1.0"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "patchesU": {
                "docstring": "Number of sections in UDefault:1"
            }, 
            "patchesV": {
                "docstring": "Number of sections in VDefault:1"
            }, 
            "pivot": {
                "docstring": "The primitive's pivot point"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "width": {
                "docstring": "Width of the objectDefault:1.0"
            }
        }
    }, 
    "nurbsCurveRebuildPref": {
        "description": "", 
        "flags": {
            "degree": {
                "docstring": ""
            }, 
            "endKnots": {
                "docstring": ""
            }, 
            "fitRebuild": {
                "docstring": ""
            }, 
            "keepControlPoints": {
                "docstring": ""
            }, 
            "keepEndPoints": {
                "docstring": ""
            }, 
            "keepRange": {
                "docstring": ""
            }, 
            "keepTangents": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rebuildType": {
                "docstring": ""
            }, 
            "smartSurfaceCurve": {
                "docstring": ""
            }, 
            "spans": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": ""
            }
        }
    }, 
    "nurbsCurveToBezier": {
        "description": "The nurbsCurveToBezier command attempts to convert an existing NURBS curve to a Bezier curve. ", 
        "flags": {}
    }, 
    "nurbsEditUV": {
        "description": "Command edits uvs on NURBS objects. When used with the query flag, it returns the uv values associated with the specified components. ", 
        "flags": {
            "angle": {
                "docstring": "Specifies the angle value (in degrees) that the uv values are to be rotated by.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pivotU": {
                "docstring": "Specifies the pivot value, in the u direction, about which the scale or rotate is to be performed."
            }, 
            "pivotV": {
                "docstring": "Specifies the pivot value, in the v direction, about which the scale or rotate is to be performed."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Specifies whether this command is editing the values relative to the currently existing values. Default is true;"
            }, 
            "rotation": {
                "docstring": "Specifies whether this command is editing the values with rotation values"
            }, 
            "scale": {
                "docstring": "Specifies whether this command is editing the values with scale values"
            }, 
            "scaleU": {
                "docstring": "Specifies the scale value in the u direction."
            }, 
            "scaleV": {
                "docstring": "Specifies the scale value in the v direction."
            }, 
            "uValue": {
                "docstring": "Specifies the value, in the u direction - absolute if relative flag is false.."
            }, 
            "vValue": {
                "docstring": "Specifies the value, in the v direction - absolute if relative flag is false.."
            }
        }
    }, 
    "nurbsPlane": {
        "description": "The nurbsPlane command creates a new NURBS Plane and return the name of the new surface. It creates an unit plane with center at origin by default. ", 
        "flags": {
            "axis": {
                "docstring": "The primitive's axisAdvanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting surface 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - hepticDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "lengthRatio": {
                "docstring": "The ratio of \"length\" to \"width\" of the plane.Default:1.0"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "patchesU": {
                "docstring": "The number of spans in the U direction.Default:1"
            }, 
            "patchesV": {
                "docstring": "The number of spans in the V direction.Default:1"
            }, 
            "pivot": {
                "docstring": "The primitive's pivot point"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "width": {
                "docstring": "The width of the planeDefault:1.0"
            }
        }
    }, 
    "nurbsSelect": {
        "description": "Performs selection operations on NURBS objects.If any of the border flags is set, then the appropriate borders are selected. Otherwise the current CV selection is used, or all CVs if the surfaces is selected as an object.The growSelection, shrinkSelection, borderSelection flags are then applied in that order.In practice, it is recommended to use one flag at a time, except for the border flags. ", 
        "flags": {
            "borderSelection": {
                "docstring": "Extract the border of the current CV selection.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "bottomBorder": {
                "docstring": "Selects the bottom border of the surface (V=0)."
            }, 
            "growSelection": {
                "docstring": "Grows the CV selection by the given number of CV"
            }, 
            "leftBorder": {
                "docstring": "Selects the left border of the surface (U=0)."
            }, 
            "rightBorder": {
                "docstring": "Selects the right border of the surface (U=MAX)."
            }, 
            "shrinkSelection": {
                "docstring": "Shrinks the CV selection by the given number of CV"
            }, 
            "topBorder": {
                "docstring": "Selects the top border of the patches (V=MAX)."
            }
        }
    }, 
    "nurbsSquare": {
        "description": "The nurbsSquare command creates a square ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "center": {
                "docstring": "The center point of the square."
            }, 
            "centerX": {
                "docstring": "X of the center point.Default:0"
            }, 
            "centerY": {
                "docstring": "Y of the center point.Default:0"
            }, 
            "centerZ": {
                "docstring": "Z of the center point.Default:0"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting circle: 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - hepticDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "normal": {
                "docstring": "The normal of the plane in which the square will lie."
            }, 
            "normalX": {
                "docstring": "X of the normal direction.Default:0"
            }, 
            "normalY": {
                "docstring": "Y of the normal direction.Default:0"
            }, 
            "normalZ": {
                "docstring": "Z of the normal direction.Default:1"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency nodeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sideLength1": {
                "docstring": "The length of a side on the square.Default:1.0"
            }, 
            "sideLength2": {
                "docstring": "The length of an adjacent side on the square.Default:1.0"
            }, 
            "spansPerSide": {
                "docstring": "The number of spans per side determines the resolution of the square.Default:1Advanced flags"
            }
        }
    }, 
    "nurbsToPoly": {
        "description": "This command tesselates a NURBS surface and produces a polygonal surface. The name of the new polygonal surface is returned. If construction history is ON, then the name of the new dependency node is returned as well. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "chordHeight": {
                "docstring": "Chord height is the absolute distance in OBJECT space which the center of a polygon edge can deviate from the actual center of the surface span. Only used if Format is General and if useChordHeight is true.Default:0.1"
            }, 
            "chordHeightRatio": {
                "docstring": "Chord height ratio is the ratio of the chord length of a surface span to the chord height. (This is a length to height ratio). 0 is a very loose fit. 1 is a very tight fit. (See also description of chord height.) Always used if Format is Standard Fit. Otherwise, only used if Format is General and useChordHeightRatio is true.Default:0.9"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curvatureTolerance": {
                "docstring": ""
            }, 
            "delta": {
                "docstring": "3D delta. Only used if Format is Standard Fit.Default:0.1"
            }, 
            "edgeSwap": {
                "docstring": "Edge swap. This attribute enables an algorithm which determines the optimal method with which to tessellate a quadrilateral into triangles. Only used if Format is General.Default:false"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "explicitTessellationAttributes": {
                "docstring": ""
            }, 
            "format": {
                "docstring": "Format: 0 - Triangle Count, 1 - Standard Fit, 2 - General, 3 - CVsDefault:1"
            }, 
            "fractionalTolerance": {
                "docstring": "Fractional tolerance. Only used if Format is Standard Fit.Default:0.01"
            }, 
            "matchNormalDir": {
                "docstring": "Only used when the format is CVs. Order the cvs so that the normal matches the direction of the original surface if set to true.Default:false"
            }, 
            "matchRenderTessellation": {
                "docstring": ""
            }, 
            "minEdgeLength": {
                "docstring": "Minimal edge length. Only used if Format is Standard Fit.Default:0.001"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "normalizeTrimmedUVRange": {
                "docstring": "This attribute is only applicable when a trimmed NURBS surface is used as the input surface. When true, the UV texture coordinates on the trimmed input surface are normalized and applied to the output surface as they are for the untrimmed version of the input surface. (The texture coordinates on the entire untrimmed surface are mapped to the entire output surface.) When false, the UV texture coordinates on the trimmed input surface are applied to the output surface as they are for the trimmed input surface. (Only the texture coordinates visible on the trimmed input surface are mapped to the output surface.)Default:trueCommon flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency nodeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "polygonCount": {
                "docstring": "The number of polygons to produce. Only used if Format is Triangle Count.Default:200"
            }, 
            "polygonType": {
                "docstring": "Polygon type: 0 - Triangles, 1 - QuadsDefault:0"
            }, 
            "query": {
                "docstring": ""
            }, 
            "smoothEdge": {
                "docstring": ""
            }, 
            "smoothEdgeRatio": {
                "docstring": ""
            }, 
            "uDivisionsFactor": {
                "docstring": ""
            }, 
            "uNumber": {
                "docstring": "Initial number of isoparms in U. Used in conjunction with the uType attribute. Only used if Format is General.Default:3"
            }, 
            "uType": {
                "docstring": "Initial U type tessellation criteria (3 types). Type 0 - Per surface # of isoparms in 3D. This type places a specific number of iso-parametric subdivision lines across the surface, equally spaced in 3D space. Type 1 - Per surface # of isoparms. This type places a specific number of iso-parametric subdivision lines across the surface, equally spaced in parameter space. Type 2 - Per span # of isoparms. This type places a specific number of iso-parametric subdivision lines across each surface span, equally spaced in parameter space. (This is the closest option to the Alias Studio tessellation parameters.) This attribute is only used if Format is General.Default:3"
            }, 
            "useChordHeight": {
                "docstring": "True means use chord height. Only used if Format is General.Default:false"
            }, 
            "useChordHeightRatio": {
                "docstring": "True means use chord height ratio.Default:true"
            }, 
            "useSurfaceShader": {
                "docstring": ""
            }, 
            "vDivisionsFactor": {
                "docstring": ""
            }, 
            "vNumber": {
                "docstring": "Initial number of isoparms in V. Used in conjunction with the vType attribute. Only used if Format is General.Default:3"
            }, 
            "vType": {
                "docstring": "Initial V type tessellation criteria (3 types). See description for the uType attribute. Only used if Format is General.Default:3"
            }
        }
    }, 
    "nurbsToPolygonsPref": {
        "description": "This command sets the values used by the nurbs-to-polygons (or \"tesselate\") preference. This preference is used by Maya menu items and is saved between Maya sessions. To query any of the flags, use the \"-query\" flag. For more information on the flags, see the node documentation for the \"nurbsTessellate\" node. In query mode, return type is based on queried flag.", 
        "flags": {
            "chordHeight": {
                "docstring": ""
            }, 
            "chordHeightRatio": {
                "docstring": ""
            }, 
            "delta3D": {
                "docstring": ""
            }, 
            "edgeSwap": {
                "docstring": ""
            }, 
            "format": {
                "docstring": "Valid values are 0, 1 and 2."
            }, 
            "fraction": {
                "docstring": ""
            }, 
            "matchRenderTessellation": {
                "docstring": ""
            }, 
            "merge": {
                "docstring": ""
            }, 
            "mergeTolerance": {
                "docstring": ""
            }, 
            "minEdgeLen": {
                "docstring": ""
            }, 
            "polyCount": {
                "docstring": ""
            }, 
            "polyType": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "uNumber": {
                "docstring": ""
            }, 
            "uType": {
                "docstring": ""
            }, 
            "useChordHeight": {
                "docstring": ""
            }, 
            "useChordHeightRatio": {
                "docstring": ""
            }, 
            "vNumber": {
                "docstring": ""
            }, 
            "vType": {
                "docstring": "Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "nurbsToSubdiv": {
        "description": "This command converts a NURBS surface and produces a subd surface. The name of the new subdivision surface is returned. If construction history is ON, then the name of the new dependency node is returned as well. ", 
        "flags": {
            "addUnderTransform": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "collapsePoles": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "matchPeriodic": {
                "docstring": ""
            }, 
            "maxPolyCount": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dep. node (where applicable)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "reverseNormal": {
                "docstring": ""
            }
        }
    }, 
    "nurbsToSubdivPref": {
        "description": "This command sets the values used by the nurbs-to-subdivision surface preference. This preference is used by the nurbs creation commands and is saved between Maya sessions. To query any of the flags, use the \"-query\" flag. For more information on the flags, see the node documentation for the \"nurbsToSubdivProc\" node. In query mode, return type is based on queried flag.", 
        "flags": {
            "bridge": {
                "docstring": "Valid values are 0, 1, 2 or 3."
            }, 
            "capType": {
                "docstring": "Valid values are 0 or 1."
            }, 
            "collapsePoles": {
                "docstring": ""
            }, 
            "matchPeriodic": {
                "docstring": ""
            }, 
            "maxPolyCount": {
                "docstring": ""
            }, 
            "offset": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "reverseNormal": {
                "docstring": ""
            }, 
            "solidType": {
                "docstring": "Valid values are 0, 1 or 2."
            }, 
            "trans00": {
                "docstring": ""
            }, 
            "trans01": {
                "docstring": ""
            }, 
            "trans02": {
                "docstring": ""
            }, 
            "trans10": {
                "docstring": ""
            }, 
            "trans11": {
                "docstring": ""
            }, 
            "trans12": {
                "docstring": ""
            }, 
            "trans20": {
                "docstring": ""
            }, 
            "trans21": {
                "docstring": ""
            }, 
            "trans22": {
                "docstring": ""
            }, 
            "trans30": {
                "docstring": ""
            }, 
            "trans31": {
                "docstring": ""
            }, 
            "trans32": {
                "docstring": "Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "nurbsUVSet": {
        "description": "Allows user to toggle between implicit and explicit UVs on a NURBS object. Also provides a facility to create, delete, rename and set the current explicit UVSet. An implicit UVSet is non-editable. It uses the parametric make-up of the NURBS object to determine the location of UVs (isoparm intersections). NURBS objects also support explicit UVSets which are similar to the UVs of a polygonal object. UVs are created at the knots (isoparm intersections) of the object and are fully editable. In order to access UV editing capabilities on a NURBS object an explicit UVSet must be created and set as the current UVSet. ", 
        "flags": {
            "create": {
                "docstring": "Creates an explicit UV set on the specified surface. If the surface already has an explicit UV set this flag will do nothing. Use the -ue/useExplicit flag to set/unset the explicit UV set as the current UV set."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "useExplicit": {
                "docstring": "Toggles the usage of explicit/implicit UVs. When true, explicit UVs will be used, otherwise the object will use implicit UVs.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "objExists": {
        "description": "This command simply returns true or false depending on whether an object with the given name exists. ", 
        "flags": {}
    }, 
    "objectCenter": {
        "description": "This command returns the coordinates of the center of the bounding box of the specified object. If one coordinate only is specified, it will be returned as a float. If no coordinates are specified, an array of floats is returned, containing x, y, and z. If you specify multiple coordinates, only one will be returned. ", 
        "flags": {
            "gl": {
                "docstring": "Return positional values in global coordinates (default).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "local": {
                "docstring": "Return positional values in local coordinates."
            }, 
            "x": {
                "docstring": "Return X value only"
            }, 
            "y": {
                "docstring": "Return Y value only"
            }, 
            "z": {
                "docstring": "Return Z value only"
            }
        }
    }, 
    "objectType": {
        "description": "This command returns the type of elements. Warning: This command is incomplete and may not be supported by all object types. ", 
        "flags": {
            "convertTag": {
                "docstring": ""
            }, 
            "isAType": {
                "docstring": "Returns true if the object is the specified type or derives from an object that is of the specified type. This flag will only work with dependency nodes."
            }, 
            "isType": {
                "docstring": "Returns true if the object is exactly of the specified type. False otherwise."
            }, 
            "tagFromType": {
                "docstring": "Returns the type tag given a type name.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "typeFromTag": {
                "docstring": "Returns the type name given an integer type tag."
            }, 
            "typeTag": {
                "docstring": "Returns an integer tag that is unique for that object type. Not all object types will have tags. This is the unique 4-byte value that is used to identify nodes of a given type in the binary file format."
            }
        }
    }, 
    "objectTypeUI": {
        "description": "This command returns the type of UI element such as button, sliders, etc. ", 
        "flags": {
            "isType": {
                "docstring": "Returns true|false if the object is of the specified type."
            }, 
            "listAll": {
                "docstring": "Returns a list of all known UI commands and their respective types. Each entry contains three strings which are the command name, ui type and class name. Note that the class name is internal and is subject to change."
            }, 
            "superClasses": {
                "docstring": "Returns a list of the names of all super classes for the given object. Note that all class names are internal and are subject to change.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "objstats": {
        "description": "", 
        "flags": {}
    }, 
    "offsetCurve": {
        "description": "The offset command creates new offset curves from the selected curves. The connecting type for breaks in offsets is off (no connection), circular (connect with an arc) or linear (connect linearly resulting in a sharp corner). If loop cutting is on then any loops in the offset curves are trimmed away. For the default cut radius of 0.0 a sharp corner is created at each intersection. For values greater than 0.0 a small arc of that radius is created at each intersection. The cut radius value is only valid when loop cutting is on. Offsets (for planar curves) are calculated in the plane of that curve and 3d curves are offset in 3d. The subdivisionDensity flag is the maximum number of times the offset object can be subdivided (i.e. calculate the offset until the offset comes within tolerance or the iteration reaches this maximum.) The reparameterize option allows the offset curve to have a different parameterization to the original curve. This avoids uneven parameter distributions in the offset curve that can occur with large offsets of curves, but is more expensive to compute. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "connectBreaks": {
                "docstring": "Connect breaks method (between gaps): 0 - off, 1 - circular, 2 - linearDefault:2"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "cutLoop": {
                "docstring": "Do loop cutting?Default:false"
            }, 
            "cutRadius": {
                "docstring": "Loop cut radius. Only used if cutLoop attribute is set true.Default:0.0"
            }, 
            "distance": {
                "docstring": "Offset distanceDefault:1.0"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "normal": {
                "docstring": "Offset plane normalAdvanced flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curveFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reparameterize": {
                "docstring": "Do reparameterization? Not advisable to change this value.Default:false"
            }, 
            "stitch": {
                "docstring": "Stitch curve segments together. Not advisable to change this value.Default:true"
            }, 
            "subdivisionDensity": {
                "docstring": "Maximum subdivision density per spanDefault:5"
            }, 
            "tolerance": {
                "docstring": "ToleranceDefault:0.01"
            }, 
            "useGivenNormal": {
                "docstring": "Use the given normal (or, alternativelly, geometry normal)Default:1"
            }
        }
    }, 
    "offsetCurveOnSurface": {
        "description": "The offsetCurveOnSurface command offsets a curve on surface resulting in another curve on surface. The connecting type for breaks in offsets is off (no connection), circular (connect with an arc) or linear (connect linearly resulting in a sharp corner). If loop cutting is on then any loops in the offset curves are trimmed away and a sharp corner is created at each intersection. The subdivisionDensity flag is the maximum number of times the offset object can be subdivided (i.e. calculate the offset until the offset comes within tolerance or the iteration reaches this maximum.) The checkPoints flag sets the number of points per span at which the distance of the offset curve from the original curve is determined. The tolerance flag determines how accurately the offset curve should satisfy the required offset distance. A satisfactory offset curve is one for which all of the checkpoints are within the given tolerance of the required offset. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "checkPoints": {
                "docstring": "Checkpoints for fit quality per span. Not advisable to change this value.Default:3"
            }, 
            "connectBreaks": {
                "docstring": "Connect breaks method (between gaps): 0 - off, 1 - circular, 2 - linearDefault:2"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "cutLoop": {
                "docstring": "Do loop cutting?Default:false"
            }, 
            "distance": {
                "docstring": "Offset distanceDefault:1.0"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curveFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "stitch": {
                "docstring": "Stitch curve segments together. Not advisable to change this value.Default:trueAdvanced flags"
            }, 
            "subdivisionDensity": {
                "docstring": "Maximum subdivision density per spanDefault:5"
            }, 
            "tolerance": {
                "docstring": "ToleranceDefault:0.01"
            }
        }
    }, 
    "offsetSurface": {
        "description": "The offset command creates new offset surfaces from the selected surfaces. The default method is a surface offset, which offsets relative to the surface itself. The CV offset method offsets the CVs directly rather than the surface, so is usually slightly less accurate but is faster. The offset surface will always have the same degree, number of CVs and knot spacing as the original surface. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "distance": {
                "docstring": "Offset distanceDefault:1.0"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "method": {
                "docstring": "Offset method 0 - Surface Fit 1 - CV FitDefault:0Advanced flags"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency nodeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "ogs": {
        "description": "OGS is one of the viewport renderers. As there is a lot of effort involved in migrating functionality it will evolve over several releases. As it evolves it is prudent to provide safeguards to get the database back to a known state. That is the function of this command, similar to how 'dgdirty' is used to restore state to the dependency graph. ", 
        "flags": {
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": "If used then reset the entire OGS database for all viewports using it. In query mode the number of viewports that would be affected is returned but the reset is not actually done.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "ogsRender": {
        "description": "Renders an image or a sequence using the OGS rendering engine ", 
        "flags": {
            "activeMultisampleType": {
                "docstring": "Query the current active multisample type."
            }, 
            "activeRenderOverride": {
                "docstring": "Set or query the current active render override."
            }, 
            "activeRenderTargetFormat": {
                "docstring": "Query the current active floating point target format.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "availableFloatingPointTargetFormat": {
                "docstring": "Returns the names of available floating point render target format."
            }, 
            "availableMultisampleType": {
                "docstring": "Returns the names of available multisample type."
            }, 
            "availableRenderOverrides": {
                "docstring": "Returns the names of available render overrides."
            }, 
            "camera": {
                "docstring": "Specify the camera to use. Use the first available camera if the camera given is not found."
            }, 
            "currentFrame": {
                "docstring": "Render the current frame."
            }, 
            "currentView": {
                "docstring": "When turned on, only the current view will be rendered."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enableFloatingPointRenderTarget": {
                "docstring": "Enable/disable floating point render target."
            }, 
            "enableMultisample": {
                "docstring": "Enable/disable multisample."
            }, 
            "frame": {
                "docstring": "Specify the frame to render."
            }, 
            "height": {
                "docstring": "The height flag pass the height to the ogsRender command. If not used, the height is taken from the render globals settings."
            }, 
            "layer": {
                "docstring": "Render the specified render layer. Only this render layer will be rendered, regardless of the renderable attribute value of the render layer. The layer name will be appended to the output image file name. The specified render layer becomes the current render layer before rendering, and remains as current render layer after the rendering."
            }, 
            "noRenderView": {
                "docstring": "When turned on, the render view is not updated after image computation"
            }, 
            "query": {
                "docstring": ""
            }, 
            "width": {
                "docstring": "The width flag pass the width to the ogsRender command. If not used, the width is taken from the render globals settings."
            }
        }
    }, 
    "ogsdebug": {
        "description": "", 
        "flags": {
            "count": {
                "docstring": ""
            }, 
            "debug": {
                "docstring": ""
            }, 
            "timing": {
                "docstring": ""
            }, 
            "verbose": {
                "docstring": ""
            }
        }
    }, 
    "openGLExtension": {
        "description": "Command returns the extension name depending on whether a given OpenGL extension is supported or not. The input is the extension string to the -extension flag. If the -extension flag is not used, or if the string argument to this flag is an empty string than all extension names are returned in a single string. If the extension exists it is not necessary true that the extension is supported. This command can only be used when a modeling view has been created. Otherwise no extensions will have been initialized and the resulting string will always be the empty string. ", 
        "flags": {
            "extension": {
                "docstring": "Specifies the OpenGL extension to query."
            }, 
            "renderer": {
                "docstring": "Specifies to query the OpenGL renderer."
            }, 
            "vendor": {
                "docstring": "Specifies to query the company responsible for the OpenGL implementation.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "version": {
                "docstring": "Specifies to query the OpenGL version."
            }
        }
    }, 
    "openMayaPref": {
        "description": "Set or query API preferences. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "errlog": {
                "docstring": "toggles whether or not an error log of failed API method calls will be created. When set to true, a file called \"OpenMayaErrorLog\" will be created in Maya's current working directory. Each time an API method fails, a detailed description of the error will be written to the file along with a mini-stack trace that indicates the routine that called the failing method. Defaults to false(off).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "lazyLoad": {
                "docstring": "toggles whether or not plugins will be loaded with the RTLD_NOW flag or the RTLD_LAZY flag of dlopen(3C). If set to true, RTLD_LAZY will be used. In this mode references to functions that cannot be resolved at load time will not be considered an error. However, if one of these symbols is actually dereferenced by the plug-in at run time, Maya will crash. Defaults to false(off)."
            }, 
            "oldPluginWarning": {
                "docstring": "toggles whether or not loadPlugin will generate a warning when plug-ins are loaded that were compiled against an older, and possibly incompatible Maya release. Defaults to true(on)."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "optionMenu": {
        "description": "This command creates a popup menu control. The command creates the control and provides its menu. Subsequent calls to the menuItem command will place them in the popup. Note that commands attached to menu items will not get called. Attach any commands via the -cc/changedCommand flag. ", 
        "flags": {
            "alwaysCallChangeCommand": {
                "docstring": ""
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Adds a callback that is called when a new item is selected. The MEL script will have the newly selected item's value substituted for #1. For Python, the callback should be a callable object which accepts one argument, which is the newly selected item's value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "itemListLong": {
                "docstring": "The long names of the menu items."
            }, 
            "itemListShort": {
                "docstring": "The short names of the menu items."
            }, 
            "label": {
                "docstring": "The optional label text to the left of the popup menu."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfItems": {
                "docstring": "The number of menu items."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "select": {
                "docstring": "The current menu item. The argument and return value is 1-based. Note that the current menu item can only be set if it is enabled. -alwaysCallChangeCommand Sets whether the change command is called when the same item is selected in the list. By default, this option is false."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "The text of the current menu item.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "optionMenuGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a pre-packaged collection of label text, option menu and an extra label. Both the label and extra label are optional. Subsequent calls to the menuItem command will place them in the option menu. When adding menu items to the option menu after the initialization step, use the name of the options menu itself. See the example below for more details. Note that commands attached to menu items will not get called. Use the -cc/changedCommandflag to be notified when the user changes the value of the option menu. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when a new item is selected.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "extraLabel": {
                "docstring": "If present on creation this specifies that there will be an extra label to the right of the option menu. Sets the string to be the extra label text."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "itemListLong": {
                "docstring": "Returns the long names of the items."
            }, 
            "itemListShort": {
                "docstring": "Returns the short names of the items."
            }, 
            "label": {
                "docstring": "If present on creation this specifies that there will be a label to the left of the option menu. Sets the string to be the label text."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfItems": {
                "docstring": "Returns the number of items."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "select": {
                "docstring": "Selects an item by index. The first item is 1."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Select an item by value. Also, returns the text of the currently selected item."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "optionVar": {
        "description": "This command allows you to set and query variables which are persistent between different invocations of Maya. These variables are stored as part of the preferences. ", 
        "flags": {
            "arraySize": {
                "docstring": "returns the size of the array named \"string\". If no such variable exists, it returns 0. If the variable is not an array, it returns 1."
            }, 
            "clearArray": {
                "docstring": "If there is an array named \"string\", it is set to be empty. Empty arrays are not saved."
            }, 
            "exists": {
                "docstring": "returns 1 if a variable named \"string\" exists, 0 otherwise. All other flags will be ignored if this is used. (Query has higher precedence)"
            }, 
            "floatValue": {
                "docstring": "creates a new variable named \"string\" with double value \"float\". If a variable already exists with this name, it is overridden in favour of the new value (even if the type is different)"
            }, 
            "floatValueAppend": {
                "docstring": "adds this value to the end of the array of floats named \"string\". If no such array exists, one is created. If there was a float value with this name before, it becomes the first element of the array. If any other kind of value existed, it is overridden."
            }, 
            "intValue": {
                "docstring": "creates a new variable named \"string\" with integer value \"int\". If a variable already exists with this name, it is overridden in favour of the new value (even if the type is different)."
            }, 
            "intValueAppend": {
                "docstring": "adds this value to the end of the array of ints named \"string\". If no such array exists, one is created. If there was an int value with this name before, it becomes the first element of the array. If any other kind of value existed, it is overridden."
            }, 
            "list": {
                "docstring": "this returns a list of all the defined variable names. All other flags will be ignored if this one is used. (Query and exists flags have a higher precedence).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the variable named \"string\", if one exists.Note: all removals are done before any value setting, if both the -r and other (-sv, -iv, -fv) flags are used in the same command."
            }, 
            "removeFromArray": {
                "docstring": "removes the element numbered \"int\" in the array named \"string\". Everything beyond it then gets shuffled down."
            }, 
            "stringValue": {
                "docstring": "creates a new variable named using the first string with value given by the second string. If a variable already exists with this name, it is overridden in favour of the new value (even if the type is different)"
            }, 
            "stringValueAppend": {
                "docstring": "adds the value given by the second string to the end of the array of strings named by the first string. If no such array exists, one is created. If there was a string value with this name before, it becomes the first element of the array. If any other kind of value existed, it is overridden."
            }, 
            "version": {
                "docstring": "Preferences version number to warn about incompatbile preference files"
            }
        }
    }, 
    "orbit": {
        "description": "The orbit command revolves the camera(s) horizontally and/or vertically in the perspective window. The rotation axis is with respect to the camera. To revolve horizontally: the rotation axis is the camera up direction vector. To revolve vertically: the rotation axis is the camera left direction vector. When both the horizontal and the vertical angles are supplied on the command line, the camera is firstly revolved horizontally, then revolved vertically. This command may be applied to more than one camera; objects that are not cameras are ignored. When no camera name supplied, this command is applied to all currently active cameras. ", 
        "flags": {
            "horizontalAngle": {
                "docstring": "Angle to revolve horizontally."
            }, 
            "pivotPoint": {
                "docstring": "Used as the pivot point in the world space.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "rotationAngles": {
                "docstring": "Angle to revolve horizontally and vertically."
            }, 
            "verticalAngle": {
                "docstring": "Angle to revolve vertically."
            }
        }
    }, 
    "orbitCtx": {
        "description": "Create, edit, or query an orbit context. ", 
        "flags": {
            "alternateContext": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "localOrbit": {
                "docstring": "Orbit around the camera's center of interest.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": ""
            }, 
            "orbitScale": {
                "docstring": "In degrees of rotation per 100 pixels of cursor drag."
            }, 
            "query": {
                "docstring": ""
            }, 
            "toolName": {
                "docstring": ""
            }
        }
    }, 
    "orientConstraint": {
        "description": "Constrain an object's orientation to match the orientation of the target or the average of a number of targets. An orientConstraint takes as input one or more \"target\" DAG transform nodes to control the orientation of the single \"constraint object\" DAG transform The orientConstraint orients the constrained object to match the weighted average of the target world space orientations. ", 
        "flags": {
            "createCache": {
                "docstring": "This flag is used to generate an animation curve that serves as a cache for the constraint. The two arguments define the start and end frames.The cache is useful if the constraint has multiple targets and the constraint's interpolation type is set to \"no flip\". The \"no flip\" mode prevents flipping during playback, but the result is dependent on the previous frame. Therefore in order to consistently get the same result on a specific frame, a cache must be generated. This flag creates the cache and sets the constraint's interpolation type to \"cache\". If a cache exists already, it will be deleted and replaced with a new cache."
            }, 
            "deleteCache": {
                "docstring": "Delete an existing interpolation cache.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "layer": {
                "docstring": "Specify the name of the animation layer where the constraint should be added."
            }, 
            "maintainOffset": {
                "docstring": "The offset necessary to preserve the constrained object's initial orientation will be calculated and used as the offset."
            }, 
            "name": {
                "docstring": "Sets the name of the constraint node to the specified name. Default name is constrainedObjectName_constraintType"
            }, 
            "offset": {
                "docstring": "Sets or queries the value of the offset. Default is 0,0,0."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the listed target(s) from the constraint."
            }, 
            "skip": {
                "docstring": "Specify the axis to be skipped. Valid values are \"x\", \"y\", \"z\" and \"none\". The default value in create mode is \"none\". This flag is multi-use."
            }, 
            "targetList": {
                "docstring": "Return the list of target objects."
            }, 
            "weight": {
                "docstring": "Sets the weight value for the specified target(s). If not given at creation time, the default value of 1.0 is used."
            }, 
            "weightAliasList": {
                "docstring": "Returns the names of the attributes that control the weight of the target objects. Aliases are returned in the same order as the targets are returned by the targetList flag"
            }
        }
    }, 
    "outlinerEditor": {
        "description": "This command creates an outliner editor which can be used to display a list of objects.WARNING: some flag combinations may not behave as you expect. The command is really intended for internal use for creating the outliner used by the various editors. ", 
        "flags": {
            "allowMultiSelection": {
                "docstring": "If true then multiple selection will be allowed in the outliner."
            }, 
            "alwaysToggleSelect": {
                "docstring": "If true, then clicking on an item in the outliner will select or deselect it without affecting the selection of other items (unless allowMultiSelection is false). If false, clicking on an item in the outliner will replace the current selection with the selected item."
            }, 
            "animLayerFilterOptions": {
                "docstring": "Specifies whether a filter is to be applied when displaying animation layers. If so, the options can be \"allAffecting\" (no filter), \"active\" (only the active layers on the object will be displayed) and \"animLayerEditor\" (the settings will be taken from the animation layer editor)."
            }, 
            "attrAlphaOrder": {
                "docstring": "Specify how attributes are to be sorted. Current recognised values are \"default\" for no sorting and \"ascend\" to sort attributes from 'a' to ''z' and \"descend\" to sort from 'z' to 'a'. Notes: a) this only applies to top level attributes."
            }, 
            "attrFilter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the attributes displayed in the editor."
            }, 
            "autoExpand": {
                "docstring": "This flag specifies whether or not objects that are loaded in should have their attributes automatically expanded"
            }, 
            "autoExpandLayers": {
                "docstring": "If true then when a node with animation layer is displayed, all the animation layers will show up in expanded form."
            }, 
            "autoSelectNewObjects": {
                "docstring": "This flag specifies whether or not new objects added to the outliner should be automatically selected"
            }, 
            "containersIgnoreFilters": {
                "docstring": "This flag specifices whether or not filters should be ignored when displaying container contents."
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "directSelect": {
                "docstring": "If true then clicking on an item in the outliner will add or remove just that item from the selection connection. If false then clicking on an item in the outliner causes the selection connection to be reloaded with the currently selected items in the outliner."
            }, 
            "displayMode": {
                "docstring": "Affects how the outliner displays when a filter is applied. List mode is a non-indented flat list. DAG mode indents to represent the hierarchical structure of the model."
            }, 
            "doNotSelectNewObjects": {
                "docstring": "If true this flag specifies that new objects added to the outliner will not be selected, even if they are active"
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "dropIsParent": {
                "docstring": "This flag specifies the mode for drag'n'drop. If the flag is true, dropping items will do a reparent; if it is false, dropping will reorder items. By default, the flag is true (parent)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editAttrName": {
                "docstring": "This flag specifies whether or not attribute names can be edited. By default double-clicking on an attribute will open the expression editor for that attribute"
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandConnections": {
                "docstring": "This flag specifies whether or not attributes should be expanded to show their input connections Note: currently the expansion will only show animCurves"
            }, 
            "expandObjects": {
                "docstring": "This flag specifies whether or not objects that are loaded in should be automatically expanded."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "highlightActive": {
                "docstring": "This flag specifies whether or not the outliner should highlight objects that are active Note: if the outliner is driving the contents of another editor setting highlightActive to true may produce unexpected behavior"
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "highlightSecondary": {
                "docstring": "This flag specifies whether or not the outliner should highlight objects that are contained in the highlightConnection"
            }, 
            "ignoreDagHierarchy": {
                "docstring": "This flag specifies whether or not DAG objects are displayed in their DAG hierarchy. Warning: using this flag without some other form of sensible filtering will lead to a very confusing outliner."
            }, 
            "isChildSelected": {
                "docstring": "This flag allows you to query if one or more of the children of the specified item is selected in the outliner. The item should be specified using a unique DAG path. Note that if the specified item appears multiple times in the outliner, the result will be true if one or more children of any occurrence of the specified item in the outliner is/are selected."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "longNames": {
                "docstring": "Controls whether long or short attribute names will be used in the interface. Note that this flag is ignored if the -niceNames flag is set. Default is short names. Queried, returns a boolean."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "mapMotionTrails": {
                "docstring": "Sets whether or not we replace the motion trail in the outliner with the object it is trailing.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "masterOutliner": {
                "docstring": "This flag is the name of an outliner that this outliner will share the objects and state from. When an outliner is shared, all of its state information comes from, and is applied to, the master outliner."
            }, 
            "niceNames": {
                "docstring": "Controls whether the attribute names will be displayed in a more user-friendly, readable way. When this is on, the longNames flag is ignored. When this is off, attribute names will be displayed either long or short, according to the longNames flag. Default is on. Queried, returns a boolean."
            }, 
            "object": {
                "docstring": "This flags is used together with the parentObjectflag to get the name of the parent object for the specified object."
            }, 
            "organizeByLayer": {
                "docstring": "If true then when a node with animation layer is displayed, attributes will be displayed according to the layer(s) it belongs to: eg: Layer1 Attr1 Attr2 Layer2 Attr1 If it is false then the outliner will be organized primarily by attributes. eg: Attr1 Layer1 Layer2 Attr2 Layer1"
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "parentObject": {
                "docstring": ""
            }, 
            "pinPlug": {
                "docstring": "Pins the named plug, so it always appears in the outliner, irrespective of the incoming selection connection. In query mode, returns a list of the pinned plugs."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectCommand": {
                "docstring": "A command to be executed when an item is selected."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "setFilter": {
                "docstring": "Specifies the name of a filter which is used to filter which (if any) sets to display."
            }, 
            "setsIgnoreFilters": {
                "docstring": "This flag specifies whether or not the filter should be ignored for expanding sets to show set members (default is true)."
            }, 
            "showAnimCurvesOnly": {
                "docstring": "This flag modifies the showConnected flag. If showConnected is set to true then this flag will cause display of only those attributes that are connected to an animCurve. If showConnected is set to false then this flag does nothing."
            }, 
            "showAnimLayerWeight": {
                "docstring": "If true then when a node with animation layer is displayed, the weight of the layer will be displayed if it is keyed."
            }, 
            "showAssets": {
                "docstring": "This flags specifies whether assets should be shown in the outliner"
            }, 
            "showAttrValues": {
                "docstring": "This flag specifies whether attribute values or attribute names should be displayed. Note: currently only string attributes can have their values displayed"
            }, 
            "showAttributes": {
                "docstring": "Specifies whether to show attributes or not."
            }, 
            "showCompounds": {
                "docstring": "This flag specifies whether or not compound attributes should be displayed, or just the leaf attributes Note: if showConnected is true, and the compound attribute is connected, it will still be displayed"
            }, 
            "showConnected": {
                "docstring": "This flag modifies the showAttributes flag. If showAttributes is set to true then this flag will cause display of only those attributes that are connected in the dependency graph. If showAttributes is set to false then this flag does nothing."
            }, 
            "showContainedOnly": {
                "docstring": "This flags specifies whether nodes belonging to containers should be show under the container node only. Otherwise, it will show up under the world as well."
            }, 
            "showContainerContents": {
                "docstring": "This flags specifies whether the contents of the container should be shown under the container node in the outliner"
            }, 
            "showDagOnly": {
                "docstring": "This flag specifies whether all dependency graph objects will be displayed, or just DAG objects."
            }, 
            "showLeafs": {
                "docstring": "This flag specifies whether or not leaf attributes should be displayed, or just the compound attributes Note: if showConnected is true, and the leaf attribute is connected, it will still be displayed"
            }, 
            "showMuteInfo": {
                "docstring": ""
            }, 
            "showNamespace": {
                "docstring": "This flag specifies whether all objects will have their namespace displayed, if namespace different than root."
            }, 
            "showNumericAttrsOnly": {
                "docstring": "This flag specifies whether or not all attributes should be displayed, or just numeric attributes Note: if showConnected is true, and the attribute is connected, it will still be displayed"
            }, 
            "showPinIcons": {
                "docstring": "Sets whether pin icons are shown for unpinned plugs."
            }, 
            "showPublishedAsConnected": {
                "docstring": "This flags enables attributes that are published to be displayed in italics; otherwise, only attributes connected as a destination are shown in italics."
            }, 
            "showReferenceNodes": {
                "docstring": "Specifies whether to show reference nodes or not."
            }, 
            "showRepresentationNodes": {
                "docstring": "Specifies whether to show representation nodes or not."
            }, 
            "showSelected": {
                "docstring": "If true then the selected items are expanded in the outliner"
            }, 
            "showSetMembers": {
                "docstring": "If true then when a set is expanded, the set members will be displayed. If false, then only other sets will be displayed."
            }, 
            "showShapes": {
                "docstring": "Specifies whether to show shapes or not."
            }, 
            "showTextureNodesOnly": {
                "docstring": "This flag modifies the showConnected flag. If showConnected is set to true then this flag will cause display of only those attributes that are connected to a texture node. If showConnected is set to false then this flag does nothing."
            }, 
            "showUVAttrsOnly": {
                "docstring": "This flag specifies whether or not all attributes should be displayed, or just uv attributes Note: currently the only attribute which will be displayed is Shape.uvSet.uvSetName"
            }, 
            "showUnitlessCurves": {
                "docstring": "This flag (in combination with -expandConnections) specifies whether or not connection expansion should show unitless animCurves"
            }, 
            "showUpstreamCurves": {
                "docstring": "Specifies exactly which attributes are displayed when showAttributes and expandConnections are both true. If true, the dependency graph is searched upstream for all curves that drive the selected plugs (showing multiple curves for example in a typical driven key setup, where first the driven key curve is encountered, followed by the actual animation curve that drives the source object). If false, only the first curves encountered will be shown. Note that, even if false, multiple curves can be shown if e.g. a blendWeighted node is being used to combine multiple curves."
            }, 
            "sortOrder": {
                "docstring": "Specify how objects are to be sorted. Current recognised values are \"none\" for no sorting and \"dagName\" to sort DAG objects by name. Notes: a) non-DAG objects are always sorted by nodeType and name. b) when sortOrder is set to \"dagName\", objects cannot be reordered using drag-and-drop, they can however be reparented"
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "transmitFilters": {
                "docstring": "This flag specifies how the selectionConnection is populated when attribute filters are enabled. If this flag is set to true, then all the attributes that pass the filter will be placed on the selectionConnection. By default this flag is false"
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "unpinPlug": {
                "docstring": "Unpins the named plug."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "outlinerPanel": {
        "description": "This command creates, edit and queries outliner panels which contain only an outliner editor. ", 
        "flags": {
            "control": {
                "docstring": "Returns the top level control for this panel. Usually used for getting a parent to attach popup menus. CAUTION: panels may not have controls at times. This flag can return \"\" if no control is present."
            }, 
            "copy": {
                "docstring": "Makes this panel a copy of the specified panel. Both panels must be of the same type."
            }, 
            "createString": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the maya panel."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editString": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "init": {
                "docstring": "Initializes the panel's default state. This is usually done automatically on file -new and file -open."
            }, 
            "isUnique": {
                "docstring": "Returns true if only one instance of this panel type is allowed."
            }, 
            "label": {
                "docstring": "Specifies the user readable label for the panel."
            }, 
            "menuBarVisible": {
                "docstring": "Controls whether the menu bar for the panel is displayed."
            }, 
            "needsInit": {
                "docstring": "(Internal) On Edit will mark the panel as requiring initialization. Query will return whether the panel is marked for initialization. Used during file -new and file -open."
            }, 
            "outlinerEditor": {
                "docstring": "This flag returns the name of the outliner editor contained by the panel.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this panel."
            }, 
            "popupMenuProcedure": {
                "docstring": "Specifies the procedure called for building the panel's popup menu(s). The default value is \"buildPanelPopupMenu\". The procedure should take one string argument which is the panel's name."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replacePanel": {
                "docstring": "Will replace the specifed panel with this panel. If the target panel is within the same layout it will perform a swap."
            }, 
            "tearOff": {
                "docstring": "Will tear off this panel into a separate window with a paneLayout as the parent of the panel. When queried this flag will return if the panel has been torn off into its own window."
            }, 
            "tearOffCopy": {
                "docstring": "Will create this panel as a torn of copy of the specified source panel."
            }, 
            "unParent": {
                "docstring": "Specifies that the panel should be removed from its layout. This (obviously) cannot be used with query."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "overrideModifier": {
        "description": "This command allows you to assign modifier key behaviour to other parts of the system. For example you can use a hotkey or input device instead of a modifer key to perform the same action. Note that the original modifier key behaviour is not altered in anyway. For example, if you've assigned \"Ctrl\" key behaviour to the \"c\" key then the \"Ctrl\" key will still work as you expect, all you've done is allowed yourself to use the \"c\" key as an alternative to the \"Ctrl\" key. ", 
        "flags": {
            "clear": {
                "docstring": "Don't force any modifier keys.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "press": {
                "docstring": "Force the following modifier to be pressed. Valid values are \"Alt\", \"Ctrl\", \"Shift\"."
            }, 
            "release": {
                "docstring": "Force the following modifier to be released. Valid values are \"Alt\", \"Ctrl\", \"Shift\"."
            }
        }
    }, 
    "paint3d": {
        "description": "", 
        "flags": {}
    }, 
    "paintEffectsDisplay": {
        "description": "Command to set the global display methods for paint effects items In query mode, return type is based on queried flag.", 
        "flags": {
            "meshDrawEnable": {
                "docstring": "Set whether mesh draw is enabled on objectsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "pairBlend": {
        "description": "The pairBlend node allows a weighted combinations of 2 inputs to be blended together. It is created automatically when keying or constraining an attribute which is already connected.Alternatively, the pairBlend command can be used to connect a pairBlend node to connected attributes of a node. The previously existing connections are rewired to input1 of the pairBlend node. Additional connections can then be made manually to input2 of the pairBlend node. The pairBlend command can also be used to query the inputs to an existing pairBlend node. ", 
        "flags": {
            "attribute": {
                "docstring": "The name of the attribute(s) which the blend will drive. This flag is required when creating the blend."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "input1": {
                "docstring": "Returns a string array of the node(s) connected to input 1."
            }, 
            "input2": {
                "docstring": "Returns a string array of the node(s) connected to input 2.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "node": {
                "docstring": "The name of the node which the blend will drive. This flag is required when creating the blend."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "palettePort": {
        "description": "This command creates an array of color cells. It could be used to to store an retrieve some colors you want to manage during your working session. ", 
        "flags": {
            "actualTotal": {
                "docstring": "Set the actual number of palette entries. This number must be greater than zero, but not be greater than maximum number of palette entries defined by the dimensionsflag."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "This command string will be executed when a color in the palette is changed.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "colorEditable": {
                "docstring": "If true then the user can modify the current index's color."
            }, 
            "colorEdited": {
                "docstring": "This command string will be executed when a color in the palette is edited."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "dimensions": {
                "docstring": "Set the dimensions of the array."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "If true then the user can change the current color."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "hsvValue": {
                "docstring": "Set a color for a given cell, using HSV format. On query return the color of the current cell."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "redraw": {
                "docstring": "Forces a redraw of the array"
            }, 
            "rgbValue": {
                "docstring": "Set a color for a given cell, using RGB format. On query return the color of the current cell."
            }, 
            "setCurCell": {
                "docstring": "Set the current cell in the array to the given index. Returns the current cell when queried."
            }, 
            "topDown": {
                "docstring": "If this flag is true, it indicates that first entry should appear in top left as opposed to the bottom left."
            }, 
            "transparent": {
                "docstring": "Set a given cell to be the transparent color. A cell value of -1 indicates that no cell is transparent. On query returns the current transparent cell."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "panZoom": {
        "description": "The panZoom command pans/zooms the 2D film. The panZoom command can be applied to either a perspective or an orthographic camera. When no camera name is supplied, this command is applied to the camera in the active view. ", 
        "flags": {
            "absolute": {
                "docstring": "This flag modifies the behavior of the distance and zoomRatio flags. If specified, the distance and zoomRatio value will be applied directly."
            }, 
            "downDistance": {
                "docstring": "Set the amount of down pan distance in inches"
            }, 
            "leftDistance": {
                "docstring": "Set the amount of left pan distance in inches"
            }, 
            "relative": {
                "docstring": "This flag modifies the behavior of the distance and zoomRatio flags. If specified, the distance or zoomRatio value is used multiply the camera's existing value. By default the relative flag is always on."
            }, 
            "rightDistance": {
                "docstring": "Set the amount of right pan distance in inches"
            }, 
            "upDistance": {
                "docstring": "Set the amount of up pan distance in inches"
            }, 
            "zoomRatio": {
                "docstring": "Set the amount of zoom ratioFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "panZoomCtx": {
        "description": "This command can be used to create camera 2D pan/zoom context. ", 
        "flags": {
            "alternateContext": {
                "docstring": ""
            }, 
            "buttonDown": {
                "docstring": ""
            }, 
            "buttonUp": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "panMode": {
                "docstring": "Specify to create a camera 2D pan context, which is the default."
            }, 
            "query": {
                "docstring": ""
            }, 
            "toolName": {
                "docstring": ""
            }, 
            "zoomMode": {
                "docstring": "Specify to create a camera 2D zoom context.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "zoomScale": {
                "docstring": "Scale the zoom. The smaller the scale the slower the drag."
            }
        }
    }, 
    "paneLayout": {
        "description": "This command creates a pane layout. A pane layout may have any number of children but at any one time only certain children may be visible, as determined by the current layout configuration. For example a horizontally split pane shows only two children, one on top of the other and a visible separator between the two. The separator may be moved to vary the size of each pane. Various other pane configurations are available and all display a moveable separator that define the size of each pane in the layout. ", 
        "flags": {
            "activeFrameThickness": {
                "docstring": "The thickness of the frame drawn around the active frame. Specify an integer value greater than or equal to 0."
            }, 
            "activePane": {
                "docstring": "The active pane has a colored border surrounding it. Only one pane may be active at any one time. Using either of the flags -ap/activePaneor -api/activePaneIndexwill automatically deactivate the previously active pane. The argument is the full or short name of the child control."
            }, 
            "activePaneIndex": {
                "docstring": "The active pane index. The active pane has a colored border surrounding it. Only one pane may be active at any one time. Using either of the flags -ap/activePaneor -api/activePaneIndexwill automatically deactivate the previously active pane. The argument is an integer value ranging from 1 to 4. Panes for any particular configuration are numbered clockwise beginning with the pane in the top left corner of the layout. If any other index is specified then the current active pane is deactivated."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "configuration": {
                "docstring": "Set the layout configuration for the panes. Valid values are: \"single\", \"horizontal2\", \"vertical2\", \"horizontal3\", \"vertical3\", \"top3\", \"left3\", \"bottom3\", \"right3\", \"horizontal4\", \"vertical4\", \"top4\", \"left4\", \"bottom4\", \"right4\", \"quad\""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "numberOfVisiblePanes": {
                "docstring": "Return the number of panes visible for the present configuration."
            }, 
            "pane1": {
                "docstring": ""
            }, 
            "pane2": {
                "docstring": ""
            }, 
            "pane3": {
                "docstring": ""
            }, 
            "pane4": {
                "docstring": "Return the name of the control in the respective pane."
            }, 
            "paneSize": {
                "docstring": "The size of a pane in the current pane layout configuration. The first argument specifies the pane index and is an integer value ranging from 1 to 4. Panes for any particular configuration are numbered clockwise beginning with the pane in the top left corner of the layout. The width and height of the pane are specified by the last two arguments. Both are integer values and they indicate the percentage of the total pane layout size rather that the number of pixels."
            }, 
            "paneUnderPointer": {
                "docstring": "Return the name of the child occupying the pane that the pointer is currently over. An empty string is returned if the pointer is not over a pane."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "separatorMovedCommand": {
                "docstring": "This command executed when the pane separators are moved.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "separatorThickness": {
                "docstring": "The thickness of the separators between the panes. Specify an integer value greater than 0. This flag has no effect on Windows systems."
            }, 
            "setPane": {
                "docstring": "This flag allows you to put a child of this layout in a particular pane. The first argument is the full or short name of the control. The second argument is an integer value ranging from 1 to 4. Panes for any particular configuration are numbered clockwise beginning with the pane in the top left corner of the layout."
            }, 
            "staticHeightPane": {
                "docstring": "Set a pane to have a static height, i.e. its height will not change when the layout is dynamically resized. Only one pane can be set to have a static height at one time. This state will be retained even if another child is switched into the pane. Specify 0 to set a pane back to the default state. Any state will be lost if the pane configuration is changed."
            }, 
            "staticWidthPane": {
                "docstring": "Set a pane to have a static width, i.e. its width will not change when the layout is dynamically resized. Only one pane can be set to have a static width at one time. This state will be retained even if another child is switched into the pane. Specify 0 to set a pane back to the default state. Any state will be lost if the pane configuration is changed."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "panel": {
        "description": "This command allows editing or querying properties of any panels. Not all of the common properites of panels can be used with this command. Flags such as -tearOff and -replacePanel require that you use the explicit panel command. The command 'getPanel -typeOf panelName' will return the explicit type of a panel. In query mode, return type is based on queried flag.", 
        "flags": {
            "control": {
                "docstring": "Returns the top level control for this panel. Usually used for getting a parent to attach popup menus. CAUTION: panels may not have controls at times. This flag can return \"\" if no control is present."
            }, 
            "copy": {
                "docstring": "Makes this panel a copy of the specified panel. Both panels must be of the same type."
            }, 
            "createString": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the maya panel.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editString": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "init": {
                "docstring": "Initializes the panel's default state. This is usually done automatically on file -new and file -open."
            }, 
            "isUnique": {
                "docstring": "Returns true if only one instance of this panel type is allowed."
            }, 
            "label": {
                "docstring": "Specifies the user readable label for the panel."
            }, 
            "menuBarVisible": {
                "docstring": "Controls whether the menu bar for the panel is displayed."
            }, 
            "needsInit": {
                "docstring": "(Internal) On Edit will mark the panel as requiring initialization. Query will return whether the panel is marked for initialization. Used during file -new and file -open."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this panel."
            }, 
            "popupMenuProcedure": {
                "docstring": "Specifies the procedure called for building the panel's popup menu(s). The default value is \"buildPanelPopupMenu\". The procedure should take one string argument which is the panel's name."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replacePanel": {
                "docstring": "Will replace the specifed panel with this panel. If the target panel is within the same layout it will perform a swap."
            }, 
            "tearOff": {
                "docstring": "Will tear off this panel into a separate window with a paneLayout as the parent of the panel. When queried this flag will return if the panel has been torn off into its own window."
            }, 
            "tearOffCopy": {
                "docstring": "Will create this panel as a torn of copy of the specified source panel."
            }, 
            "unParent": {
                "docstring": "Specifies that the panel should be removed from its layout. This (obviously) cannot be used with query."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "panelConfiguration": {
        "description": "This command creates a panel configuration object. Typically you would not call this method command directly. Instead use the Panel Editor. Once a panel configuration is created you can make it appear in the main Maya window by selecting it from any panel's \"Panels-Saved Layouts\" menu. ", 
        "flags": {
            "addPanel": {
                "docstring": "Adds the specified panel to the configuration. Arguments are: isFixed, label string, type string, create string, edit string."
            }, 
            "configString": {
                "docstring": "Specifies the string that arranges the panels."
            }, 
            "createStrings": {
                "docstring": "Returns an string array of the panel creation strings."
            }, 
            "defaultImage": {
                "docstring": "The default image for this configuration. Once the default image is set it may not be changed. If an image is set with the -i/imageflag then it's value will take precedence."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editStrings": {
                "docstring": "Returns an string array of the panel edit strings.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "image": {
                "docstring": "The user specified image for this configuration. Use this flag to override the default image."
            }, 
            "isFixedState": {
                "docstring": "Returns an integer array of whether the panels have fixed states or not."
            }, 
            "label": {
                "docstring": "Configuration label."
            }, 
            "labelStrings": {
                "docstring": "Returns an string array of the panel labels."
            }, 
            "numberOfPanels": {
                "docstring": "Returns the number of panels in the configuration."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeAllPanels": {
                "docstring": "Removes the last panel in the config."
            }, 
            "removeLastPanel": {
                "docstring": "Removes the last panel in the config."
            }, 
            "replaceCreateString": {
                "docstring": "Replaces the specified create string. The index is 1 based."
            }, 
            "replaceEditString": {
                "docstring": "Replaces the specified edit string. The index is 1 based."
            }, 
            "replaceFixedState": {
                "docstring": "Replaces the specified fixed state value (true|false). The index is 1 based."
            }, 
            "replaceLabel": {
                "docstring": "Replaces the specified label. The index is 1 based."
            }, 
            "replacePanel": {
                "docstring": "Replaces the specified panel in the configuration. Arguments are: index, isFixed, label string, type string, create string, edit string. The index is 1 based."
            }, 
            "replaceTypeString": {
                "docstring": "Replaces the specified type string. The index is 1 based."
            }, 
            "sceneConfig": {
                "docstring": "Specifies whether the configuration is associated with the scene. Scene configurations are created when the scene is opened and deleted when the scene is closed."
            }, 
            "typeStrings": {
                "docstring": "Returns an string array of the panel types."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "panelHistory": {
        "description": "This command creates a panel history object. The object is targeted on a particular paneLayout and thereafter notes changes in panel configurations within that paneLayout, building up a history list. The list can be stepped through backwards or forwards. ", 
        "flags": {
            "back": {
                "docstring": "Go back one level on the history list."
            }, 
            "clear": {
                "docstring": "Clear the history stack"
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "forward": {
                "docstring": "Go forward one level on the history list."
            }, 
            "historyDepth": {
                "docstring": "Specifies how many levels of history are maintained."
            }, 
            "isEmpty": {
                "docstring": "Returns true if there is currently no panel history.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "suspend": {
                "docstring": "Specifies whether to suspend or resume updates to the panel history. Useful for chunking a number of changes into one history event."
            }, 
            "targetPane": {
                "docstring": "Specifies which paneLayout the history will be maintained for."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "wrap": {
                "docstring": "Specifies whether the history will wrap at the end and beginning. This value is true by default."
            }
        }
    }, 
    "paramDimContext": {
        "description": "Command used to register the paramDimCtx tool. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "paramDimension": {
        "description": "This command is used to create a param dimension to display the parameter value of a curve/surface at a specified point on the curve/surface. ", 
        "flags": {}
    }, 
    "paramLocator": {
        "description": "The command creates a locator in the underworld of a NURBS curve or NURBS surface at the specified parameter value. If no object is specified, then a locator will be created on the first valid selected item (either a curve point or a surface point). ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "position": {
                "docstring": "Whether to set the locator position in normalized space.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "parent": {
        "description": "This command parents (moves) objects under a new group, removes objects from an existing group, or adds/removes parents. If the -w flag is specified all the selected or specified objects are parented to the world (unparented first). If the -rm flag is specified then all the selected or specified instances are removed. If there are more than two objects specified all the objects are parented to the last object specified. If the -add flag is specified, the objects are not reparented but also become children of the last object specified. If there is only a single object specified then the selected objects are parented to that object. If an object is parented under a different group and there is an object in that group with the same name then this command will rename the parented object. ", 
        "flags": {
            "absolute": {
                "docstring": "preserve existing world object transformations (overall object transformation is preserved by modifying the objects local transformation) If the object to parent is a joint, it will alter the translation and joint orientation of the joint to preserve the world object transformation if this suffices. Otherwise, a transform will be inserted between the joint and the parent for this purpose. In this case, the transformation inside the joint is not altered. [default]"
            }, 
            "addObject": {
                "docstring": "preserve existing local object transformations but don't reparent, just add the object(s) under the parent. Use -world to add the world as a parent of the given objects."
            }, 
            "noConnections": {
                "docstring": "The parent command will normally generate new instanced set connections when adding instances. (ie. make a connection to the shading engine for new instances) This flag supresses this behaviour and is primarily used by the file format.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "relative": {
                "docstring": "preserve existing local object transformations (relative to the parent node)"
            }, 
            "removeObject": {
                "docstring": "Remove the immediate parent of every object specified. To remove only a single instance of a shape from a parent, the path to the shape should be specified. Note: if there is a single parent then the object is effectively deleted from the scene. Use -world to remove the world as a parent of the given object."
            }, 
            "shape": {
                "docstring": "The parent command usually only operates on transforms. Using this flags allows a shape that is specified to be directly parented under the given transform. This is used to instance a shape node. (ie. \"parent -add -shape\" is equivalent to the \"instance\" command). This flag is primarily used by the file format."
            }, 
            "world": {
                "docstring": "unparent given object(s) (parent to world)"
            }
        }
    }, 
    "parentConstraint": {
        "description": "Constrain an object's position and rotation so that it behaves as if it were a child of the target object(s). In the case of multiple targets, the overall position and rotation of the constrained object is the weighted average of each target's contribution to the position and rotation of the object. A parentConstraint takes as input one or more \"target\" DAG transform nodes at which to position and rotate the single \"constraint object\" DAG transform node. The parentConstraint positions and rotates the constrained object at the weighted average of the world space position, rotation and scale target objects. ", 
        "flags": {
            "createCache": {
                "docstring": "This flag is used to generate an animation curve that serves as a cache for the constraint. The two arguments define the start and end frames.The cache is useful if the constraint has multiple targets and the constraint's interpolation type is set to \"no flip\". The \"no flip\" mode prevents flipping during playback, but the result is dependent on the previous frame. Therefore in order to consistently get the same result on a specific frame, a cache must be generated. This flag creates the cache and sets the constraint's interpolation type to \"cache\". If a cache exists already, it will be deleted and replaced with a new cache."
            }, 
            "deleteCache": {
                "docstring": "Delete an existing interpolation cache.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "layer": {
                "docstring": "Specify the name of the animation layer where the constraint should be added."
            }, 
            "maintainOffset": {
                "docstring": "If this flag is specified the position and rotation of the constrained object will be maintained."
            }, 
            "name": {
                "docstring": "Sets the name of the constraint node to the specified name. Default name is constrainedObjectName_constraintType"
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the listed target(s) from the constraint."
            }, 
            "skipRotate": {
                "docstring": "Causes the axis specified not to be considered when constraining rotation. Valid arguments are \"x\", \"y\", \"z\" and \"none\"."
            }, 
            "skipTranslate": {
                "docstring": "Causes the axis specified not to be considered when constraining translation. Valid arguments are \"x\", \"y\", \"z\" and \"none\"."
            }, 
            "targetList": {
                "docstring": "Return the list of target objects."
            }, 
            "weight": {
                "docstring": "Sets the weight value for the specified target(s). If not given at creation time, the default value of 1.0 is used."
            }, 
            "weightAliasList": {
                "docstring": "Returns the names of the attributes that control the weight of the target objects. Aliases are returned in the same order as the targets are returned by the targetList flag"
            }
        }
    }, 
    "particle": {
        "description": "The particle command creates a new particle object from a list of world space points. If a particle object is created, the command returns the names of the new particle shape and its associated particle object dependency node. If an object was queried, the results of the query are returned. Per particle attributes can be queried using the particleId or the order of the particle in the particle array. If an object was edited, nothing is returned. ", 
        "flags": {
            "attribute": {
                "docstring": "Used in per particle attribute query and edit. Specifies the name of the attribute being queried or edited. "
            }, 
            "cache": {
                "docstring": "Turns caching on/off for the particle shape."
            }, 
            "conserve": {
                "docstring": "Conservation of momentum control (between 0 and 1). Specifies the fraction of the particle shape's existing momentum which is conserved from frame to frame. A value of 1 (the default) corresponds to true Newtonian physics, in which momentum is conserved."
            }, 
            "count": {
                "docstring": "Returns the number of particles in the object."
            }, 
            "deleteCache": {
                "docstring": "Deletes the particle shapes cache. This command is not undoable.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dynamicAttrList": {
                "docstring": "Returns a list of the dynamic attributes in the object."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "floatValue": {
                "docstring": "Used only in per particle attribute edit. Specifies that the edit is of a float attribute and must be followed by the new float value."
            }, 
            "gridSpacing": {
                "docstring": "Spacing between particles in the grid."
            }, 
            "inherit": {
                "docstring": "Inherit this fraction (0-1) of emitting object's velocity."
            }, 
            "jitterBasePoint": {
                "docstring": "Base point (center point) for jitters. The command will create one swatch of jitters for each base point. It will pair up other flags with base points in the order they are given in the command line. If not enough instances of the other flags are availble, the last one on the line with be used for all other instances of -jpb."
            }, 
            "jitterRadius": {
                "docstring": "Max radius from the center to place the particle instances."
            }, 
            "lowerLeft": {
                "docstring": "Lower left point of grid."
            }, 
            "name": {
                "docstring": "name of particle object"
            }, 
            "numJitters": {
                "docstring": "Number of jitters (instances) per particle."
            }, 
            "order": {
                "docstring": "Used in per particle attribute query and edit. Specifies the zero-based order (index) of the particle whose attribute is being queried or edited in the particle array. Querying the value of a per particle attribute requires the -attribute and -id or -order flags and their arguments to precede the -q flag. "
            }, 
            "particleId": {
                "docstring": "Used in per particle attribute query and edit. Specifies the id of the particle whose attribute is being queried or edited. Querying the value of a per particle attribute requires the -attribute and -id or -order flags and their arguments to precede the -q flag. "
            }, 
            "perParticleDouble": {
                "docstring": "Returns a list of the per-particle double attributes, excluding initial-state, cache, and information-only attributes."
            }, 
            "perParticleVector": {
                "docstring": "Returns a list of the per-particle vector attributes, excluding initial-state, cache, and information-only attributes."
            }, 
            "position": {
                "docstring": "World-space position of each particle."
            }, 
            "query": {
                "docstring": ""
            }, 
            "shapeName": {
                "docstring": "Specify the shape name used for geometry instancing. DO not confuse this with the -n flag which names the particle object."
            }, 
            "upperRight": {
                "docstring": "Upper right point of grid."
            }, 
            "vectorValue": {
                "docstring": "Used only in per particle attribute edit. Specifies that the edit is of a vector attribute and must be followed by all three float values for the vector."
            }
        }
    }, 
    "particleExists": {
        "description": "This command is used to query if a particle or soft object with the given name exists. Either the transform or shape name can be used as well as the name of the soft object. ", 
        "flags": {}
    }, 
    "particleFill": {
        "description": "This command generates an nParticle system that fills the selected object with a grid of particles. ", 
        "flags": {
            "closePacking": {
                "docstring": "If this is on then the particles are positioned as closely as possible in a hexagonal close packing arrangement. Otherwise particles are packed in a uniform grid lattice.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "doubleWalled": {
                "docstring": "This flag should be used if the thickness of the object to fill has been modeled( for example a mug ). Otherwise the particles will be created inside the wall. Note that doubleWalled will not handle some cases very well. For example a double walled donut shape may get the center region of the donut filled. In cases like this it may be better to make the internal wall a separate mesh then fill that without using doubleWalled."
            }, 
            "maxX": {
                "docstring": "The fill max bounds of the particles in X relative to the X bounds of the object. A value of zero is totally empty and one is totally full. The default value is 1, or fully filled."
            }, 
            "maxY": {
                "docstring": "The fill max bounds of the particles in Y relative to the Y bounds of the object. A value of zero is totally empty and one is totally full. The default value is 1, or fully filled."
            }, 
            "maxZ": {
                "docstring": "The fill max bounds of the particles in Z relative to the Z bounds of the object. A value of zero is totally empty and one is totally full. The default value is 1, or fully filled."
            }, 
            "minX": {
                "docstring": "The fill lower bounds of the particles in X relative to the X bounds of the object. A value of zero is totally full and one is totally empty. The default value is 0, or fully filled."
            }, 
            "minY": {
                "docstring": "The fill lower bounds of the particles in Y relative to the Y bounds of the object. A value of zero is totally full and one is totally empty. The default value is 0, or fully filled."
            }, 
            "minZ": {
                "docstring": "The fill lower bounds of the particles in Z relative to the Z bounds of the object. A value of zero is totally full and one is totally empty. The default value is 0, or fully filled."
            }, 
            "particleDensity": {
                "docstring": "This controls the size of the particles. At a value of 1.0 the particle size will exactly match the grid spacing determined by the resolution parameter and the object bounds. Particles which overlap the surface will be rejected even if the center of the particle is inside."
            }, 
            "resolution": {
                "docstring": "This determines the total number of particles generated. It represent the resolution along the largest axis of the object's bounding box. For a cube shape the total potential particles will be the cube of the resolution. For other shapes it will be less. The default value for this flag is 10, so 1000 particles could be generated for a cube shape."
            }
        }
    }, 
    "particleInstancer": {
        "description": "This command is used to create a particle instancer node and set the proper attributes in the particle shape and in the instancer node. It will also create the connections needed between the particle shape and the instancer node. ", 
        "flags": {
            "addObject": {
                "docstring": "This flag indicates that objects specified by the -object flag will be added to the instancer node as instanced objects."
            }, 
            "aimAxis": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the aim axis of the instanced objects."
            }, 
            "aimDirection": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the aim direction of the instanced objects."
            }, 
            "aimPosition": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the aim position of the instanced objects."
            }, 
            "aimUpAxis": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the aim up axis of the instanced objects."
            }, 
            "aimWorldUp": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the aim world up of the instanced objects."
            }, 
            "attributeMapping": {
                "docstring": "This flag queries the particle attribute mapping list."
            }, 
            "cycle": {
                "docstring": "This flag sets or queries the cycle attribute for the instancer node. The options are \"none\", \"sequential\". The default is \"none\"."
            }, 
            "cycleStartObject": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the cycle start object of the instanced objects."
            }, 
            "cycleStep": {
                "docstring": "This flag sets or queries the cycle step attribute for the instancer node. This attribute indicates the size of the step in frames or seconds (see cycleStepUnits)."
            }, 
            "cycleStepUnits": {
                "docstring": "This flag sets or queries the cycle step unit attribute for the instancer node. The options are \"frames\" or \"seconds\". The default is \"frames\"."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "index": {
                "docstring": "This flag is used to query the name of the ith instanced object."
            }, 
            "instanceId": {
                "docstring": "This flag queries the particle attribute name to be used for the id of the instanced objects.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "levelOfDetail": {
                "docstring": "This flag sets or queries the level of detail of the instanced objects. The options are \"geometry\", \"boundingBox\" or \"boundingBoxes\". The default is \"geometry\"."
            }, 
            "name": {
                "docstring": "This flag sets or queries the name of the instancer node."
            }, 
            "object": {
                "docstring": "This flag indicates which objects will be add/removed from the list of instanced objects. The flag is used in conjuction with the -addObject and -remove flags. If neither of these flags is specified on the command line then -addObject is assumed."
            }, 
            "objectIndex": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the object index of the instanced objects."
            }, 
            "particleAge": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the age of the instanced objects."
            }, 
            "position": {
                "docstring": "DEFAULT \"worldPosition\" This flag sets or queries the particle attribute name to be used for the positions of the instanced objects. By default the attribute is worldPosition."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeObject": {
                "docstring": "This flag indicates that objects specified by the -object flag will be removed from the instancer node as instanced objects."
            }, 
            "rotation": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the rotation of the instanced objects."
            }, 
            "rotationOrder": {
                "docstring": "This flag specifies the rotation order associated with the rotation flag. The options are XYZ, XZY, YXZ, YZX, ZXY, or ZYX. By default the attribute is XYZ."
            }, 
            "rotationType": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the rotation type of the instanced objects."
            }, 
            "rotationUnits": {
                "docstring": "This flag specifies the rotation units associated with the rotation flag. The options are degrees or radians. By default the attribute is degrees."
            }, 
            "scale": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the scale of the instanced objects."
            }, 
            "shear": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the shear of the instanced objects."
            }, 
            "visibility": {
                "docstring": "This flag sets or queries the particle attribute name to be used for the visibility of the instanced objects."
            }
        }
    }, 
    "particleRenderInfo": {
        "description": "This action provides information access to the particle render subclasses. These are derived from TdynRenderBase. This action is used primarily by the Attribute Editor to gather information about attributes used for rendering. In query mode, return type is based on queried flag.", 
        "flags": {
            "attrList": {
                "docstring": "Return the list of attributes used by this render type."
            }, 
            "attrListAll": {
                "docstring": "Return a complete list of all render attributes used by the particle object. This also includes the per particle attributes."
            }, 
            "name": {
                "docstring": "Return the name of the render subclass using the render type."
            }, 
            "query": {
                "docstring": ""
            }, 
            "renderTypeCount": {
                "docstring": "Return the count of registered render classes for particle.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "partition": {
        "description": "This command is used to create, query or add/remove sets to a partition. If a partition name needs to be specified, it is the first argument, other arguments represent the set names. Without any flags, the command will create a partition with a default name. Any sets which are arguments to the command will be added to the partition. A set can be added to a partition only if none of its members are in any of the other sets in the partition. If the -re/render flag is specified when the partition is created, only 'renderable' sets can be added to the partition. Sets can be added and removed from a partition by using the -addSet or -removeSet flags. Note:If a set is already selected, and the partition command is executed, the set will be added to the created partition. ", 
        "flags": {
            "addSet": {
                "docstring": "Adds the list of sets to the named partition."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Assigns the given name to new partition. Valid only for create mode."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeSet": {
                "docstring": "Removes the list of sets from the named partition.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "render": {
                "docstring": "New partition can contain render sets. For use in creation mode only. Default is false. Can also be used with query flag - returns boolean."
            }
        }
    }, 
    "pasteKey": {
        "description": "The pasteKey command pastes curve segment hierarchies from the clipboard onto other objects or curves. If the object hierarchy from which the curve segments were copied or cut does not match the object hierarchy being pasted to, pasteKey will paste as much as it can match in the hierarchy. If animation from only one object is on the clipboard, it will be pasted to each of the target objects. If animation from more than one object is on the clipboard, selection list order determines what animation is pasted to which object. Valid operations include: One attribute to one or more attributes (Clipboard animation is pasted onto all target attributes.One attribute to one or more objects (Clipboard animation pasted onto target object, when attribute names match.)Many attributes to one or more objectsClipboard animation pasted onto targets when attribute names match.TbaseKeySetCmd.h The way the keyset clipboard will be pasted to the specified object's attributes depends on the paste \"-option\" specified. Each of these options below will be explained using an example. For all the explanations, let us assume that there is a curve segment with 20 frames of animation on the keyset clipboard (you can put curve segments onto the clipboard using the cutKeyor copyKeycommands). We will call the animation curve that we are pasting to the target curve: pasteKey -time 5 -option insert1. Shift all keyframes on the target curve after time 5 to the right by 20 frames (to make room for the 20-frame clipboard segment).2. Paste the 20-frame clipboard segment starting at time 5.pasteKey -time \"5:25\" -option replace1. Remove all keys on the target curve from 5 to 25.2. Paste the 20-frame clipboard curve at time 5.pasteKey -option replaceCompletely1. Remove all keys on the target curve.2. Paste the 20-frame clipboard curve, preserving the clipboard curve's original keyframe times.pasteKey -time 5 -option merge1.The clipboard curve segment will be pasted starting at time 5 for its full 20-frame range until frame 25.2. If a keyframe on the target curve has the same time as a keyframe on the clipboard curve, it is overwritten. Otherwise, any keys that existed in the 5:25 range before the paste, will remain untouchedpasteKey -time \"3:10\" -option scaleInsert1. Shift all keyframes on the target curve after time 3 to the right by 7 frames (to clear the range 3:10 to paste in)2. The clipboard curve segment will be scaled to fit the specified time range (i.e. the 20 frames on the clipboard will be scaled to fit into 7 frames), and then pasted into the range 3:10.pasteKey -time \"3:10\" -option scaleReplace1. Any existing keyframes in the target curve in the range 3:10 are removed.2. The clipboard curve segment will be scaled to fit the specified time range (i.e. the 20 frames on the clipboard will be scaled to fit into 7 frames), and then pasted into the range 3:10.pasteKey -time \"3:10\" -option scaleMerge1. The clipboard curve segment will be scaled to fit the specified time range (i.e. the 20 frames on the clipboard will be scaled to fit into 7 frames).2. If there are keys on the target curve at the same time as keys on the clipboard curve, they are overwritten. Otherwise, keyframes on the target curve that existed in the 3:10 range before the paste, will remain untouched.pasteKey -time \"3:10\" -option fitInsert1. Shift all the keyframes on the target curve after time 3 to the right by 7 frames (to clear the range 3:10 to paste in)2. The first 7 frames of the clipboard curve segment will be pasted into the range 3:10.pasteKey -time \"3:10\" -option fitReplace1. Any existing frames in the target curve in the range 3:10 are removed.2. The first 7 frames of the clipboard curve segment will be pasted into the range 3:10.pasteKey -time \"3:10\" -option fitMerge1. The first 7 frames of the clipboard curve segment will be pasted into the range 3:10.2. If there are keys on the target curve at the same time as keys on the clipboard curve, they are overwritten. Otherwise, keyframes on the target curve that existed in the 3:10 range before the paste, will remain untouched.", 
        "flags": {
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "clipboard": {
                "docstring": "Specifies the clipboard from which animation is pasted. Valid clipboards are \"api\" and \"anim\". The default clipboard is: anim"
            }, 
            "connect": {
                "docstring": "When true, connect the source curve with the destination curve's value at the paste time. (This has the effect of shifting the clipboard curve in value to connect with the destination curve.) False preserves the source curve's original keyframe values. Default is false."
            }, 
            "copies": {
                "docstring": "The number of times to paste the source curve."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "floatOffset": {
                "docstring": "How much to offset the pasted keys in time (for non-time-input animation curves)."
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "matchByName": {
                "docstring": "When true, we will only paste onto items in the scene whose node and attribute names match up exactly with a corresponding item in the clipboard. No hierarchy information is used. Default is false, and in this case the usual matching by hierarchy occurs.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "option": {
                "docstring": "Valid values are \"insert\", \"replace\", \"replaceCompletely\", \"merge\", \"scaleInsert,\" \"scaleReplace\", \"scaleMerge\", \"fitInsert\", \"fitReplace\", and \"fitMerge\". The default paste option is: \"insert\"."
            }, 
            "query": {
                "docstring": ""
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }, 
            "timeOffset": {
                "docstring": "How much to offset the pasted keys in time (for time-input animation curves)."
            }, 
            "valueOffset": {
                "docstring": "How much to offset the pasted keys in value."
            }
        }
    }, 
    "pathAnimation": {
        "description": "The pathAnimation command constructs the necessary graph nodes and their interconnections for a motion path animation. Motion path animation requires a curve and one or more other objects. During the animation, the objects will be moved along the 3D curve or the curveOnSurface.There are two ways to specify the moving objects: by explicitly specifying their names in the command line, orby making the objects selected (interactively, or through a MEL command).Likewise, there are two ways to specify a motion curve: by explicitly specifying the name of the motion curve in the command line (i.e. using the -c curve_name option), orby selecting the moving objects first before selecting the motion curve. I.e. if the name of the motion curve is not provided in the command line, the curve will be taken to be the last selected object in the selection list.When the end time is not specified: only one keyframe will be created either at the current time, or at the specified start time. ", 
        "flags": {
            "bank": {
                "docstring": "If on, enable alignment of the up axis of the moving object(s) to the curvature of the path geometry.Default is false.When queried, this flag returns a boolean."
            }, 
            "bankScale": {
                "docstring": "This flag specifies a factor to scale the amount of bank angle.Default is 1.0When queried, this flag returns a float."
            }, 
            "bankThreshold": {
                "docstring": "This flag specifies the limit of the bank angle.Default is 90 degreesWhen queried, this flag returns an angle."
            }, 
            "curve": {
                "docstring": "This flag specifies the name of the curve for the path.Default is NONEWhen queried, this flag returns a string."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endTimeU": {
                "docstring": "This flag specifies the ending time of the animation for the u parameter.Default is NONE.When queried, this flag returns a time.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "endU": {
                "docstring": "This flag specifies the ending value of the u parameterization for the animation.Default is the end parameterization value of the curve.When queried, this flag returns a linear."
            }, 
            "follow": {
                "docstring": "If on, enable alignment of the front axis of the moving object(s).Default is false.When queried, this flag returns a boolean."
            }, 
            "followAxis": {
                "docstring": "This flag specifies which object local axis to be aligned to the tangent of the path curve.Default is yWhen queried, this flag returns a string."
            }, 
            "fractionMode": {
                "docstring": "If on, evaluation on the path is based on the fraction of length of the path curve.Default is false.When queried, this flag returns a boolean."
            }, 
            "inverseFront": {
                "docstring": "This flag specifies whether or not to align the front axis of the moving object(s) to the opposite direction of the tangent vector of the path geometry.Default is false.When queried, this flag returns a boolean."
            }, 
            "inverseUp": {
                "docstring": "This flag specifies whether or not to align the up axis of the moving object(s) to the opposite direction of the normal vector of the path geometry.Default is false.When queried, this flag returns a boolean."
            }, 
            "name": {
                "docstring": "This flag specifies the name for the new motion path node. (instead of the default name)When queried, this flag returns a string."
            }, 
            "query": {
                "docstring": ""
            }, 
            "startTimeU": {
                "docstring": "This flag specifies the starting time of the animation for the u parameter.Default is the the current time.When queried, this flag returns a time."
            }, 
            "startU": {
                "docstring": "This flag specifies the starting value of the u parameterization for the animation.Default is the start parameterization value of the curve.When queried, this flag returns a linear."
            }, 
            "upAxis": {
                "docstring": "This flag specifies which object local axis to be aligned a computed up direction.Default is zWhen queried, this flag returns a string."
            }, 
            "useNormal": {
                "docstring": "This flag is now obsolete. Use -wut/worldUpType instead."
            }, 
            "worldUpObject": {
                "docstring": "Set the DAG object to use for worldUpType \"object\" and \"objectrotation\". See -wut/worldUpType for greater detail. The default value is no up object, which is interpreted as world space."
            }, 
            "worldUpType": {
                "docstring": "Set the type of the world up vector computation. The worldUpType can have one of 5 values: \"scene\", \"object\", \"objectrotation\", \"vector\", or \"normal\". If the value is \"scene\", the upVector is aligned with the up axis of the scene and worldUpVector and worldUpObject are ignored. If the value is \"object\", the upVector is aimed as closely as possible to the origin of the space of the worldUpObject and the worldUpVector is ignored. If the value is \"objectrotation\" then the worldUpVector is interpreted as being in the coordinate space of the worldUpObject, transformed into world space and the upVector is aligned as closely as possible to the result. If the value is \"vector\", the upVector is aligned with worldUpVector as closely as possible and worldUpObject is ignored. Finally, if the value is \"normal\" the upVector is aligned to the path geometry. The default worldUpType is \"vector\"."
            }, 
            "worldUpVector": {
                "docstring": "Set world up vector. This is the vector in world coordinates that up vector should align with. See -wut/worldUpType for greater detail. If not given at creation time, the default value of (0.0, 1.0, 0.0) is used."
            }
        }
    }, 
    "pause": {
        "description": "Pause for a specified number of seconds for canned demos or for test scripts to allow user to view results. ", 
        "flags": {
            "seconds": {
                "docstring": "Pause for the specified number of seconds.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "percent": {
        "description": "This command sets percent values on members of a weighted node such as a cluster or a jointCluster. With no flags specified the command sets the percent value for selected components of the specified node to the specified percent value. A dropoff from the specified percent value to 0 can be specifed from a point, plane or curve using a dropoff distance around that shape. The percent value can also be added or multiplied with existing percent values of the node components. In query mode, return type is based on queried flag.", 
        "flags": {
            "addPercent": {
                "docstring": "Add the percent value specified with the -v flag to the existing percent values"
            }, 
            "dropoffAxis": {
                "docstring": "Specifies the axis along which to dropoff the percent value, starting from the dropoffPosition."
            }, 
            "dropoffCurve": {
                "docstring": "Specifies the curve around which to dropoff the percent value."
            }, 
            "dropoffDistance": {
                "docstring": "Specifies the dropoff distance from the point, plane or curve that was specified using the -dp -dax or -dc flags."
            }, 
            "dropoffPosition": {
                "docstring": "Specifies the point around which to dropoff the percent value."
            }, 
            "dropoffType": {
                "docstring": "Specifies the type of dropoff. Used in conjunction with the -dp, -dax or -dc flags. Default is linear. Valid values are: linear, sine, exponential, linearSquared, none."
            }, 
            "multiplyPercent": {
                "docstring": "Multiply the percent value specified with the -v flag with existing percent valuesFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "value": {
                "docstring": "The percent value to be applied. The default is 1. In query mode, returns an array of doubles corresponding to the weights of the selected object components."
            }
        }
    }, 
    "performanceOptions": {
        "description": "Sets the global performance options for the application. The options allow the disabling of features such as stitch surfaces or deformers to cut down on computation time in the scene. Performance options that are in effect may be on all the time, or they can be turned on only for interaction. In the latter case, the options will only take effect during UI interaction or playback. Note that none of these performance options will affect rendering. ", 
        "flags": {
            "clusterResolution": {
                "docstring": "Sets the global cluster resolution. This value may range between 0.0 (exact calculation) and 10.0 (rough approximation)"
            }, 
            "disableStitch": {
                "docstring": "Sets the state of stitch surface disablement. Setting this to \"on\" suppresses the generation of stitch surfaces. Valid values are \"on\", \"off\", \"interactive\"."
            }, 
            "disableTrimBoundaryDisplay": {
                "docstring": ""
            }, 
            "disableTrimDisplay": {
                "docstring": "Sets the state of trim drawing disablement. Setting this to \"on\" suppresses the drawing of surface trims. Valid values are \"on\", \"off\", \"interactive\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "latticeResolution": {
                "docstring": "Sets the global lattice resolution. This value may range between 0.0 (exact calculation) and 1.0 (rough approximation)"
            }, 
            "passThroughBindSkinAndFlexors": {
                "docstring": "Sets the state of bind skin and all flexors pass through. Valid values are \"on\", \"off\", \"interactive\"."
            }, 
            "passThroughBlendShape": {
                "docstring": "Sets the state of blend shape deformer pass through. Valid values are \"on\", \"off\", \"interactive\"."
            }, 
            "passThroughCluster": {
                "docstring": "Sets the state of cluster deformer pass through. Valid values are \"on\", \"off\", \"interactive\"."
            }, 
            "passThroughFlexors": {
                "docstring": "Sets the state of flexor pass through. Valid values are \"on\", \"off\", \"interactive\"."
            }, 
            "passThroughLattice": {
                "docstring": "Sets the state of lattice deformer pass through. Valid values are \"on\", \"off\", \"interactive\"."
            }, 
            "passThroughPaintEffects": {
                "docstring": "Sets the state of paint effects pass through. Valid values are \"on\", \"off\", \"interactive\"."
            }, 
            "passThroughSculpt": {
                "docstring": "Sets the state of sculpt deformer pass through. Valid values are \"on\", \"off\", \"interactive\"."
            }, 
            "passThroughWire": {
                "docstring": "Sets the state of wire deformer pass through. Valid values are \"on\", \"off\", \"interactive\"."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useClusterResolution": {
                "docstring": "Sets the state of cluster deformer global resolution. This allows clusters to be calculated at a lower resolution. Valid values are \"on\", \"off\", \"interactive\"."
            }, 
            "useLatticeResolution": {
                "docstring": "Sets the state of lattice deformer global resolution. This allows lattices to be calculated at a lower resolution. Valid values are \"on\", \"off\", \"interactive\"."
            }
        }
    }, 
    "pfxstrokes": {
        "description": "This command will loop through all the Paint Effects strokes, including pfxHair nodes, and write the current state of all the tubes to a file. For normal stroke nodes tubes must be ON in the brush or there will be no output. For pfxHair nodes there will always be output, but the format is different than for stroke nodes(however one can assign a brush with tubes = ON to a pfxHair node, in which case it will output the same format as strokes). The general file format is ASCII, using commas to separate numerical values and newlines between blocks of data. The format used for pfxHair nodes presents the hair curves points in order from root to tip of the hair. The hairs follow sequentially in the following fashion: NumCvs pointX,pointY,pointZ, normalX,normalY,normalZ, width, colorR,colorG,colorB, paramU pointX,pointY,pointZ, normalX,normalY,normalZ, width, colorR,colorG,colorB, paramU etc... NumCvs pointX,pointY,pointZ, normalX,normalY,normalZ, width, colorR,colorG,colorB, paramU etc.. The format used to output files for brushes with tubes=ON is more complex. The tubes can branch and the order the segments are written is the same order they are drawn in. Slowly drawing a tall grass brush in the paint effects panel can help to illustrate the order the segments will appear in the file. New tubes can start \"growing\" before others are finished. There is no line for \"NumCvs\". Instead all data for each segment appears on each line. The data on each line is the same as passed into the paint effects runtime function. See the argument list of paintRuntimeFunc.mel for the order and a description of these parameters. The parameters match up exactly in the order they appear on a line of the output file with the order of arguments to this function. If one wishes to parse the output file and connect the segments together into curves the branchId, parentId and siblingCnt parameters can help when sorting which segment connects to which line. Using the -postCallback option will write out the tubes data after it has been proessed by the runTime callback. ", 
        "flags": {
            "filename": {
                "docstring": "The output file.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "postCallback": {
                "docstring": "Output information to the file after the Runtime Callback MEL function has been invoked. The default is to output the information prior to the callback."
            }, 
            "selected": {
                "docstring": "Only loop through the selected strokes."
            }
        }
    }, 
    "pickWalk": {
        "description": "The pickWalk command allows you to quickly change the selection list relative to the nodes that are currently selected. It is called pickWalk, because it walks from one selection list to another by unselecting what's currently selected, and selecting nodes that are in the specified direction from the currently selected list. If you specify objects on the command line, the pickWalk command will walk from those objects instead of the selected list. If the -type flag is instances, then the left and right direction will walk to the previous or next instance of the same selected dag node. ", 
        "flags": {
            "direction": {
                "docstring": "The direction to walk from the node. The choices are up | down | left | right | in | out. up walks to the parent node, down to the child node, and left and right to the sibling nodes. If a CV on a surface is selected, the left and right directions walk in the U parameter direction of the surface, and the up and down directions walk in the V parameter direction. In and out are only used if the type flag is 'latticepoints'. Default is right."
            }, 
            "type": {
                "docstring": "The choices are nodes | instances | edgeloop | edgering | faceloop | keys | latticepoints | motiontrailpoints. If type is nodes, then the left and right direction walk to the next dag siblings. If type is instances, the left and right direction walk to the previous or next instance of the same dag node. If type is edgeloop, then the edge loop starting at the first selected edge will be selected. If type is edgering, then the edge ring starting at the first selected edge will be selected. If type is faceloop, and there are two connected quad faces selected which define a face loop, then that face loop will be selected. edgeloop, edgering and faceloop all remember which was the first edge or faces selected for as long as consecutive selections are made by this command. They use this information to determine what the \"next\" loop or ring selection should be. Users can make selections forwards and backwards by using the direction flag with \"left\" or \"right\". If type is motiontrailpoints, then the left and right direction walk to the previous or next motion trail points respectively. Default is nodes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "picture": {
        "description": "This command creates a static image. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "image": {
                "docstring": "Sets the image given the .xpm file name."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "tile": {
                "docstring": "If true, the picture is tiled to fill the picture area. False by default. (Windows only flag)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "pixelMove": {
        "description": "The pixelMove command moves objects by what appears as pixel units based on the current view. It takes two integer arguments which specify the direction in screen space an object should appear to move. The vector between the center pixel of the view and the specified offset is mapped to some world space vector which defines the relative amount to move the selected objects. The mapping is dependent upon the view. ", 
        "flags": {}
    }, 
    "planarSrf": {
        "description": "This command computes a planar trimmed surface given planar boundary curves that form a closed region. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting surface: 1 - linear, 3 - cubicDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "keepOutside": {
                "docstring": "If true, keep the regions outside the given curves.Default:false"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curveFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "tolerance": {
                "docstring": "The distance tolerance for the cvs of the curves to be in the same plane.Default:0.01Advanced flags"
            }
        }
    }, 
    "plane": {
        "description": "The command creates a sketch plane (also known as a \"construction plane\") in space. To create an object (such as a NURBS curve, joint chain or polygon) on a construction plane, you need to first make the plane live. See also the makeLive command. ", 
        "flags": {
            "length": {
                "docstring": "The length of plane. \"linear\" means that this flag can handle values with units."
            }, 
            "name": {
                "docstring": "Name the resulting objectFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "position": {
                "docstring": "3D position where the centre of the plane is positioned. \"linear\" means that this flag can handle values with units."
            }, 
            "rotation": {
                "docstring": "The rotation of plane. \"angle\" means that this flag can handle values with units."
            }, 
            "size": {
                "docstring": "The combined size (size x size) of plane. \"linear\" means that this flag can handle values with units."
            }, 
            "width": {
                "docstring": "The width of plane. \"linear\" means that this flag can handle values with units."
            }
        }
    }, 
    "play": {
        "description": "This command starts and stops playback. In order to change the frame range of playback, see the playbackOptions command. In query mode, return type is based on queried flag.", 
        "flags": {
            "forward": {
                "docstring": "When true, play back the animation from the currentTime to the maximum of the playback range. When false, play back from the currentTime to the minimum of the playback range. When queried, returns an int."
            }, 
            "playSound": {
                "docstring": "Specify whether or not sound should be used during playbackFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "record": {
                "docstring": "enable the recording system and start one playback loop"
            }, 
            "sound": {
                "docstring": "Specify the sound node to be used during playback"
            }, 
            "state": {
                "docstring": "start or stop playing back"
            }, 
            "wait": {
                "docstring": "Wait till completion before returning control to command Window."
            }
        }
    }, 
    "playbackOptions": {
        "description": "This command sets/queries certain values associated with playback: looping style, start/end times, etc. Only commands modifying the -minTime/maxTime, the -animationStartTime/animationEndTime, or the -by value are undoable. ", 
        "flags": {
            "animationEndTime": {
                "docstring": "Sets the end time of the animation. Query returns a float."
            }, 
            "animationStartTime": {
                "docstring": "Sets the start time of the animation. Query returns a float."
            }, 
            "blockingAnim": {
                "docstring": "All tangents playback as stepped so that animation can be viewed in pure pose-to-pose formFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "by": {
                "docstring": "Increment between times viewed during playback. (Default 1.0)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "framesPerSecond": {
                "docstring": "Queries the actual playback rate. Query returns a float."
            }, 
            "loop": {
                "docstring": "Controls if and how playback repeats. Valid values are \"once,\" \"continuous,\" and \"oscillate.\" Query returns string."
            }, 
            "maxPlaybackSpeed": {
                "docstring": "Sets the desired maximum playback speed. Query returns a float. The maxPlaybackSpeed is only used by Maya when your playbackSpeed is 0 (play every frame). The maxPlaybackSpeed will clamp the maximum playback rate to prevent it from going more than a certain amount. A maxPlaybackSpeed of 0 will give free (unclamped) playback."
            }, 
            "maxTime": {
                "docstring": "Sets the end of the playback time range. Query returns a float."
            }, 
            "minTime": {
                "docstring": "Sets the start of the playback time range. Query returns a float."
            }, 
            "playbackSpeed": {
                "docstring": "Sets the desired playback speed. Query returns a float."
            }, 
            "query": {
                "docstring": ""
            }, 
            "view": {
                "docstring": "Controls how many modelling views update during playback. Valid values are \"all\" and \"active\". Query returns a string."
            }
        }
    }, 
    "playblast": {
        "description": "This command playblasts the current playback range. Sound is optional. ", 
        "flags": {
            "activeEditor": {
                "docstring": "This flag will return the current model editor that would be used for playblast. It does not invoke playblast itself."
            }, 
            "cameraSetup": {
                "docstring": "Information about camera setup. The first string defines a camera setup MEL procedure. The camera setup procedure will be invoked before executing a playblast. The second string argument which is used as a camera identifier and is appended to the root file name to specify the final output file name(s). The command will fail there is not a pair of strings supplied to the argument."
            }, 
            "clearCache": {
                "docstring": "When true, all previous temporary playblast files will be deleted before the new playblast files are created. Any playblast files that were explicitly given a name by the user will not be deleted. All remaining temporary playblast files will be deleted when the application quits regardless of whether this flag was set."
            }, 
            "combineSound": {
                "docstring": "Combine the trax sounds into a single track. This might force a resampling of the sound if the sound paramters don't match up.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "completeFilename": {
                "docstring": "When set, this string specifies the exact name of the output image. In contrast with the -f/filename flag, -cf/completeFilename does not append any frame number or extension string at the end of the filename. Additionally, playblast will not delete the image from disk after it is displayed. This flag should not be used in conjunction with -f/filename."
            }, 
            "compression": {
                "docstring": "Specify the compression to use for the movie file. Use the command `playblast -options` command to launch a dialog to determine wich setting are avalible for a given platform.When the 'format' flag is 'image', this flag is used to pass in the desired image format."
            }, 
            "endTime": {
                "docstring": "Specify the end time of the playblast. Default is the end time of the playback range displayed in the Time Slider. Overridden by -frame."
            }, 
            "filename": {
                "docstring": "The filename to use for the output of this playblast. If the file already exists, a confirmation box will be displayed if playblast is performed interactively. If playblast is executed from the command line and the file already exists, it will abort."
            }, 
            "forceOverwrite": {
                "docstring": "Overwrite existing playblast files which may have the the same name as the one specified with the \"-f\" flag"
            }, 
            "format": {
                "docstring": "The format of the output of this playblast. Valid values and their meanings:-- \"movie\" This will result in the defaulting movie format on a given platform On Windows, the out is AVI format and the player is Microsoft Media Player. On Mac OSX, the output is of type QuickTime and the player is QuickTime. On Unix, this option outputs SGI's movie format and sets the default viewing command to \"movieplayer\". The resulting file is named according to the \"-f\" flag, if specified.-- \"avi\" Set the format to use avi as the output format. Only supported on Windows.-- \"qt\" QuickTime. Supported on all platforms but 64 bit windows.-- \"sgi\" Use the older sgi format.-- \"image\" Outputs a sequence of image files and sets the viewing command to the application specified in the preferences by the user. If no application is specified, it sets viewing command to \"fcheck\". The image format will be the Output Format specified using Render-RenderGlobals. The resulting files use the value of the \"-f\" flag as a prefix, with an appended frame number, as in \"myFile.0007.iff\"-- \"iff\" Synonymous with \"image\"The default value of the -fmt/format flag is \"movie\"."
            }, 
            "frame": {
                "docstring": "List of frames to blast. One frame specified per flag. The frames can be specifed in any order but will be output in an ordered sequence. When specified this flag will override any start/end range"
            }, 
            "framePadding": {
                "docstring": "Number of zeros used to pad file name. Typically set to 4 to support fcheck."
            }, 
            "height": {
                "docstring": "Height of the final image. This value will be clamped if larger than the width of the active window.Windows: If not using fcheck, the width and height must each be divisible by 4."
            }, 
            "indexFromZero": {
                "docstring": "Output frames starting with file.0000.ext and incrementing by one. Typically frames use the Maya time as their frame number. This option can only be used for frame based output formats."
            }, 
            "offScreen": {
                "docstring": "When set, this toggle allow playblast to use an offscreen buffer to render the view. This allows playblast to work when the application is iconified, or obscured. This flag is only supported on Linux."
            }, 
            "options": {
                "docstring": "Brings up a dialog for setting playblast options, and does not run the playblast."
            }, 
            "percent": {
                "docstring": "Percentage of current view size to use during blasting. Accepted values are integers between 10 and 100. All other values are clamped to be within this range. A value of 25 means 1/4 of the current view size; a value of 50 means half the current view size; a value of 100 means full size. (Default is 50.)"
            }, 
            "quality": {
                "docstring": "Specify the compression quality factor to use for the movie file. Value should be in the 0-100 range"
            }, 
            "query": {
                "docstring": ""
            }, 
            "rawFrameNumbers": {
                "docstring": "Playblast typically numbers its frames sequentially, starting at zero. This flag will override the default action and frames will be numbered using the actual frames specified by the -frame or -startFrame/-endFrame flags."
            }, 
            "replaceAudioOnly": {
                "docstring": "When set, this string dictates that only the audio will be replaced when the scene is re-playblasted."
            }, 
            "replaceEndTime": {
                "docstring": "Specify the end time of a replayblast of an existing playblast. Default is the start time of the playback range displayed in the Time Slider. Overridden by -frame."
            }, 
            "replaceFilename": {
                "docstring": "When set, this string specifies the name of an input playblast file which will have frames replaced according to the replace start and end times."
            }, 
            "replaceStartTime": {
                "docstring": "Specify the start time of a replayblast of an existing playblast. Default is the start time of the playback range displayed in the Time Slider. Overridden by -frame."
            }, 
            "sequenceTime": {
                "docstring": "Use sequence time"
            }, 
            "showOrnaments": {
                "docstring": "Sets whether or not model view ornaments (e.g. the axis icon) should be displayed"
            }, 
            "sound": {
                "docstring": "Specify the sound node to be used during playblast"
            }, 
            "startTime": {
                "docstring": "Specify the start time of the playblast. Default is the start time of the playback range displayed in the Time Slider. Overridden by -frame."
            }, 
            "useTraxSounds": {
                "docstring": ""
            }, 
            "viewer": {
                "docstring": "Specify whether a viewer should be launched for the playblast. Default is \"true\". Runs \"fcheck\" when -fmt is \"image\". The player for movie files depends on the OS: Windows uses Microsoft Media Player, Irix uses movieplayer, OSX uses QuickTime."
            }, 
            "width": {
                "docstring": "Width of the final image. This value will be clamped if larger than the width of the active window.Windows: If not using fcheck, the width and height must each be divisible by 4."
            }, 
            "widthHeight": {
                "docstring": "Final image's width and height. Values larger than the dimensions of the active window are clamped. A width and height of 0 means to use the window's current size.Windows: If not using fcheck, the width and height must each be divisible by 4."
            }
        }
    }, 
    "pluginInfo": {
        "description": "This command provides access to the plugin registry of the application. It is used mainly to query the characteristics of registered plugins. Plugins automatically become registered the first time that they are loaded. The argument is either the internal name of the plug-in or the path to access it. ", 
        "flags": {
            "activeFile": {
                "docstring": "Specifies that the -pluginsInUse/-pu flag should return the plugins used by the active file only, not the entire scene. For use during export selected."
            }, 
            "apiVersion": {
                "docstring": "returns a string containing the version of the API that this plugin was complied with. See the comments in MTypes.h for the details on how to interpret this value."
            }, 
            "autoload": {
                "docstring": "sets whether or not this plugin should be loaded every time the application starts up. Returns a boolean in query mode."
            }, 
            "cacheFormat": {
                "docstring": "returns a string array containing the names of all of the registered geometry cache formats"
            }, 
            "changedCommand": {
                "docstring": "adds a callback that will get executed every time the plugin registry changes. Any other previously registered callbacks will also get called."
            }, 
            "command": {
                "docstring": "returns a string array containing the names of all of the normal commands registered by this plugin. Constraint, control, context and model editor commands are not included."
            }, 
            "constraintCommand": {
                "docstring": "Returns a string array containing the names of all of the constraint commands registered by this plugin.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "controlCommand": {
                "docstring": "Returns a string array containing the names of all of the control commands registered by this plugin."
            }, 
            "data": {
                "docstring": "returns a string array containing the names of all of the data types registered by this plugin."
            }, 
            "dependNode": {
                "docstring": "returns a string array containing the names of all of the custom nodes types registered by this plugin."
            }, 
            "dependNodeByType": {
                "docstring": "returns a string array of all registered node types within a specified class of nodes. Each custom node type registered by a plug-in belongs to a more general class of node types as specified by its MPxNode::Type. The flag's argument is an MPxNode::Type as a string. For example, if you want to list all registered Locator nodes, you should specify kLocatorNode as a argument to this flag."
            }, 
            "dependNodeId": {
                "docstring": "returns a integer array containing the ids of all of the custom node types registered by this plugin."
            }, 
            "device": {
                "docstring": "returns a string array containing the names of all of the devices registered by this plugin."
            }, 
            "dragAndDropBehavior": {
                "docstring": "returns a string array containing the names of all of the drag and drop behaviors registered by this plugin."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "iksolver": {
                "docstring": "returns a string array containing the names of all of the ik solvers registered by this plugin."
            }, 
            "listPlugins": {
                "docstring": "returns a string array containing all the plugins that are currently loaded."
            }, 
            "listPluginsPath": {
                "docstring": ""
            }, 
            "loadPluginPrefs": {
                "docstring": "loads the plugin preferences (ie. autoload) from pluginPrefs.mel into Maya."
            }, 
            "loaded": {
                "docstring": "returns a boolean specifying whether or not the plugin is loaded."
            }, 
            "modelEditorCommand": {
                "docstring": "Returns a string array containing the names of all of the model editor commands registered by this plugin."
            }, 
            "name": {
                "docstring": "returns a string containing the internal name by which the plugin is registered."
            }, 
            "path": {
                "docstring": "returns a string containing the absolute path name to the plugin."
            }, 
            "pluginsInUse": {
                "docstring": "returns a string array containing all the plugins that are currently being used in the scene."
            }, 
            "query": {
                "docstring": ""
            }, 
            "registered": {
                "docstring": "returns a boolean specifying whether or not plugin is currently registered with the system."
            }, 
            "remove": {
                "docstring": "removes the given plugin's record from the registry. There is no return value."
            }, 
            "savePluginPrefs": {
                "docstring": "saves the plugin preferences (ie. autoload) out to pluginPrefs.mel"
            }, 
            "serviceDescriptions": {
                "docstring": "if there are services in use, then this flag will return a string array containing short descriptions saying what those services are."
            }, 
            "settings": {
                "docstring": "Returns an array of values with the loaded, autoload, registered flags"
            }, 
            "tool": {
                "docstring": "returns a string array containing the names of all of the tool contexts registered by this plugin."
            }, 
            "translator": {
                "docstring": "returns a string array containing the names of all of the file translators registered by this plugin."
            }, 
            "unloadOk": {
                "docstring": "returns a boolean that specifies whether or not the plugin can be safely unloaded. It will return false if the plugin is currently in use. For example, if the plugin adds a new dependency node type, and an instance of that node type is present in the scene, then this query will return false."
            }, 
            "userNamed": {
                "docstring": "returns a boolean specifying whether or not the plugin has been assigned a name by the user."
            }, 
            "vendor": {
                "docstring": "returns a string containing the vendor of the plugin."
            }, 
            "version": {
                "docstring": "returns a string containing the version the plugin."
            }
        }
    }, 
    "pointConstraint": {
        "description": "Constrain an object's position to the position of the target object or to the average position of a number of targets. A pointConstraint takes as input one or more \"target\" DAG transform nodes at which to position the single \"constraint object\" DAG transform node. The pointConstraint positions the constrained object at the weighted average of the world space position target objects. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "layer": {
                "docstring": "Specify the name of the animation layer where the constraint should be added."
            }, 
            "maintainOffset": {
                "docstring": "The offset necessary to preserve the constrained object's initial position will be calculated and used as the offset."
            }, 
            "name": {
                "docstring": "Sets the name of the constraint node to the specified name. Default name is constrainedObjectName_constraintType"
            }, 
            "offset": {
                "docstring": "Sets or queries the value of the offset. Default is 0,0,0."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the listed target(s) from the constraint."
            }, 
            "skip": {
                "docstring": "Specify the axis to be skipped. Valid values are \"x\", \"y\", \"z\" and \"none\". During creation, \"none\" is the default. This flag is multi-use.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "targetList": {
                "docstring": "Return the list of target objects."
            }, 
            "weight": {
                "docstring": "Sets the weight value for the specified target(s). If not given at creation time, the default value of 1.0 is used."
            }, 
            "weightAliasList": {
                "docstring": "Returns the names of the attributes that control the weight of the target objects. Aliases are returned in the same order as the targets are returned by the targetList flag"
            }
        }
    }, 
    "pointCurveConstraint": {
        "description": "The command enables direct manipulation of a NURBS curve. It does so by apply a position constraint at the specified parameter location on the NURBS curve. If construction history for the cmd is enabled, a locator is created to enable subsequent interactive manipulation of the curve. The locator position may be key framed or transformed and the \"curve1\" will try to match the position of the locator. The argument is a curve location ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only."
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "pointConstraintUVW": {
                "docstring": "Point constraint parameter space location on input NURBS Object"
            }, 
            "pointWeight": {
                "docstring": "Point constraint weight. Determines how strong an influence the constraint has on the input NURBS object.Default:1.0Advanced flags"
            }, 
            "position": {
                "docstring": "The new desired position in space for the nurbs object at the specified parameter space component. If not specified, the position is taken to be the one evaluated at the parameter space component on the nurbs object."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "weight": {
                "docstring": "weight of the lsq constraint. The larger the weight, the least squares constraint is strictly met.Common flags"
            }
        }
    }, 
    "pointLight": {
        "description": "The pointLight command is used to edit the parameters of existing pointLights, or to create new ones. The default behaviour is to create a new pointlight. ", 
        "flags": {
            "decayRate": {
                "docstring": "decay rate of the light (0-no decay, 1-slow, 2-realistic, 3-fast)"
            }, 
            "discRadius": {
                "docstring": "radius of the disc around the light"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": "This flag is obsolete."
            }, 
            "intensity": {
                "docstring": "intensity of the light (expressed as a percentage)"
            }, 
            "name": {
                "docstring": "specify the name of the light"
            }, 
            "position": {
                "docstring": "This flag is obsolete."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rgb": {
                "docstring": "color of the light (0-1)"
            }, 
            "rotation": {
                "docstring": "This flag is obsolete."
            }, 
            "shadowColor": {
                "docstring": "the shadow color"
            }, 
            "shadowDither": {
                "docstring": "dither the shadow"
            }, 
            "shadowSamples": {
                "docstring": "number of shadow samples."
            }, 
            "softShadow": {
                "docstring": "soft shadow"
            }, 
            "useRayTraceShadows": {
                "docstring": "ray trace shadowsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "pointOnCurve": {
        "description": "This command returns information for a point on a NURBS curve. If no flag is specified, it assumes p/position by default. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or offFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "curvatureCenter": {
                "docstring": "Returns the (x,y,z) center of curvature of the specified point on the curve"
            }, 
            "curvatureRadius": {
                "docstring": "Returns the radius of curvature of the specified point on the curveCommon flags"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "normal": {
                "docstring": "Returns the (x,y,z) normal of the specified point on the curve"
            }, 
            "normalizedNormal": {
                "docstring": "Returns the (x,y,z) normalized normal of the specified point on the curve"
            }, 
            "normalizedTangent": {
                "docstring": "Returns the (x,y,z) normalized tangent of the specified point on the curve"
            }, 
            "parameter": {
                "docstring": "The parameter value on curveDefault:0.0"
            }, 
            "position": {
                "docstring": "Returns the (x,y,z) position of the specified point on the curve"
            }, 
            "query": {
                "docstring": ""
            }, 
            "tangent": {
                "docstring": "Returns the (x,y,z) tangent of the specified point on the curve"
            }, 
            "turnOnPercentage": {
                "docstring": "Whether the parameter is normalized (0,1) or notDefault:false"
            }
        }
    }, 
    "pointOnPolyConstraint": {
        "description": "Constrain an object's position to the position of the target object or to the average position of a number of targets. A pointOnPolyConstraint takes as input one or more \"target\" DAG transform nodes at which to position the single \"constraint object\" DAG transform node. The pointOnPolyConstraint positions the constrained object at the weighted average of the world space position target objects. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "layer": {
                "docstring": "Specify the name of the animation layer where the constraint should be added."
            }, 
            "maintainOffset": {
                "docstring": "The offset necessary to preserve the constrained object's initial position will be calculated and used as the offset."
            }, 
            "name": {
                "docstring": "Sets the name of the constraint node to the specified name. Default name is constrainedObjectName_constraintType"
            }, 
            "offset": {
                "docstring": "Sets or queries the value of the offset. Default is 0,0,0."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the listed target(s) from the constraint."
            }, 
            "skip": {
                "docstring": "Specify the axis to be skipped. Valid values are \"x\", \"y\", \"z\" and \"none\". During creation, \"none\" is the default. This flag is multi-use.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "targetList": {
                "docstring": "Return the list of target objects."
            }, 
            "weight": {
                "docstring": "Sets the weight value for the specified target(s). If not given at creation time, the default value of 1.0 is used."
            }, 
            "weightAliasList": {
                "docstring": "Returns the names of the attributes that control the weight of the target objects. Aliases are returned in the same order as the targets are returned by the targetList flag"
            }
        }
    }, 
    "pointOnSurface": {
        "description": "This command returns information for a point on a surface. If no flag is specified, this command assumes p/position by default. If more than one flag is specifed, then a string array is returned. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or offFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "normal": {
                "docstring": "Returns the (x,y,z) normal of the specified point on the surface"
            }, 
            "normalizedNormal": {
                "docstring": "Returns the (x,y,z) normalized normal of the specified point on the surface"
            }, 
            "normalizedTangentU": {
                "docstring": "Returns the (x,y,z) normalized U tangent of the specified point on the surface"
            }, 
            "normalizedTangentV": {
                "docstring": "Returns the (x,y,z) normalized V tangent of the specified point on the surfaceCommon flags"
            }, 
            "parameterU": {
                "docstring": "The U parameter value on surfaceDefault:0.0"
            }, 
            "parameterV": {
                "docstring": "The V parameter value on surfaceDefault:0.0"
            }, 
            "position": {
                "docstring": "Returns the (x,y,z) positon of the specified point on the surface"
            }, 
            "query": {
                "docstring": ""
            }, 
            "tangentU": {
                "docstring": "Returns the (x,y,z) U tangent of the specified point on the surface"
            }, 
            "tangentV": {
                "docstring": "Returns the (x,y,z) V tangent of the specified point on the surface"
            }, 
            "turnOnPercentage": {
                "docstring": "Whether the parameter is normalized (0,1) or notDefault:false"
            }
        }
    }, 
    "pointPosition": {
        "description": "This command returns the world or local space position for any type of point object. Valid selection items are: - curve and surface CVs - poly vertices - lattice points - particles - curve and surface edit points - curve and surface parameter points - poly uvs - rotate/scale/joint pivots - selection handles - locators, param locators and arc length locators It works on the selected object or you can specify the object in the command. By default, if no flag is specified then the world position is returned. ", 
        "flags": {
            "local": {
                "docstring": "Return the point in local space coordinates.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "world": {
                "docstring": "Return the point in world space coordinates."
            }
        }
    }, 
    "poleVectorConstraint": {
        "description": "Constrains the poleVector of an ikRPsolve handle to point at a target object or at the average position of a number of targets. An poleVectorConstraint takes as input one or more \"target\" DAG transform nodes at which to aim pole vector for an IK handle using the rotate plane solver. The pole vector is adjust such that the in weighted average of the world space position target objects lies is the \"rotate plane\" of the handle. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "layer": {
                "docstring": "Specify the name of the animation layer where the constraint should be added.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "Sets the name of the constraint node to the specified name. Default name is constrainedObjectName_constraintType"
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the listed target(s) from the constraint."
            }, 
            "targetList": {
                "docstring": "Return the list of target objects."
            }, 
            "weight": {
                "docstring": "Sets the weight value for the specified target(s). If not given at creation time, the default value of 1.0 is used."
            }, 
            "weightAliasList": {
                "docstring": "Returns the names of the attributes that control the weight of the target objects. Aliases are returned in the same order as the targets are returned by the targetList flag"
            }
        }
    }, 
    "polyAppend": {
        "description": "Appends a new face to the selected polygonal object. The first argument must be a border edge. The new face will be automatically closed.Only works with one object selected. ", 
        "flags": {
            "append": {
                "docstring": "Appends to the given polygon object. The append flag should be used multiple times to specify the edges, points, and holes that make up the new face that is being added. You may specify an edge by passing a single argument which will be the edges index. A point is specified with three arguments which are the coordinates of the point in the objects local space. Pass no arguments indicates that the values which follow shall specify a hole. In Python, pass an empty tuple to specify no arguments.Common flags"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edge": {
                "docstring": "Adds the given edge of the selected object to the new face. This edge must be a border, which will be then shared by the new face and the neighboring one. The new face is oriented according to the orientation of the given edge(s). Note that this flag should be avoided in Python. You may use the \"append\" flag instead and pass one argument."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "hole": {
                "docstring": "Add a hole. The following points and edges will define a hole. Note that this flag should be avoided in Python. You may use the \"append\" flag instead and pass an empty tuple ()."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "point": {
                "docstring": "Adds a new point to the new face. Coordinates of free points are given in the local object reference. Note that this flag should be avoided in Python. You may use the \"append\" flag instead and pass three arguments."
            }, 
            "query": {
                "docstring": ""
            }, 
            "subdivision": {
                "docstring": "This flag specifies the level of subdivisions. Automatically subdivides new edges into the given number of edges. Existing edges cannot be subdivided.C : Default is 1 (no subdivision).Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "Specifies how new faces are mapped.0 - None; 1 - Normalize; 2 - UnitizeC: Default is 0 (no mapping).Q: When queried, this flag returns an int"
            }
        }
    }, 
    "polyAppendFacetCtx": {
        "description": "Create a new context to append facets on polygonal objects In query mode, return type is based on queried flag.", 
        "flags": {
            "append": {
                "docstring": "Allows to switch to polyCreateFacetCtx tool"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "isRotateAvailable": {
                "docstring": "Tells if the control associated to rotate flag is available. If several edges are already selected and they are not aligned (thus there is no \"rotation axis\") the rotation is no longer available."
            }, 
            "maximumNumberOfPoints": {
                "docstring": "Allows the ability to set a upper bound on the number of points in interactively place before polygon is created. A value less than 2 will mean that there is no upper bound.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "planarConstraint": {
                "docstring": "Allows/avoid new facet to be non-planar.If on, all new points will be projected onto current facet plane. Selected edges will be checked as well."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rotate": {
                "docstring": "Rotate current facet around the first edge selected."
            }, 
            "subdivision": {
                "docstring": "Number of sub-edges created for each new edge. Default is 1."
            }, 
            "texture": {
                "docstring": ""
            }
        }
    }, 
    "polyAppendVertex": {
        "description": "Appends a new face to the selected polygonal object. The direction of the normal is given by the vertex order: the face normal points towards the user when the vertices rotate counter clockwise. Note that holes must be described in the opposite direction.Only works with one object selected. ", 
        "flags": {
            "append": {
                "docstring": "Append a vertex or a point to the selected object, or mark the start of a hole.This flag may also be used in place of the \"hole\", \"vertex\" and \"point\" flags. If no argument is passed to the \"append\" flag, then it marks the beginning of a hole (use an empty tuple in Python '()'). If one argument is passed, then the argument is considered to be an index into the vertices of the selected object, as with the \"vertex\" flag. If three arguments are passed, then it is interpreted as the coordinates of a new point which will be inserted, as with the \"point\" flag."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "hole": {
                "docstring": "Add a hole. The following points and edges will define a hole. Note that this flag should be avoided in Python. You may use the \"append\" flag instead and pass an empty tuple '()' to specify the start of a hole.Common flags"
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "point": {
                "docstring": "Adds a new point to the new face. Coordinates of free points are given in the local object reference. Note that this flag should be avoided in Python. You may use the \"append\" flag instead and pass three arguments."
            }, 
            "query": {
                "docstring": ""
            }, 
            "texture": {
                "docstring": "Specifies how new faces are mapped.0 - None; 1 - Normalize; 2 - UnitizeC: Default is 0 (no mapping).Q: When queried, this flag returns an int"
            }, 
            "vertex": {
                "docstring": "Adds the given vertex of the selected object to the new face. Note that this flag should be avoided in Python. You may use the \"append\" flag instead and pass one argument."
            }
        }
    }, 
    "polyAutoProjection": {
        "description": "Projects a map onto an object, using several orthogonal projections simultaneously. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "createNewMap": {
                "docstring": "Create a new UV set, as opposed to editing the current one, or the one given by the -uvSetName flag."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "insertBeforeDeformers": {
                "docstring": "This flag specifies if the projection node should be inserted before or after deformer nodes already applied to the shape. Inserting the projection after the deformer leads to texture swimming during animation and is most often undesirable.C: Default is on.Common flags"
            }, 
            "layout": {
                "docstring": "What layout algorithm should be used:0 UV pieces are set to no layout.1 UV pieces are aligned along the U axis.2 UV pieces are moved in a square shape."
            }, 
            "layoutMethod": {
                "docstring": "Set which layout method to use:0 Block Stacking.1 Shape Stacking."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "optimize": {
                "docstring": "Use two different flavors for the cut generation.0 Every face is assigned to the best plane. This optimizes the map distortion.1 Small UV pieces are incorporated into larger ones, when the extra distortion introduced is reasonable. This tends to produce fewer UV pieces."
            }, 
            "percentageSpace": {
                "docstring": "When layout is set to square, this value is a percentage of the texture area which is added around each UV piece. It can be used to ensure each UV piece uses different pixels in the texture.Maximum value is 5 percent."
            }, 
            "pivot": {
                "docstring": "This flag specifies the pivot for scaling and rotation.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "pivotX": {
                "docstring": "This flag specifies the X pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotY": {
                "docstring": "This flag specifies the Y pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotZ": {
                "docstring": "This flag specifies the Z pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "planes": {
                "docstring": "Number of intermediate projections used. Valid numbers are 4, 5, 6, 8, and 12.C: Default is 6."
            }, 
            "projectBothDirections": {
                "docstring": "This flag specifies which reference to use. If \"on\" : projections are mirrored on directly opposite faces. If \"off\" : projections are not mirrored on opposite faces.C: Default is \"off\".Q: When queried, this flag returns an integer.Global Values"
            }, 
            "query": {
                "docstring": ""
            }, 
            "rotate": {
                "docstring": "This flag specifies the rotation angles around X, Y, Z.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateX": {
                "docstring": "This flag specifies the rotation angle around X.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateY": {
                "docstring": "This flag specifies the rotation angle around Y.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies the rotation angle around Z.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "scale": {
                "docstring": "This flag specifies the scaling vector.C: Default is 1.0 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "scaleMode": {
                "docstring": "How to scale the pieces, after projections:0 No scale is applied.1 Uniform scale to fit in unit square.2 Non proportional scale to fit in unit square."
            }, 
            "scaleX": {
                "docstring": "This flag specifies X for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleY": {
                "docstring": "This flag specifies Y for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleZ": {
                "docstring": "This flag specifies Z for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "skipIntersect": {
                "docstring": "When on, self intersection of UV pieces are not tested. This makes the projection faster and produces fewer pieces, but may lead to overlaps in UV space."
            }, 
            "translate": {
                "docstring": "This flag specifies the translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "translateX": {
                "docstring": "This flag specifies the X translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateY": {
                "docstring": "This flag specifies the Y translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateZ": {
                "docstring": "This flag specifies the Z translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the UV set to edit uvs on. If not specified will use the current UV set if it exists.When createNewMap is on, the name is used to generate a new unique UV set name."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is \"on\".Q: When queried, this flag returns an integer."
            }
        }
    }, 
    "polyAverageNormal": {
        "description": "Set normals of vertices or vertex-faces to an average value when the vertices within a given threshold. First, it sorts out the containing edges, and set them to be soft, if it is possible, so to let the normals appear to be \"merged\". The remained components then are sorted into lumps where vertices in each lump are within the given threshold. For all vertices and vertex-faces, set their normals to the average normal in the lump. Selected vertices may or may not on the same object. If objects are selected, it is assumed that all vertices are selected. If edges or faces are selected, it is assumed that the related vertex-faces are selected. ", 
        "flags": {
            "allowZeroNormal": {
                "docstring": "Specifies whether to allow zero normals to be created. By default it is false. If it is false, replaceNormal is needed."
            }, 
            "distance": {
                "docstring": "Specifies the distance threshold. All vertices within the threshold are considered when computing an average normal. By default it is 0.0."
            }, 
            "postnormalize": {
                "docstring": "Specifies whether to normalize the resulting normals. By default it is true."
            }, 
            "prenormalize": {
                "docstring": "Specifies whether to normalize the normals before averaging. By default it is true."
            }, 
            "replaceNormalXYZ": {
                "docstring": "If the allowZeroNormalis false, this value is used to replace the zero normals. By default it is (1, 0, 0).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "polyAverageVertex": {
        "description": "Moves the selected vertices of a polygonal object to round its shape. Translate, move, rotate or scale vertices. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "iterations": {
                "docstring": "Number of rounding steps."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"true\" : all geometrical values are taken in world reference. If \"false\" : all geometrical values are taken in object reference.C: Default is \"false\".Common flags"
            }
        }
    }, 
    "polyBevel": {
        "description": "Bevel edges. ", 
        "flags": {
            "angleTolerance": {
                "docstring": "This flag specifies the angle beyond which additional faces may be inserted to avoid possible twisting of faces. If the bevel produces unwanted faces, try increasing the angle tolerance.C: Default is 5 degrees.Q: When queried, this flag returns a double."
            }, 
            "autoFit": {
                "docstring": "Computes a smooth roundness, new faces round off a smooth angle.C: Default is on.Q: When queried, this flag returns an int."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "fillNgons": {
                "docstring": ""
            }, 
            "mergeVertexTolerance": {
                "docstring": ""
            }, 
            "mergeVertices": {
                "docstring": ""
            }, 
            "miteringAngle": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "offset": {
                "docstring": "This flag specifies the offset distance for the bevelling.C: Default is 0.2.Q: When queried, this flag returns a float."
            }, 
            "offsetAsFraction": {
                "docstring": "This flag specifies whether the offset is a fraction or an absolute value. If a fraction, the offset can range between 0 and 1, where 1 is the maximum possible offsetC: Default is false.Q: When queried, this flag returns an int."
            }, 
            "query": {
                "docstring": ""
            }, 
            "roundness": {
                "docstring": "This flag specifies the roundness of bevel. A roundness of 0 means that all new faces are coplanar. This value is only used if the autoFit value is off.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "segments": {
                "docstring": "This flag specifies the number of segments used for the bevelling.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "smoothingAngle": {
                "docstring": ""
            }, 
            "uvAssignment": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "This flags specifies the used reference. If on : the offset flag is taken in world reference. If off : the offset flag is taken in object reference (the default).C: Default is off.Q: When queried, this flag returns an int.Common flagsCommon flags"
            }
        }
    }, 
    "polyBlendColor": {
        "description": "Takes two color sets and blends them together into a third specified color set. ", 
        "flags": {
            "baseColorName": {
                "docstring": ""
            }, 
            "blendFunc": {
                "docstring": ""
            }, 
            "blendWeightA": {
                "docstring": ""
            }, 
            "blendWeightB": {
                "docstring": ""
            }, 
            "blendWeightC": {
                "docstring": ""
            }, 
            "blendWeightD": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "dstColorName": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "srcColorName": {
                "docstring": ""
            }
        }
    }, 
    "polyBlindData": {
        "description": "Command creates blindData types (basically creates an instance of TdnPolyBlindData). When used with the query flag, it returns the data types that define this blindData type. This command is to be used create a blindData node \\*and\\* to edit the same.. The associationType flag \\*has\\* to be specified at all times.. This is because if an instance of the specified BD typeId exists in the history chain but if the associationType is not the same, then a new polyBlindData node is created.. For object level blind data, only the object itself must be specified. A new compound attribute BlindDataNNNN will be created on the object. Blind data attribute names must be unique across types for object level blind data. So, the command will require the following to be specified: - typeId, - associationType - longDataName or shortDataName of data being edited. - The actual data being specified. - The components that this data is to be attached to. ", 
        "flags": {
            "associationType": {
                "docstring": "Specifies the dataTypes that are part of BlindData node being created. Allowable associations are \"object\" for any object, and \"vertex\" \"edge\" and \"face\" for mesh objects. Other associations for other geometry types may be added."
            }, 
            "binaryData": {
                "docstring": "Specifies the data type is a binary data valueFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "booleanData": {
                "docstring": "Specifies the data type is a boolean logic value"
            }, 
            "delete": {
                "docstring": "Specifies that this will remove the blind data if found"
            }, 
            "doubleData": {
                "docstring": "Specifies the data type is a floating point double value"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "int64Data": {
                "docstring": "Specifies the data type is an 64-bit integer value"
            }, 
            "intData": {
                "docstring": "Specifies the data type is an integer value"
            }, 
            "longDataName": {
                "docstring": "Specifies the long name of the data that is being modified by this command."
            }, 
            "rescan": {
                "docstring": "Enables a rescan of blind data nodes for cached information"
            }, 
            "reset": {
                "docstring": "Specifies that this command will reset the given attribute to default value"
            }, 
            "shape": {
                "docstring": "For object association only, apply blind data to the shape(s) below this node instead of the node itself"
            }, 
            "shortDataName": {
                "docstring": "Specifies the short name of the data that is being modified by this command."
            }, 
            "stringData": {
                "docstring": "Specifies the data type is a string value"
            }, 
            "typeId": {
                "docstring": "Specifies the typeId of the BlindData type being created"
            }
        }
    }, 
    "polyBoolOp": {
        "description": "This command creates a new poly as the result of a boolean operation on input polys : union, intersection, difference.Only for difference, the order of the selected objects is important :result = object1 - object2.If no objects are specified in the command line, then the objects from the active list are used. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "faceAreaThreshold": {
                "docstring": ""
            }, 
            "mergeUVSets": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "operation": {
                "docstring": "1=union, 2=difference, 3=intersection"
            }, 
            "preserveColor": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "useThresholds": {
                "docstring": ""
            }, 
            "vertexDistanceThreshold": {
                "docstring": ""
            }
        }
    }, 
    "polyBridgeEdge": {
        "description": "Bridges two sets of edges. ", 
        "flags": {
            "bridgeOffset": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "curveType": {
                "docstring": ""
            }, 
            "divisions": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "inputCurve": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "smoothingAngle": {
                "docstring": ""
            }, 
            "startVert1": {
                "docstring": ""
            }, 
            "startVert2": {
                "docstring": ""
            }, 
            "taper": {
                "docstring": ""
            }, 
            "taperCurve_FloatValue": {
                "docstring": ""
            }, 
            "taperCurve_Interp": {
                "docstring": ""
            }, 
            "taperCurve_Position": {
                "docstring": ""
            }, 
            "twist": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is \"off\".Q: When queried, this flag returns an int.Common flags"
            }
        }
    }, 
    "polyCacheMonitor": {
        "description": "When the cacheInput attribute has a positive value the midModifier node caches the output mesh improving performance in computations of downstream nodes. When the counter has a zero value the midModifier releases the cached data. ", 
        "flags": {
            "cacheValue": {
                "docstring": "Flag to indicate whether the node's cache counter should be incremented or decremented. True increments the counter, false decrements the counter.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "nodeName": {
                "docstring": "Name of the node whose cache counter needs to be changed."
            }
        }
    }, 
    "polyCheck": {
        "description": "Dumps a description of internal memory representation of poly objects.If no objects are specified in the command line, the objects from the active list are used.Default behaviour is to print only a summary. Use the flags above to get more details on a specific part of the object. ", 
        "flags": {
            "edge": {
                "docstring": "Check edge descriptions."
            }, 
            "face": {
                "docstring": "Check face descriptions. If no flag is set, a complete check is performed."
            }, 
            "faceOffset": {
                "docstring": ""
            }, 
            "openFile": {
                "docstring": "Opens a file that contains a poly description, as dumped out by the debug commands.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "polyChipOff": {
        "description": "Extract facets. Faces can be extracted separately or together, and manipulations can be performed either in world or object space. ", 
        "flags": {
            "attraction": {
                "docstring": "This flag specifies the attraction, related to magnet.C: Default is 0.0. The range is [-2.0, 2.0].Q: When queried, this flag returns a float."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "duplicate": {
                "docstring": "If \"on\", facets are duplicated, otherwise original facets are removed.C: Default is \"on\".Q: When queried, this flag returns an int."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "gain": {
                "docstring": ""
            }, 
            "gravity": {
                "docstring": "This flag specifies the gravity vector.C: Default is 0.0 -1.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "gravityX": {
                "docstring": "This flag specifies X for the gravity vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "gravityY": {
                "docstring": "This flag specifies Y for the gravity vector.C: Default is -1.0.Q: When queried, this flag returns a float."
            }, 
            "gravityZ": {
                "docstring": "This flag specifies Z for the gravity vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "keepFacesTogether": {
                "docstring": "This flag specifies how to chip off facets. If \"on\", facets are pulled together (connected ones stay connected), otherwise they are pulled independentely.C: Default is \"on\".Q: When queried, this flag returns an int."
            }, 
            "keepFacetTogether": {
                "docstring": ""
            }, 
            "localCenter": {
                "docstring": ""
            }, 
            "localDirection": {
                "docstring": "This flag specifies the local slant axis (see local rotation).C: Default is 0.0 0.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localDirectionX": {
                "docstring": "This flag specifies X for the local slant axis.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localDirectionY": {
                "docstring": "This flag specifies Y for the local slant axis.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localDirectionZ": {
                "docstring": "This flag specifies Y for the local slant axis.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localRotate": {
                "docstring": "This flag specifies the local rotations : (slantRot, slantRoll, twistRot).C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]. Local rotation (slantRot, slantRoll, twistRot)."
            }, 
            "localRotateX": {
                "docstring": "This flag specifies local rotation X angle (Slant Rot around slantAxis).C: Default is 0.0. The range is [0, 360].Q: When queried, this flag returns a float."
            }, 
            "localRotateY": {
                "docstring": "This flag specifies local rotation Y angle (Slant Roll of slantAxis).C: Default is 0.0. The range is [0, 180].Q: When queried, this flag returns a float."
            }, 
            "localRotateZ": {
                "docstring": "This flag specifies local rotation Z angle (Twist around normal).C: Default is 0.0. The range is [0, 360].Q: When queried, this flag returns a float."
            }, 
            "localScale": {
                "docstring": "This flag specifies the local scaling vector.C: Default is 1.0 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localScaleX": {
                "docstring": "This flag specifies X for local scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localScaleY": {
                "docstring": "This flag specifies Y for local scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localScaleZ": {
                "docstring": "This flag specifies Z for local scaling vector : Flattening.C: Default is 1.0. The range is [0.0, 1.0].Q: When queried, this flag returns a float. Dynamic Values"
            }, 
            "localTranslate": {
                "docstring": "This flag specifies the local translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localTranslateX": {
                "docstring": "This flag specifies the X local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslateY": {
                "docstring": "This flag specifies the Y local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslateZ": {
                "docstring": "This flag specifies the Z local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "magnX": {
                "docstring": "This flag specifies X for the magnet vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "magnY": {
                "docstring": "This flag specifies Y for the magnet vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "magnZ": {
                "docstring": "This flag specifies Z for the magnet vector.C: Default is 0.0.Q: When queried, this flag returns a float.Common flags"
            }, 
            "magnet": {
                "docstring": "This flag specifies the magnet vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "offset": {
                "docstring": "This flag specifies the local offset.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivot": {
                "docstring": "This flag specifies the pivot for scaling and rotation.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "pivotX": {
                "docstring": "This flag specifies the X pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotY": {
                "docstring": "This flag specifies the Y pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotZ": {
                "docstring": "This flag specifies the Z pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float. Local Values"
            }, 
            "query": {
                "docstring": ""
            }, 
            "random": {
                "docstring": "This flag specifies the random value for all parameters.C: Default is 0.0. The range is [-10.0, 10.0].Q: When queried, this flag returns a float. Global Values"
            }, 
            "rotate": {
                "docstring": "This flag specifies the rotation angles around X, Y, Z.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateX": {
                "docstring": "This flag specifies the rotation angle around X.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateY": {
                "docstring": "This flag specifies the rotation angle around Y.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies the rotation angle around Z.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "scale": {
                "docstring": "This flag specifies the scaling vector.C: Default is 1.0 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "scaleX": {
                "docstring": "This flag specifies X for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleY": {
                "docstring": "This flag specifies Y for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleZ": {
                "docstring": "This flag specifies Z for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "translate": {
                "docstring": "This flag specifies the translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "translateX": {
                "docstring": "This flag specifies the X translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateY": {
                "docstring": "This flag specifies the Y translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateZ": {
                "docstring": "This flag specifies the Z translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "weight": {
                "docstring": "This flag specifies the weight, related to gravity.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is \"off\".Q: When queried, this flag returns an int."
            }
        }
    }, 
    "polyClipboard": {
        "description": "The command allows the user to copy and paste certain polygonal attributes to a clipboard. These attributes are: 1) Shader (shading engine) assignment. 2) Texture coordinate (UV) assignment. 3) Color value assignment. Any combination of attributes can be chosen for the copy or paste operation. If the attribute has not been copied to the clipboard, then naturally it cannot be pasted from the clipboard. The copy option will copy the attribute assignments from a single source polygonal dag object or polygon component. If the source does not have the either UV or color attributes, then nothing will be copied to the clipboard. The paste option will paste the attribute assignments to one or more polygon components or polygonal dag objects. If the destination does not have either UV or color attributes, then new values will be assigned as needed. Additionally, there is the option to clear the clipboard contents ", 
        "flags": {
            "clear": {
                "docstring": "When used, will mean to clear the specified attribute argument(s).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "color": {
                "docstring": "When used, will be to copy or paste color attributes"
            }, 
            "copy": {
                "docstring": "When used, will mean to copy the specified attribute argument(s)."
            }, 
            "paste": {
                "docstring": "When used, will mean to paste the specified attribute argument(s)."
            }, 
            "shader": {
                "docstring": "When used, will be to copy or paste shader attributes"
            }, 
            "uvCoordinates": {
                "docstring": "When used, will be to copy or paste texture coordinate attributes"
            }
        }
    }, 
    "polyCloseBorder": {
        "description": "Closes open borders of objects. For each border edge given, a face is created to fill the hole the edge lies on. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyCollapseEdge": {
        "description": "Turns each selected edge into a point. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyCollapseFacet": {
        "description": "Turns each selected facet into a point. ", 
        "flags": {
            "areaThreshold": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useAreaThreshold": {
                "docstring": ""
            }
        }
    }, 
    "polyColorBlindData": {
        "description": "This command applies false color to the selected polygonal components and objects, depending on whether or not blind data exists for the selected components (or, in the case of poly objects, dynamic attributes), and, depending on the color mode indicated, what the values are. It is possible to color objects based on whether or not the data exists, if the data matches a specific value or range of values, or grayscale color the data according to what the actual value is in relation to the specified min and max. This command also has a query mode in which the components and/or objects are returned in a string array to allow for selection filtering. ", 
        "flags": {
            "aboveMaxColorBlue": {
                "docstring": "Specifies blue component of color to use for data that is above max"
            }, 
            "aboveMaxColorGreen": {
                "docstring": "Specifies green component of color to use for data that is above max"
            }, 
            "aboveMaxColorRed": {
                "docstring": "Specifies red component of color to use for data that is above max"
            }, 
            "attrName": {
                "docstring": "Specifies the name of the data that is being examined by this command."
            }, 
            "belowMinColorBlue": {
                "docstring": "Specifies blue component of color to use for data that is below min"
            }, 
            "belowMinColorGreen": {
                "docstring": "Specifies green component of color to use for data that is below min"
            }, 
            "belowMinColorRed": {
                "docstring": "Specifies red component of color to use for data that is below min"
            }, 
            "clashColorBlue": {
                "docstring": "Specifies blue component color to use for data which clashes"
            }, 
            "clashColorGreen": {
                "docstring": "Specifies green component color to use for data which clashes"
            }, 
            "clashColorRed": {
                "docstring": "Specifies red component color to use for data which clashes"
            }, 
            "colorBlue": {
                "docstring": "Specifies blue component of color to use for given data"
            }, 
            "colorGreen": {
                "docstring": "Specifies green component of color to use for given data"
            }, 
            "colorRed": {
                "docstring": "Specifies red component of color to use for given data"
            }, 
            "dataType": {
                "docstring": "Specifies the type for this id"
            }, 
            "enableFalseColor": {
                "docstring": "Turns false coloring on or off for all poly objects in the scene"
            }, 
            "maxColorBlue": {
                "docstring": "Specifies blue component of color to use for max value for grayscale"
            }, 
            "maxColorGreen": {
                "docstring": "Specifies green component of color to use for max value for grayscale"
            }, 
            "maxColorRed": {
                "docstring": "Specifies red component of color to use for max value for grayscale"
            }, 
            "maxValue": {
                "docstring": "Specifies the max value for grayscale or discrete range data"
            }, 
            "minColorBlue": {
                "docstring": "Specifies blue component of color to use for min value for grayscale"
            }, 
            "minColorGreen": {
                "docstring": "Specifies green component of color to use for min value for grayscale"
            }, 
            "minColorRed": {
                "docstring": "Specifies red component of color to use for min value for grayscale"
            }, 
            "minValue": {
                "docstring": "Specifies the min value for grayscale or discrete range data"
            }, 
            "mode": {
                "docstring": "Specifies the mode: 0 : binary - only components and objects that have the data will be colored1 : discrete value - a value is specified. Data that matches this value will be colored2 : discrete range - values that fall within the given range will be colored3 : unsigned set mode - if ( givenValue actualValue ) then data will be colored4 : unsigned not set mode - if ( !(givenValue actualValue) ) then data will be colored5 : unsigned equal mode - if ( givenValue == actualValue ) then data will be colored6 : grayscale mode - a min value, max value, min color, max color, below min color, and above max color are given. Data is colored according to how it relates to these values.7 : as color mode - if the blind data consists of 3 doubles, ranged 0-1, the components are colored as the data specifies"
            }, 
            "noColorBlue": {
                "docstring": "Specifies blue component of color to use for no data assigned"
            }, 
            "noColorGreen": {
                "docstring": "Specifies green component of color to use for no data assigned"
            }, 
            "noColorRed": {
                "docstring": "Specifies red component of color to use for no data assigned"
            }, 
            "numIdTypes": {
                "docstring": "Specifies how many attrs are in this id type"
            }, 
            "queryMode": {
                "docstring": "If on, do not color and return selection as string array instead. Any data that would be colored normally (except for 'no color' and out of range colors) is returned"
            }, 
            "typeId": {
                "docstring": "Specifies the typeId of the BlindData type being created"
            }, 
            "useMax": {
                "docstring": "Specifies whether the max should be used for discrete rangesFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useMin": {
                "docstring": "Specifies whether the min should be used for discrete ranges"
            }, 
            "value": {
                "docstring": "The value of the data"
            }
        }
    }, 
    "polyColorDel": {
        "description": "Deletes color from selected components. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "colorSetName": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyColorMod": {
        "description": "Modifies the attributes of a poly color set. ", 
        "flags": {
            "alphaScale_FloatValue": {
                "docstring": ""
            }, 
            "alphaScale_Interp": {
                "docstring": ""
            }, 
            "alphaScale_Position": {
                "docstring": ""
            }, 
            "baseColorName": {
                "docstring": "The name of the color set to be modified."
            }, 
            "blueScale_FloatValue": {
                "docstring": ""
            }, 
            "blueScale_Interp": {
                "docstring": ""
            }, 
            "blueScale_Position": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "greenScale_FloatValue": {
                "docstring": ""
            }, 
            "greenScale_Interp": {
                "docstring": ""
            }, 
            "greenScale_Position": {
                "docstring": ""
            }, 
            "huev": {
                "docstring": "Rotates hue value of the final color."
            }, 
            "intensityScale_FloatValue": {
                "docstring": ""
            }, 
            "intensityScale_Interp": {
                "docstring": ""
            }, 
            "intensityScale_Position": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "redScale_FloatValue": {
                "docstring": ""
            }, 
            "redScale_Interp": {
                "docstring": ""
            }, 
            "redScale_Position": {
                "docstring": ""
            }, 
            "satv": {
                "docstring": "scales the saturation of the final color."
            }, 
            "value": {
                "docstring": "Scales the final color value.Common flags"
            }
        }
    }, 
    "polyColorPerVertex": {
        "description": "Command associates color(rgb and alpha) with vertices on polygonal objects. When used with the query flag, it returns the color associated with the specified components. ", 
        "flags": {
            "alpha": {
                "docstring": "Specifies the alpha channel of color"
            }, 
            "clamped": {
                "docstring": "This flag specifies if the color set will truncate any value that is outside 0 to 1 range."
            }, 
            "colorB": {
                "docstring": "Specifies the B channel of color"
            }, 
            "colorDisplayOption": {
                "docstring": "Change the display options on the mesh to display the vertex colors."
            }, 
            "colorG": {
                "docstring": "Specifies the G channel of color"
            }, 
            "colorR": {
                "docstring": "Specifies the R channel of color"
            }, 
            "colorRGB": {
                "docstring": "Specifies the RGB channels of color"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "notUndoable": {
                "docstring": "Execute the command, but without having the command be undoable. This option will greatly improve performance for large numbers of object. This will make the command not undoable regardless of whether undo has been enabled or not."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "When used, the color values specified are added relative to the current values."
            }, 
            "remove": {
                "docstring": "When used, the color values are removed from the selected or specified objects or components. This option only supports meshes with no construction history, or meshes whose construction history includes a recent polyColorPerVertexNode. For meshes whose construction history includes a polgon operation the polyColorPerVertexNode, consider using the polyColorDel command instead"
            }, 
            "representation": {
                "docstring": "This flag corresponds to the color channels to used, for example A(alpha only), RGB, and RGBA.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "polyColorSet": {
        "description": "Command to do the following to color sets: - delete an existing color set. - rename an existing color set. - create a new empty color set. - set the current color set to a pre-existing color set. - modify sharing between instances of per-instance color sets - query the current color set. - query the names of all color sets. - query the name(s) along with representation value(s) or clamped value(s) of all color sets - query the representation value or clamped value of the current color set ", 
        "flags": {
            "allColorSets": {
                "docstring": "This flag when used in a query will return a list of all of the color set names"
            }, 
            "clamped": {
                "docstring": "This flag specifies if the color set will truncate any value that is outside 0 to 1 range."
            }, 
            "colorSet": {
                "docstring": "Specifies the name of the color set that this command needs to work on. This flag has to be specified for this command to do anything meaningful other than query the current color set."
            }, 
            "copy": {
                "docstring": "This flag when used will result in the copying of the color set corresponding to name specified with the colorSet flag to the colorSet corresponding to the name specified with the newcolorSet flag"
            }, 
            "create": {
                "docstring": "This flag when used will result in the creation of an empty color set corresponding to the name specified with the colorSet flag. If a color set with that name already exists, then no new color set will be created."
            }, 
            "currentColorSet": {
                "docstring": "This flag when used will set the current color set that the object needs to work on, to be the color set corresponding to the name specified with the colorSet flag. This does require that a colorSet with the specified name exist. When queried, this returns the current color set."
            }, 
            "currentPerInstanceSet": {
                "docstring": "This is a query-only flag for use when the current color set is a per-instance color set family. This returns the member of the set family that corresponds to the currently select instance.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "delete": {
                "docstring": "This flag when used will result in the deletion of the color set corresponding to the name specified with the colorSet flag."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "newColorSet": {
                "docstring": "Specifies the name that the color set corresponding to the name specified with the colorSet flag, needs to be renamed to."
            }, 
            "perInstance": {
                "docstring": "This flag can be used in conjunction with the create flag to indicate whether or not the color set is per-instance. When you create a per-instance color set, the set will be applied as shared between all selected instances of the shape unless the unshared flag is used. The perInstance flag can be used in query mode with the currentColorSet or allColorSets flag to indicate that the set family names (i.e. not containing instance identifiers) will be returned by the query. In query mode, this flag can accept a value."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rename": {
                "docstring": "This flag when used will result in the renaming of the color set corresponding to the name specified with the colorSet flag to the name specified using the newColorSet flag."
            }, 
            "representation": {
                "docstring": "This flag corresponds to the color channels to used, for example A(alpha only), RGB, and RGBA."
            }, 
            "shareInstances": {
                "docstring": "This flag is used to modify the sharing of per-instance color sets within a given color set family so that all selected instances share the specified set. In query mode, it returns a list of the instances that share the set specified by the colorSet flag."
            }, 
            "unshared": {
                "docstring": "This flag can be used in conjunction with the create and perInstance flags to indicate that the newly created per-instance set should be created with a separate set per instance."
            }
        }
    }, 
    "polyCompare": {
        "description": "Compares two Polygonal Geometry objects with a fine control on what to compare.If no objects are specified in the command line, then the objects from the active list are used.Default behaviour is to compare all flags.Use MEL script polyCompareTwoObjects.mel to get formatted output from this command. ", 
        "flags": {
            "colorSetIndices": {
                "docstring": "Compare poly1, poly2 for matching Color Indices."
            }, 
            "colorSets": {
                "docstring": "Compare poly1, poly2 for matching Color Sets."
            }, 
            "edges": {
                "docstring": "Compare poly1, poly2 for matching Edges."
            }, 
            "faceDesc": {
                "docstring": "Compare poly1, poly2 for matching Face Descriptions. Face descriptions describe the topology of a face, for example number and orientation of edges, number of topology of any holes in the face etc."
            }, 
            "userNormals": {
                "docstring": "Compare poly1, poly2 for matching User Normals.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "uvSetIndices": {
                "docstring": "Compare poly1, poly2 for matching UV Indices."
            }, 
            "uvSets": {
                "docstring": "Compare poly1, poly2 for matching UV Sets."
            }, 
            "vertices": {
                "docstring": "Compare poly1, poly2 for matching Vertices."
            }
        }
    }, 
    "polyCone": {
        "description": "The cone command creates a new polygonal cone. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the cone.Q: When queried, this flag returns a float[3]."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a specific UV mechanism to be selected, while creating the cone.The valid values are 0, 1, 2 or 3.0 implies that no UVs will be generated (No texture to be applied).1 implies UVs should be created for the object as a whole without any normalization.The cone will be unwrapped and then the texture will be appliedwithout any distortion.In the unwrapped cone, the shared edges will have shared UVs.2 implies the UVs should be normalized. This will normalize theU and V direction separately, thereby resulting in distortion of textures.4 implies UVs are created so that the texture will not be distorted when applied.The texture lying outside the UV range will be truncated (since that cannot besqueezed in, without distorting the texture.For better understanding of these options, you may have to open thetexture view windowC: Default is 3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "height": {
                "docstring": "This flag specifies the height of the cone.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "This flag specifies the radius of the cone.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "roundCap": {
                "docstring": ""
            }, 
            "subdivisionsAxis": {
                "docstring": ""
            }, 
            "subdivisionsCap": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsX": {
                "docstring": "This specifies the number of subdivisions in the X direction for the cone.C: Default is 20.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsY": {
                "docstring": "This flag specifies the number of subdivisions in the Y direction for the cone.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsZ": {
                "docstring": "This flag specifies the number of subdivisions in the Z direction for the cone.C: Default is 0.Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.Common flags"
            }
        }
    }, 
    "polyConnectComponents": {
        "description": "Splits polygon edges according to the selected components. The selected components are gathered into connected 'paths' that define continuous splits. Mixed components (vertices, edges and faces) can be used at once. The connection rules are: \\* Edges can connect to other edges in the same face or to vertices in the same face (that are not in the edge itself) or to faces connected to other edges in the same face. \\* Vertices can connect to edges (as above) or to vertices in the same face (that are not joined to the first vertex by an edge) or to faces adjacent to a face that uses the vertex (except those that also use the vertex). \\* Faces can connect to vertices or edges (as above) or to adjacent faces. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyCopyUV": {
        "description": "Copy some UVs from a UV set into another. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "createNewMap": {
                "docstring": "This flag when set true will create a new map with a the name passed in, if the map does not already exist."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "uvSetName": {
                "docstring": "Specifies name of the output uv set to modify. Default is the current UV set.Common flags"
            }, 
            "uvSetNameInput": {
                "docstring": "Specifies name of the input uv set to read the UV description from. Default is the current UV set."
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "polyCrease": {
        "description": "Command to set the crease values on the edges or vertices of a poly. The crease values are used by the smoothing algorithm. ", 
        "flags": {
            "createHistory": {
                "docstring": "For objects that have no construction history, this flag can be used to force the creation of construction history for creasing. By default, history is not created if the object has no history. Regardless of this flag, history is always created if the object already has history."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "operation": {
                "docstring": "Operation to perform. Valid values are: 0: Crease the specified components. 1: Remove the crease values for the specified components. 2: Remove all crease values from the mesh. Default is 0.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relativeValue": {
                "docstring": "Specifies a new relative value for all selected vertex and edge components. This flag can not be used at the same time as either the value or vertexValue flags."
            }, 
            "value": {
                "docstring": "Specifies the crease value for the selected edge components. When specified multiple times, the values are assigned respectively to the specified edges."
            }, 
            "vertexValue": {
                "docstring": "Specifies the crease value for the selected vertex components. When specified multiple times, the values are assigned respectively to the specified vertices."
            }
        }
    }, 
    "polyCreaseCtx": {
        "description": "Create a new context to crease components on polygonal objects In query mode, return type is based on queried flag.", 
        "flags": {
            "createSet": {
                "docstring": "Creates a set for the selected components.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "extendSelection": {
                "docstring": "Enable/disable extending selection to all connected creased components."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Enable/disable applying value relative to existing crease value. If disabled, absolute value is applied."
            }
        }
    }, 
    "polyCreateFacet": {
        "description": "Create a new polygonal object with the specified face, which will be closed. List of arguments must have at least 3 points. ", 
        "flags": {
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "hole": {
                "docstring": "Add a hole. The following points will define a hole. Holes can be defined either clockwise or counterclockwise. Note that this flag is not recommended for use in Python. When specifying facets with the point flag in Python, pass in an empty point \"()\" when you want to start specifying a hole.Common flags"
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "point": {
                "docstring": "Adds a new point to the face. Coordinates of points are given in world reference. The point flag may also be passed with no arguments. That indicates that the following points will specify a hole. Passing the point flag with no arguments is the same as using the \"hole\" flag, except that it will work in Python."
            }, 
            "query": {
                "docstring": ""
            }, 
            "subdivision": {
                "docstring": "This flag specifies the level of subdivision. Subdivides edges into the given number of edges.C: Default is 1 (no subdivision).Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "Specifies how the face is mapped.0 - None; 1 - Normalize; 2 - UnitizeC: Default is 0 (no mapping).Q: When queried, this flag returns an int"
            }
        }
    }, 
    "polyCreateFacetCtx": {
        "description": "Create a new context to create polygonal objects In query mode, return type is based on queried flag.", 
        "flags": {
            "append": {
                "docstring": "Allows to switch to polyAppendFacetCtx tool"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "maximumNumberOfPoints": {
                "docstring": "Allows the ability to set a upper bound on the number of points in interactively place before polygon is created. A value less than 2 will mean that there is no upper bound.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "planarConstraint": {
                "docstring": "allows/avoid new facet to be non-planar.If on, all new points will be projected onto current facet plane."
            }, 
            "query": {
                "docstring": ""
            }, 
            "subdivision": {
                "docstring": "number of sub-edges created for each new edge. Default is 1."
            }, 
            "texture": {
                "docstring": ""
            }
        }
    }, 
    "polyCube": {
        "description": "The cube command creates a new polygonal cube. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the cube.Q: When queried, this flag returns a float[3]."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a specific UV mechanism to be selected, while creating the cube.The valid values are 0, 1, 2 ,3 or 4.0 implies that no UVs will be generated (No texture to be applied).1 implies UVs should be created for the object as a whole without any normalization.The cube will be unwrapped and then the texture will be appliedwithout any distortion.In the unwrapped cube, the shared edges will have shared UVs.2 implies UVs are created separately for each of the faces of the cube.3 implies the UVs should be normalized. This will normalize theU and V direction separately, thereby resulting in distortion of textures.4 implies UVs are created so that the texture will not be distorted when applied.The texture lying outside the UV range will be truncated (since that cannot besqueezed in, without distorting the texture.For better understanding of these options, you may have to open thetexture view windowC: Default is 4"
            }, 
            "depth": {
                "docstring": "This flag specifies the depth of the cube.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "height": {
                "docstring": "This flag specifies the height of the cube.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "subdivisionsDepth": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsWidth": {
                "docstring": ""
            }, 
            "subdivisionsX": {
                "docstring": "This specifies the number of subdivisions in the X direction for the cube.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsY": {
                "docstring": "This flag specifies the number of subdivisions in the Y direction for the cube.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsZ": {
                "docstring": "This flag specifies the number of subdivisions in the Z direction for the cube.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.Common flags"
            }, 
            "width": {
                "docstring": "This flag specifies the width of the cube.C: Default is 1.0.Q: When queried, this flag returns a float."
            }
        }
    }, 
    "polyCut": {
        "description": "This command splits a mesh, or a set of poly faces, along a plane. The position and orientation of the plane can be adjusted using the appropriate flags listed above. In addition, the cut operation can also delete the faces lying on one side of the cutting plane, or extract those faces by an offset amount. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "cutPlaneCenter": {
                "docstring": "This flag specifies the position of the cutting plane."
            }, 
            "cutPlaneCenterX": {
                "docstring": "This flag specifies the X position of the cutting plane."
            }, 
            "cutPlaneCenterY": {
                "docstring": "This flag specifies the Y position of the cutting plane."
            }, 
            "cutPlaneCenterZ": {
                "docstring": "This flag specifies the Z position of the cutting plane."
            }, 
            "cutPlaneHeight": {
                "docstring": "This flag specifies the height of the cutting plane. This is used only for displaying the manipulator, and has no effect on the cut operation."
            }, 
            "cutPlaneRotate": {
                "docstring": "This flag specifies the orientation of the cutting plane."
            }, 
            "cutPlaneRotateX": {
                "docstring": "This flag specifies the X rotation of the cutting plane."
            }, 
            "cutPlaneRotateY": {
                "docstring": "This flag specifies the Y rotation of the cutting plane."
            }, 
            "cutPlaneRotateZ": {
                "docstring": "This flag specifies the Z rotation of the cutting plane."
            }, 
            "cutPlaneSize": {
                "docstring": "This flag specifies the size of the cutting plane. This is used only for displaying the manipulator, and has no effect on the cut operation."
            }, 
            "cutPlaneWidth": {
                "docstring": "This flag specifies the width of the cutting plane. This is used only for displaying the manipulator, and has no effect on the cut operation."
            }, 
            "cuttingDirection": {
                "docstring": "This flag specifies the direction of the cutting plane. Valid values are \"x\", \"y\", \"z\" A value of \"x\" will cut the object along the YZ plane cutting through the center of the bounding box. A value of \"y\" will cut the object along the ZX plane cutting through the center of the bounding box. A value of \"z\" will cut the object along the XY plane cutting through the center of the bounding box."
            }, 
            "deleteFaces": {
                "docstring": "This flag specifies if the cut faces should be deleted or not."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "extractFaces": {
                "docstring": "This flag specifies if the cut faces should be extracted or not."
            }, 
            "extractOffset": {
                "docstring": "This flag specifies the offset by which the cut faces will be extracted. This flag has no effect when the \"extractFaces\" is turned off."
            }, 
            "extractOffsetX": {
                "docstring": "This flag specifies the offset in X by which the cut faces will be extracted. This flag has no effect when the \"extractFaces\" is turned off."
            }, 
            "extractOffsetY": {
                "docstring": "This flag specifies the offset in Y by which the cut faces will be extracted. This flag has no effect when the \"extractFaces\" is turned off."
            }, 
            "extractOffsetZ": {
                "docstring": "This flag specifies the offset in Z by which the cut faces will be extracted. This flag has no effect when the \"extractFaces\" is turned off."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "onObject": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "This flag is ignored. polyCut command always works on worldSpace.Common flags"
            }
        }
    }, 
    "polyCutCtx": {
        "description": "Create a new context to cut facets on polygonal objects In query mode, return type is based on queried flag.", 
        "flags": {
            "deleteFaces": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "extractFaces": {
                "docstring": ""
            }, 
            "extractOffset": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyCylinder": {
        "description": "The cylinder command creates a new polygonal cylinder. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the cylinder.Q: When queried, this flag returns a float[3]."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a specific UV mechanism to be selected, while creating the primitive.The valid values are 0, 1, 2 or 3.0 implies that no UVs will be generated (No texture to be applied).1 implies UVs should be created for the object as a whole without any normalization.The primitive will be unwrapped and then the texture will be appliedwithout any distortion.In the unwrapped primitive, the shared edges will have shared UVs.2 implies the UVs should be normalized. This will normalize theU and V direction separately, thereby resulting in distortion of textures.4 implies UVs are created so that the texture will not be distorted when applied.The texture lying outside the UV range will be truncated (since that cannot besqueezed in, without distorting the texture.For better understanding of these options, you may have to open thetexture view windowC: Default is 3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "height": {
                "docstring": "This flag specifies the height of the cylinder.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "This flag specifies the radius of the cylinder.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "roundCap": {
                "docstring": ""
            }, 
            "subdivisionsAxis": {
                "docstring": ""
            }, 
            "subdivisionsCaps": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsX": {
                "docstring": "This specifies the number of subdivisions in the X direction for the cylinder.C: Default is 20.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsY": {
                "docstring": "This flag specifies the number of subdivisions in the Y direction for the cylinder.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsZ": {
                "docstring": "This flag specifies the number of subdivisions in the Z direction for the cylinder.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.Common flags"
            }
        }
    }, 
    "polyCylindricalProjection": {
        "description": "Projects a cylindrical map onto an object. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "createNewMap": {
                "docstring": "This flag when set true will create a new map with a the name passed in, if the map does not already exist.Common flags"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "imageCenter": {
                "docstring": "This flag specifies the center point of the 2D model layout.C: Default is 0.5 0.5.Q: When queried, this flag returns a float[2]."
            }, 
            "imageCenterX": {
                "docstring": "This flag specifies X of the center point of the 2D model layout.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "imageCenterY": {
                "docstring": "This flag specifies Y of the center point of the 2D model layout.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "imageScale": {
                "docstring": "This flag specifies the UV scale : Enlarges or reduces the 2D version of the model in U or V space relative to the 2D centerpoint.C: Default is 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "imageScaleU": {
                "docstring": "This flag specifies the U scale : Enlarges or reduces the 2D version of the model in U space relative to the 2D centerpoint.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "imageScaleV": {
                "docstring": "This flag specifies the U scale : Enlarges or reduces the 2D version of the model in V space relative to the 2D centerpoint.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "insertBeforeDeformers": {
                "docstring": "This flag specifies if the projection node should be inserted before or after deformer nodes already applied to the shape. Inserting the projection after the deformer leads to texture swimming during animation and is most often undesirable.C: Default is on."
            }, 
            "keepImageRatio": {
                "docstring": ""
            }, 
            "mapDirection": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "perInstance": {
                "docstring": ""
            }, 
            "projectionCenter": {
                "docstring": "This flag specifies the point of origin from which the map is projected.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "projectionCenterX": {
                "docstring": "This flag specifies the X of the origin's point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionCenterY": {
                "docstring": "This flag specifies the Y of the origin's point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionCenterZ": {
                "docstring": "This flag specifies the Z of the origin's point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionHeight": {
                "docstring": ""
            }, 
            "projectionHorizontalSweep": {
                "docstring": ""
            }, 
            "projectionScale": {
                "docstring": "This flag specifies the width and the height of the map relative to the 3D projection axis.C: Default is 180.0 1.0.Q: When queried, this flag returns a float[2]."
            }, 
            "projectionScaleU": {
                "docstring": "This flag specifies the width of the map relative to the 3D projection axis : the scale aperture.C: Default is 180.0. The range is [0, 360].Q: When queried, this flag returns a float."
            }, 
            "projectionScaleV": {
                "docstring": "This flag specifies the height of the map relative to the 3D projection axis : the scale height.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "rotate": {
                "docstring": "This flag specifies mapping's rotate angles.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateX": {
                "docstring": "This flag specifies X for mapping's rotate angles.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateY": {
                "docstring": "This flag specifies Y for mapping's rotate angles.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies Z for mapping's rotate angles.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotationAngle": {
                "docstring": "This flag specifies the angle for the rotation. When the angle is positive, then the map rotates counterclockwise on the mapped model, whereas when it is negative then the map rotates lockwise on the mapped model.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "seamCorrect": {
                "docstring": "This flag specifies to perform a seam correction on the mapped faces."
            }, 
            "smartFit": {
                "docstring": "This flag specifies if the manipulator should be placed best fitting the object, or be placed on the specified position with the specified transformation values.Default is on."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If on : all geometrical values are taken in world reference. If off : all geometrical values are taken in object reference.C: Default is off.Q: When queried, this flag returns an int."
            }
        }
    }, 
    "polyDelEdge": {
        "description": "Deletes selected edges, and merges neighboring faces. If deletion leaves winged vertices, they may be deleted as well.Notice : only non border edges can be deleted. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "cleanVertices": {
                "docstring": "If on : delete resulting winged vertices.C: Default is \"off\".Q: When queried, this flag returns an int.Common flags"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyDelFacet": {
        "description": "Deletes faces. If the result is split into disconnected pieces, the pieces (so-called shells) are still considered to be one object.Notice : The last face cannot be deleted. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyDelVertex": {
        "description": "Deletes vertices. Joins two edges which have a common vertex. The vertices must be connected to exactly two edges (so-called \"winged\"). ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyDuplicateAndConnect": {
        "description": "This command duplicates the input polygonal object, connects up the outMesh attribute of the original polygonal shape to the inMesh attribute of the newly created duplicate shape and copies over the shader assignments from the original shape to the new duplicated shape. The command will fail if no objects are selected or sent as argument or if the object sent as argument is not a polygonal object. ", 
        "flags": {
            "removeOriginalFromShaders": {
                "docstring": "Used to specify if the original object should be removed from the shaders (shadingGroups) that it is a member of. The shader associations will get transferred to the duplicated object, before they are removed from the original. If this flag is specified then the original polygonal object will be drawn in wireframe mode even if all objects are being drawn in shaded mode."
            }, 
            "renameChildren": {
                "docstring": "rename the children nodes of the hierarchy, to make them unique.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "polyDuplicateEdge": {
        "description": "Duplicates a series of connected edges (edgeLoop) ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "deleteEdge": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endVertexOffset": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "offset": {
                "docstring": "Weight value controlling the relative positioning of the new edges. The range of values is [0.0, 1.0]."
            }, 
            "query": {
                "docstring": ""
            }, 
            "smoothingAngle": {
                "docstring": "Subdivide new edges will be soft if less then this angle.C: Default is 180.0Common flags"
            }, 
            "splitType": {
                "docstring": "Choose between 2 different types of splits. If this is set to 0 then the split type will be absolute. This is where each of the splits will maintain an equal distance from the associated vertices. If this set to 1 then the split type will be relative. This is where each split will be made at an equal percentage along the length of the edge."
            }, 
            "startVertexOffset": {
                "docstring": ""
            }
        }
    }, 
    "polyEditUV": {
        "description": "Command edits uvs on polygonal objects. When used with the query flag, it returns the uv values associated with the specified components. ", 
        "flags": {
            "angle": {
                "docstring": "Specifies the angle value (in degrees) that the uv values are to be rotated by."
            }, 
            "pivotU": {
                "docstring": "Specifies the pivot value, in the u direction, about which the scale or rotate is to be performed."
            }, 
            "pivotV": {
                "docstring": "Specifies the pivot value, in the v direction, about which the scale or rotate is to be performed."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Specifies whether this command is editing the values relative to the currently existing values. Default is true;"
            }, 
            "rotation": {
                "docstring": "Specifies whether this command is editing the values with rotation values"
            }, 
            "scale": {
                "docstring": "Specifies whether this command is editing the values with scale values"
            }, 
            "scaleU": {
                "docstring": "Specifies the scale value in the u direction."
            }, 
            "scaleV": {
                "docstring": "Specifies the scale value in the v direction."
            }, 
            "uValue": {
                "docstring": "Specifies the value, in the u direction - absolute if relative flag is false.."
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "vValue": {
                "docstring": "Specifies the value, in the v direction - absolute if relative flag is false.."
            }
        }
    }, 
    "polyEditUVShell": {
        "description": "Command edits uv shells on polygonal objects. When used with the query flag, it returns the transformation values associated with the specified components. ", 
        "flags": {
            "angle": {
                "docstring": "Specifies the angle value (in degrees) that the uv values are to be rotated by."
            }, 
            "pivotU": {
                "docstring": "Specifies the pivot value, in the u direction, about which the scale or rotate is to be performed."
            }, 
            "pivotV": {
                "docstring": "Specifies the pivot value, in the v direction, about which the scale or rotate is to be performed."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Specifies whether this command is editing the values relative to the currently existing values. Default is true;"
            }, 
            "rotation": {
                "docstring": "Specifies whether this command is editing the values with rotation values"
            }, 
            "scale": {
                "docstring": "Specifies whether this command is editing the values with scale values"
            }, 
            "scaleU": {
                "docstring": "Specifies the scale value in the u direction."
            }, 
            "scaleV": {
                "docstring": "Specifies the scale value in the v direction."
            }, 
            "uValue": {
                "docstring": "Specifies the value, in the u direction - absolute if relative flag is false.."
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "vValue": {
                "docstring": "Specifies the value, in the v direction - absolute if relative flag is false.."
            }
        }
    }, 
    "polyEvaluate": {
        "description": "Returns the required counts on the specified objects.If no objects are specified in the command line, then the objects from the active list are used. In MEL, the values are returned in the same order as the flags are set. Under Python, there is no concept of argument ordering, so the items are returned in a dictionary keyed by the name of the flag. In Python, if only one item is requested, then it will not be returned in a dictionary.For user convenience, if no flag is set, then all values are echoed. All flags (except -fmt/format) are in fact query-flags. For user convenience, the -q flag may be ommitted. Some comments for non-formatted output :3d bounding boxes are returned as 3 couples of floats, 2d ones as 2 couples of floats.if a bounding box is queried and cannot be computed (for example the component bounding box when no component is selected, or 2d bounding box for and unmapped object) 0 is returned for each array element, so that indices in the output array remain consistent.intvalues (queried by topological flags) cannot be mixed with floatvalues (queried by bounding box flags). Thus if no flag is set, only intvalues are returned.", 
        "flags": {
            "accurateEvaluation": {
                "docstring": "used to get accurate results for the bounding box computation For objects with large vertex counts, accurate evaluation takes more time"
            }, 
            "activeShells": {
                "docstring": ""
            }, 
            "area": {
                "docstring": "returns the surface area of the object's faces in local space as a float"
            }, 
            "boundingBox": {
                "docstring": "returns the object's bounding box in 3d space as 6 floats in MEL: xmin xmax ymin ymax zmin zmax, or as a tuple of three pairs in Python: ((xmin,xmax), (ymin,ymax), (zmin,zmax))"
            }, 
            "boundingBox2d": {
                "docstring": "returns the object's uv bounding box (for the current map if one is not specified) in 2d space as 4 floats in MEL : xmin xmax ymin ymax, or as a tuple of three pairs in Python: ((xmin,xmax), (ymin,ymax), (zmin,zmax))"
            }, 
            "boundingBoxComponent": {
                "docstring": "returns the bounding box of selected components in 3d space as 6 floats in MEL : xmin xmax ymin ymax zmin zmax, or as a tuple of three pairs in Python: ((xmin,xmax), (ymin,ymax), (zmin,zmax))"
            }, 
            "boundingBoxComponent2d": {
                "docstring": "returns the bounding box of selected uv coordinates in 2d space as 4 floats in MEL : xmin xmax ymin ymax, or as a tuple of two pairs in Python: ((xmin,xmax), (ymin,ymax))"
            }, 
            "displayStats": {
                "docstring": "toggles the display of poly statistics for the active View. All other flags are ignored if this flag is specified (Obsolete - refer to the headsUpDisplay command)"
            }, 
            "edge": {
                "docstring": "returns the number of edges as an int"
            }, 
            "edgeComponent": {
                "docstring": "returns the object's number of selected edges as an int"
            }, 
            "face": {
                "docstring": "returns the number of faces as an int"
            }, 
            "faceComponent": {
                "docstring": "returns the object's number of selected faces as an int"
            }, 
            "format": {
                "docstring": "used to display the results as an explicit sentence"
            }, 
            "shell": {
                "docstring": "returns the number of shells shells (disconnected pieces) as an int"
            }, 
            "triangle": {
                "docstring": "returns the number of triangles as an int"
            }, 
            "triangleComponent": {
                "docstring": "returns the number of triangles of selected components as an int"
            }, 
            "uvComponent": {
                "docstring": "returns the object's number of selected uv coordinates as an int"
            }, 
            "uvSetName": {
                "docstring": "used when querying texture vertices to specify the uv set. If a uv set is not specified then the current map for the object will be used"
            }, 
            "uvcoord": {
                "docstring": "returns the number of uv coordinates (for the current map if one is not specified) as an int"
            }, 
            "vertex": {
                "docstring": "returns the number of vertices as an int"
            }, 
            "vertexComponent": {
                "docstring": "returns the object's number of selected vertices as an int"
            }, 
            "worldArea": {
                "docstring": "returns the surface area of the object's faces in world space as a floatFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "polyExtrudeEdge": {
        "description": "Extrude edges separately or together. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "createCurve": {
                "docstring": ""
            }, 
            "divisions": {
                "docstring": "This flag specifies the number of subdivisions.C: Default is 1Q: When queried, this flag returns an int."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "gain": {
                "docstring": ""
            }, 
            "inputCurve": {
                "docstring": "This flag specifies the name of the curve to be used as input for extrusionC: The selected edges will be extruded along the curve. It will be useful to set a higher value (greater than 4) for the '-d/-divisions' flag, to get good results. The normal of the surface has to be aligned with the direction of the curve. The extrusion is evenly distributed in the curve's parameter space, and not on the curve's geometry space"
            }, 
            "keepFacesTogether": {
                "docstring": "This flag specifies how to extrude edgess. If \"on\", edges are pulled together (connected ones stay connected), otherwise they are pulled independentely.C: Default is \"on\".Q: When queried, this flag returns an int."
            }, 
            "localCenter": {
                "docstring": ""
            }, 
            "localDirection": {
                "docstring": "This flag specifies the local slant axis (see local rotation).C: Default is 0.0 0.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localDirectionX": {
                "docstring": "This flag specifies X for the local slant axis.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localDirectionY": {
                "docstring": "This flag specifies Y for the local slant axis.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localDirectionZ": {
                "docstring": "This flag specifies Z for the local slant axis.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localRotate": {
                "docstring": "This flag specifies the local rotations : (slantRot, slantRoll, twistRot).C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]. Local rotation (slantRot, slantRoll, twistRot)."
            }, 
            "localRotateX": {
                "docstring": "This flag specifies local rotation X angle (Slant Rot around slantAxis).C: Default is 0.0. The range is [0, 360].Q: When queried, this flag returns a float."
            }, 
            "localRotateY": {
                "docstring": "This flag specifies local rotation Y angle (Slant Roll of slantAxis).C: Default is 0.0. The range is [0, 180].Q: When queried, this flag returns a float."
            }, 
            "localRotateZ": {
                "docstring": "This flag specifies local rotation Z angle (Twist around normal).C: Default is 0.0. The range is [0, 360].Q: When queried, this flag returns a float."
            }, 
            "localScale": {
                "docstring": "This flag specifies the local scaling vector.C: Default is 1.0 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localScaleX": {
                "docstring": "This flag specifies X for local scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localScaleY": {
                "docstring": "This flag specifies Y for local scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localScaleZ": {
                "docstring": "This flag specifies Z for local scaling vector : Flattening.C: Default is 1.0. The range is [0.0, 1.0].Q: When queried, this flag returns a float.Common flags"
            }, 
            "localTranslate": {
                "docstring": "This flag specifies the local translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localTranslateX": {
                "docstring": "This flag specifies the X local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslateY": {
                "docstring": "This flag specifies the Y local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslateZ": {
                "docstring": "This flag specifies the Z local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "offset": {
                "docstring": ""
            }, 
            "pivot": {
                "docstring": "This flag specifies the pivot for scaling and rotation.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "pivotX": {
                "docstring": "This flag specifies the X pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotY": {
                "docstring": "This flag specifies the Y pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotZ": {
                "docstring": "This flag specifies the Z pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float. Local Values"
            }, 
            "query": {
                "docstring": ""
            }, 
            "random": {
                "docstring": "This flag specifies the random value for all parameters.C: Default is 0.0. The range is [-10.0, 10.0].Q: When queried, this flag returns a float."
            }, 
            "rotate": {
                "docstring": "This flag specifies the rotation angles around X, Y, Z.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateX": {
                "docstring": "This flag specifies the rotation angle around X.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateY": {
                "docstring": "This flag specifies the rotation angle around Y.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies the rotation angle around Z.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "scale": {
                "docstring": "This flag specifies the scaling vector.C: Default is 1.0 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "scaleX": {
                "docstring": "This flag specifies X for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleY": {
                "docstring": "This flag specifies Y for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleZ": {
                "docstring": "This flag specifies Z for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "smoothingAngle": {
                "docstring": "This flag specifies smoothingAngle threshold used to determine whether newly created edges are hard or soft.C: Default is 30.0. The range is [0, 180].Q: When queried, this flag returns a float. Global Values"
            }, 
            "taper": {
                "docstring": ""
            }, 
            "taperCurve_FloatValue": {
                "docstring": ""
            }, 
            "taperCurve_Interp": {
                "docstring": ""
            }, 
            "taperCurve_Position": {
                "docstring": ""
            }, 
            "thickness": {
                "docstring": ""
            }, 
            "translate": {
                "docstring": "This flag specifies the translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "translateX": {
                "docstring": "This flag specifies the X translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateY": {
                "docstring": "This flag specifies the Y translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateZ": {
                "docstring": "This flag specifies the Z translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "twist": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is off.Q: When queried, this flag returns an int."
            }
        }
    }, 
    "polyExtrudeFacet": {
        "description": "Extrude faces. Faces can be extruded separately or together, and manipulations can be performed either in world or object space. ", 
        "flags": {
            "attraction": {
                "docstring": "This flag specifies the attraction, related to magnet.C: Default is 0.0. The range is [-2.0, 2.0].Q: When queried, this flag returns a float."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "createCurve": {
                "docstring": ""
            }, 
            "divisions": {
                "docstring": "This flag specifies the number of subdivisions.C: Default is 1Q: When queried, this flag returns an int."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "gain": {
                "docstring": ""
            }, 
            "gravity": {
                "docstring": "This flag specifies the gravity vector.C: Default is 0.0 -1.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "gravityX": {
                "docstring": "This flag specifies X for the gravity vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "gravityY": {
                "docstring": "This flag specifies Y for the gravity vector.C: Default is -1.0.Q: When queried, this flag returns a float."
            }, 
            "gravityZ": {
                "docstring": "This flag specifies Z for the gravity vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "inputCurve": {
                "docstring": "This flag specifies the name of the curve to be used as input for extrusionC: The selected faces will be extruded along the curve. It will be useful to set a higher value (greater than 4) for the '-d/-divisions' flag, to get good results. The normal of the surface has to be aligned with the direction of the curve. The extrusion is evenly distributed in the curve's parameter space, and not on the curve's geometry space"
            }, 
            "keepFacesTogether": {
                "docstring": "This flag specifies how to extrude faces. If \"on\", faces are pulled together (connected ones stay connected and only outside edges form new faces), otherwise they are pulled independently (each edge on selected faces creates a new face and manipulations are performed on each selected face separately).C: Default is \"on\".Q: When queried, this flag returns an int."
            }, 
            "keepFacetTogether": {
                "docstring": ""
            }, 
            "localCenter": {
                "docstring": ""
            }, 
            "localDirection": {
                "docstring": "This flag specifies the local slant axis (see local rotation).C: Default is 0.0 0.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localDirectionX": {
                "docstring": "This flag specifies X for the local slant axis.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localDirectionY": {
                "docstring": "This flag specifies Y for the local slant axis.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localDirectionZ": {
                "docstring": "This flag specifies Z for the local slant axis.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localRotate": {
                "docstring": "This flag specifies the local rotations : (slantRot, slantRoll, twistRot).C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]. Local rotation (slantRot, slantRoll, twistRot)."
            }, 
            "localRotateX": {
                "docstring": "This flag specifies local rotation X angle (Slant Rot around slantAxis).C: Default is 0.0. The range is [0, 360].Q: When queried, this flag returns a float."
            }, 
            "localRotateY": {
                "docstring": "This flag specifies local rotation Y angle (Slant Roll of slantAxis).C: Default is 0.0. The range is [0, 180].Q: When queried, this flag returns a float."
            }, 
            "localRotateZ": {
                "docstring": "This flag specifies local rotation Z angle (Twist around normal).C: Default is 0.0. The range is [0, 360].Q: When queried, this flag returns a float."
            }, 
            "localScale": {
                "docstring": "This flag specifies the local scaling vector.C: Default is 1.0 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localScaleX": {
                "docstring": "This flag specifies X for local scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localScaleY": {
                "docstring": "This flag specifies Y for local scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localScaleZ": {
                "docstring": "This flag specifies Z for local scaling vector : Flattening.C: Default is 1.0. The range is [0.0, 1.0].Q: When queried, this flag returns a float. Dynamic Values"
            }, 
            "localTranslate": {
                "docstring": "This flag specifies the local translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localTranslateX": {
                "docstring": "This flag specifies the X local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslateY": {
                "docstring": "This flag specifies the Y local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslateZ": {
                "docstring": "This flag specifies the Z local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "magnX": {
                "docstring": "This flag specifies X for the magnet vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "magnY": {
                "docstring": "This flag specifies Y for the magnet vector.C: Default is 0.0.Q: When queried, this flag returns a float.Common flags"
            }, 
            "magnZ": {
                "docstring": ""
            }, 
            "magnet": {
                "docstring": "This flag specifies the magnet vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "maya2012": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "offset": {
                "docstring": "This flag specifies the local offset. Each edge of each selected face moves towards the inside of the face by given distance (in local reference).C: Default is 0.0."
            }, 
            "pivot": {
                "docstring": "This flag specifies the pivot for scaling and rotation.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "pivotX": {
                "docstring": "This flag specifies the X pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotY": {
                "docstring": "This flag specifies the Y pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotZ": {
                "docstring": "This flag specifies the Z pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float. Local Values"
            }, 
            "query": {
                "docstring": ""
            }, 
            "random": {
                "docstring": "This flag specifies the random value for all parameters.C: Default is 0.0. The range is [-10.0, 10.0].Q: When queried, this flag returns a float."
            }, 
            "rotate": {
                "docstring": "This flag specifies the rotation angles around X, Y, Z.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateX": {
                "docstring": "This flag specifies the rotation angle around X.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateY": {
                "docstring": "This flag specifies the rotation angle around Y.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies the rotation angle around Z.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "scale": {
                "docstring": "This flag specifies the scaling vector.C: Default is 1.0 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "scaleX": {
                "docstring": "This flag specifies X for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleY": {
                "docstring": "This flag specifies Y for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleZ": {
                "docstring": "This flag specifies Z for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "smoothingAngle": {
                "docstring": "This flag specifies smoothingAngle threshold used to determine whether newly created edges are hard or soft.C: Default is 30.0. The range is [0, 180].Q: When queried, this flag returns a float. Global Values"
            }, 
            "taper": {
                "docstring": ""
            }, 
            "taperCurve_FloatValue": {
                "docstring": ""
            }, 
            "taperCurve_Interp": {
                "docstring": ""
            }, 
            "taperCurve_Position": {
                "docstring": ""
            }, 
            "thickness": {
                "docstring": ""
            }, 
            "translate": {
                "docstring": "This flag specifies the translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "translateX": {
                "docstring": "This flag specifies the X translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateY": {
                "docstring": "This flag specifies the Y translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateZ": {
                "docstring": "This flag specifies the Z translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "twist": {
                "docstring": ""
            }, 
            "weight": {
                "docstring": "This flag specifies the weight, related to gravity.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is off.Q: When queried, this flag returns an int."
            }
        }
    }, 
    "polyExtrudeVertex": {
        "description": "Command that extrudes selected vertices outwards. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "divisions": {
                "docstring": "This flag specifies the number of subdivisions.C: Default is 1Q: When queried, this flag returns an int."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "length": {
                "docstring": "This flag specifies the length of the vertex extrusion.C: Default is 0Q: When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "width": {
                "docstring": "This flag specifies the width of the vertex extrusion.C: Default is 0Q: When queried, this flag returns a float."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is off.Q: When queried, this flag returns a int.Common flags"
            }
        }
    }, 
    "polyFlipEdge": {
        "description": "Command to flip the edges shared by 2 adjacent triangles. When used with the edit flag, new edges can be added to the same node, instead of creating a separate node in the chain. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyFlipUV": {
        "description": "Flip (mirror) the UVs (in texture space) of input polyFaces, about either the U or V axis.. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "createNewMap": {
                "docstring": "Create a new UV set, as opposed to editing the current one, or the one given by the uvSetName flag."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "flipType": {
                "docstring": "Flip along U or V direction. 0Horizontal1VerticalC: Default is 0.Q: When queried returns an int."
            }, 
            "insertBeforeDeformers": {
                "docstring": "This flag specifies if the polyFlipUV node should be inserted before or after deformer nodes already applied to the shape. Inserting the node after the deformer leads to texture swimming during animation and is most often undesirable.C: Default is on."
            }, 
            "local": {
                "docstring": "Flips in the local space of the input faces.C: Default is on.Q: When queried returns an int.Common flags"
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the UV set to edit uvs on. If not specified will use the current UV set if it exists.When createNewMap is on, the name is used to generate a new unique UV set name."
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "polyForceUV": {
        "description": "A set of functionalities can be called through this command. The input for this command is a set of faces. Based on the arguments passed, the UVs for these selected faces can be created.Project UVs based on the camera:(UV creation)Based on the current view direction/orientation, the UVs are generated and assigned to the faces. Any previously assigned UV information will be lost.Best Plane Projection:(UV creation)The UVs are computed based on the plane defined by the user, and is applied to the selected faces. This tool has 2 phases. In the first phase, the faces to be mapped (faces to which UVs are to be created) are selected. In the second phase, the points (vertices, CVs) that define the projecting plane are selected. Any previously assigned UV information will be lost.Unitize:(UV creation)A new set of unitized UVs are generated and assigned to the faces. Any previously assigned UV information will be lost.Unshare:(UV creation)Force the specified UV to be unshared by possibly creating new UVs. Any previously assigned UV information will be lost.", 
        "flags": {
            "cameraProjection": {
                "docstring": "Project the UVs based on the camera position/orientation"
            }, 
            "createNewMap": {
                "docstring": "Create new map if does not existsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "flipHorizontal": {
                "docstring": "OBSOLETE flag. Use polyFlipUV instead."
            }, 
            "flipVertical": {
                "docstring": "OBSOLETE flag. Use polyFlipUV instead."
            }, 
            "g": {
                "docstring": "OBSOLETE flag."
            }, 
            "local": {
                "docstring": "OBSOLETE flag."
            }, 
            "normalize": {
                "docstring": "OBSOLETE flag. Use polyNormalizeUV instead."
            }, 
            "numItems": {
                "docstring": "This flag is only used for the best plane texturingof polygonal faces. This flag should be followed by a selection list. If not specified, the selected objects will be used (in the order they were selected).This flag specifies the number of items (leading) in the selection list that should be used for the mapping. The trailing items will be used for computing the plane (See example below). The best plane texturingis better suited for using interactively from within its context. You can type \"setToolTo polyBestPlaneTexturingContext\" in the command window OR (EditPolygons-Texture-BestPlaneTexturing from the Menu) to enter its context."
            }, 
            "preserveAspectRatio": {
                "docstring": "OBSOLETE flag."
            }, 
            "unitize": {
                "docstring": "To unitize the UVs of the selected faces"
            }, 
            "unshare": {
                "docstring": "To unshare tye specified UV"
            }, 
            "uvSetName": {
                "docstring": "Specifies name of the uv set to work on"
            }
        }
    }, 
    "polyGeoSampler": {
        "description": "This command performs a render sampling of surface color and transparency for each selected vertex or face and stores the sampled data as either the color value, or uses the sampled data to displace the affected vertices or faces by a sampled data value. Transparency is not used for displacement, and displacement is performed along vertex normals. The sampled data value used can be pre-scaled by a user defined amount. Additionally, the normals chosen for sampling can be overridden using a \"flat\" shading option. This option basically means to always use the normals of the faces when computing sampling values. This may be a desired if the user wishes to override an edge smoothness factor. Basically with the \"flat\" shading option on, edges are always considered to be hard. Note that displacement sampling will result in the -sampleByFace option to be turned off, since a displacement of a vertex always affects the faces the vertex is connected to. Finally, it is possible to force the storage of shared colors per vertex, and / or force the usage of unshared UV values. The computation of the resulting color is as follows: resulting-RGB = (sampled-RGB \\* scale-factor);         if (color blend is none)                 resulting-RGB = geometry-RGB         else if (color blend is add)                 resulting-RGB = geometry-RGB + sampled-RGB;         else if (color blend is subtract)                 resulting-RGB = geometry-RGB - sampled-RGB;         else if (color blend is multiply)                 resulting-RGB = geometry-RGB \\* sampled-RGB;         else if (color blend is divide)                 resulting-RGB = geometry-RGB / sampled-RGB;         else if (color blend is average)                 resulting-RGB = (geometry-RGB \\* 1/2) + (sampled-RGB \\* 1/2);         if (clamp option set)                 clamp resulting-RGB between minimum-RGB and maximum-RGB, The analogous computation is done for computing the resulting alpha value. The command requires that there be a camera selected in your scene in order to work properly in -batch or -prompt mode. ", 
        "flags": {
            "alphaBlend": {
                "docstring": "When specified, indicates the type of alpha blend to be applied. Options are: \"none\", \"overwrite\", \"add\", \"subtract\", \"multiply\", \"divide\", \"average\". This option only applies when colors are being set. The default if this argument is not specified is \"overwrite\". The \"none\" options to not overwrite the existing value."
            }, 
            "averageColor": {
                "docstring": "When used, will mean to force the storage of shared colors for vertex level sampling. By default vertex level sampling stores unshared colors."
            }, 
            "clampAlphaMax": {
                "docstring": "When used, will mean to clamp the storage of alpha to a maximum"
            }, 
            "clampAlphaMin": {
                "docstring": "When used, will mean to clamp the storage of alpha to a minimum"
            }, 
            "clampRGBMax": {
                "docstring": "When used, will mean to clamp the storage of RGB color to a maximum"
            }, 
            "clampRGBMin": {
                "docstring": "When used, will mean to clamp the storage of RGB color to a minimum"
            }, 
            "colorBlend": {
                "docstring": "When specified, indicates the type of color blend to be applied. Options are: \"none\", \"overwrite\", \"add\", \"subtract\", \"multiply\", \"divide\", \"average\". This option only applies when colors are being set. The default if this argument is not specified is \"overwrite\". The \"none\" options to not overwrite the existing value."
            }, 
            "colorDisplayOption": {
                "docstring": "Change the display options on the mesh to display the vertex colors.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "computeShadows": {
                "docstring": "When used, shadow maps will be computed, saved, and reused during the sampling process."
            }, 
            "displaceGeometry": {
                "docstring": "When used, geometry will be displaced along the normals at the sampling positions, as opposed to storing color values. The default is to store colors."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "flatShading": {
                "docstring": "When used, flat shaded sampling will be computed. The default is smooth shading."
            }, 
            "ignoreDoubleSided": {
                "docstring": "When specified, the double sided flag will be ignored for prelighting."
            }, 
            "lightingOnly": {
                "docstring": "When used, incoming illumination will be computed as opposed to surface color an tranparency"
            }, 
            "reuseShadows": {
                "docstring": "When used, if shadow maps were previosly computed and saved, then they will be reused during the sampling process. The computeShadows option must be enabled for this option to apply."
            }, 
            "sampleByFace": {
                "docstring": "When used, sample will occur at a per face level versus a per vertex level, which is the default behaviour"
            }, 
            "scaleFactor": {
                "docstring": "When used, will scale the sampled value by the specified amount. The default scale factor is 1.0. Negative values are acceptable for displacement, but not for color values."
            }, 
            "shareUV": {
                "docstring": "When used, UVs are shared at a vertex when sampled. By default UVs are forced to be unshared."
            }, 
            "useLightShadows": {
                "docstring": "When used, will use each lights shadow map options. Otherwise these options will be overrridden when the computeShadows, and/or reusedShadows option is enabled."
            }
        }
    }, 
    "polyHelix": {
        "description": "The polyHelix command creates a new polygonal helix. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the helix.Q: When queried, this flag returns a float[3]."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "coils": {
                "docstring": "This flag specifies the number of coils in helix.C: Default is 1.0Q: When queried, this flag returns a float."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a specific UV mechanism to be selected, while creating the helix.The valid values are 0, 1, 2 or 3.0 implies that no UVs will be generated (No texture to be applied).1 implies UVs should be created for the object as a whole without any normalization.The helix will be unwrapped and then the texture will be appliedwithout any distortion.In the unwrapped helix, the shared edges will have shared UVs.2 implies the UVs should be normalized. This will normalize theU and V direction separately, thereby resulting in distortion of textures.4 implies UVs are created so that the texture will not be distorted when applied.The texture lying outside the UV range will be truncated (since that cannot besqueezed in, without distorting the texture.For better understanding of these options, you may have to open thetexture view windowC: Default is 3"
            }, 
            "direction": {
                "docstring": "This flag alows a direction of coil to be selected, while creating the helix.The valid values are 0 or 1.0 implies clockwise direction.1 implies CounterClockwise direction.C: Default is 1"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "height": {
                "docstring": "This flag specifies the height of the helix.C: Default is 2.0.Q: When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "This flag specifies the radius of helix tube.C: Default is 1.0.Q: When queried, this flag returns an float."
            }, 
            "roundCap": {
                "docstring": ""
            }, 
            "subdivisionsAxis": {
                "docstring": "This specifies the number of subdivisions around the axis of the helix.C: Default is 8.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsCaps": {
                "docstring": "This flag specifies the number of subdivisions along the thickness of the coil.C: Default is 0.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsCoil": {
                "docstring": "This flag specifies the number of subdivisions along the coil of the helix.C: Default is 50.Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.Common flags"
            }, 
            "useOldInitBehaviour": {
                "docstring": ""
            }, 
            "width": {
                "docstring": "This specifies the width of the helix.C: Default is 1.0.Q: When queried, this flag returns an float."
            }
        }
    }, 
    "polyHole": {
        "description": "Command to set and clear holes on given faces. ", 
        "flags": {
            "assignHole": {
                "docstring": "Assign the selected faces to be hole or unassign the hole faces to be non-hole. By default, the command will assign faces to be hole.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createHistory": {
                "docstring": "For objects that have no construction history, this flag can be used to force the creation of construction history for hole. By default, history is not created if the object has no history. Regardless of this flag, history is always created if the object already has history."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyInfo": {
        "description": "Command query's topological information on polygonal objects and components. So, the command will require the following to be specified: - selection list to query ", 
        "flags": {
            "edgeToFace": {
                "docstring": "Returns the faces that share the specified edge. Requires edges to be selected."
            }, 
            "edgeToVertex": {
                "docstring": "Returns the vertices defining an edge. Requires edges to be selected."
            }, 
            "faceNormals": {
                "docstring": "Returns face normals of the specified object. If faces are selected the command returns the face normals of selected faces. Else it returns the face normals of all the faces of the object.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "faceToEdge": {
                "docstring": "Returns the edges defining a face. Requires faces to be selected."
            }, 
            "faceToVertex": {
                "docstring": "Returns the vertices defining a face. Requires faces to be selected."
            }, 
            "laminaFaces": {
                "docstring": "Find all lamina faces in the specified objects."
            }, 
            "nonManifoldEdges": {
                "docstring": "Find all non-manifold edges in the specified objects."
            }, 
            "nonManifoldVertices": {
                "docstring": "Find all non-manifold vertices in the specified objects."
            }, 
            "vertexToEdge": {
                "docstring": "Returns the Edges connected to a vertex. Requires vertices to be selected."
            }, 
            "vertexToFace": {
                "docstring": "Returns the faces that share the specified vertex. Requires vertices to be selected."
            }
        }
    }, 
    "polyInstallAction": {
        "description": "Installs/uninstalls several things to help the user to perform the specified action : PickmaskInternal selection constraintsDisplay attributes", 
        "flags": {
            "commandName": {
                "docstring": "return as a string the name of the command previously installed"
            }, 
            "convertSelection": {
                "docstring": "convert all polys selected in object mode into their full matching component selection. For example : if a polyMesh is selected,polyInstallAction -cs polyCloseBorderwill select all border edges."
            }, 
            "installConstraint": {
                "docstring": "C: install selection pickmask and internal constraints for actionnameQ: returns 1 if any internal constraint is set for current action"
            }, 
            "installDisplay": {
                "docstring": "C: install display attributes for actionnameQ: returns 1 if any display is set for current action"
            }, 
            "keepInstances": {
                "docstring": "Convert components for all selected instances rather than only the first selected instance.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "uninstallConstraint": {
                "docstring": "uninstall internal constraints previously installed"
            }, 
            "uninstallDisplay": {
                "docstring": "uninstall display attributes previously installed"
            }
        }
    }, 
    "polyIterOnPoly": {
        "description": "", 
        "flags": {}
    }, 
    "polyLayoutUV": {
        "description": "Move UVs in the texture plane to avoid overlaps. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "flipReversed": {
                "docstring": "If this flag is turned on, the reversed UV pieces are fliped."
            }, 
            "layout": {
                "docstring": "How to move the UV pieces, after cuts are applied:0 No move is applied.1 Layout the pieces along the U axis.2 Layout the pieces in a square shape."
            }, 
            "layoutMethod": {
                "docstring": "Which layout method to use:0 Block Stacking.1 Shape Stacking."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "percentageSpace": {
                "docstring": "When layout is set to square, this value is a percentage of the texture area which is added around each UV piece. It can be used to ensure each UV piece uses different pixels in the texture.Maximum value is 5 percent."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rotateForBestFit": {
                "docstring": "0 No rotation is applied. 1 Only allow 90 degree rotations. 2 Allow free rotations."
            }, 
            "scale": {
                "docstring": "How to scale the pieces, after move and cuts:0 No scale is applied.1 Uniform scale to fit in unit square.2 Non proportional scale to fit in unit square."
            }, 
            "separate": {
                "docstring": "Which UV edges should be cut:0 No cuts.1 Cut only along folds.2 Make all necessary cuts to avoid all intersections."
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists."
            }, 
            "worldSpace": {
                "docstring": "If true, performs the operation in world space coordinates as opposed to local space.Common flags"
            }
        }
    }, 
    "polyListComponentConversion": {
        "description": "This command converts poly components from one or more types to another one or more types, and returns the list of the conversion. It doesn't change anything of the current database. ", 
        "flags": {
            "border": {
                "docstring": "Indicates that the converted components must be on the border of the selection. If it is not provided, the converted components will be the related ones."
            }, 
            "fromEdge": {
                "docstring": ""
            }, 
            "fromFace": {
                "docstring": ""
            }, 
            "fromUV": {
                "docstring": ""
            }, 
            "fromVertex": {
                "docstring": ""
            }, 
            "fromVertexFace": {
                "docstring": "Indicates the component type to convert from. If none of them is provided, it is assumed to be all of them, including poly objects."
            }, 
            "internal": {
                "docstring": "Indicates that the converted components must be totally envolved by the source components. E.g. a converted face must have all of its surrounding vertices being given. If it is not provided, the converted components will be the related ones."
            }, 
            "toEdge": {
                "docstring": ""
            }, 
            "toFace": {
                "docstring": ""
            }, 
            "toUV": {
                "docstring": ""
            }, 
            "toVertex": {
                "docstring": ""
            }, 
            "toVertexFace": {
                "docstring": "Indicates the component type to convert to. If none of them is provided, it is assumed to the object."
            }, 
            "vertexFaceAllEdges": {
                "docstring": "When converting from face vertices to edges, indicates that all edges with an end at the face vertex should be included. Without this flag, the default behaviour is to only include one edge per face vertex.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "polyMapCut": {
        "description": "Cut along edges of the texture mapping. The cut edges become map borders. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyMapDel": {
        "description": "Deletes texture coordinates (UVs) from selected faces. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyMapSew": {
        "description": "Sew border edges in texture space. Selected edges must be map borders. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyMapSewMove": {
        "description": "This command can be used to Move and Sew together separate UV pieces along geometric edges. UV pieces that correspond to the same geometric edge, are merged together by moving the smaller piece to the larger one.", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "limitPieceSize": {
                "docstring": "When on, this flag tells that the face number limit described above should be used."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "numberFaces": {
                "docstring": "Maximum number of faces in a UV piece. When trying to combine two UV pieces into a single one, the merge operation is rejected if the smaller piece has more faces than the number specified by this flag.This flag is only used when limitPieceSizeis set to on."
            }, 
            "query": {
                "docstring": ""
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.Common flags"
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "polyMergeEdge": {
        "description": "Sews two border edges together.The new edge is located either on the first, last, or between both selected edges, depending on the mode. Both edges must belong to the same object, and orientations must match (i.e. normals on corresponding faces must point in the same direction).Edge flags are mandatory. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "firstEdge": {
                "docstring": "The number of the first edge to merge."
            }, 
            "mergeMode": {
                "docstring": "This flag specifies how to merge, merge mode : at first edge : 0, in between : 1, at last edge : 2.C: Default is in between."
            }, 
            "mergeTexture": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "secondEdge": {
                "docstring": "The number of the second edge to merge.Common flags"
            }
        }
    }, 
    "polyMergeEdgeCtx": {
        "description": "Create a new context to merge edges on polygonal objects In query mode, return type is based on queried flag.", 
        "flags": {
            "activeNodes": {
                "docstring": "Return the active nodes in the tool"
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "firstEdge": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "immediate": {
                "docstring": "Acts on the object not the tool defaults"
            }, 
            "mergeMode": {
                "docstring": "The merge mode. (at first edge : 0, in between : 1, at last edge : 2)Default is in between.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "mergeTexture": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "previous": {
                "docstring": "Reset to previously stored values"
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": "Reset to default values"
            }, 
            "secondEdge": {
                "docstring": ""
            }, 
            "toolNode": {
                "docstring": "Return the node used for tool defaults"
            }
        }
    }, 
    "polyMergeFacet": {
        "description": "The second face becomes a hole in the first face.The new holed face is located either on the first, last, or between both selected faces, depending on the mode. Both faces must belong to the same object.Facet flags are mandatory. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "firstFacet": {
                "docstring": "The number of the first (outer) face to merge."
            }, 
            "mergeMode": {
                "docstring": "This flag specifies how faces are merged: 0: moves second face to first one 1: moves both faces to average 2: moves first face to second one 3, 4, 5: same as above, except faces are projected but not centred 6: Nothing moves.C: Default is None (6)."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "secondFacet": {
                "docstring": "The number of the second (hole) face to merge.Common flags"
            }
        }
    }, 
    "polyMergeFacetCtx": {
        "description": "Create a new context to merge facets on polygonal objects In query mode, return type is based on queried flag.", 
        "flags": {
            "activeNodes": {
                "docstring": "Return the active nodes in the tool"
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "firstFacet": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "immediate": {
                "docstring": "Acts on the object not the tool defaults"
            }, 
            "mergeMode": {
                "docstring": "The merge mode. (at first facet : 0, in between : 1, at last facet : 2)Default is in between.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "previous": {
                "docstring": "Reset to previously stored values"
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": "Reset to default values"
            }, 
            "secondFacet": {
                "docstring": ""
            }, 
            "toolNode": {
                "docstring": "Return the node used for tool defaults"
            }
        }
    }, 
    "polyMergeUV": {
        "description": "Merge UVs of an object based on their distance. UVs are merge only if they belong to the same 3D vertex. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "distance": {
                "docstring": "This flag specifies the maximum distance to merge UVs.C: Default is 0.0.Q: When queried, this flag returns a double."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.Common flags"
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "polyMergeVertex": {
        "description": "Merge vertices within a given threshold.Since this allows merging any vertices that lie on the same object it is possible for the resulting geometry to be non-manifold.First, perform comparison of pairs of selected vertices. Pairs that lie within given distance of one another are merged, along with the edge between them.Second, any selected vertices which share an edge are merged if the distance between them is within the specified distance.Unlike Merge Edges, Merge Vertices will perform the merge even if the edges adjoining the vertices do not have matching orientation (i.e. normals of adjacent faces do not point in the same direction). As this restriction is not enforced while merging vertices, resulting geometry can be non-manifold.If alwaysMergeTwoVertices is set and there are only two vertices, tolerance is ignored and the vertices will be merged.Resulting mesh may have extra vertices or edges to ensure geometry is valid. ", 
        "flags": {
            "alwaysMergeTwoVertices": {
                "docstring": "This flag specifies whether to always merge if only two vertices are selected regardless of distance.C: Default is false.Q: When queried, this flag returns a boolean."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "distance": {
                "docstring": "This flag specifies the distance within which vertices will be merged.C: Default is 0.0 (i.e. vertices are coincident).Q: When queried, this flag returns a double."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "mergeToComponents": {
                "docstring": "Optionally defines the position to merge all of the vertices to. If set, the distance flag will be ignored, and instead the center point of the set components will be calculated and all vertices will be merged to that location.C: Default is empty string.Q: When queried, this flag returns a string.Common flags"
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "texture": {
                "docstring": "This flag specifies whether the texture is sewn in addition to the 3d edgeC: Default is true.Q: When queried, this flag returns a boolean."
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "polyMirrorFace": {
        "description": "Mirror all the faces of the selected object. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "direction": {
                "docstring": "This flag specifies the mirror direction.C: Default is 0"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "mergeMode": {
                "docstring": "This flag specifies the behaviour of the mirror with respect to the border edges. Valid values are 0-5, corresponding to +X, -X, +Y, -Y, +Z, -Z direction respectively.If the mode is 0, the border edges will not be merged (co-incident vertices will be present).If the mode is 1, the border vertices/edges will be mergedIf the mode is 2, the border edges will be extruded and connected.C: Default is 0"
            }, 
            "mergeThreshold": {
                "docstring": "This flag specifies the tolerance value for merging borders.C: Default is 0.1Common flags"
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pivot": {
                "docstring": "This flag specifies the pivot for the mirror.C: Default is computed using the bounding box of the object"
            }, 
            "pivotX": {
                "docstring": "This flag specifies the X pivot for the mirror.C: Default is computed using the bounding box of the object"
            }, 
            "pivotY": {
                "docstring": "This flag specifies the Y pivot for the mirror.C: Default is computed using the bounding box of the object"
            }, 
            "pivotZ": {
                "docstring": "This flag specifies the Z pivot for the mirror.C: Default is computed using the bounding box of the object"
            }, 
            "query": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is off.Q: When queried, this flag returns an int."
            }
        }
    }, 
    "polyMoveEdge": {
        "description": "Modifies edges of a polygonal object. Translate, move, rotate or scale edges. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "gain": {
                "docstring": ""
            }, 
            "localCenter": {
                "docstring": "This flag specifies the local center on the edge : 0 - Middle point, 1 - Start point, 2 - End point.C: Default is 0 (Middle point).Common flags"
            }, 
            "localDirection": {
                "docstring": "This flag specifies the X axis for local space.C: Default is 0.0 0.0 1.0."
            }, 
            "localDirectionX": {
                "docstring": "This flag specifies X coord of the X axis.C: Default is 0.0."
            }, 
            "localDirectionY": {
                "docstring": "This flag specifies Y coord of the X axis.C: Default is 0.0."
            }, 
            "localDirectionZ": {
                "docstring": "This flag specifies Z coord of the X axis.C: Default is 1.0."
            }, 
            "localRotate": {
                "docstring": "This flag specifies the local rotations : (twistRot, slantRot, slantRoll).C: Default is 0.0 0.0 0.0. Local rotation (twistRot, slantRot, slantRoll)."
            }, 
            "localRotateX": {
                "docstring": "This flag specifies local rotation X angle (Twist around normal)C: Default is 0.0. The range is [0, 360]."
            }, 
            "localRotateY": {
                "docstring": "This flag specifies local rotation Y angle (Slant Rot around slantAxis).C: Default is 0.0. The range is [0, 360]."
            }, 
            "localRotateZ": {
                "docstring": "This flag specifies local rotation Z angle (Slant Roll of slantAxis).C: Default is 0.0. The range is [0, 180]."
            }, 
            "localScale": {
                "docstring": "This flag specifies the local scaling vector.C: Default is 1.0 1.0 1.0."
            }, 
            "localScaleX": {
                "docstring": "This flag specifies X for local scaling vector.C: Default is 1.0."
            }, 
            "localScaleY": {
                "docstring": "This flag specifies Y for local scaling vector.C: Default is 1.0."
            }, 
            "localScaleZ": {
                "docstring": "This flag specifies Z for local scaling vector.C: Default is 1.0."
            }, 
            "localTranslate": {
                "docstring": "This flag specifies the local translation vector.C: Default is 0.0 0.0 0.0."
            }, 
            "localTranslateX": {
                "docstring": "This flag specifies the local X translation.C: Default is 0.0."
            }, 
            "localTranslateY": {
                "docstring": "This flag specifies the local Y translation.C: Default is 0.0."
            }, 
            "localTranslateZ": {
                "docstring": "This flag specifies the local Z translation.C: Default is 0.0."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pivot": {
                "docstring": "This flag specifies the pivot for scaling and rotation.C: Default is 0.0 0.0 0.0."
            }, 
            "pivotX": {
                "docstring": "This flag specifies the X pivot for scaling and rotation.C: Default is 0.0."
            }, 
            "pivotY": {
                "docstring": "This flag specifies the Y pivot for scaling and rotation.C: Default is 0.0."
            }, 
            "pivotZ": {
                "docstring": "This flag specifies the Z pivot for scaling and rotation.C: Default is 0.0."
            }, 
            "query": {
                "docstring": ""
            }, 
            "random": {
                "docstring": "This flag specifies the random value for all parameters.C: Default is 0.0. The range is [-10.0, 10.0]. Local Values"
            }, 
            "rotate": {
                "docstring": "This flag specifies the rotation angles around X, Y, Z.C: Default is 0.0 0.0 0.0."
            }, 
            "rotateX": {
                "docstring": "This flag specifies the rotation angle around X.C: Default is 0.0."
            }, 
            "rotateY": {
                "docstring": "This flag specifies the rotation angle around Y.C: Default is 0.0."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies the rotation angle around Z.C: Default is 0.0."
            }, 
            "scale": {
                "docstring": "This flag specifies the scaling vector.C: Default is 1.0 1.0 1.0."
            }, 
            "scaleX": {
                "docstring": "This flag specifies X for scaling vector.C: Default is 1.0."
            }, 
            "scaleY": {
                "docstring": "This flag specifies Y for scaling vector.C: Default is 1.0."
            }, 
            "scaleZ": {
                "docstring": "This flag specifies Z for scaling vector.C: Default is 1.0."
            }, 
            "translate": {
                "docstring": "This flag specifies the translation vector.C: Default is 0.0 0.0 0.0."
            }, 
            "translateX": {
                "docstring": "This flag specifies the X translation vector.C: Default is 0.0."
            }, 
            "translateY": {
                "docstring": "This flag specifies the Y translation vector.C: Default is 0.0."
            }, 
            "translateZ": {
                "docstring": "This flag specifies the Z translation vector.C: Default is 0.0."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If on : all geometrical values are taken in world reference. If off : all geometrical values are taken in object reference.C: Default is off.Global Values"
            }
        }
    }, 
    "polyMoveFacet": {
        "description": "Modifies facet of a polygonal object. Translate, move, rotate or scale facets. ", 
        "flags": {
            "attraction": {
                "docstring": "This flag specifies the attraction, related to magnet.C: Default is 0.0. The range is [-2.0, 2.0].Q: When queried, this flag returns a float."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "gain": {
                "docstring": ""
            }, 
            "gravity": {
                "docstring": "This flag specifies the gravity vector.C: Default is 0.0 -1.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "gravityX": {
                "docstring": "This flag specifies X for the gravity vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "gravityY": {
                "docstring": "This flag specifies Y for the gravity vector.C: Default is -1.0.Q: When queried, this flag returns a float."
            }, 
            "gravityZ": {
                "docstring": "This flag specifies Z for the gravity vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localCenter": {
                "docstring": ""
            }, 
            "localDirection": {
                "docstring": "This flag specifies the X axis for local space.C: Default is 0.0 0.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localDirectionX": {
                "docstring": "This flag specifies X coord of the X axis.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localDirectionY": {
                "docstring": "This flag specifies Y coord of the X axis.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localDirectionZ": {
                "docstring": "This flag specifies Z coord of the X axis.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localRotate": {
                "docstring": "This flag specifies the local rotations : (slantRot, slantRoll, twistRot).C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]. Local rotation (slantRot, slantRoll, twistRot)."
            }, 
            "localRotateX": {
                "docstring": "This flag specifies local rotation X angle (Slant Rot around slantAxis).C: Default is 0.0. The range is [0, 360].Q: When queried, this flag returns a float."
            }, 
            "localRotateY": {
                "docstring": "This flag specifies local rotation Y angle (Slant Roll of slantAxis).C: Default is 0.0. The range is [0, 180].Q: When queried, this flag returns a float."
            }, 
            "localRotateZ": {
                "docstring": "This flag specifies local rotation Z angle (Twist around normal).C: Default is 0.0. The range is [0, 360].Q: When queried, this flag returns a float."
            }, 
            "localScale": {
                "docstring": "This flag specifies the local scaling vector.C: Default is 1.0 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localScaleX": {
                "docstring": "This flag specifies X for local scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localScaleY": {
                "docstring": "This flag specifies Y for local scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localScaleZ": {
                "docstring": "This flag specifies Z for local scaling vector : Flattening.C: Default is 1.0. The range is [0.0, 1.0].Q: When queried, this flag returns a float.Dynamic Values"
            }, 
            "localTranslate": {
                "docstring": "This flag specifies the local translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localTranslateX": {
                "docstring": "This flag specifies the X local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslateY": {
                "docstring": "This flag specifies the Y local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslateZ": {
                "docstring": "This flag specifies the Z local translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "magnX": {
                "docstring": "This flag specifies X for the magnet vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "magnY": {
                "docstring": "This flag specifies Y for the magnet vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "magnZ": {
                "docstring": "This flag specifies Z for the magnet vector.C: Default is 0.0.Q: When queried, this flag returns a float.Common flags"
            }, 
            "magnet": {
                "docstring": "This flag specifies the magnet vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "offset": {
                "docstring": "This flag specifies the local offset.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivot": {
                "docstring": "This flag specifies the pivot for scaling and rotation.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "pivotX": {
                "docstring": "This flag specifies the X pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotY": {
                "docstring": "This flag specifies the Y pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotZ": {
                "docstring": "This flag specifies the Z pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float.Local Values"
            }, 
            "query": {
                "docstring": ""
            }, 
            "random": {
                "docstring": "This flag specifies the random value for all parameters.C: Default is 0.0. The range is [-10.0, 10.0].Q: When queried, this flag returns a float.Global Values"
            }, 
            "rotate": {
                "docstring": "This flag specifies the rotation angles around X, Y, Z.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateX": {
                "docstring": "This flag specifies the rotation angle around X.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateY": {
                "docstring": "This flag specifies the rotation angle around Y.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies the rotation angle around Z.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "scale": {
                "docstring": "This flag specifies the scaling vector.C: Default is 1.0 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "scaleX": {
                "docstring": "This flag specifies X for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleY": {
                "docstring": "This flag specifies Y for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleZ": {
                "docstring": "This flag specifies Z for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "translate": {
                "docstring": "This flag specifies the translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "translateX": {
                "docstring": "This flag specifies the X translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateY": {
                "docstring": "This flag specifies the Y translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateZ": {
                "docstring": "This flag specifies the Z translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "weight": {
                "docstring": "This flag specifies the weight, related to gravity.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If on : all geometrical values are taken in world reference. If off : all geometrical values are taken in object reference.C: Default is off.Q: When queried, this flag returns an int."
            }
        }
    }, 
    "polyMoveFacetUV": {
        "description": "Modifies the map by moving all UV values associated with the selected face(s). The UV coordinates of the model are manipulated without changing the vertices of the 3D object. ", 
        "flags": {
            "axisLen": {
                "docstring": "Axis Length vector, used to draw the manip handles.C: Default is 1.0, 1.0Q: When queried, this flag returns a float[2]."
            }, 
            "axisLenX": {
                "docstring": "Axis Length in X, used to draw the manip handles.C: Default is 1.0Q: When queried, this flag returns a float."
            }, 
            "axisLenY": {
                "docstring": "Axis Length in Y, used to draw the manip handles.C: Default is 1.0Q: When queried, this flag returns a float."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pivot": {
                "docstring": "This flag specifies the pivot for scaling and rotation.C: Default is 0.0 0.0.Q: When queried, this flag returns a float[2]."
            }, 
            "pivotU": {
                "docstring": "This flag specifies U for the pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotV": {
                "docstring": "This flag specifies V for the pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "query": {
                "docstring": ""
            }, 
            "random": {
                "docstring": "This flag specifies the random value for all parameters.C: Default is 0.0. The range is [-10.0, 10.0].Q: When queried, this flag returns a float."
            }, 
            "rotationAngle": {
                "docstring": "Angle of rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "scale": {
                "docstring": "This flag specifies the scaling vector.C: Default is 1.0 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleU": {
                "docstring": "This flag specifies U for the scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleV": {
                "docstring": "This flag specifies V for the scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "translate": {
                "docstring": "This flag specifies the translation vector.C: Default is 0.0 0.0.Q: When queried, this flag returns a float[2]."
            }, 
            "translateU": {
                "docstring": "This flag specifies the U translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateV": {
                "docstring": "This flag specifies the V translation vector.C: Default is 0.0.Q: When queried, this flag returns a float.Common flags"
            }
        }
    }, 
    "polyMoveUV": {
        "description": "Moves selected UV coordinates in 2D space. As the selected UVs are adjusted, the way the image is mapped onto the object changes accordingly. This command manipulates the UV values without changing the 3D geometry of the object. ", 
        "flags": {
            "axisLen": {
                "docstring": ""
            }, 
            "axisLenX": {
                "docstring": ""
            }, 
            "axisLenY": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pivot": {
                "docstring": "This flag specifies the pivot for scaling and rotation.C: Default is 0.0 0.0.Q: When queried, this flag returns a float[2]."
            }, 
            "pivotU": {
                "docstring": "This flag specifies U for the pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotV": {
                "docstring": "This flag specifies V for the pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "query": {
                "docstring": ""
            }, 
            "random": {
                "docstring": "This flag specifies the random value for all parameters.C: Default is 0.0. The range is [-10.0, 10.0].Q: When queried, this flag returns a float. Common flagsCommon flags"
            }, 
            "rotationAngle": {
                "docstring": "Angle of rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "scale": {
                "docstring": "This flag specifies the scaling vector.C: Default is 1.0 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleU": {
                "docstring": "This flag specifies U for the scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleV": {
                "docstring": "This flag specifies V for the scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "translate": {
                "docstring": "This flag specifies the translation vector.C: Default is 0.0 0.0.Q: When queried, this flag returns a float[2]."
            }, 
            "translateU": {
                "docstring": "This flag specifies the U translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateV": {
                "docstring": "This flag specifies the V translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }
        }
    }, 
    "polyMoveVertex": {
        "description": "Modifies vertices of a polygonal object. Translate, rotate or scale vertices in local or world space. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "gain": {
                "docstring": ""
            }, 
            "localDirection": {
                "docstring": "This flag specifies the X axis for local space.C: Default is 0.0 0.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localDirectionX": {
                "docstring": "This flag specifies X coord for thr X axis.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localDirectionY": {
                "docstring": "This flag specifies Y coord for thr X axis.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localDirectionZ": {
                "docstring": "This flag specifies Z coord for thr X axis.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslate": {
                "docstring": "Local translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "localTranslateX": {
                "docstring": "Local translation X coord.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslateY": {
                "docstring": "Local translation Y coord.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "localTranslateZ": {
                "docstring": "Local translation Z coord : Move along the vertex normal.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pivot": {
                "docstring": "This flag specifies the pivot for scaling and rotation.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "pivotX": {
                "docstring": "This flag specifies the X pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotY": {
                "docstring": "This flag specifies the Y pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "pivotZ": {
                "docstring": "This flag specifies the Z pivot for scaling and rotation.C: Default is 0.0.Q: When queried, this flag returns a float. Local Values"
            }, 
            "query": {
                "docstring": ""
            }, 
            "random": {
                "docstring": "This flag specifies the random value for all parameters.C: Default is 0.0. The range is [-10.0, 10.0].Q: When queried, this flag returns a float.Common flags"
            }, 
            "rotate": {
                "docstring": "This flag specifies the rotation angles around X, Y, Z.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateX": {
                "docstring": "This flag specifies the rotation angle around X.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateY": {
                "docstring": "This flag specifies the rotation angle around Y.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies the rotation angle around Z.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "scale": {
                "docstring": "This flag specifies the scaling vector.C: Default is 1.0 1.0 1.0.Q: When queried, this flag returns a float[3]."
            }, 
            "scaleX": {
                "docstring": "This flag specifies X for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleY": {
                "docstring": "This flag specifies Y for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "scaleZ": {
                "docstring": "This flag specifies Z for scaling vector.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "translate": {
                "docstring": "This flag specifies the translation vector.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "translateX": {
                "docstring": "This flag specifies the X translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateY": {
                "docstring": "This flag specifies the Y translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "translateZ": {
                "docstring": "This flag specifies the Z translation vector.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is \"off\".Q: When queried, this flag returns an int. Global Values"
            }
        }
    }, 
    "polyMultiLayoutUV": {
        "description": "place the UVs of the selected polygonal objects so that they do not overlap. ", 
        "flags": {
            "flipReversed": {
                "docstring": "If this flag is turned on, the reversed UV pieces are fliped."
            }, 
            "layout": {
                "docstring": "How to move the UV pieces, after cuts are applied:0 No move is applied.1 Layout the pieces along the U axis.2 Layout the pieces in a square shape."
            }, 
            "layoutMethod": {
                "docstring": "// -lm/layoutMethod layoutMethod integer// (C, E, Q) Which layout method to use: //0 Block Stacking. //1 Shape Stacking."
            }, 
            "offsetU": {
                "docstring": "Offset the layout in the U direction by the given value."
            }, 
            "offsetV": {
                "docstring": "Offset the layout in the V direction by the given value."
            }, 
            "percentageSpace": {
                "docstring": "When layout is set to square, this value is a percentage of the texture area which is added around each UV piece. It can be used to ensure each UV piece uses different pixels in the texture.Maximum value is 5 percent."
            }, 
            "prescale": {
                "docstring": "Prescale the shell before laying it out.0 No scale is applied.1 Object space scaling applied.2 World space scaling applied."
            }, 
            "rotateForBestFit": {
                "docstring": "How to rotate the pieces, before move:0 No rotation is applied.1 Only allow 90 degree rotations.2 Allow free rotations."
            }, 
            "scale": {
                "docstring": "How to scale the pieces, after move:0 No scale is applied.1 Uniform scale to fit in unit square.2 Non proportional scale to fit in unit square."
            }, 
            "sizeU": {
                "docstring": "Scale the layout in the U direction by the given value."
            }, 
            "sizeV": {
                "docstring": "Scale the layout in the V direction by the given value."
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "polyNormal": {
        "description": "Control the normals of an object. This command works on faces or polygonal objects. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "normalMode": {
                "docstring": "This flag specifies the normal mode.0: reverse; (This flag is being phased out and is included for backwards compatibility only.)1: propagate; (This flag is being phased out and is included for backwards compatibility only.)2: conform; (This flag is being phased out and is included for backwards compatibility only.)3: reverse and cut; Reverse the normal(s) on the selected face(s). Selected faces are cut along their collective border and a new shell is created. The normals in the new shell are reversed from what they were before the action.4: reverse and propagate; Reverse the normal(s) on the selected face(s) and propagate this direction to all other faces in the shell.C: Default is 0 (reverse mode).Q: When queried, this flag returns an int.Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "userNormalMode": {
                "docstring": ""
            }
        }
    }, 
    "polyNormalPerVertex": {
        "description": "Command associates normal(x, y, z) with vertices on polygonal objects. When used with the query flag, it returns the normal associated with the specified components. However, when queried, the command returns all normals (all vtx-face combinations) on the vertex, regardless of whether they ar shared or not. ", 
        "flags": {
            "allLocked": {
                "docstring": "Queries if all normals on the selected vertices are locked (frozen) or not"
            }, 
            "deformable": {
                "docstring": "DEFAULT true OBSOLETE flag. This flag will be removed in the next release.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "freezeNormal": {
                "docstring": "Specifies that the normal values be frozen (locked) at the current value."
            }, 
            "normalX": {
                "docstring": "Specifies the x value normal"
            }, 
            "normalXYZ": {
                "docstring": "Specifies the xyz values normal"
            }, 
            "normalY": {
                "docstring": "Specifies the y value normal"
            }, 
            "normalZ": {
                "docstring": "Specifies the z value normal"
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "When used, the normal values specified are added relative to the current value."
            }, 
            "unFreezeNormal": {
                "docstring": "Specifies that the normal values that were frozen at the current value be un-frozen (un-locked)."
            }
        }
    }, 
    "polyNormalizeUV": {
        "description": "Normalizes the UVs of input polyFaces. The existing UVs of the faces are normalized between 0 and 1. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "createNewMap": {
                "docstring": "Create a new UV set, as opposed to editing the current one, or the one given by the uvSetName flag."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "insertBeforeDeformers": {
                "docstring": "This flag specifies if the polyNormalizeUV node should be inserted before or after deformer nodes already applied to the shape. Inserting the node after the deformer leads to texture swimming during animation and is most often undesirable.C: Default is on."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "normalizeType": {
                "docstring": "Options for normalize. 0Separate1CollectiveC: Default is 1.Q: When queried returns an int."
            }, 
            "preserveAspectRatio": {
                "docstring": "Scale uniform along u and v.C: Default is on.Q: When queried returns an int.Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the UV set to edit uvs on. If not specified will use the current UV set if it exists.When createNewMap is on, the name is used to generate a new unique UV set name."
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "polyOptUvs": {
        "description": "Optimizes selected UVs. ", 
        "flags": {
            "applyToShell": {
                "docstring": "Specifies where the whole object or just shells that are selected or pinned should be affected."
            }, 
            "areaWeight": {
                "docstring": "Surface driven importance. 0 treat all faces equal. 1 gives more importance to large ones."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "globalBlend": {
                "docstring": "This allows the user to blend between a local optimization method (globalBlend = 0.0) and a global optimization method (globalBlend = 1.0). The local optimization method looks at the ratio between the triangles on the object and the triangles in UV space. It has a side affect that it can sometimes introduce tapering problems. The global optimization is much slower, but takes into consideration the entire object when optimizing uv placement."
            }, 
            "globalMethodBlend": {
                "docstring": "The global optimization method uses two functions to compute a minimization. The first function controls edge stretch by using edges lengths between xyz and uv. The second function penalizes the first function by preventing configurations where triangles would overlap. For every surface there is a mix between these two functions that will give the appropriate response. Values closer to 1.0 give more weight to the edge length function. Values closer to 0.0 give more weight to surface area. The default value of '0.5' is a even mix between these two values."
            }, 
            "iterations": {
                "docstring": "Maximum number of iterations for each connected UV piece."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "optimizeAxis": {
                "docstring": "Degree of freedom for optimization: 0=Optimize freely, 1=Move vertically only, 2=Move horzontally only"
            }, 
            "pinSelected": {
                "docstring": "Specifies that the selected components should be pinned instead the unselected components."
            }, 
            "pinUvBorder": {
                "docstring": "Specifies that the UV border should be pinned when doing the solve. By default only unselected components are pinned."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scale": {
                "docstring": "Ratio between 2d and 3d space."
            }, 
            "stoppingThreshold": {
                "docstring": "Minimum distorsion improvment between two steps in %."
            }, 
            "useScale": {
                "docstring": "Adjust the scale or not."
            }, 
            "uvSetName": {
                "docstring": "Specifies name of the uv set to modify. Default is the current UV set.Common flags"
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "polyOptions": {
        "description": "Changes the global display polygonal attributes. In query mode, return type is based on queried flag.", 
        "flags": {
            "activeObjects": {
                "docstring": "Apply user choices for all active objects."
            }, 
            "allEdges": {
                "docstring": "Display all edges in solid line."
            }, 
            "backCullVertex": {
                "docstring": "BackCull vertices."
            }, 
            "backCulling": {
                "docstring": "Display with no back culling."
            }, 
            "colorMaterialChannel": {
                "docstring": "If colorShadedDisplay is true, then determines which material channel to display color per vertex in. The options are: \"none\" : disable material shading\"ambient\" : ambient material channel\"ambientDiffuse\" : ambient and diffuse material channel\"diffuse\" : diffuse material channel\"specular\" : specular material channel\"emission\" : emission material channel"
            }, 
            "colorShadedDisplay": {
                "docstring": "Use color per vertex display in shaded mode."
            }, 
            "displayAlphaAsGreyScale": {
                "docstring": "Display alpha as grey scale."
            }, 
            "displayBorder": {
                "docstring": "Highlight border edge."
            }, 
            "displayCenter": {
                "docstring": "Display facet centers."
            }, 
            "displayCreaseEdge": {
                "docstring": "Highlight creased edges"
            }, 
            "displayCreaseVertex": {
                "docstring": "Highlight creased vertices"
            }, 
            "displayGeometry": {
                "docstring": "Display geometry."
            }, 
            "displayInvisibleFaces": {
                "docstring": "Highlight invisible facesFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "displayItemNumbers": {
                "docstring": "Displays item numbers (vertices edges facets uvs)"
            }, 
            "displayMapBorder": {
                "docstring": "Highlight map border edge."
            }, 
            "displayNormal": {
                "docstring": "Display normals."
            }, 
            "displaySubdComps": {
                "docstring": "Display subdivided components when in Smooth Mesh Preview mode."
            }, 
            "displayTangent": {
                "docstring": ""
            }, 
            "displayTriangle": {
                "docstring": "Display triangulation."
            }, 
            "displayUVTopology": {
                "docstring": "Option on UV display to display UVs topologically."
            }, 
            "displayUVs": {
                "docstring": "Display UVs."
            }, 
            "displayVertex": {
                "docstring": "Display vertices."
            }, 
            "displayWarp": {
                "docstring": "Highlight warped facets."
            }, 
            "facet": {
                "docstring": "For use with -dn flag. Set the normal display style to facet display."
            }, 
            "fullBack": {
                "docstring": "Display with full back culling."
            }, 
            "gl": {
                "docstring": "Apply user choices for all objects."
            }, 
            "hardBack": {
                "docstring": "Backculled hard edges only for backculled faces."
            }, 
            "hardEdge": {
                "docstring": "Display only hard edges."
            }, 
            "materialBlend": {
                "docstring": "The options are: \"overwrite\" \"add\" \"subtract\" \"multiply\" \"divide\" \"average\" \"modulate2x\""
            }, 
            "newPolymesh": {
                "docstring": "Set component display state of new polymesh objects."
            }, 
            "point": {
                "docstring": "For use with -dn flag. Set the normal display style to vertex display."
            }, 
            "pointFacet": {
                "docstring": "For use with -dn flag. Set the normal display style to vertex and face display."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "When this flag is used with flags dealing with size, the value (size) is a multiplication factor : i.e for flags : -sizeNormal, -sizeBorder. When this flag is used with flags dealing with a boolean value, the boolean value is toggled : i.e for flags : displayVertex, displayCenter, displayTriangle, displayBorder, backCullVertex, displayWarp, displayItemNumbers."
            }, 
            "reuseTriangles": {
                "docstring": "Avoid regenerating triangles, by reusing the old triangles upstream in the construction history. The construction history is searched upstream and downstream for other mesh nodes, and the given boolean value is set on those mesh nodes. Note, that this command does not set the value on the given mesh node. That has to be done using the setAttr command. This option would affect only the interactive 3d viewport. The batch-rendering would use the properly computed triangles. This is useful only for interactive performance such as skinning playback, when the display mode is shaded (or wireframe with triangles displayed) Using this option for wireframe display mode is not recomended."
            }, 
            "sizeBorder": {
                "docstring": "Set the size of the polygonal border edges."
            }, 
            "sizeNormal": {
                "docstring": "Set the size of the polygonal normals."
            }, 
            "sizeUV": {
                "docstring": "Set the size of the polygonal UV."
            }, 
            "sizeVertex": {
                "docstring": "Set the size of the polygonal vertex."
            }, 
            "softEdge": {
                "docstring": "Display soft edges in dotted lines."
            }, 
            "wireBackCulling": {
                "docstring": "Backculled faces are in wireframe."
            }
        }
    }, 
    "polyOutput": {
        "description": "Dumps a description of internal memory representation of poly objects. If no objects are specified in the command line, then the objects from the active list are used. If information on the geometry in the history of a poly shape is desired, then the plug of interest needs to be specified in the command line. Default behaviour is to print only a summary. Use the flags above to get more details on a specific part of the object. ", 
        "flags": {
            "allValues": {
                "docstring": "Shortcut for setting all the flags above"
            }, 
            "color": {
                "docstring": "Prints the color per vertex. In case of multiple sets, all sets are printed."
            }, 
            "colorDesc": {
                "docstring": "Print the color per vertex description. Each integer is an entry in the color array."
            }, 
            "edge": {
                "docstring": "Print the edge description."
            }, 
            "edgeFace": {
                "docstring": "Prints the edge to face adjascency list. Only available if the information is already computed on the object."
            }, 
            "face": {
                "docstring": "Print the faces description"
            }, 
            "faceNorm": {
                "docstring": "Prints the normals per face. Only available if the information is already computed on the object."
            }, 
            "force": {
                "docstring": "Force evaluation of missing pieces before printing."
            }, 
            "group": {
                "docstring": "Print the groups of the object."
            }, 
            "noOutput": {
                "docstring": "Dont output any data. Would be useful if you want to just evaluate the data, for testing purposes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "normDesc": {
                "docstring": "Prints the normals per vertex description. Each integer is an entry in the vertNorm array. Only available if the information is already computed on the object."
            }, 
            "outputFile": {
                "docstring": ""
            }, 
            "triangle": {
                "docstring": "Prints the triangles per face. Only available if the information is already computed on the object."
            }, 
            "uvDesc": {
                "docstring": "Print the UV description. Each integer is an entry in the uvValue array."
            }, 
            "uvValue": {
                "docstring": "Prints the UV positions. In case of multiple UV sets, all sets are printed."
            }, 
            "vert": {
                "docstring": "Prints the vertex positions."
            }, 
            "vertEdge": {
                "docstring": "Prints the vertex to edge adjascency list. Only available if the information is already computed on the object."
            }, 
            "vertNorm": {
                "docstring": "Prints the normals per vertex. Only available if the information is already computed on the object."
            }
        }
    }, 
    "polyPipe": {
        "description": "The polyPipe command creates a new polygonal pipe. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the pipe.Q: When queried, this flag returns a float[3]."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a texture to be applied.C: Default is \"on\" (uv's are computed).Q: When queried, this flag returns an int."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "height": {
                "docstring": "This flag specifies the height of the pipe.C: Default is 2.0.Q: When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "This flag specifies the outer radius of the pipe.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "roundCap": {
                "docstring": ""
            }, 
            "subdivisionsAxis": {
                "docstring": ""
            }, 
            "subdivisionsCaps": {
                "docstring": "This flag specifies the number of subdivisions along the thickness of the pipe.C: Default is 0.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsHeight": {
                "docstring": "This flag specifies the number of subdivisions along the height of the pipe.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.Common flags"
            }, 
            "thickness": {
                "docstring": "This specifies the thickness of the pipe.C: Default is 0.5.Q: When queried, this flag returns an float."
            }
        }
    }, 
    "polyPlanarProjection": {
        "description": "Projects a map onto an object, using an orthogonal projection. The piece of the map defined from isu, isv, icx, icy area, is placed at pcx, pcy, pcz location. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "createNewMap": {
                "docstring": "This flag when set true will create a new map with a the name passed in, if the map does not already exist.Common flags"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "imageCenter": {
                "docstring": "This flag specifies the center point of the 2D model layout.C: Default is 0.5 0.5.Q: When queried, this flag returns a float[2]."
            }, 
            "imageCenterX": {
                "docstring": "This flag specifies X for the center point of the 2D model layout.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "imageCenterY": {
                "docstring": "This flag specifies Y for the center point of the 2D model layout.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "imageScale": {
                "docstring": "This flag specifies the UV scale : Enlarges or reduces the 2D version of the model in U or V space relative to the 2D centerpoint.C: Default is 1.0 1.0.Q: When queried, this flag returns a float[2]."
            }, 
            "imageScaleU": {
                "docstring": "This flag specifies the U scale : Enlarges or reduces the 2D version of the model in U space relative to the 2D centerpoint.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "imageScaleV": {
                "docstring": "This flag specifies the V scale : Enlarges or reduces the 2D version of the model in V space relative to the 2D centerpoint.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "insertBeforeDeformers": {
                "docstring": "This flag specifies if the projection node should be inserted before or after deformer nodes already applied to the shape. Inserting the projection after the deformer leads to texture swimming during animation and is most often undesirable.C: Default is on."
            }, 
            "keepImageRatio": {
                "docstring": ""
            }, 
            "mapDirection": {
                "docstring": "This flag specifies the mapping direction.'x', 'y' and 'z' projects the map along the corresponding axis.'c' projects along the current camera viewing direction.'p' does perspective projection if current camera is perspective.'b' projects along the best plane fitting the objects selected."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "perInstance": {
                "docstring": ""
            }, 
            "projectionCenter": {
                "docstring": "This flag specifies the origin point from which the map is projected.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "projectionCenterX": {
                "docstring": "This flag specifies X for the origin point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionCenterY": {
                "docstring": "This flag specifies Y for the origin point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionCenterZ": {
                "docstring": "This flag specifies Z for the origin point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionHeight": {
                "docstring": ""
            }, 
            "projectionHorizontalSweep": {
                "docstring": ""
            }, 
            "projectionScale": {
                "docstring": "This flag specifies the width and the height of the map relative to the 3D projection axis.C: Default is 1.0 1.0.Q: When queried, this flag returns a float[2]."
            }, 
            "projectionScaleU": {
                "docstring": "This flag specifies the width of the map relative to the 3D projection axis.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "projectionScaleV": {
                "docstring": "This flag specifies the height of the map relative to the 3D projection axis.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "rotate": {
                "docstring": "This flag specifies the mapping rotate angles.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateX": {
                "docstring": "This flag specifies X mapping rotate angle.C: Default is 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateY": {
                "docstring": "This flag specifies Y mapping rotate angle.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies Z mapping rotate angle.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotationAngle": {
                "docstring": "This flag specifies the rotation angle in the mapping space. When the angle is positive, then the map rotates counterclockwise on the mapped model, whereas when it is negative then the map rotates lockwise on the mapped model.C: Default is 10.0.Q: When queried, this flag returns a float."
            }, 
            "seamCorrect": {
                "docstring": ""
            }, 
            "smartFit": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is \"off\".Q: When queried, this flag returns an int."
            }
        }
    }, 
    "polyPlane": {
        "description": "The mesh command creates a new polygonal plane. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the plane."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a specific UV mechanism to be selected, while creating the plane. The valid values are 0, 1 or 2.0 implies that no UVs will be generated (No texture to be applied).1 implies UVs should be created for the object as a whole without any normalization.The helix will be unwrapped and then the texture will be applied without any distortion.In the unwrapped helix, the shared edges will have shared UVs.2 implies UVs are created so that the texture will not be distorted when applied.The texture lying outside the UV range will be truncated (since that cannot besqueezed in, without distorting the texture.For better understanding of these options, you may have to open thetexture view windowC: Default is 2"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "height": {
                "docstring": "This flag specifies the height of the plane.Default is 1.0."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsWidth": {
                "docstring": ""
            }, 
            "subdivisionsX": {
                "docstring": "This specifies the number of subdivisions in the X direction for the plane.Default is 5."
            }, 
            "subdivisionsY": {
                "docstring": "This flag specifies the number of subdivisions in the Y direction for the plane.Default is 5."
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The cuv/createUVs flag should be used instead.Common flags"
            }, 
            "width": {
                "docstring": "This flag specifies the width of the plane.Default is 1.0."
            }
        }
    }, 
    "polyPlatonicSolid": {
        "description": "The polyPlatonicSolid command creates a new polygonal platonic solid. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the platonic solid.Q: When queried, this flag returns a float[3]."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a specific UV mechanism to be selected, while creating.The valid values are 0, 1, 2 ,3 or 4.0 implies that no UVs will be generated (No texture to be applied).1 implies UVs should be created for the object as a whole without any normalization.The solid will be unwrapped and then the texture will be appliedwithout any distortion.In the unwrapped solid, the shared edges will have shared UVs.2 implies UVs are created separately for each of the faces of the solid.3 implies the UVs should be normalized. This will normalize theU and V direction separately, thereby resulting in distortion of textures.4 implies UVs are created so that the texture will not be distorted when applied.The texture lying outside the UV range will be truncated (since that cannot besqueezed in, without distorting the texture.For better understanding of these options, you may have to open thetexture view windowC: Default is 4"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "This flag specifies the radius of the platonic solid.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "sideLength": {
                "docstring": "This flag specifies the side length of platonic solid.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "solidType": {
                "docstring": "This flag allows a specific platonic solid to be selected for creation of mesh,The valid values are 0, 1, 2 and 3.0 implies dodecahedron to be created.1 implies icosahedron to be created.2 implies octahedron to be created.3 implies tertrahedron to be created.C: Default is 0"
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.Common flags"
            }
        }
    }, 
    "polyPoke": {
        "description": "Introduces a new vertex in the middle of the selected face, and connects it to the rest of the vertices of the face. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "localTranslate": {
                "docstring": "translate the new vertex in the local face coordinate."
            }, 
            "localTranslateX": {
                "docstring": "translate the new vertex in the local face coordinate along X."
            }, 
            "localTranslateY": {
                "docstring": "translate the new vertex in the local face coordinate along Y."
            }, 
            "localTranslateZ": {
                "docstring": "translate the new vertex in the local face coordinate along Z."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "translate": {
                "docstring": "translate the new vertex in the world space."
            }, 
            "translateX": {
                "docstring": "translate the new vertex in the world space along X."
            }, 
            "translateY": {
                "docstring": "translate the new vertex in the world space along Y."
            }, 
            "translateZ": {
                "docstring": "translate the new vertex in the world space along Z."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies if the operation has to be performed in the world space or not.Common flags"
            }
        }
    }, 
    "polyPrimitive": {
        "description": "Create a polygon primative ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the primitive polygon.Q: When queried, this flag returns a float[3]."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "polyType": {
                "docstring": "This flag allows a specific primitive poly to be selected for creation of mesh,The valid values is 00 implies soccer ball to be created.C: Default is 0Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "This flag specifies the radius of the primitive polygon.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "sideLength": {
                "docstring": "This flag specifies the side length of primitive polygon.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "texture": {
                "docstring": ""
            }
        }
    }, 
    "polyPrimitiveMisc": {
        "description": "", 
        "flags": {}
    }, 
    "polyPrism": {
        "description": "The prism command creates a new polygonal prism. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the prism.Q: When queried, this flag returns a float[3]."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a specific UV mechanism to be selected, while creating the primitive.The valid values are 0, 1, 2 or 3.0 implies that no UVs will be generated (No texture to be applied).1 implies UVs should be created for the object as a whole without any normalization.The primitive will be unwrapped and then the texture will be appliedwithout any distortion.In the unwrapped primitive, the shared edges will have shared UVs.2 implies the UVs should be normalized. This will normalize theU and V direction separately, thereby resulting in distortion of textures.4 implies UVs are created so that the texture will not be distorted when applied.The texture lying outside the UV range will be truncated (since that cannot besqueezed in, without distorting the texture.For better understanding of these options, you may have to open thetexture view windowC: Default is 3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "length": {
                "docstring": "This flag specifies the length of the prism.C: Default is 2.0.Q: When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "numberOfSides": {
                "docstring": "This specifies the number of sides for the prism.C: Default is 3.Q: When queried, this flag returns an int."
            }, 
            "numderOfSides": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "sideLength": {
                "docstring": "This flag specifies the edge length of the prism.C: Default is 2.0.Q: When queried, this flag returns a float."
            }, 
            "subdivisionsCaps": {
                "docstring": "This flag specifies the subdivisions on the caps for the prism.C: Default is 2.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsHeight": {
                "docstring": "This specifies the subdivisions along the height for the prism.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.Common flags"
            }
        }
    }, 
    "polyProjectCurve": {
        "description": "The polyProjectCurve command creates curves by projecting a selected curve onto a selected poly mesh. The direction of projection will be the current view direction unless the direction vector is specified with the -direction/-d flag. ", 
        "flags": {
            "addUnderTransform": {
                "docstring": ""
            }, 
            "automatic": {
                "docstring": ""
            }, 
            "baryCoord": {
                "docstring": ""
            }, 
            "baryCoord1": {
                "docstring": ""
            }, 
            "baryCoord2": {
                "docstring": ""
            }, 
            "baryCoord3": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "curveSamples": {
                "docstring": ""
            }, 
            "direction": {
                "docstring": ""
            }, 
            "directionX": {
                "docstring": ""
            }, 
            "directionY": {
                "docstring": ""
            }, 
            "directionZ": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "face": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "object": {
                "docstring": ""
            }, 
            "pointsOnEdges": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": ""
            }, 
            "triangle": {
                "docstring": ""
            }
        }
    }, 
    "polyProjection": {
        "description": "Creates a mapping on the selected polygonal faces. When construction history is created, the name of the new node is returned. In other cases, the command returns nothing. ", 
        "flags": {
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable)"
            }, 
            "createNewMap": {
                "docstring": "Create new map if does not existsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "imageCenterX": {
                "docstring": "Specifies the X (U) translation of the projected UVs Default is 0.5"
            }, 
            "imageCenterY": {
                "docstring": "Specifies the Y (V) translation of the projected UVs Default is 0.5"
            }, 
            "imageScaleU": {
                "docstring": "Specifies the U scale factor of the projected UVs Default is 1"
            }, 
            "imageScaleV": {
                "docstring": "Specifies the V scale factor of the projected UVs Default is 1"
            }, 
            "insertBeforeDeformers": {
                "docstring": "Specifies if the projection node should be inserted before or after deformer nodes already applied to the shape. Inserting the projection after the deformer leads to texture swimming during animation and is most often undesirable. Default is on."
            }, 
            "keepImageRatio": {
                "docstring": "Specifies if the xy scaling in the planar projection has to be uniform. By setting this flag, the texture aspect ratio is preserved. This flag is ignored for cylindrical and spherical projections."
            }, 
            "mapDirection": {
                "docstring": "Specifies the direction of the projection. By specifying this flag, the projection placement values (pcx, pcy, pcz, rx, ry, rz, psu, psv) are internally computed. If both this flag and the projection values are specified, the projection values are ignored Valid Values are : X Projects along the X Axis Y Projects along the Y Axis Z Projects along the Z Axis bestPlane Projects on the best plane fitting the object camera Projects along the viewing direction perspective Creates perspective projection if current camera is perspective Default is bestPlane"
            }, 
            "projectionCenterX": {
                "docstring": "Specifies the X coordinate of the center of the projection manipulator"
            }, 
            "projectionCenterY": {
                "docstring": "Specifies the Y coordinate of the center of the projection manipulator"
            }, 
            "projectionCenterZ": {
                "docstring": "Specifies the Z coordinate of the center of the projection manipulator"
            }, 
            "projectionScaleU": {
                "docstring": "Specifies the U scale component of the projection manipulator"
            }, 
            "projectionScaleV": {
                "docstring": "Specifies the V scale component of the projection manipulator"
            }, 
            "rotateX": {
                "docstring": "Specifies the X-axis rotation of the projection manipulator"
            }, 
            "rotateY": {
                "docstring": "Specifies the Y-axis rotation of the projection manipulator"
            }, 
            "rotateZ": {
                "docstring": "Specifies the Z-axis rotation of the projection manipulator"
            }, 
            "rotationAngle": {
                "docstring": "Specifies the rotation of the projected UVs in the UV space Default is 0"
            }, 
            "seamCorrect": {
                "docstring": "Specifies if seam correction has to be done for spherical and cylindrical projections. This flag is ignored, if the planar projection is specified."
            }, 
            "smartFit": {
                "docstring": "Specifies if the projection manipulator has to be placed fitting the object. Used for cylindrical and spherical projections. For smart fitting the planar projection, the mapDirection flag has to be used, since there are several options for smart fitting a planar projection."
            }, 
            "type": {
                "docstring": "Specify the type of mapping to be performed Valid values for the STRING are \"planar\" \"cylindrical\" \"spherical\" Default is planar"
            }, 
            "uvSetName": {
                "docstring": "Specifies name of the uv set to work on"
            }
        }
    }, 
    "polyPyramid": {
        "description": "The pyramid command creates a new polygonal pyramid. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the pyramid.Q: When queried, this flag returns a float[3]."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a specific UV mechanism to be selected, while creating the primitive.The valid values are 0, 1, 2 or 3.0 implies that no UVs will be generated (No texture to be applied).1 implies UVs should be created for the object as a whole without any normalization.The primitive will be unwrapped and then the texture will be appliedwithout any distortion.In the unwrapped primitive, the shared edges will have shared UVs.2 implies the UVs should be normalized. This will normalize theU and V direction separately, thereby resulting in distortion of textures.4 implies UVs are created so that the texture will not be distorted when applied.The texture lying outside the UV range will be truncated (since that cannot besqueezed in, without distorting the texture.For better understanding of these options, you may have to open thetexture view windowC: Default is 3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "numberOfSides": {
                "docstring": "This specifies the number of sides for the pyramid base.C: Default is 3.Q: When queried, this flag returns an int."
            }, 
            "numderOfSides": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "sideLength": {
                "docstring": "This flag specifies the edge length of the pyramid.C: Default is 2.0.Q: When queried, this flag returns a float."
            }, 
            "subdivisionsCaps": {
                "docstring": "This flag specifies the number of subdivisions on bottom cap for the pyramid.C: Default is 0.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsHeight": {
                "docstring": "This flag specifies the number of subdivisions along height for the pyramid.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.Common flags"
            }
        }
    }, 
    "polyQuad": {
        "description": "Merges selected triangles of a polygonal object into four-sided faces. ", 
        "flags": {
            "angle": {
                "docstring": "Angle threshold above which two triangles are not merged.C: Default is 30 degrees. The range is [0.0, 180.0].Q: When queried, this flag returns a float."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "keepGroupBorder": {
                "docstring": "Keep facet group border : If \"on\", the borders of selected faces are maintained, otherwise the borders of selected facets may be modified.C: Default is \"on\".Q: When queried, this flag returns an int."
            }, 
            "keepHardEdges": {
                "docstring": "Keep hard edges : If \"on\", the hard edges of selected faces are maintained, otherwise they may be deleted between two triangles.C: Default is \"on\".Q: When queried, this flag returns an int."
            }, 
            "keepTextureBorders": {
                "docstring": "Keep texture border : If \"on\", the borders of texture maps are maintained, otherwise the boreders of texture maps may be modified.C: Default is \"on\".Q: When queried, this flag returns an int.Common flags"
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is \"off\".Q: When queried, this flag returns an int."
            }
        }
    }, 
    "polyQueryBlindData": {
        "description": "Command query's blindData associated with particular polygonal components. So, the command will require the following to be specified: - selection list to query Optional are the: - typeId - associationType - longDataName or shortDataName of data being queried. - The actual data being specified. - showComponent flag Note that for object level blind data, the showComponent flag will be ignored. If no components are selected, the assocation flag will be ignored and object level data will be queried. ", 
        "flags": {
            "associationType": {
                "docstring": "Specifies the dataTypes that are part of BlindData node being queried. Allowable associations are \"object\" for any object, and \"vertex\" \"edge\" and \"face\" for mesh objects."
            }, 
            "binaryData": {
                "docstring": "Specifies the binary string value to search for"
            }, 
            "booleanData": {
                "docstring": "Specifies the string value to search for"
            }, 
            "doubleData": {
                "docstring": "Specifies the double/float value to search for"
            }, 
            "intData": {
                "docstring": "Specifies the integer value to search for"
            }, 
            "longDataName": {
                "docstring": "Specifies the long name of the data that is being queried by this command."
            }, 
            "maxValue": {
                "docstring": "Specifies the maximum value to search for. This option will query float, double, and integer types of blind data."
            }, 
            "minValue": {
                "docstring": "Specifies the minimum value to search for. This option will query float, double and integer types of blind data."
            }, 
            "shortDataName": {
                "docstring": "Specifies the short name of the data that is being queried by this command."
            }, 
            "showComp": {
                "docstring": "The showComponent option controls whether the object.[component].attribute name is output preceeding the actual value. If the showComponent option is used then the restriction of only returning 1 type of blind data (i.e. one of integer, float, double... is removed, as the return for all are strings. If the association is object and not component, then this option will still cause all the attribute names to be printedFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "stringData": {
                "docstring": "Specifies the string value to search for"
            }, 
            "subString": {
                "docstring": "Specifies the substring that should be checked against a STRING type blind data. If the sub string is found query is successful. Will not look at non String type blind data elements."
            }, 
            "typeId": {
                "docstring": "Specifies the typeId of the BlindData type being queried. If the typeId is not specified, then all of the components that match the query will be output. The typeId of the elements found will be output if the ShowComponents option is used. Will be in the format \"object.component.attribute::typeId\". If the typeId is specifed then the \"::typeId\" portion will not be output with the ShowComponents option."
            }
        }
    }, 
    "polyReduce": {
        "description": "Reduce a polygonal object. ", 
        "flags": {
            "border": {
                "docstring": "This flag specifies the degree to which vertices along the geometric border are to be preserved. It has effect only if the -keepBorder flag is set to false. A value of 1.0 results in no special effort being made to preserve any border vertices. A value of 0 results in all border vertices being preserved.C: Default is .5, range is [0,1].Q: When queried, this flag returns a float."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "cachingReduce": {
                "docstring": ""
            }, 
            "colorWeights": {
                "docstring": ""
            }, 
            "compactness": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "detail": {
                "docstring": "This flag specifies how much of the reduced geometry should be dedicated to preserving regions of high curvature. A value of 1.0 will result in relatively equal distribution of vertices and faces regardless of curvature. A value of 0 will concentrate the detail in areas of high curvature. This value is ignored when -keepHardEdge is set to false.C: Default is .5, range is [0,1].Q: When queried, this flag returns a float."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "geomWeights": {
                "docstring": ""
            }, 
            "keepBorder": {
                "docstring": "If true, vertices on border will not be modified.C: Default is false.Q: When queried, this flag returns a boolean."
            }, 
            "keepHardEdge": {
                "docstring": "If true, vertices on hard edges will not be modified.C: Default is false.Q: When queried, this flag returns a boolean."
            }, 
            "keepMapBorder": {
                "docstring": "If true, vertices on UV border will not be modified.C: Default is false.Q: When queried, this flag returns a boolean."
            }, 
            "keepOriginalVertices": {
                "docstring": "If true, vertices will retain their original positions and will not be repositioned for optimal shapeC: Default is false.Q: When queried, this flag returns a boolean."
            }, 
            "keepQuadsWeight": {
                "docstring": ""
            }, 
            "line": {
                "docstring": "This flag specifies the degree to which \"feature lines\" (edges joining faces with sharp geometric angles between them) are to be preserved. A value of 1.0 results in no special effort being made to preserve such features. A value of 0 results in the greatest possible effort to preserve such features.C: Default is .5, range is [0,1].Q: When queried, this flag returns a float."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "percentage": {
                "docstring": "This flag specifies what percentage of vertices have to be removed from the original object.C: Default is 100. 0 will remove as many vertices as possible.Q: When queried, this flag returns a float."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace) (not available in all commands). NOTE: This flag is intended for use by the \"Reduce\" menu item. If 'polyReduce -rpo 0' is executed from the command line, Shader information will not be copied from the original mesh to the result.Common flags"
            }, 
            "triangulate": {
                "docstring": ""
            }, 
            "uvWeights": {
                "docstring": ""
            }, 
            "weightCoefficient": {
                "docstring": ""
            }
        }
    }, 
    "polySelect": {
        "description": "This command makes different types of poly component selections. The return value is an integer array containing the id's of the components in the selection in order. If a given type of selection loops back on itself then this is indicated by the start id appearing twice, once at the start and once at the end. ", 
        "flags": {
            "add": {
                "docstring": "Indicates that the specified items should be added to the active list without removing existing items from the active list."
            }, 
            "addFirst": {
                "docstring": "Indicates that the specified items should be added to the front of the active list without removing existing items from the active list."
            }, 
            "asSelectString": {
                "docstring": "Changes the return type from an integer array to a string array which can be used as a selection string.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "deselect": {
                "docstring": "Indicates that the specified items should be removed from the active list if they are on the active list."
            }, 
            "edgeBorder": {
                "docstring": "Select all conected border edges starting at the given edge. "
            }, 
            "edgeBorderPath": {
                "docstring": "Given two edges on the same border, this will select the edges on the border in the path between them. "
            }, 
            "edgeBorderPattern": {
                "docstring": "Given two edges on the same border, this will check how many edges there are between the given edges and then continue that pattern of selection around the border. "
            }, 
            "edgeLoop": {
                "docstring": "Select an edge loop starting at the given edge. "
            }, 
            "edgeLoopOrBorder": {
                "docstring": "Select an edge loop or all conected border edges, depending on whether the edge is on a border or not, starting at the given edge. "
            }, 
            "edgeLoopOrBorderPattern": {
                "docstring": "Given two edges either on the same edge loop or on the same edge border, this will check how many edges there are between the given edges and then continue that pattern of selection around the edge loop or edge border. "
            }, 
            "edgeLoopPath": {
                "docstring": "Given two edges that are on the same edge loop, this will select the shortest path between them on the loop. "
            }, 
            "edgeLoopPattern": {
                "docstring": "Given two edges on the same edge loop, this will check how many edges there are between the given edges and then continue that pattern of selection around the edge loop. "
            }, 
            "edgeRing": {
                "docstring": "Select an edge ring starting at the given edge. "
            }, 
            "edgeRingPath": {
                "docstring": "Given two edges that are on the same edge ring, this will select the shortest path between them on the ring. "
            }, 
            "edgeRingPattern": {
                "docstring": "Given two edges on the same edge ring, this will check how many edges there are between the given edges and then continue that pattern of selection around the edge ring. "
            }, 
            "edgeUVLoopOrBorder": {
                "docstring": "Select an edge loop or border, terminating at UV borders. "
            }, 
            "everyN": {
                "docstring": ""
            }, 
            "extendToShell": {
                "docstring": "Select the poly shell given a face id. "
            }, 
            "noSelection": {
                "docstring": "If this flag is used then the selection is not changed at all."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replace": {
                "docstring": "Indicates that the specified items should replace the existing items on the active list."
            }, 
            "shortestEdgePath": {
                "docstring": "Given two vertices, this will select the shortest path between them in the 3d object space. "
            }, 
            "shortestEdgePathUV": {
                "docstring": "Given two UVs, this will select the shortest path between them in the 2d texture space. "
            }, 
            "shortestFacePath": {
                "docstring": "Given two faces, this will select the shortest path between them in the 3d object space. "
            }, 
            "toggle": {
                "docstring": "Indicates that those items on the given list which are on the active list should be removed from the active list and those items on the given list which are not on the active list should be added to the active list."
            }
        }
    }, 
    "polySelectConstraint": {
        "description": "Changes the global polygonal selection constraints. In query mode, return type is based on queried flag.", 
        "flags": {
            "angle": {
                "docstring": "0(off) 1(on)."
            }, 
            "anglebound": {
                "docstring": "min and max angles. The given value should be in the current units that Maya is using. See the examples for how to check the current unit.For vertices : angle between the 2 edges owning the vertex.For edges : angle between the 2 faces owning the edge."
            }, 
            "border": {
                "docstring": "If true, selection will be extended to all connected border components so that the whole \"loop\" is selected."
            }, 
            "convexity": {
                "docstring": "0(off) 1(concave) 2(convex)."
            }, 
            "crease": {
                "docstring": "If true, selection will be extended to all connected creased components."
            }, 
            "disable": {
                "docstring": "Toggles offall constraints for all component types, but leaves the other constraint parameters.This flag may be used together with other ones toggling some constraints on: if so, all constraints are disabled first (no matter the position of the -disable flag in the command line) then the specified ones are activated."
            }, 
            "dist": {
                "docstring": "0(off) 1(to point) 2(to axis) 3(to plane)."
            }, 
            "distaxis": {
                "docstring": "axis. (Normal to the plane in case of distance to plane)."
            }, 
            "distbound": {
                "docstring": "min and max distances."
            }, 
            "distpoint": {
                "docstring": "point. (Axis/plane origin in case of distance to axis/plane)."
            }, 
            "edgeDistance": {
                "docstring": "Maximum distance (number of edges) to extend the edge selection for \"Contiguous Edges\" propagate mode. 0 means to ignore the distance constraint."
            }, 
            "geometricarea": {
                "docstring": "0(off) 1(on)."
            }, 
            "geometricareabound": {
                "docstring": "min and max areas."
            }, 
            "holes": {
                "docstring": "0(off) 1(holed) 2(non holed)."
            }, 
            "length": {
                "docstring": "0(off) 1(on)."
            }, 
            "lengthbound": {
                "docstring": "min and max lengths."
            }, 
            "max2dAngle": {
                "docstring": "Maximum angle between two consecutive edges in the 2d tangent plane for \"Contiguous Edges\" propagate mode."
            }, 
            "max3dAngle": {
                "docstring": "Maximum angle between two consecutive edges in 3d space for \"Contiguous Edges\" propagate mode."
            }, 
            "mode": {
                "docstring": "0(Off) 1(Next) 2(Current and Next) 3(All and Next).Off : no constraints are used at all.Next : constraints will be used to filter next selections.Current and Next : constraints will be aplied on current selection and then used to filter next selections.All and Next : all items satisfying constraints are selected."
            }, 
            "nonmanifold": {
                "docstring": "0(off) 1(on)"
            }, 
            "oppositeEdges": {
                "docstring": ""
            }, 
            "order": {
                "docstring": "0(off) 1(on)."
            }, 
            "orderbound": {
                "docstring": "min and max orders. number of owning edges."
            }, 
            "orient": {
                "docstring": "0(off) 1(orientation) 2(direction)."
            }, 
            "orientaxis": {
                "docstring": "axis."
            }, 
            "orientbound": {
                "docstring": "min and max angles. The given value should be in the current units that Maya is using. See the examples for how to check the current unit."
            }, 
            "planarity": {
                "docstring": "0(off) 1(non planar) 2(planar)."
            }, 
            "propagate": {
                "docstring": "0(Off) 1(More) 2(Less) 3(Border) 4(Contiguous Edges).More : will add current selection border to current selection.Less : will remove current selection border from current selection.Border : will keep only current selection border.Contiguous Edges : Add edges aligned with the current edges selected. The direction and number of edges selected is controlled by the -m2a, -m3a, and -ed flags."
            }, 
            "query": {
                "docstring": ""
            }, 
            "random": {
                "docstring": "0(off) 1(on)."
            }, 
            "randomratio": {
                "docstring": "ratio [0,1].Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "shell": {
                "docstring": "If true, selection will be extended to all connected components so that the whole piece of object is selected."
            }, 
            "size": {
                "docstring": "0(off) 1(triangles) 2(quads) 3(nsided)."
            }, 
            "smoothness": {
                "docstring": "0(off) 1(hard) 2(smooth)."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that would restore all the current settings."
            }, 
            "textured": {
                "docstring": "0(off) 1(mapped) 2(unmapped)."
            }, 
            "texturedarea": {
                "docstring": "0(off) 1(Area specified is unsigned) 2(Area specified is signed)."
            }, 
            "texturedareabound": {
                "docstring": "min and max areas."
            }, 
            "textureshared": {
                "docstring": "0(off) 1(on). This option will select any uvs on the currentMap which are shared by more than one vertex"
            }, 
            "topology": {
                "docstring": "0(off) 1(non triangulatable) 2(lamina) 3(non triangulatable and lamina)"
            }, 
            "type": {
                "docstring": "0x0000(none)0x0001(vertex)0x8000(edge)0x0008(face)0x0010(texture coordinates)"
            }, 
            "visibility": {
                "docstring": "0(off) 1(on)."
            }, 
            "visibilityangle": {
                "docstring": "angle [0,360]."
            }, 
            "visibilitypoint": {
                "docstring": "point."
            }, 
            "where": {
                "docstring": "0(off) 1(on border) 2(inside)."
            }, 
            "wholeSensitive": {
                "docstring": "Tells how to select faces : eitherby picking anywhere inside the face (if true)or by picking on the face center marker (if false)."
            }
        }
    }, 
    "polySelectConstraintMonitor": {
        "description": "Manage the window to display/edit the polygonal selection constraint parameters ", 
        "flags": {
            "changeCommand": {
                "docstring": "Specifies the mel callback to refresh the window. First argument is the callback, second is the window name."
            }, 
            "create": {
                "docstring": "Specifies the Monitor should be created"
            }, 
            "delete": {
                "docstring": "Specifies that the Monitor should be removedFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "polySelectCtx": {
        "description": "Create a new context to select polygon components In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "mode": {
                "docstring": "Edge loop or Edge ring or Border edge modeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polySelectEditCtx": {
        "description": "Create a new context to select and edit polygonal objects ", 
        "flags": {
            "absoluteOffset": {
                "docstring": ""
            }, 
            "autoComplete": {
                "docstring": ""
            }, 
            "deleteEdge": {
                "docstring": ""
            }, 
            "divisions": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endVertexOffset": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "fixQuads": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "mode": {
                "docstring": "which mode to work on. Available modes are 1-loop and 2-ringFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "smoothingAngle": {
                "docstring": ""
            }, 
            "splitType": {
                "docstring": ""
            }, 
            "startVertexOffset": {
                "docstring": ""
            }, 
            "useEqualMultiplier": {
                "docstring": ""
            }
        }
    }, 
    "polySelectEditCtxDataCmd": {
        "description": "", 
        "flags": {}
    }, 
    "polySelectSp": {
        "description": "", 
        "flags": {
            "loop": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "ring": {
                "docstring": ""
            }
        }
    }, 
    "polySeparate": {
        "description": "This command creates new objects from the given poly. A new object will be created for each section of the mesh that is distinct (no edges connect it to the rest of the mesh).This command can only separate one object at a time. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeShells": {
                "docstring": ""
            }, 
            "separateSpecificShell": {
                "docstring": ""
            }
        }
    }, 
    "polySetToFaceNormal": {
        "description": "This command takes selected polygonal vertices or vertex-faces and changes their normals. If the option userNormalis used, the new normal values will be the face normals arround the vertices/vertex-faces. Otherwise the new normal values will be default values according to the internal calculation. ", 
        "flags": {
            "setUserNormal": {
                "docstring": "when this flag is presented, user normals will be created on each vertex face and the values will be the face normal value. Otherwise the normal values will be the internal computing results. Default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "polySetVertices": {
        "description": "", 
        "flags": {}
    }, 
    "polySewEdge": {
        "description": "Merge border edges within a given threshold.Perform pair-wise comparison of selected edges. Pairs whose corresponding vertices meet threshold conditions and whose orientations are aligned (i.e. their respective normals point in the same direction) are merged, as are the vertices (in other words, vertices are shared). Resulting mesh may have extra vertices or edges to ensure geometry is valid.Edges must be on the same object to be merged.Default : share only vertices lying exactly at the same place. (polySewEdge -t 0.0) ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "texture": {
                "docstring": "If true : texture is sewn as well as the 3d edge.C: Default is true.Q: When queried, this flag returns an int."
            }, 
            "tolerance": {
                "docstring": "The tolerance to sew edges (edge distance)C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : tolerance value is taken in world reference. If \"off\" : tolerance value is considered in object reference.C: Default is \"off\".Q: When queried, this flag returns an int.Common flags"
            }
        }
    }, 
    "polyShortestPathCtx": {
        "description": "Creates a new context to select shortest edge path between two vertices or UVs in the 3d viewport. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polySlideEdge": {
        "description": "Moves an edge loop selection along the edges connected to the sides of its vertices. ", 
        "flags": {
            "absolute": {
                "docstring": "This flag specifies whether or not the command uses absolute mode If in absolute then all vertices will move the same distance (the specified percentage of the smallest edge)C: Default is offFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "direction": {
                "docstring": "This flag specifies the direction of the slide edge movement 1: is left direction (relative) 0: is right direction (relative)C: Default is 0"
            }, 
            "edgeDirection": {
                "docstring": "This flag specifies the relative percentage to move along the edges on either side of the vertices along the edge loopC: Default is 0.0"
            }
        }
    }, 
    "polySlideEdgeCtx": {
        "description": "", 
        "flags": {
            "absolute": {
                "docstring": ""
            }, 
            "direction": {
                "docstring": ""
            }, 
            "edgeDirection": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "snappingPoints": {
                "docstring": ""
            }, 
            "snappingTolerance": {
                "docstring": ""
            }, 
            "useSnapping": {
                "docstring": ""
            }
        }
    }, 
    "polySmooth": {
        "description": "Smooth a polygonal object. This command works on polygonal objects or faces. ", 
        "flags": {
            "boundaryRule": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "continuity": {
                "docstring": "This flag specifies the smoothness parameter. The minimum value of 0.0 specifies that the faces should only be subdivided. Maximum value of 1.0 smooths the faces as much as possible.C: Default is 1.0Q: When queried, this flag returns a float."
            }, 
            "degree": {
                "docstring": ""
            }, 
            "divisions": {
                "docstring": "This flag specifies the number of recursive smoothing steps.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "divisionsPerEdge": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "keepBorder": {
                "docstring": "If on, the border of the object will not move during smoothing operation.C: Default is \"on\".Q: When queried, this flag returns an int."
            }, 
            "keepHardEdge": {
                "docstring": "If true, vertices on hard edges will not be modified.C: Default is false.Q: When queried, this flag returns a boolean."
            }, 
            "keepMapBorders": {
                "docstring": ""
            }, 
            "keepSelectionBorder": {
                "docstring": "If true, vertices on border of the selection will not be modified.C: Default is false.Q: When queried, this flag returns a boolean."
            }, 
            "keepTesselation": {
                "docstring": ""
            }, 
            "keepTessellation": {
                "docstring": "If true, the object will be tessellated consistently at each frame. If false, non-starlike faces will be triangulated before being subdivided, to avoid self-overlapping faces.C: Default is true.Q: When queried, this flag returns a boolean. Common flagsCommon flags"
            }, 
            "method": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "propagateEdgeHardness": {
                "docstring": "If true, edges which are a result of smoothed edges will be given the same value for their edge hardness. New subdivided edges will always be smooth.C: Default is false.Q: When queried, this flag returns a boolean."
            }, 
            "pushStrength": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "roundness": {
                "docstring": ""
            }, 
            "smoothUVs": {
                "docstring": ""
            }, 
            "subdivisionLevels": {
                "docstring": ""
            }
        }
    }, 
    "polySoftEdge": {
        "description": "Selectively makes edges soft or hard.An edge will be made hard if the angle between two owning faces is sharper (larger) than the smoothing angle.An edge wil be made soft if the angle between two owning facets is flatter (smaller) than the smoothing angle. ", 
        "flags": {
            "angle": {
                "docstring": "Smoothing angle.C: Default is 30 degrees.Q: When queried, this flag returns a float."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is \"off\".Q: When queried, this flag returns an int.Common flags"
            }
        }
    }, 
    "polySphere": {
        "description": "The sphere command creates a new polygonal sphere. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the sphere.Q: When queried, this flag returns a float[3]."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a specific UV mechanism to be selected, while creating the helix.The valid values are 0, 1, or 2.0 implies that no UVs will be generated (No texture to be applied).1 implies UVs are created with pinched at poles2 implies UVs are created with sawtooth at polesFor better understanding of these options, you may have to open thetexture view windowC: Default is 2"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "This flag specifies the radius of the sphere.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "subdivisionsAxis": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsX": {
                "docstring": "This specifies the number of subdivisions in the X direction for the sphere.C: Default is 20.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsY": {
                "docstring": "This flag specifies the number of subdivisions in the Y direction for the sphere.C: Default is 20.Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.Common flags"
            }
        }
    }, 
    "polySphericalProjection": {
        "description": "Projects a spherical map onto an object. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "createNewMap": {
                "docstring": "This flag when set true will create a new map with a the name passed in, if the map does not already exist.Common flags"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "imageCenter": {
                "docstring": "This flag specifies the center point of the 2D model layout.C: Default is 0.5 0.5.Q: When queried, this flag returns a float[2]."
            }, 
            "imageCenterX": {
                "docstring": "This flag specifies X for the center point of the 2D model layout.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "imageCenterY": {
                "docstring": "This flag specifies Y for the center point of the 2D model layout.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "imageScale": {
                "docstring": "This flag specifies the UV scale : Enlarges or reduces the 2D version of the model in U or V space relative to the 2D centerpoint.C: Default is 1.0 1.0.Q: When queried, this flag returns a float[2]."
            }, 
            "imageScaleU": {
                "docstring": "This flag specifies the U scale : Enlarges or reduces the 2D version of the model in U space relative to the 2D centerpoint.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "imageScaleV": {
                "docstring": "This flag specifies the V scale : Enlarges or reduces the 2D version of the model in V space relative to the 2D centerpoint.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "insertBeforeDeformers": {
                "docstring": "This flag specifies if the projection node should be inserted before or after deformer nodes already applied to the shape. Inserting the projection after the deformer leads to texture swimming during animation and is most often undesirable.C: Default is on."
            }, 
            "keepImageRatio": {
                "docstring": ""
            }, 
            "mapDirection": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "perInstance": {
                "docstring": ""
            }, 
            "projectionCenter": {
                "docstring": "This flag specifies the origin point from which the map is projected.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "projectionCenterX": {
                "docstring": "This flag specifies X for the origin point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionCenterY": {
                "docstring": "This flag specifies Y for the origin point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionCenterZ": {
                "docstring": "This flag specifies Z for the origin point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionHeight": {
                "docstring": ""
            }, 
            "projectionHorizontalSweep": {
                "docstring": ""
            }, 
            "projectionScale": {
                "docstring": "This flag specifies the width and the height of the map relative to the 3D projection axis.C: Default is 180.0 90.0.Q: When queried, this flag returns a float[2]."
            }, 
            "projectionScaleU": {
                "docstring": "This flag specifies the width of the map relative to the 3D projection axis : the scale aperture. The range is [0, 360].C: Default is 180.0.Q: When queried, this flag returns a float."
            }, 
            "projectionScaleV": {
                "docstring": "This flag specifies the height of the map relative to the 3D projection axis : the scale height.C: Default is 90.0.Q: When queried, this flag returns a float."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "rotate": {
                "docstring": "This flag specifies the mapping rotate angles.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateX": {
                "docstring": "This flag specifies X mapping rotate angle.C: Default is 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateY": {
                "docstring": "This flag specifies Y mapping rotate angle.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies Z mapping rotate angle.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotationAngle": {
                "docstring": "This flag specifies the rotation angle in the mapping space. When the angle is positive, then the map rotates counterclockwise on the mapped model, whereas when it is negative then the map rotates lockwise on the mapped model.C: Default is 10.0.Q: When queried, this flag returns a float."
            }, 
            "seamCorrect": {
                "docstring": "This flag specifies to perform a seam correction on the mapped faces."
            }, 
            "smartFit": {
                "docstring": "This flag specifies if the manipulator should be placed best fitting the object, or be placed on the specified position with the specified transformation values.Default is on."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If on : all geometrical values are taken in world reference. If off : all geometrical values are taken in object reference.C: Default is off.Q: When queried, this flag returns an int."
            }
        }
    }, 
    "polySpinEdge": {
        "description": "", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "offset": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polySplit": {
        "description": "Split facets/edges of a polygonal object. The first and last arguments must be edges. Intermediate points may lie on either a shared face or an edge which neighbors the previous point. ", 
        "flags": {
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "detachEdges": {
                "docstring": ""
            }, 
            "edgepoint": {
                "docstring": "The given edge is split into two new edges by inserting a new vertex located the given percentage along the edge.Note:This flag is not recommended for use from Python. See the insertpoint flag instead."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "facepoint": {
                "docstring": "A new vertex is inserted, lying at the given coordinates inside the given face. Coordinates are given in the local object space.Note:This flag is not recommended for use from Python. See the insertpoint flag instead."
            }, 
            "insertpoint": {
                "docstring": "This flag allows the caller to insert a new vertex into an edge or a face.To insert a new vertex in an edge, pass the index of the edge and a percentage along the edge at which to insert the new vertex. When used to insert a vertex into an edge, this flag takes two arguments.To insert a new vertex into a face, pass the index of the face and three values which define the coordinates for the insertion in local object space. When used to insert a vertex into a face, this flag takes four arguments.This flag replaces the edgepoint and facepoint flags."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "projectedCurve": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "smoothingangle": {
                "docstring": "Subdivide new edges will be soft if less then this angle.C: Default is 0.0Common flags"
            }, 
            "subdivision": {
                "docstring": "Subdivide new edges into the given number of sections. Edges involving free points won't be subdivided.C: Default is 1 (no subdivision).Q: When queried, this flag returns an int."
            }
        }
    }, 
    "polySplitCtx": {
        "description": "Create a new context to split facets on polygonal objects In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "enablesnap": {
                "docstring": "Enable/disable custom magnet snapping to start/middle/end of edge"
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "magnetsnap": {
                "docstring": "number of extra magnets to snap onto, regularly spaced along the edge"
            }, 
            "precsnap": {
                "docstring": "precision for custom magnet snapping. Range[0,100]. Value 100 means any click on an edge will snap to either extremities or magnets."
            }, 
            "query": {
                "docstring": ""
            }, 
            "smoothingangle": {
                "docstring": "the threshold that controls whether newly created edges are hard or softFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "snaptoedge": {
                "docstring": "Enable/disable snapping to edge. If enabled any click in the current face will snap to the closest valid edge. If there is no valid edge, the click will be ignored. NOTE: This is different from magnet snapping, which causes the click to snap to certain points along the edge."
            }, 
            "subdivision": {
                "docstring": "number of sub-edges to add between 2 consecutive edge points. Default is 1."
            }
        }
    }, 
    "polySplitCtx2": {
        "description": "Create a new context to split facets on polygonal objects In query mode, return type is based on queried flag.", 
        "flags": {
            "constrainToEdges": {
                "docstring": "Enable/disable snapping to edge. If enabled any click in the current face will snap to the closest valid edge. If there is no valid edge, the click will be ignored. NOTE: This is different from magnet snapping, which causes the click to snap to certain points along the edge."
            }, 
            "detachEdges": {
                "docstring": ""
            }, 
            "edgeMagnets": {
                "docstring": "number of extra magnets to snap onto, regularly spaced along the edgeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "highlightPointColor": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "snapTolerance": {
                "docstring": "precision for custom magnet snapping. Range[0,1]. Value 1 means any click on an edge will snap to either extremities or magnets."
            }, 
            "snappedToEdgeColor": {
                "docstring": ""
            }, 
            "snappedToFaceColor": {
                "docstring": ""
            }, 
            "snappedToMagnetColor": {
                "docstring": ""
            }, 
            "snappedToVertexColor": {
                "docstring": ""
            }, 
            "snappingTolerance": {
                "docstring": ""
            }, 
            "splitLineColor": {
                "docstring": ""
            }
        }
    }, 
    "polySplitEdge": {
        "description": "Split Edges.There are two operations for this command depending on the value of the -operation flag. If -operation is set to 1 then this command will split apart faces along all selected manifold edges. If -operation is set to 0 then this command will split non-manifold edges so as to make them manifold edges. It creates the minimum number of edges that can be created to make the edge manifold. The default value for -operation is 1, operate on manifold edges. Resulting mesh may have extra vertices or edges to ensure geometry is valid. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "operation": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polySplitRing": {
        "description": "Splits a series of ring edges of connected quads and inserts connecting edges between them. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "direction": {
                "docstring": "The direction to associate the absoluteWeights on the edge. By toggling the boolean value, the new edges can be positioned either to the start or the end vertex of the edge thats split.Default is on"
            }, 
            "divisions": {
                "docstring": "If the splitType is set to 2 then this is used to control how many new edge loops are inserted. This number has to be at least 1."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enableProfileCurve": {
                "docstring": ""
            }, 
            "fixQuads": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "profileCurveInputOffset": {
                "docstring": ""
            }, 
            "profileCurveInputScale": {
                "docstring": ""
            }, 
            "profileCurve_FloatValue": {
                "docstring": ""
            }, 
            "profileCurve_Interp": {
                "docstring": ""
            }, 
            "profileCurve_Position": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rootEdge": {
                "docstring": "The edge id of the object, to be used as a reference for the flags absoluteWeight and direction.Default is -1"
            }, 
            "smoothingAngle": {
                "docstring": "Subdivide new edges will be soft if less then this angle.Default is 180.0Common flags"
            }, 
            "splitType": {
                "docstring": "Choose between 3 different types of splits. If this is set to 0 then the split type will be absolute. This is where each of the splits will maintain an equal distance from the associated vertices. If this set to 1 then the split type will be relative. This is where each split will be made at an equal percentage along the length of the edge. If this is set to 2 then the edge will be split one or more times. The number of times is controlled by the -div/-divisions flag. For an absolute or relative type of split the user can adjust the weight to position where the split occurrs. If the split is a multi split then the splits will be spaced out evenly."
            }, 
            "useEqualMultiplier": {
                "docstring": ""
            }, 
            "useFaceNormalsAtEnds": {
                "docstring": ""
            }, 
            "weight": {
                "docstring": "The weight value of the new vertex to be positioned at the first edge. The same weight value is used for all the edges split.Default is 0.5"
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "polySplitVertex": {
        "description": "Use this command to split one or more vertices.A mesh is made up of one or more faces. The faces are defined by edges which connect vertices together. Typically a face will share vertices and edges with adjacent faces in the same mesh. Sharing vertices and edges helps reduce the amount of memory used by a mesh. It also ensures that when a face is moved, all the connected faces move together.Sometimes you may want to separate a face from its connected faces so that it may be moved in isolation. There are three ways to accomplish this depending upon which parts of the face you want to extract:polySplitVertexsplit one or more vertices so that each face that shared the vertex acquires its own copy of the vertexpolySplitEdgesplit one or more edges so that each face that shared the vertex acquires its own copy of the edgepolyChipOffcompletely extract the face so that it has its own vertices and edgesNotice that the area of affect of each operation is different. polySplitVertex will affect all the edges and faces that shared the vertex. This is the broadest effect. polySplitEdge will only affect the faces which shared the edge and polyChipOff will affect a specific face. If we just count vertices to measure the effect of each command when splitting all components of a face, starting from a 3x3 plane which has 16 vertices and we were to split the middle face:polySplitVertex applied to the four vertices would end up creating 12 new verticespolySplitEdge applied to the four edges would end up creating 4 new verticespolyChipOff applied to the middle face would end up creating 4 new verticesNote that polySplitVertex may create non-manifold geometry as a part of this operation. You can use Polygons-Cleanup afterwards to to clean up any non-manifold geometry. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "Not used by this commandCommon flags"
            }
        }
    }, 
    "polyStraightenUVBorder": {
        "description": "Move border UVs along a simple curve. ", 
        "flags": {
            "blendOriginal": {
                "docstring": "Interpolation factor between the target and original UV shape. When the value is 0, the UVs will exactly fit the target curve. When the value is 1, no UV move."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "curvature": {
                "docstring": "How curved the UV path will be. 0 is a straight line. When the values is 1, the mid point of the curve will be moved away from a straight line by 1/2 the length of the UV segment."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "gapTolerance": {
                "docstring": "When non 0, Small gaps between UV selection are filled. The integer number represent how many UVs must be traversed to connect togeterh selected pieces."
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preserveLength": {
                "docstring": "How much we want to respect the UV edge ratios. When the value is 1, we build new UV position along the desired curve, respecting the original UV spacings. When the value is 0, new UVs are equally spaced along the curve."
            }, 
            "query": {
                "docstring": ""
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.Common flags"
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "polySubdivideEdge": {
        "description": "Subdivides an edge into two or more subedges.Default : divide edge into two edges of equal length. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "divisions": {
                "docstring": "The maximum number of vertices to be inserted in each edge. This number may be reduced if it creates edges shorter than the specified minimum length.C: Default is 1 (divide edges in half).Q: When queried, this flag returns an int."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "size": {
                "docstring": "The minimum length of each subedge created. If the given subdivision creates edges that are shorter than this length, the number of divisions is changed to respect min length.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is \"off\".Q: When queried, this flag returns an int.Common flags"
            }
        }
    }, 
    "polySubdivideFacet": {
        "description": "Subdivides a face into quads or triangles.In quad mode, a center point is introduced at the center of each face and midpoints are inserted on all the edges of each face. New faces (all quadrilaterals) are built by adding edges from the midpoints towards the center.In triangle mode, only the center point is created; new faces (all triangles) are created by connecting the center point to all the existing vertices of the face.Default : one subdivision step in quad mode (polySubdFacet -dv 1 -m 0;) ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "divisions": {
                "docstring": "This number specifies how many times to recursively subdivide the selected faces. For example, with divisions set to 3 in quad mode, each initial quadrilateral will be recursively subdivided into 4 subfaces 3 times, yielding a total of 4 \\* 4 \\* 4 = 64 faces.C: Default is 1.Q: When queried, this flag returns an int."
            }, 
            "divisionsU": {
                "docstring": ""
            }, 
            "divisionsV": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "mode": {
                "docstring": "The subdivision mode.0: subdivision into quads1: subdivision into trianglesC: Default is 0.Q: When queried, this flag returns an int.Common flags"
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "subdMethod": {
                "docstring": ""
            }
        }
    }, 
    "polySuperCtx": {
        "description": "", 
        "flags": {
            "attach": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyTestPop": {
        "description": "", 
        "flags": {}
    }, 
    "polyToCurve": {
        "description": "", 
        "flags": {
            "addUnderTransform": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "degree": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "form": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyToSubdiv": {
        "description": "This command converts a polygon and produces a subd surface. The name of the new subdivision surface is returned. If construction history is ON, then the name of the new dependency node is returned as well. ", 
        "flags": {
            "absolutePosition": {
                "docstring": "If true, the possible blind data information that comes from the polygon will be treated as absolute positions of the vertices, instead of the relative offsets. You most likelly just want to use the default of false, unless you know that the blind data has the absolute positions in it.Default:false"
            }, 
            "addUnderTransform": {
                "docstring": ""
            }, 
            "applyMatrixToResult": {
                "docstring": "If true, the matrix on the input geometry is applied to the object and the resulting geometry will have identity matrix on it. If false the conversion is done on the local space object and the resulting geometry has the input object's matrix on it.Default:true"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "maxEdgesPerVert": {
                "docstring": "The maximum allowed valence for a vertex on the input meshDefault:32"
            }, 
            "maxPolyCount": {
                "docstring": "The maximum number of polygons accepted on the input mesh.Default:1000"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dep. node (where applicable)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preserveVertexOrdering": {
                "docstring": "Preserve vertex ordering in conversionDefault:true"
            }, 
            "query": {
                "docstring": ""
            }, 
            "quickConvert": {
                "docstring": "Debug flag to test the performanceDefault:trueAdvanced flags"
            }, 
            "uvPoints": {
                "docstring": "This is a cached uv point needed to transfer uv data associated with finer level vertices (when switching between standard editing mode and poly proxy mode."
            }, 
            "uvPointsU": {
                "docstring": "U value of a cached uv point"
            }, 
            "uvPointsV": {
                "docstring": "V value of a cached uv point"
            }, 
            "uvTreatment": {
                "docstring": "Treatment of Subd UVs when in proxy mode: 0 - preserve Subd UVs1 - build Subd UVs from Poly UVs2 - no UVs on SubdDefault:0"
            }
        }
    }, 
    "polyTorus": {
        "description": "The torus command creates a new polygonal torus. ", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the primitive axis used to build the torus.Q: When queried, this flag returns a vector."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "createUVs": {
                "docstring": "This flag alows a texture to be applied.C: Default is \"on\" (uv's are computed).Q: When queried, this flag returns an int."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "This flag specifies the radius of the torus.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "sectionRadius": {
                "docstring": "This flag specifies the section radius of the torus.C: Default is 0.25.Q: When queried, this flag returns a float."
            }, 
            "subdivisionsAxis": {
                "docstring": ""
            }, 
            "subdivisionsHeight": {
                "docstring": ""
            }, 
            "subdivisionsX": {
                "docstring": "This specifies the number of subdivisions in the X direction for the torus (number of sections).C: Default is 20.Q: When queried, this flag returns an int."
            }, 
            "subdivisionsY": {
                "docstring": "This flag specifies the number of subdivisions in the Y direction for the torus (number of segments per section).C: Default is 20.Q: When queried, this flag returns an int."
            }, 
            "texture": {
                "docstring": "This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.Common flags"
            }, 
            "twist": {
                "docstring": "This flag specifies the section twist of the torus.C: Default is 0.0.Q: When queried, this flag returns a float."
            }
        }
    }, 
    "polyTransfer": {
        "description": "Transfer information from one polygonal object to another one. Both objects must have identical topology, that is same vertex, edge, and face numbering. The flags specify which of the vertices, UV sets or vertex colors will be copied. ", 
        "flags": {
            "alternateObject": {
                "docstring": "Name of the alternate object."
            }, 
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "uvSets": {
                "docstring": "When true, the UV sets are copied from the alternate object.C: Default is \"on\"."
            }, 
            "vertexColor": {
                "docstring": "When true, the colors per vertex are copied from the alternate object.C: Default is \"off\".Common flags"
            }, 
            "vertices": {
                "docstring": "When true, the vertices positions are copied from the alternate object.C: Default is \"off\"."
            }
        }
    }, 
    "polyTriangulate": {
        "description": "Triangulation breaks polygons down into triangles, ensuring that all faces are planar and non-holed. Triangulation of models can be beneficial in many areas. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyUVRectangle": {
        "description": "Given two vertices, does one of the following: 1) If the vertices define opposite corners of a rectangular area of quads, assigns a grid of UVs spanning the 0-1 area to that rectangle. 2) If the vertices define an edge in a rectangular and topologically cylindrical area of quads, assigns UVs spanning the 0-1 area to that cylindrical patch, using the defined edge as the U=0 edge. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyUVSet": {
        "description": "Command to do the following to uv sets: - delete an existing uv set. - rename an existing uv set. - create a new empty uv set. - copy the values from one uv set to a another pre-existing uv set. - set the current uv set to a pre-existing uv set. - modify sharing between instances of per-instance uv sets - query the current uv set. - set the current uv set to the last uv set added to an object. - query the names of all uv sets. ", 
        "flags": {
            "allUVSets": {
                "docstring": "This flag when used in in a query will return a list of all of the uv set names"
            }, 
            "allUVSetsIndices": {
                "docstring": "This flag when queried will return a list of the logical plug indices of all the uv sets in the sparse uv set array."
            }, 
            "allUVSetsWithCount": {
                "docstring": "This flag when used in a query will return a list of all of the uv set family names, with a count appended to the perInstance sets indicating the number of instances in the uv set shared by the specified or selected shape."
            }, 
            "copy": {
                "docstring": "This flag when used will result in the copying of the uv set corresponding to name specified with the uvSet flag to the uvset corresponding to the name specified with the newUVSet flag"
            }, 
            "create": {
                "docstring": "This flag when used will result in the creation of an empty uv set corresponding to the name specified with the uvSet flag. If a uvSet with that name already exists, then no new uv set will be created."
            }, 
            "currentLastUVSet": {
                "docstring": "This flag when used will set the current uv set that the object needs to work on, to be the last uv set added to the object. If no uv set exists for the object, then no uv set name will be returned."
            }, 
            "currentPerInstanceUVSet": {
                "docstring": "This is a query-only flag for use when the current uv set is a per-instance uv set family. This returns the member of the set family that corresponds to the currently select instance.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "currentUVSet": {
                "docstring": "This flag when used will set the current uv set that the object needs to work on, to be the uv set corresponding to the name specified with the uvSet flag. This does require that a uvSet with the specified name exist. When queried, this returns the current uv set."
            }, 
            "delete": {
                "docstring": "This flag when used will result in the deletion of the uv set corresponding to the name specified with the uvSet flag."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "newUVSet": {
                "docstring": "Specifies the name that the uv set corresponding to the name specified with the uvSet flag, needs to be renamed to."
            }, 
            "perInstance": {
                "docstring": "This flag can be used in conjunction with the create flag to indicate whether or not the uv set is per-instance. When you create a per-instance uv set, the set will be applied as shared between all selected instances of the shape unless the unshared flag is used. The perInstance flag can be used in query mode with the currentUVSet or allUVSets flag to indicate that the set family names (i.e. not containing instance identifiers) will be returned by the query. In query mode, this flag can accept a value."
            }, 
            "projections": {
                "docstring": "This flag when used in a query will return a list of polygon uv projection node names. The order of the list is from most-recently-applied to least-recently-applied."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rename": {
                "docstring": "This flag when used will result in the renaming of the uv set corresponding to the name specified with the uvSet flag to the name specified using the newUVSet flag."
            }, 
            "shareInstances": {
                "docstring": "This flag is used to modify the sharing of per-instance uv sets within a given uv set family so that all selected instances share the specified set. In query mode, it returns a list of the instances that share the set specified by the uvSet flag."
            }, 
            "unshared": {
                "docstring": "This flag can be used in conjunction with the create and perInstance flags to indicate that the newly created per-instance set should be created with a separate set per instance."
            }, 
            "uvSet": {
                "docstring": "Specifies the name of the uv set that this command needs to work on. This flag has to be specified for this command to do anything meaningful other than query the current uv set. "
            }
        }
    }, 
    "polyUnite": {
        "description": "This command creates a new poly as an union of a list of polys If no objects are specified in the command line, then the objects from the active list are used. ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "mergeUVSets": {
                "docstring": "Specify how UV sets will be merged on the output mesh. The choices are 0 | 1 | 2. 0 = Do not merge. Each UV set on each mesh will become a new UV set in the output. 1 = Merge by name. UV sets with the same name will be merged. 2 = Merge by UV links. UV sets will be merged so that UV linking on the input meshes continues to work. The default is 1 (merge by name).Common flags"
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node (where applicable).Common flags"
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "polyVertexNormalCtx": {
        "description": "", 
        "flags": {
            "deformmode": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "lockmode": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "relativemode": {
                "docstring": ""
            }, 
            "rotatemode": {
                "docstring": ""
            }
        }
    }, 
    "polyWarpImage": {
        "description": "", 
        "flags": {
            "background": {
                "docstring": ""
            }, 
            "bilinear": {
                "docstring": ""
            }, 
            "fileFormat": {
                "docstring": ""
            }, 
            "inputName": {
                "docstring": ""
            }, 
            "inputUvSetName": {
                "docstring": ""
            }, 
            "noAlpha": {
                "docstring": ""
            }, 
            "outputName": {
                "docstring": ""
            }, 
            "outputUvSetName": {
                "docstring": ""
            }, 
            "overwrite": {
                "docstring": ""
            }, 
            "tiled": {
                "docstring": ""
            }, 
            "xResolution": {
                "docstring": ""
            }, 
            "yResolution": {
                "docstring": ""
            }
        }
    }, 
    "polyWedgeFace": {
        "description": "Extrude faces about an axis. The axis is the average of all the selected edges. If the edges are not aligned, the wedge may not look intuitive. To separately wedge faces about different wedge axes, the command should be issued as many times as the wedge axes. (as in the second example) ", 
        "flags": {
            "caching": {
                "docstring": "Toggle caching for all attributes so that no recomputation is needed"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.Note:If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain."
            }, 
            "divisions": {
                "docstring": "This flag specifies the number of subdivisions along the extrusion."
            }, 
            "edge": {
                "docstring": "This flag specifies the edgeId, that should be used to perform the wedge about. Multiple edges can be specified. The wedge operation is performed about an axis which is the average of all the edges. It is recommended that only colinear edges are used, otherwise the result may not look intuitive."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Give a name to the resulting node."
            }, 
            "nodeState": {
                "docstring": "Defines how to evaluate the node. 0: Normal1: PassThrough2: Blocking3: Internally disabled. Will return to Normal state when enabled4: Internally disabled. Will return to PassThrough state when enabled5: Internally disabled. Will return to Blocking state when enabledFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "wedgeAngle": {
                "docstring": "This flag specifies the angle of rotation."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is off.Q: When queried, this flag returns an int.Common flags"
            }
        }
    }, 
    "popupMenu": {
        "description": "This command creates a popup menu and attaches it to the current control if no parent is specified. The popup menu is posted with the right mouse button by default. Popup menus can be added to any kind of control, however, on some widgets, only the standard menu button (3rd mouse button) can be used to trigger popup menus. This is to meet generally accepted UI guidelines that assign the 3rd mouse button and only this one to popup menus, and also to prevent unexpected behavior of controls like text fields, that expect 1st and 2nd button to be reserved for contextual operations like text or item selection... ", 
        "flags": {
            "allowOptionBoxes": {
                "docstring": "Indicate whether the menu will be able to support option box menu items. An error results if an option box item is added to a menu that doesn't allow them. This flag may be queried and must be specified when the popup menu is created. The default value is false."
            }, 
            "altModifier": {
                "docstring": "Specify this flag if the Alt modifier must be pressed when posting the popup menu."
            }, 
            "button": {
                "docstring": "Indicate which button posts the popup menu. Valid values range from 1 to 3 where 1 is the left most button on the mouse."
            }, 
            "ctrlModifier": {
                "docstring": "Specify this flag if the Cntl modifier must be pressed when posting the popup menu."
            }, 
            "defineTemplate": {
                "docstring": ""
            }, 
            "deleteAllItems": {
                "docstring": "Delete all the items in this menu.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "itemArray": {
                "docstring": "Return string array of the menu item names."
            }, 
            "markingMenu": {
                "docstring": "Set the marking menu state of this popup menu."
            }, 
            "numberOfItems": {
                "docstring": "Return number of items in the menu."
            }, 
            "parent": {
                "docstring": ""
            }, 
            "postMenuCommand": {
                "docstring": "Specify a script to be executed when the popup menu is about to be shown."
            }, 
            "postMenuCommandOnce": {
                "docstring": "Indicate the -pmc/postMenuCommandshould only be invoked once. Default value is false, ie. the -pmc/postMenuCommandis invoked every time the popup menu is shown."
            }, 
            "query": {
                "docstring": ""
            }, 
            "shiftModifier": {
                "docstring": "Specify this flag if the Shift modifier must be pressed when posting the popup menu."
            }, 
            "useTemplate": {
                "docstring": ""
            }
        }
    }, 
    "pose": {
        "description": "This command is used to create character poses. ", 
        "flags": {
            "allPoses": {
                "docstring": "This flag is used to query all the poses in the scene.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "apply": {
                "docstring": "This flag is used in conjunction with the name flag to specify a pose should be applied to the character."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "In create mode, specify the pose name. In query mode, return a list of all the poses for the character. In apply mode, specify the pose to be applied."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "preloadRefEd": {
        "description": "This creates an editor for managing which references will be read in (loaded) and which deferred (unloaded) upon opening a file. ", 
        "flags": {
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectCommand": {
                "docstring": ""
            }, 
            "selectFileNode": {
                "docstring": "Query the currently selected load setting. Returns the id of the currently selected load setting. This id can be used as an argument to the selLoadSettings command.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "progressBar": {
        "description": "Creates a progress bar control that graphically fills in as its progress value increases. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "beginProgress": {
                "docstring": "Only valid for the main progress barShows the main progress bar (normally in the Help Line). This is normally issued through MEL when a length computation is about to occur."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "endProgress": {
                "docstring": "Only valid for the main progress barHides the progress bar. No other flags can be used at the same time. This is normally issued through MEL in response to the -ic/isCancelled flag being set or if the progress value reaches its maximum.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isCancelled": {
                "docstring": "Returns true if the user has tried to cancel the operation. Returns false otherwise."
            }, 
            "isInterruptable": {
                "docstring": "Only valid for the main progress barReturns true if the isCancelled flag should respond to attempts to cancel the operation. Setting this to true will put make the help line display message to the user indicating that they can cancel the operation."
            }, 
            "isMainProgressBar": {
                "docstring": "Determines whether this progressBar is used to show the progress of all basic operations such as Open/Save file.The main progressBar behaves very differently, in that it only shows itself when there is an ongoing basic operation.Defaults to false, and only one progress bar will be recognized as the \"main\" one."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxValue": {
                "docstring": "The maximum or \"ending\" value of the progress indicator. If the progress value is greater than the -max/maxValue, the progress value will be set to the maximum. Default value is 100."
            }, 
            "minValue": {
                "docstring": "The minimum or \"starting\" value of the progress indicator. If the progress value is less than the -min/minValue, the progress value will be set to the minimum. Default value is 0."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "progress": {
                "docstring": "The amount of progress currently shown on the control. The value will always be between min and max. Default is equal to the minimum when the control is created."
            }, 
            "query": {
                "docstring": ""
            }, 
            "status": {
                "docstring": "Only valid for the main progress barSets the contents of the helpLine control when the progressBar is showing. Use this instead of setting the helpLine directly because this will force a graphical refresh before returning."
            }, 
            "step": {
                "docstring": "Increments the -pr/progress value by the amount specified."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "progressWindow": {
        "description": "The progressWindow command creates a window containing a status message, a graphical progress gauge, and optionally a \"Hit ESC to Cancel\" label for interruptable operations. Only one progress window is allowed on screen at a time. While the window is visible, the busy cursor is shown. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "endProgress": {
                "docstring": "Terminates the progress window. No other flags can be used at the same time. This is normally issued through MEL in response to the -ic/isCancelled flag being set or if the progress value reaches its maximum.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "isCancelled": {
                "docstring": "Returns true if the user has tried to cancel the operation. Returns false otherwise."
            }, 
            "isInterruptable": {
                "docstring": "Returns true if the progress window should respond to attempts to cancel the operation. The cancel button is disabled if this is set to true."
            }, 
            "maxValue": {
                "docstring": "The maximum or \"ending\" value of the progress indicator. If the progress value is greater than the -max/maxValue, the progress value will be set to the maximum. Default value is 100."
            }, 
            "minValue": {
                "docstring": "The minimum or \"starting\" value of the progress indicator. If the progress value is less than the -min/minValue, the progress value will be set to the minimum. Default value is 0."
            }, 
            "progress": {
                "docstring": "The amount of progress currently shown on the control. The value will always be between min and max. Default is equal to the minimum when the control is created."
            }, 
            "query": {
                "docstring": ""
            }, 
            "status": {
                "docstring": "The status text appearing above the progress gauge."
            }, 
            "step": {
                "docstring": "Increments the -pr/progress value by the amount specified."
            }, 
            "title": {
                "docstring": "The window title."
            }
        }
    }, 
    "projectCurve": {
        "description": "The projectCurve command creates curves on surface where all selected curves project onto the selected surfaces. Projection can be done using the surface normals or the user can specify the vector to project along. Note: the user does not have to specify the curves and surfaces in any particular order in the command line. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "direction": {
                "docstring": "Direction of projection. Available only if useNormal is false."
            }, 
            "directionX": {
                "docstring": "X direction of projection.Default:0.0"
            }, 
            "directionY": {
                "docstring": "Y direction of projection.Default:0.0"
            }, 
            "directionZ": {
                "docstring": "Z direction of projection.Default:1.0"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curveFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "tolerance": {
                "docstring": "Tolerance to fit to.Default:0.01"
            }, 
            "useNormal": {
                "docstring": "True if the surface normal is to be used and false if the direction vector should be used instead.Default:falseAdvanced flags"
            }
        }
    }, 
    "projectTangent": {
        "description": "The project tangent command is used to align (for tangents) a curve to two other curves or a surface. A surface isoparm may be selected to define the direction (U or V) to align to. The end of the curve must intersect with these other objects. Curvature continuity may also be applied if required. Tangent continuity means the end of the curve is modified to be tangent at the point it meets the other objects. Curvature continuity means the end of the curve is modified to be curvature continuous as well as tangent. If the normal tangent direction is used, the curvature continuity and rotation do not apply. Also, curvature continuity is only available if align to a surface (not with 2 curves). ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curvature": {
                "docstring": "Curvature continuity is on if true and off otherwise.Default:false"
            }, 
            "curvatureScale": {
                "docstring": "Curvature scale applied to curvature of curve to align. Available if curvature option is true.Default:0.0"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "ignoreEdges": {
                "docstring": "If false, use the tangents of the trim edge curves if the surface is trimmed. If true, use the tangents of the underlying surface in the U/V directions.Default:falseAdvanced flags"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reverseTangent": {
                "docstring": "Reverse the tangent direction if true and leave it the way it is if false.Default:false"
            }, 
            "rotate": {
                "docstring": "Amount by which the tangent of the curve to align will be rotated. Available only if the normal direction (3) is not used for tangentDirection.Default:0.0"
            }, 
            "tangentDirection": {
                "docstring": "Tangent align direction type legal values: 1=u direction (of surface or use first curve), 2=v direction (of surface or use second curve), 3=normal direction (at point of intersection).Default:1"
            }, 
            "tangentScale": {
                "docstring": "Tangent scale applied to tangent of curve to align.Default:1.0"
            }
        }
    }, 
    "projectionContext": {
        "description": "Set the context for projection manips ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "projectionManip": {
        "description": "Various commands to set the manipulator to interesting positions. In query mode, return type is based on queried flag.", 
        "flags": {
            "fitBBox": {
                "docstring": "Fit the projection manipulator size and position to the shading group bounding box. The orientation is not modified."
            }, 
            "projType": {
                "docstring": "Set the projection type to the given value. Projection type values are: 1 = planar.2 = spherical.3 = cylindrical.4 = ball.5 = cubic.6 = triplanar.7 = concentric.8 = camera."
            }, 
            "query": {
                "docstring": ""
            }, 
            "switchType": {
                "docstring": "Loop over the allowed types. If the hardware shading is on, it loops over the hardware shadeable types (planar, cylindrical, spherical), otherwise, it loops over all the types. If there is no given value, it loops over the different projection types.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "promptDialog": {
        "description": "The promptDialog command creates a modal dialog with a message to the user, a text field in which the user may enter a response, and a variable number of buttons to dismiss the dialog. The dialog is dismissed when the user presses any button or chooses the close item from the window menu. In the case where a button is pressed then the name of the button selected is returned. If the dialog is dismissed via the close item then the string returned is specified by the -ds/dismissStringflag. The default behaviour when no arguments are specified is to create an empty single button dialog. To obtain the text entered by the user simply query the -tx/textflag. ", 
        "flags": {
            "backgroundColor": {
                "docstring": "The background color of the dialog. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0. (Windows only flag)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "button": {
                "docstring": "Create a button with the given string as it's text."
            }, 
            "cancelButton": {
                "docstring": "The cancel button is activated by pressing the escape key. Note that this flag does not create a button, it simply indicates which button created via the -b/buttonflag shall respond to the escape key."
            }, 
            "defaultButton": {
                "docstring": "The default button is activated by pressing the enter key. Note that this flag does not create a button, it simply indicates which button created via the -b/buttonflag shall respond to the enter key."
            }, 
            "dismissString": {
                "docstring": "The string returned when the user selects the 'Close' item from the Window Manager menu. If this flag is not set then the string \"dismiss\" is returned."
            }, 
            "message": {
                "docstring": "The message text appearing in the dialog."
            }, 
            "messageAlign": {
                "docstring": "Align the message left, center, or right."
            }, 
            "parent": {
                "docstring": "Specify the parent window for the dialog. The dialog will be centered on this window and raise and lower with it's parent. By default, the dialog is not parented to a particular window and is simply centered on the screen."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scrollableField": {
                "docstring": "By default a single line text field is used in the dialog. Specify true for a multi-line scroll field."
            }, 
            "style": {
                "docstring": "Specify the type of input expected in the input field. Vaid input types are \"integer\" \"float\" \"text\". If this flag is not specified, we assume the input type is \"text\"."
            }, 
            "text": {
                "docstring": "The field text."
            }, 
            "title": {
                "docstring": "The dialog title."
            }
        }
    }, 
    "propModCtx": {
        "description": "Controls the proportional move context. ", 
        "flags": {
            "animCurve": {
                "docstring": "Name of the anim curve to use as a drop-off curve. Only the 0 -side of the curve will be used and the distance will be mapped to \"seconds\". The profile of the curve will be used as the profile for propmod function."
            }, 
            "animCurveFalloff": {
                "docstring": "The profile of the curve will be used as the profile for propmod function in both U and V. This will be scaled in U, V according to the paramters provided. The ratio of the U, V scaling parameters will dictate the footprint of the fuction while the curve itself provides the magnitudes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "animCurveParam": {
                "docstring": "Name of the anim curve to use as a drop-off curve. Only the 0 -side of the curve will be used and the distance will be mapped to \"seconds\", where 1 second maps to 0.01 units in parametric space."
            }, 
            "direction": {
                "docstring": "Direction along which to compute the distance for the distance based drop-off functions. The default is (1 1 1)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "linear": {
                "docstring": "If using linear drop-off function, this is its slope. The default of -0.1 means the point at the locator moves with it and the point 10 units away doesn't move at all."
            }, 
            "linearParam": {
                "docstring": "If using parametric linear drop-off function, these specify its limits along the U and V directions."
            }, 
            "nurbsCurve": {
                "docstring": "Name of the nurbs curve to use as a drop-off curve. The closest point distance would be used as the drop off percentage."
            }, 
            "powerCutoff": {
                "docstring": "If using the power drop-off function, this is its distance cutoff value. The default is 10.0."
            }, 
            "powerCutoffParam": {
                "docstring": "If using the power drop-off function, these specify one of it's limits, 0 for U, and 1 and V. The default cutoff is 10.0."
            }, 
            "powerDegree": {
                "docstring": "If using the power drop-off function, this is its degree. The default is 3."
            }, 
            "powerDegreeParam": {
                "docstring": "If using the power drop-off function, this is its degree. The default is 3."
            }, 
            "query": {
                "docstring": ""
            }, 
            "script": {
                "docstring": "The name of the script to use to compute the drop-off. The script takes 6 floats as input - first 3 are the position of the move locator, the next 3 the position of the point to be manipulated. The script should return a drop-off coefficient which could be negative or zero."
            }, 
            "scriptParam": {
                "docstring": "The name of the script to use to compute the drop-off. The script takes 4 floats as input - first 2 are the parametric position of the move locator, the next 2 the parametric position of the point to be manipulated. The script should return a drop-off coefficient which could be negative or zero."
            }, 
            "type": {
                "docstring": "Choose the type for the drop-off function. Legal values are 1 for linear, 2 for power, 3 for script, 4 for anim curve. The default is 1."
            }, 
            "worldspace": {
                "docstring": "Set the space in which the tool works. True for world space, false for parametric space."
            }
        }
    }, 
    "propMove": {
        "description": "Performs a proportional translate, scale or rotate operation on any number of objects. The percentages to rotate, scale or translate by can be specified using either the -p flags or -px, -py, -pz flags. Each selected object must have a corresponding -p or -px, -py, -pz flag. The rotate, scale or translate performed is relative. ", 
        "flags": {
            "percent": {
                "docstring": "The percentage effect that the specified x,y,z has on an object. This flag must be specified once for each object, ie. if there are 4 objects specified, there must be 4 \"-p\" flags, (otherwise a percentage of 1.0 will be used). This flag generally has a range between 0.0 and 1.0, but can be any float value."
            }, 
            "percentX": {
                "docstring": "The percentage effect that the specified x has on an object. This flag is specified one per object. The value ranges between 0.0 and 1.0, but can be any float value. If the -p flag has been specified, this flag usage is invalid."
            }, 
            "percentY": {
                "docstring": "The percentage effect that the specified y has on an object. This flag is specified one per object. The value ranges between 0.0 and 1.0, but can be any float value. If the -p flag has been specified, this flag usage is invalid."
            }, 
            "percentZ": {
                "docstring": "The percentage effect that the specified z has on an object. This flag is specified one per object. The value ranges between 0.0 and 1.0, but can be any float value. If the -p flag has been specified, this flag usage is invalid."
            }, 
            "pivot": {
                "docstring": "Specify the pivot about which a rotation or scale will occur. The change in pivot lasts only as long as the current 'propMove' command, and so must be used in conjunction with one of the above move flags for any effect to be noticeable.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "rotate": {
                "docstring": "Proportionally rotate each object by the given angles. The rotation values are scaled by the percentage specified by that object's corresponding \"-percent\" flag. All angles are in degrees. The rotation is about the pivot specified by the \"-pivot\" flag, or (0, 0, 0) if the \"-pivot\" flag is not present."
            }, 
            "scale": {
                "docstring": "Proportionally scale each object by the given amounts. The scale values are scaled by the percentage specified by that object's corresponding \"-percent\" flag. The position and size of each object is measured relative to the pivot specified by the \"-pivot\" flag, and defaults to each object's individual pivot. In the case of control vertices, or some other object component, the default is the parent object's pivot."
            }, 
            "translate": {
                "docstring": "Proportionally translate each object by the given amounts. The translation values are scaled by the percentage specified by that object's corresponding \"-percent\" flag. The \"-pivot\" flag has no effect on translation."
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "psdChannelOutliner": {
        "description": "Create a psdChannelOutliner control which is capable of displaying a tree structure upto one level. ", 
        "flags": {
            "addChild": {
                "docstring": "This flag should be used along with the \"-psdParent/ppa\" flag. A string item gets added as a child to the parent specifed with \"-psdParent/ppa\" flag. The next string assigns an associated image name."
            }, 
            "allItems": {
                "docstring": "Returns all the items in the form parent.child."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "doubleClickCommand": {
                "docstring": "Specify the command to be executed when an item is double clicked."
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfItems": {
                "docstring": "Total number of items in the control.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "psdParent": {
                "docstring": "Adds an item string to the controls which is treated as parent."
            }, 
            "removeAll": {
                "docstring": "Removes all the items from the control."
            }, 
            "removeChild": {
                "docstring": "Deletes the particular child of the parent as specifed in \"-psdParent/ppa\" flag."
            }, 
            "selectCommand": {
                "docstring": "Specify the command to be executed when an item is selected."
            }, 
            "selectItem": {
                "docstring": "Returns the selected items."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "psdConvSolidTxOptions": {
        "description": "", 
        "flags": {}
    }, 
    "psdEditTextureFile": {
        "description": "Edits the existing PSD file. Addition and deletion of the channels (layer sets) are supported. ", 
        "flags": {
            "addChannel": {
                "docstring": "Adds an empty layer set with the given name to a already existing PSD file."
            }, 
            "addChannelColor": {
                "docstring": "(M) Specifies the filled color of the layer which is created in a layer set given by the layer name."
            }, 
            "addChannelImage": {
                "docstring": "(M) Specifies the image file name whose image needs to be added as a layer to a given layer set which is the first string."
            }, 
            "deleteChannel": {
                "docstring": "(M) Deletes the channels (layer sets) from a PSD file. This is a multiuse flag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "psdFileName": {
                "docstring": "PSD file name."
            }, 
            "snapShotImage": {
                "docstring": "Image file name on the disk containing UV snapshot / reference image."
            }, 
            "uvSnapPostionTop": {
                "docstring": "Specifies the position of UV snapshot image layer in the PSD file. \"True\" positions this layer at the top and \"False\" positions the layer at the bottom next to the background layer in the PSD file"
            }
        }
    }, 
    "psdExport": {
        "description": "Writes the Photoshop file layer set into different formats. The output file depth (bit per channel ) can be different from that of the input. If the input is 16 bpc and output is 8 bpc, there will be data loss. In query mode, return type is based on queried flag.", 
        "flags": {
            "alphaChannelIdx": {
                "docstring": "Index of the alpha channel to output, if not supplied, writes out the default alpha channel. The index is zero based. This is useful to write out specific alpha channels available as \"Additional Alpha Channels\" of Photoshop."
            }, 
            "bytesPerChannel": {
                "docstring": "Output file depth. Any of these keyword: 0 for choosing depth based on input1 for 8 bits per channel2 for 16 bits per channelDefault is 0."
            }, 
            "emptyLayerSet": {
                "docstring": "Option to check if the given layer set is empty or not. This should be used in query mode and input file name and layer set names should be specified.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "format": {
                "docstring": "Output file format. Any of these keyword: \"iff\", \"sgi\", \"pic\", \"tif\", \"als\", \"gif\", \"rla\", \"jpg\" Default is iff."
            }, 
            "layerName": {
                "docstring": "Name of the layer to output."
            }, 
            "layerSetName": {
                "docstring": "Name of the layer set to output, if not supplied, writes out the Composite image. "
            }, 
            "outFileName": {
                "docstring": "Name(with path) of the output file."
            }, 
            "preMultiplyAlpha": {
                "docstring": "Option to multiply RGB colors with alpha values. If (r,g,b,a) is the value of pixel, it will be changed to (r\\*a, g\\*a, b\\*a, a) when this flag is used."
            }, 
            "psdFileName": {
                "docstring": "Name(with path) of the input Photoshop file. "
            }
        }
    }, 
    "psdTextureFile": {
        "description": "Creates a Photoshop file with UVSnap shot image and the layer set names as the input. ", 
        "flags": {
            "channelRGB": {
                "docstring": "(M) Layer set names, index, red, green and blue values are given as input. Using this flag, the layers created can be filled with specified colors. This is a multi use flag. The index specifies the placement order of layer sets in the created file."
            }, 
            "channels": {
                "docstring": "(M) Layer set names and index are given as input. This is a multi use flag. A layer set with the given name will be created. The second argument is the index which specifies the placement order of layer sets in the created file. The third argument is a boolean, if \"true\" a layer is created inside the layer set , \"false\" creates an empty layer set"
            }, 
            "imageFileName": {
                "docstring": "Image file name, Layerset name and index. The image in the file will be transferred to layer set specified. The index specifies the placement order of layer sets in the created psd file. The image file specified can be in any of the formats supported by maya (ex. iff, jpg, gif, tif etc.)"
            }, 
            "psdFileName": {
                "docstring": "PSD file name."
            }, 
            "snapShotImageName": {
                "docstring": "Image file name on the disk containing UV snapshot / reference image."
            }, 
            "uvSnapPostionTop": {
                "docstring": "Specifies the position of UV snapshot image layer in the PSD file. \"True\" positions this layer at the top and \"False\" positions the layer at the bottom next to the background layer in the PSD fileFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "xResolution": {
                "docstring": "X - resolution of the image."
            }, 
            "yResolution": {
                "docstring": "Y - resolution of the image."
            }
        }
    }, 
    "python": {
        "description": "", 
        "flags": {}
    }, 
    "querySubdiv": {
        "description": "Queries a subdivision surface based on a set of query parameters and updates the selection list with the results. ", 
        "flags": {
            "action": {
                "docstring": "Specifies the query parameter: 1 = find all tweaked verticies at level 2 = find all sharpened vertices at level 3 = find all sharpened edges at level 4 = find all faces at level If the attribute \"level\" is not specified then the query is applied to the current component display level. If the attribute level is specified then the query is applied to that level, either absolute or relative to the current level based on the \"relative\" flag state."
            }, 
            "level": {
                "docstring": "Specify the level of the subdivision surface on which to perform the operation."
            }, 
            "relative": {
                "docstring": "If set, level flag refers to the level relative to the current component display level.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "quit": {
        "description": "This command is used to exit the application. ", 
        "flags": {
            "abort": {
                "docstring": "Will quit without saving like -force, but will also prevent preferences/hotkeys/colors from being saved. Use at your own risk.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "exitCode": {
                "docstring": "Specifies the exit code to be returned once the application exits. The default exit code is 0."
            }, 
            "force": {
                "docstring": "If specified, this flag will force a quit without saving or prompting for saving changes. Use at your own risk."
            }
        }
    }, 
    "radial": {
        "description": "A radial field pushes objects directly towards or directly away from it, like a magnet. The transform is the associated dependency node. Use connectDynamic to cause the field to affect a dynamic object. If fields are created, this command returns the names of each of the fields. If a field was queried, the results of the query are returned. If a field was edited, the field name is returned. If object names are provided or the active selection list is non-empty, the command creates a field for every object in the list and calls addDynamic to add it to the object. If the list is empty, the command defaults to -pos 0 0 0. Setting the -pos flag with objects named on the command line is an error. ", 
        "flags": {
            "attenuation": {
                "docstring": "Attentuation rate of field"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "magnitude": {
                "docstring": "Strength of field."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which field is exerted. -1 indicates that the field has no maximum distance."
            }, 
            "name": {
                "docstring": "name of field"
            }, 
            "perVertex": {
                "docstring": "Per-vertex application. If this flag is set true, then each individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical copy of the force field. If this flag is set to false, then the froce is exerted only from the geometric center of the set of points."
            }, 
            "position": {
                "docstring": "Position in space where you want to place a field. The field then emanates from this position in space rather than from an object. Note that you can both use -pos (creating a field at a position) and also provide object names."
            }, 
            "query": {
                "docstring": ""
            }, 
            "torusSectionRadius": {
                "docstring": ""
            }, 
            "type": {
                "docstring": "Type of radial field (0 - 1). This controls the algorithm by which the field is attenuated. Type 1, provided for backward compatibility, specifies the same algorithm as Alias | Wavefront Dynamation. A value between 0 and 1 yields a linear blend.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "volumeExclusion": {
                "docstring": ""
            }, 
            "volumeOffset": {
                "docstring": ""
            }, 
            "volumeShape": {
                "docstring": ""
            }, 
            "volumeSweep": {
                "docstring": ""
            }
        }
    }, 
    "radioButton": {
        "description": "This command creates a radio button that is added to the most recently created radio collection if the -cl/collectionflag is not used. ", 
        "flags": {
            "align": {
                "docstring": "This flag is obsolete and should no longer be used. The radio button label will always be left-aligned."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the radio button's state is changed. Note that this flag should not be used in conjunction with onCommand and offCommand. That is, one should either use changeCommand and test the state of the radio button from inside the callback, or use onCommand and offCommand as separate callbacks.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "collection": {
                "docstring": "To explicitly add a radio button to a collection of radio buttons specify the name of the radio collection."
            }, 
            "data": {
                "docstring": "Internal data associated with the radio button."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "The edit state of the radio button. By default, this flag is set to true and the radio button value may be changed by clicking on it. If false then the radio button is 'read only' and can not be clicked on. The value of the radio button can always be changed with the -sl/selectflag regardless of the state of the -ed/editableflag."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The label text. The default label is the name of the control."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "offCommand": {
                "docstring": "Command executed when the radio button is turned off."
            }, 
            "onCommand": {
                "docstring": "Command executed when the radio button is turned on."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "recomputeSize": {
                "docstring": "If true then the control will recompute it's size to just fit the size of the label. If false then the control size will remain fixed as you change the size of the label. The default value of this flag is true."
            }, 
            "select": {
                "docstring": "Select the radio button."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "radioButtonGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates from one to four radio buttons in a single row. By default the radio buttons will share a single collection, but they can also share the collection of another radio button group. The buttons can also have an optional text label. TelfBaseGrpCmd.cpp ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "annotation1": {
                "docstring": "specifies the tooptip of the first radiobutton"
            }, 
            "annotation2": {
                "docstring": "specifies the tooptip of the second radiobutton"
            }, 
            "annotation3": {
                "docstring": "specifies the tooptip of the third radiobutton"
            }, 
            "annotation4": {
                "docstring": "specifies the tooptip of the fourth radiobutton"
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the group changes state. Note that this flag should not be used in conjunction with onCommand and offCommand. That is, one should either use changeCommand and test the state of a radio button from inside the callback, or use onCommand and offCommand as separate callbacks."
            }, 
            "changeCommand1": {
                "docstring": ""
            }, 
            "changeCommand2": {
                "docstring": ""
            }, 
            "changeCommand3": {
                "docstring": ""
            }, 
            "changeCommand4": {
                "docstring": "Specify a changed state command for each respective radio button."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "data1": {
                "docstring": ""
            }, 
            "data2": {
                "docstring": ""
            }, 
            "data3": {
                "docstring": ""
            }, 
            "data4": {
                "docstring": "Internal data associated with each radio button."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "The edit state of the group. By default, this flag is set to true and the radio button values may be changed by clicking on them. If false then the radio buttons are 'read only' and can not be clicked on. The value of the radio button can always be changed with the sl/selectflags regardless of the state of the ed/editableflag."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enable1": {
                "docstring": ""
            }, 
            "enable2": {
                "docstring": ""
            }, 
            "enable3": {
                "docstring": ""
            }, 
            "enable4": {
                "docstring": "Enable state of the individual radio buttons."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "When present on creation an optional text label will be built with the group. The string specifes the label text."
            }, 
            "label1": {
                "docstring": ""
            }, 
            "label2": {
                "docstring": ""
            }, 
            "label3": {
                "docstring": ""
            }, 
            "label4": {
                "docstring": "Specify label strings for the respective radio buttons in the group."
            }, 
            "labelAnnotation": {
                "docstring": "when present on creation an optional text label will be built with the group . The string specifies the label tooltip"
            }, 
            "labelArray2": {
                "docstring": ""
            }, 
            "labelArray3": {
                "docstring": ""
            }, 
            "labelArray4": {
                "docstring": "Specify multiple labels in a single flag. These flags are ignored if the number of radio buttons doesn't match."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "numberOfRadioButtons": {
                "docstring": "Number of radio buttons in the group (1 - 4)."
            }, 
            "offCommand": {
                "docstring": "Command executed when any radio button turns off."
            }, 
            "offCommand1": {
                "docstring": ""
            }, 
            "offCommand2": {
                "docstring": ""
            }, 
            "offCommand3": {
                "docstring": ""
            }, 
            "offCommand4": {
                "docstring": "Off command for each respective radio button."
            }, 
            "onCommand": {
                "docstring": "Command executed when any radio button turns on."
            }, 
            "onCommand1": {
                "docstring": ""
            }, 
            "onCommand2": {
                "docstring": ""
            }, 
            "onCommand3": {
                "docstring": ""
            }, 
            "onCommand4": {
                "docstring": "On command for each respective radio button."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "select": {
                "docstring": "Selected radio button. The argument is a 1 based integer."
            }, 
            "shareCollection": {
                "docstring": "Specify the radioButtonGrp that this radio group is to be associated with. By default the radio group will be a separate collection."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "vertical": {
                "docstring": "Whether the orientation of the radio buttons in this group are horizontal (default) or vertical.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "radioCollection": {
        "description": "This command creates a radio button collection. Collections are parented to the current default layout if no parent is specified with the -p/parentflag. As children of the layout they will be deleted when the layout is deleted. Collections may also span more than one window if the -gl/globalflag is used. In this case the collection has no parent and must be explicitly deleted with the deleteUIcommand when it is no longer wanted. ", 
        "flags": {
            "collectionItemArray": {
                "docstring": "Return a string list giving the long names of all the items in this collection.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "gl": {
                "docstring": "Set the collection to have no parent layout. Global collections must be explicitly deleted."
            }, 
            "numberOfCollectionItems": {
                "docstring": "Return the number of items in this collection."
            }, 
            "parent": {
                "docstring": "The parent of the collection. The collection will be deleted along with the parent."
            }, 
            "query": {
                "docstring": ""
            }, 
            "select": {
                "docstring": "Select the specified collection item. If queried will return the name of the currently selected collection item."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "radioMenuItemCollection": {
        "description": "This command creates a radioMenuItemCollection. Attach radio menu items to radio menu item collection objects to get radio button behaviour. Radio menu item collections will be parented to the current menu if no parent is specified with the -p/parentflag. As children of the menu they will be deleted when the menu is deleted. Collections may also span more than one menu if the -g/globalflag is used. In this case the collection has no parent menu and must be explicitly deleted with the deleteUIcommand when it is no longer wanted. ", 
        "flags": {
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "gl": {
                "docstring": "Set the collection to have no parent menu. Global collections must be explicitly deleted."
            }, 
            "parent": {
                "docstring": "The parent of the collection. The collection will be deleted along with the parent.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "rampColorPort": {
        "description": "This command creates a control that displays an image representing the ramp node specified, and supports editing of that node. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "node": {
                "docstring": "Specifies the name of the newRamp texture node this port will represent."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectedColorControl": {
                "docstring": "Set the name of the control (if any) which is to be used to show the color of the currently selected entry in the ramp. This control will automatically update as the user selects different entries in the ramp, and will modify the selected entry if edited. The type of control must be an attrColorSliderGrp."
            }, 
            "selectedPositionControl": {
                "docstring": "Set the name of the control (if any) which is to be used to show the position of the currently selected entry in the ramp. This control will automatically update as the user selects different entries in the ramp, and will modify the selected entry if edited. The type of control must be an attrFieldSliderGrp.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "rampWidget": {
        "description": "", 
        "flags": {}
    }, 
    "rampWidgetAttrless": {
        "description": "", 
        "flags": {}
    }, 
    "rangeControl": {
        "description": "This command creates a control used for displaying and modifying the current playback range. Note: only one master rangeControl may exist. Any addition rangeControls that a user creates are slaved to the master range control widget. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changedCommand": {
                "docstring": "script to be executed when the range changes"
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxRange": {
                "docstring": "Controls the max range displayable in the controlFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "minRange": {
                "docstring": "Controls the max range displayable in the control"
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "widthHeight": {
                "docstring": "Controls the dimensions of the control"
            }
        }
    }, 
    "readPDC": {
        "description": "", 
        "flags": {
            "file": {
                "docstring": ""
            }, 
            "test": {
                "docstring": ""
            }
        }
    }, 
    "readTake": {
        "description": "This action reads a take (.mov) file to a defined device.See also: writeTake, applyTake ", 
        "flags": {
            "angle": {
                "docstring": "Sets the angular unit used in the take. Valid strings are \"deg\", \"degree\", \"rad\", and \"radian\".C: The default is the current user angular unit."
            }, 
            "device": {
                "docstring": "Specifies the device into which the take data is read. This is a required argument."
            }, 
            "frequency": {
                "docstring": "The timestamp is ignored and the specified frequency is used. If timeStamp data is not in the .mov file, the -noTimestamp flag should also be used. This flag resample, instead the data is assumed to be at the specified frequency.C: If the take file does not use time stamps, the default frequency is 60Hz.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "linear": {
                "docstring": "Sets the linear unit used in the take. Valid strings are \"mm\", \"millimeter\", \"cm\", \"centimeter\", \"m\", \"meter\", \"km\", \"kilometer\", \"in\", \"inch\", \"ft\", \"foot\", \"yd\", \"yard\", \"mi\", and \"mile\".C: The default is the current user linear unit."
            }, 
            "noTime": {
                "docstring": "Specifies if the take (.mov) file contains time stamps.C: The default is to assume time stamps are part of the take file."
            }, 
            "take": {
                "docstring": "Reads the specified take file. It is safest to pass the full path to the flag."
            }
        }
    }, 
    "rebuildCurve": {
        "description": "This command rebuilds a curve by modifying its parameterization. In some cases the shape may also change. The rebuildType (-rt) determines how the curve is to be rebuilt. The optional second curve can be used to specify a reference parameterization. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting curve 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - hepticDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endKnots": {
                "docstring": "End conditions for the curve 0 - uniform end knots, 1 - multiple end knots,Default:0"
            }, 
            "fitRebuild": {
                "docstring": "If true use the least squares fit rebuild. Otherwise use the convert method.Default:true"
            }, 
            "keepControlPoints": {
                "docstring": "If true, the CVs will remain the same. This forces uniform parameterization unless rebuildType is matchKnots.Default:false"
            }, 
            "keepEndPoints": {
                "docstring": "If true, keep the endpoints the same.Default:true"
            }, 
            "keepRange": {
                "docstring": "Determine the parameterization for the resulting curve. 0 - reparameterize the resulting curve from 0 to 1, 1 - keep the original curve parameterization, 2 - reparameterize the result from 0 to number of spansDefault:1"
            }, 
            "keepTangents": {
                "docstring": "If true, keep the end tangents the same.Default:true"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "noChanges": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curveFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "rebuildType": {
                "docstring": "How to rebuild the input curve. 0 - uniform, 1 - reduce spans, 2 - match knots, 3 - remove multiple knots, 4 - curvature 5 - rebuild ends 6 - cleanDefault:0"
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)"
            }, 
            "smartSurfaceCurveRebuild": {
                "docstring": "If true, curve on surface is rebuild in 3D and 2D info is keptDefault:falseAdvanced flags"
            }, 
            "spans": {
                "docstring": "The number of spans in resulting curve Used only if rebuildType is uniform.Default:4"
            }, 
            "tolerance": {
                "docstring": "The tolerance with which to rebuild.Default:0.01"
            }
        }
    }, 
    "rebuildSurface": {
        "description": "This command rebuilds a surface by modifying its parameterization. In some cases the shape of the surface may also change. The rebuildType (-rt) attribute determines how the surface is rebuilt. The optional second surface can be used to specify a reference parameterization. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degreeU": {
                "docstring": "The degree of the resulting surface in the u direction 0 - maintain current, 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - hepticDefault:3"
            }, 
            "degreeV": {
                "docstring": "The degree of the resulting surface in the v direction 0 - maintain current, 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - hepticDefault:3"
            }, 
            "direction": {
                "docstring": "The direction in which to rebuild: 0 - U, 1 - V, 2 - Both U and VDefault:2"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endKnots": {
                "docstring": "End conditions for the surface 0 - uniform end knots, 1 - multiple end knots,Default:0"
            }, 
            "fitRebuild": {
                "docstring": "Specify the type of rebuild method to be used: 0 - Convert Classic, the default and original convert method. 1 - Fit using the least squares fit method. 2 - Convert Match, alternate matching convert method. 3 - Convert Grid, uses a grid-based fit algorithm.Default:0Advanced flags"
            }, 
            "keepControlPoints": {
                "docstring": "Use the control points of the input surface. This forces uniform parameterization unless rebuildType is 2 (match knots)Default:false"
            }, 
            "keepCorners": {
                "docstring": "The corners of the resulting surface will not change from the corners of the input surface.Default:true"
            }, 
            "keepRange": {
                "docstring": "Determine the parameterization for the resulting surface. 0 - reparameterize the resulting surface from 0 to 1; 1 - keep the original surface parameterization; 2 - reparameterize the result from 0 to number of spansDefault:1"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "noChanges": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rebuildType": {
                "docstring": "The rebuild type: 0 - uniform, 1 - reduce spans, 2 - match knots, 3 - remove multiple knots, 4 - force non rational 5 - rebuild ends 6 - trim convert (uniform) 7 - into Bezier meshDefault:0"
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)"
            }, 
            "spansU": {
                "docstring": "The number of spans in the u direction in resulting surface. Used only when rebuildType is 0 - uniform. If 0, keep the same number of spans as the original surface.Default:4"
            }, 
            "spansV": {
                "docstring": "The number of spans in the v direction in resulting surface. Used only when rebuildType is 0 - uniform. If 0, keep the same number of spans as the original surface.Default:4"
            }, 
            "tolerance": {
                "docstring": "The tolerance with which to rebuildDefault:0.01"
            }
        }
    }, 
    "recordAttr": {
        "description": "This command sets up an attribute to be recorded. When the record command is executed, any changes to this attribute are recorded. When recording stops these changes are turned into keyframes. If no attributes are specified all attributes of the node are recorded. In query mode, return type is based on queried flag.", 
        "flags": {
            "attribute": {
                "docstring": "specify the attribute to record"
            }, 
            "delete": {
                "docstring": "Do not record the specified attributesFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "recordDevice": {
        "description": "Starts and stops server side device recording. The data is recorded at the device rate. Once recorded, the data may be brought into Maya with the applyTake command.See also: enableDevice, applyTake, readTake, writeTake In query mode, return type is based on queried flag.", 
        "flags": {
            "cleanup": {
                "docstring": "Removes the recorded data from the device.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "data": {
                "docstring": "Specifies if the device has recorded data. If the device is recording at the time of query, the flag will return false.Q: When queried, this flag returns an int."
            }, 
            "device": {
                "docstring": "Specifies which device(s) to start record recording. The listed device(s) will start recording regardless of their record enable state.C: The default is to start recording all devices that are record enabled."
            }, 
            "duration": {
                "docstring": "Duration (in seconds) of the recording. When the duration expires, the device will still be in a recording state and must be told to stop recording.C: The default is 60.Q: When queried, this flag returns an int."
            }, 
            "playback": {
                "docstring": "If any attribute is connected to an animation curve, the animation curve will play back while recording the device(s) including any animation curves attached to attributes being recorded.C: The default is false.Q: When queried, this flag returns an int."
            }, 
            "query": {
                "docstring": ""
            }, 
            "state": {
                "docstring": "Start or stop device recording.C: The default is true.Q: When queried, this flag returns an int."
            }, 
            "wait": {
                "docstring": "If -p/playback specified, wait until playback completion before returning control to the user. This flag is ignored if -p is not used."
            }
        }
    }, 
    "redo": {
        "description": "Takes the most recently undone command from the undo list and redoes it. ", 
        "flags": {}
    }, 
    "reference": {
        "description": "", 
        "flags": {
            "connectionsBroken": {
                "docstring": ""
            }, 
            "connectionsMade": {
                "docstring": ""
            }, 
            "dagPath": {
                "docstring": ""
            }, 
            "editCommand": {
                "docstring": ""
            }, 
            "filename": {
                "docstring": ""
            }, 
            "isNodeReferenced": {
                "docstring": ""
            }, 
            "longName": {
                "docstring": ""
            }, 
            "node": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "referenceNode": {
                "docstring": ""
            }, 
            "shortName": {
                "docstring": ""
            }
        }
    }, 
    "referenceEdit": {
        "description": "Use this command to remove and change the modifications which have been applied to references. A valid commandTarget is either a reference node, a reference file, a node in a reference, or a plug from a reference. Only modifications that have been made from the currently open scene can be changed or removed. The 'referenceQuery -topReference' command can be used to determine what modifications have been made to a given commandTarget. Additionally only unapplied edits will be affected. Edits are unapplied when the node(s) which they affect are unloaded, or when they could not be successfully applied. By default this command only works on failed edits (this can be adjusted using the \"-failedEdits\" and \"-successfulEdits\" flags). Specifying a reference node as the command target is equivalent to specifying every node in the target reference file as a target. In this situation the results may differ depending on whether the target reference is loaded or unloaded. When it is unloaded edits which affect both a node in the target reference and a node in one of its decendant references may be missed (e.g. they may not be removed). Edits which only affect nodes in the target reference or one of its ancestral references, however, should be removed as expected. This is because when a reference is unloaded Maya no longer retains detailed information about which nodes belong to it. NOTE: When specifying a plug it is important to use the appropriate long attribute name. ", 
        "flags": {
            "applyFailedEdits": {
                "docstring": "Attempts to apply any unapplied edits. This flag is useful if previously failing edits have been fixed using the -changeEditTarget flag. This flag can only be used on loaded references. If the command target is a referenced node, the associated reference is used instead."
            }, 
            "changeEditTarget": {
                "docstring": "Used to change a target of the specified edits. This flag takes two parameters: the old target of the edits, and the new target to change it to. The target can either be a node name (\"node\"), a node and attribute name (\"node.attr\"), or just an attribute name (\".attr\"). If an edit currently affects the old target, it will be changed to affect the new target. You should use 'referenceQuery' to determine the format of the edit targets. As an example most edits store the long name of the attribute (e.g. \"translateX\"), so when specifying the old target, a long name must also be used. If the short name is specified (e.g. \"tx\"), chances are the edit won't be retargeted."
            }, 
            "editCommand": {
                "docstring": "This is a secondary flag used to indicate which type of reference edits should be considered by the command. If this flag is not specified all edit types will be included. This flag requires a string parameter. Valid values are: \"addAttr\", \"connectAttr\", \"deleteAttr\", \"disconnectAttr\", \"parent\", and \"setAttr\". In some contexts, this flag may be specified more than once to specify multiple edit types to consider."
            }, 
            "failedEdits": {
                "docstring": "This is a secondary flag used to indicate whether or not failed edits should be acted on (e.g. queried, removed, etc...). A failed edit is an edit which could not be successfully applied the last time its reference was loaded. An edit can fail for a variety of reasons (e.g. the referenced node to which it applies was removed from the referenced file). By default failed edits will be acted on."
            }, 
            "onReferenceNode": {
                "docstring": "This is a secondary flag used to indicate that only those edits which are stored on the indicated reference node should be considered. This flag only supports multiple uses when specified with the \"exportEdits\" command.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "removeEdits": {
                "docstring": "Remove edits which affect the specified unloaded commandTarget."
            }, 
            "successfulEdits": {
                "docstring": "This is a secondary flag used to indicate whether or not successful edits should be acted on (e.g. queried, removed, etc...). A successful edit is any edit which was successfully applied the last time its reference was loaded. This flag will have no affect if the commandTarget is loaded. By default successful edits will not be acted on."
            }
        }
    }, 
    "referenceQuery": {
        "description": "Use this command to find out information about references and referenced nodes. A valid target is either a reference node, a reference file, or a referenced node. Some flags don't require a target, see flag descriptions for more information on what effect this has. When a scene contains multiple levels of file references, those edits which affect a nested reference may be stored on several different reference nodes. For example: A.ma has a reference to B.ma which has a reference to C.ma which contains a poly sphere (pSphere1). If you were to open B.ma and translate the sphere, an edit would be stored on CRN which refers to a node named \"C:pSphere1\". If you were then to open A.ma and parent the sphere, an edit would be stored on BRN which refers to a node named \"B:C:pSphere1\". It is important to note that when querying edits which affect a nested reference, the edits will be returned in the same format that they were applied. In the above example, opening A.ma and querying all edits which affect C.ma, would return two edits a parent edit affecting \"B:C:pSphere1\", and a setAttr edit affecting \"C:pSphere1\". Since there is currently no node named C:pSphere1 (only B:C:pSphere1) care will have to be taken when interpreting the returned information. The same care should be taken when referenced DAG nodes have been parented or instanced. Continuing with the previous example, let's say that you were to open A.ma and, instead of simply parenting pSphere1, you were to instance it. While A.ma is open, \"B:C:pSphere1\" may now be an amibiguous name, replaced by \"|B:C:pSphere1\" and \"group1|B:C:pSphere1\". However querying the edits which affect C.ma would still return a setAttr edit affecting \"C:pSphere1\" since it was applied prior to B:C:pSphere1 being instanced. Some tips: 1. Use the '-topReference' flag to query only those edits which were applied from the currently open file. 2. Use the '-onReferenceNode' flag to limit the results to those edits where are stored on a given reference node. You can then use various string manipulation techniques to extrapolate the current name of any affected nodes. ", 
        "flags": {
            "child": {
                "docstring": "This flag modifies the '-rfn/-referenceNode' and '-f/-filename' flags to indicate the the children of the target reference will be returned. Returns a string array."
            }, 
            "dagPath": {
                "docstring": "This flag modifies the '-n/-nodes' flag to indicate that the names of any dag objects returned will include as much of the dag path as is necessary to make the names unique. If this flag is not present, the names returned will not include any dag paths."
            }, 
            "editAttrs": {
                "docstring": "Returns string array. A main flag used to query the edits that have been applied to the target. Only the names of the attributes involved in the reference edit will be returned. If an edit involves multiple attributes (e.g. \"connectAttr\" edits) the nodes will be returned as separate, consecutive entries in the string array. A valid target is either a reference node, a reference file, or a referenced node. If a referenced node is specified, only those edits which affect that node will be returned. If a reference file or reference node is specified any edit which affects a node in that reference will be returned. If no target is specified all edits are returned. This command can be used on both loaded and unloaded references. By default it will return all the edits, formatted as MEL commands, which apply to the target. This flag can be used in combination with the '-ea/-editAttrs' flag to indicate that the names of both the involved nodes and attributes will be returned in the format 'node.attribute'."
            }, 
            "editCommand": {
                "docstring": "This is a secondary flag used to indicate which type of reference edits should be considered by the command. If this flag is not specified all edit types will be included. This flag requires a string parameter. Valid values are: \"addAttr\", \"connectAttr\", \"deleteAttr\", \"disconnectAttr\", \"parent\", and \"setAttr\". In some contexts, this flag may be specified more than once to specify multiple edit types to consider."
            }, 
            "editNodes": {
                "docstring": "Returns string array. A main flag used to query the edits that have been applied to the target. Only the names of the nodes involved in the reference edit will be returned. If an edit involves multiple nodes (e.g. \"connectAttr\" edits) the nodes will be returned as separate, consecutive entries in the string array. A valid target is either a reference node, a reference file, or a referenced node. If a referenced node is specified, only those edits which affect that node will be returned. If a reference file or reference node is specified any edit which affects a node in that reference will be returned. If no target is specified all edits are returned. This command can be used on both loaded and unloaded references. By default it will return all the edits, formatted as MEL commands, which apply to the target. This flag can be used in combination with the '-ea/-editAttrs' flag to indicate that the names of both the involved nodes and attributes will be returned in the format 'node.attribute'."
            }, 
            "editStrings": {
                "docstring": "Returns string array. A main flag used to query the edits that have been applied to the target. The edit will be returned as a valid MEL command. A valid target is either a reference node, a reference file, or a referenced node. If a referenced node is specified, only those edits which affect that node will be returned. If a reference file or reference node is specified any edit which affects a node in that reference will be returned. If no target is specified all edits are returned. This command can be used on both loaded and unloaded references. By default it will return all the edits, formatted as MEL commands, which apply to the target. This flag cannot be used with either the '-en/-editNodes' or '-ea/-editAttrs' flags."
            }, 
            "failedEdits": {
                "docstring": "This is a secondary flag used to indicate whether or not failed edits should be acted on (e.g. queried, removed, etc...). A failed edit is an edit which could not be successfully applied the last time its reference was loaded. An edit can fail for a variety of reasons (e.g. the referenced node to which it applies was removed from the referenced file). By default failed edits will not be acted on."
            }, 
            "filename": {
                "docstring": "Returns string. A main flag used to query the filename associated with the target reference."
            }, 
            "isExportEdits": {
                "docstring": "Returns a boolean indicating whether the specified reference node or file name is an edits file (created with the Export Edits feature)"
            }, 
            "isLoaded": {
                "docstring": "Returns a boolean indicating whether the specified reference node or file name refers to a loaded or unloaded reference."
            }, 
            "isNodeReferenced": {
                "docstring": "Returns boolean. A main flag used to determine whether or not the target node comes from a referenced file. true if the target node comes from a referenced file, false if not."
            }, 
            "isPreviewOnly": {
                "docstring": "Returns boolean. This flag is used to determine whether or not the target reference node is only a preview reference node."
            }, 
            "liveEdits": {
                "docstring": "Specifies that the edits should be returned based on the live edits database. Only valid when used in conjunction with the editStrings flag."
            }, 
            "namespace": {
                "docstring": "Returns string. This flag returns the full namespace path of the target reference, starting from the root namespace \":\". It can be combined with the shortName flag to return just the base name of the namespace."
            }, 
            "nodes": {
                "docstring": "Returns string array. A main flag used to query the contents of the target reference."
            }, 
            "onReferenceNode": {
                "docstring": "This is a secondary flag used to indicate that only those edits which are stored on the indicated reference node should be considered. This flag only supports multiple uses when specified with the \"exportEdits\" command.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "parent": {
                "docstring": "This flag modifies the '-rfn/-referenceNode' and '-f/-filename' flags to indicate the the parent of the target reference will be returned."
            }, 
            "parentNamespace": {
                "docstring": "A main flag used to query and return the parent namespace of the target reference."
            }, 
            "referenceNode": {
                "docstring": "Returns string. A main flag used to query the reference node associated with the target reference."
            }, 
            "shortName": {
                "docstring": "This flag modifies the '-f/-filename' and '-ns/-namespace' flags. Used with the '-f/-filename' flag indicates that the file name returned will be the short name (i.e. just a file name without any directory paths). If this flag is not present, the full name and directory path will be returned. Used with the '-ns/-namespace' flag indicates that the namespace returned will be the base name of the namespace. (i.e. the base name of the full namespace path \":AAA:BBB:CCC\" is \"CCC\" )"
            }, 
            "showDagPath": {
                "docstring": "Shows/hides the full dag path for edits. If false only displays the node-name of reference edits. Must be used with the -editNodes, -editStrings or -editAttrs flag."
            }, 
            "showNamespace": {
                "docstring": "Shows/hides the namespaces on nodes in the reference edits. Must be used with the -editNodes, -editStrings or -editAttrs flag"
            }, 
            "successfulEdits": {
                "docstring": "This is a secondary flag used to indicate whether or not successful edits should be acted on (e.g. queried, removed, etc...). A successful edit is any edit which was successfully applied the last time its reference was loaded. By default successful edits will be acted on."
            }, 
            "topReference": {
                "docstring": "This flag modifies the '-rfn/-referenceNode' flag to indicate the top level ancestral reference of the target reference will be returned."
            }, 
            "unresolvedName": {
                "docstring": "This flag modifies the '-f/-filename' flag to indicate that the file name returned will be unresolved (i.e. it will be the path originally specified when the file was loaded into Maya; this path may contain environment variables and may not exist on disk). If this flag is not present, the resolved name will be returned."
            }, 
            "withoutCopyNumber": {
                "docstring": "This flag modifies the '-f/-filename' flag to indicate that the file name returned will not have a copy number (e.g. '{1}') appended to the end. If this flag is not present, the file name returned may have a copy number appended to the end."
            }
        }
    }, 
    "refineSubdivSelectionList": {
        "description": "Refines a subdivision surface set of components based on the selection list. The selected components are subdivided. The selection list after the command is the newly created components at the finer subdivision level. ", 
        "flags": {}
    }, 
    "refresh": {
        "description": "This command is used to force a redraw during script execution. Normally, redraw is suspended while scripts are executing but sometimes it is useful to show intermediate results for purposes such as capturing images from the screen. If the -cv flag is specified, then only the current active view is redrawn. ", 
        "flags": {
            "currentView": {
                "docstring": "Redraw only the current view (default redraws all views)."
            }, 
            "fileExtension": {
                "docstring": ""
            }, 
            "filename": {
                "docstring": ""
            }, 
            "force": {
                "docstring": "Force the refresh regardless of the state of the model."
            }, 
            "suspend": {
                "docstring": "Suspends or resumes Maya's handling of refresh events. Specify \"on\" to suspend refreshing, and \"off\" to resume refreshing. Note that resuming refresh does not itself cause a refresh -- the next natural refresh event in Maya after \"refresh -suspend off\" is issued will cause the refresh to occur. Use this flag with caution: although it provides opportunities to enhance performance, much of Maya's dependency graph evaluation in interactive mode is refresh driven, thus use of this flag may lead to slight solve differences when you have a complex dependency graph with interrelations.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "refreshEditorTemplates": {
        "description": "This command refreshes all cached attribute editor templates, including those copied from the standard AE. This is useful if attribute elements have changed and the templates need to be re-evaluated accordingly. ", 
        "flags": {}
    }, 
    "regionSelectKeyCtx": {
        "description": "This command creates a context which may be used to scale keyframes within the graph editor using the region select tool. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "rehash": {
        "description": "", 
        "flags": {}
    }, 
    "relationship": {
        "description": "This is primarily for use with file IO. Rather than write out the specific attributes/connections required to maintain a relationship, a description of the related nodes/plugs is written instead. The relationship must have an owner node, and have a specific type. During file read, maya will make the connections necessary to represent the realtionship in the dependency graph. ", 
        "flags": {
            "b": {
                "docstring": "Break the specified relationship instead of creating itFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "reloadImage": {
        "description": "This command reloads an xpm image from disk. This can be used when the file has changed on disk and needs to be reloaded. The first string argument is the file name of the .xpm file. The second string argument is the name of a control using the specified pixmap. ", 
        "flags": {}
    }, 
    "removeJoint": {
        "description": "This command will remove the selected joint or the joint given at the command line from the skeleton. The given(or selected) joint should not be the root joint of the skeleton, and not have skin attached. The command works on the given(or selected) joint. No options or flags are necessary. ", 
        "flags": {}
    }, 
    "removeMultiInstance": {
        "description": "Removes a particular instance of a multiElement. This is only useful for input attributes since outputs will get regenerated the next time the node gets executed. This command will remove the instance and optionally break all incoming and outgoing connections to that instance. If the connections are not broken (with the -b true) flag, then the command will fail if connections exist. ", 
        "flags": {
            "b": {
                "docstring": "If the argument is true, all connections to the attribute will be broken before the element is removed. If false, then the command will fail if the element is connected.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "rename": {
        "description": "Renames the given object to have the new name. If only one argument is supplied the command will rename the (first) selected object. If the new name conflicts with an existing name, the object will be given a unique name based on the supplied name. It is not legal to rename an object to the empty string. When a transform is renamed then any shape nodes beneath the transform that have the same prefix as the old transform name are renamed. For example, \"rename nurbsSphere1 ball\" would rename \"nurbsSphere1|nurbsSphereShape1\" to \"ball|ballShape\". If the new name ends in a single '#' then the rename command will replace the trailing '#' with a number that ensures the new name is unique. ", 
        "flags": {
            "ignoreShape": {
                "docstring": "Indicates that renaming of shape nodes below transform nodes should be prevented.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "renameAttr": {
        "description": "Renames the given user-defined attribute to the name given in the string argument. If the new name conflicts with an existing name then this command will fail. Note that it is not legal to rename an attribute to the empty string. ", 
        "flags": {}
    }, 
    "renameUI": {
        "description": "This command renames the UI object passed as first arument to the new name specified as second argument. If the new name is a duplicate, or not valid, then re-naming fails and the old name is returned. ", 
        "flags": {}
    }, 
    "render": {
        "description": "The render command is used to start off a MayaSoftware rendering session of the currently active camera. If a rendering is already in progress, then this command stops the rendering. This command is not undoable. ", 
        "flags": {
            "abortMissingTexture": {
                "docstring": "Abort renderer when encountered missing texture. Only available when -batch is set"
            }, 
            "batch": {
                "docstring": "Run in batch mode. Compute the images for all renderable cameras. This is the mel equivalent of running maya in batch mode with the -render flag set. All other flags are ignored when -batch is used."
            }, 
            "keepPreImage": {
                "docstring": "Keep the renderings prior to post-process around. Only available when -batch is set"
            }, 
            "layer": {
                "docstring": "Render the specified render layer. Only this render layer will be rendered, regardless of the renderable attribute value of the render layer. The layer name will be appended to the output image file name. The specified render layer becomes the current render layer before rendering, and remains as current render layer after the rendering.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "nglowpass": {
                "docstring": "Overwrite glow pass capabilities (can turn off glow pass globally by setting this value to false)"
            }, 
            "nshadows": {
                "docstring": "Shadowing capabilities (can turn off shadow globally by setting this value to false)"
            }, 
            "replace": {
                "docstring": "Replace the rendered image if it already exists. Only available when -batch is set"
            }, 
            "xresolution": {
                "docstring": "Overwrite x resolution"
            }, 
            "yresolution": {
                "docstring": "Overwrite y resolution"
            }
        }
    }, 
    "renderGlobalsNode": {
        "description": "The renderGlobalsNode creates a render globals node and registers it with the model. The createNode command will not register nodes of this type correctly. ", 
        "flags": {
            "name": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": ""
            }, 
            "renderQuality": {
                "docstring": "Set the quality to be the renderQuality node with the given name.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "renderResolution": {
                "docstring": "Set the resolution to be the resolution node with the given name."
            }, 
            "shared": {
                "docstring": ""
            }, 
            "skipSelect": {
                "docstring": ""
            }
        }
    }, 
    "renderInfo": {
        "description": "The renderInfo commands sets geometric properties of surfaces of the selected object. In query mode, return type is based on queried flag.", 
        "flags": {
            "castShadows": {
                "docstring": "Determines if object casts shadow or not."
            }, 
            "chordHeight": {
                "docstring": "Tessellation subdivision criteria."
            }, 
            "chordHeightRatio": {
                "docstring": "Tessellation subdivision criteria."
            }, 
            "doubleSided": {
                "docstring": "Determines if object double or single sided."
            }, 
            "edgeSwap": {
                "docstring": "Tessellation subdivision criteria."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "minScreen": {
                "docstring": "Tessellation subdivision criteria."
            }, 
            "name": {
                "docstring": ""
            }, 
            "opposite": {
                "docstring": "Determines if the normals of the object is to be reversed."
            }, 
            "query": {
                "docstring": ""
            }, 
            "smoothShading": {
                "docstring": "Determines if smooth shaded, or flat shaded - applies only to polysets."
            }, 
            "unum": {
                "docstring": "Tessellation subdivision criteria."
            }, 
            "useChordHeight": {
                "docstring": "Tessellation subdivision criteria."
            }, 
            "useChordHeightRatio": {
                "docstring": "Tessellation subdivision criteria."
            }, 
            "useDefaultLights": {
                "docstring": "Obsolete flag."
            }, 
            "useMinScreen": {
                "docstring": "Tessellation subdivision criteria."
            }, 
            "utype": {
                "docstring": "Tessellation subdivision criteria."
            }, 
            "vnum": {
                "docstring": "Tessellation subdivision criteria."
            }, 
            "vtype": {
                "docstring": "Tessellation subdivision criteria.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "renderLayerPostProcess": {
        "description": "Post process the results when rendering is done with. Presently this generates a layered PSD file using individual iff files. In query mode, return type is based on queried flag.", 
        "flags": {
            "keepImages": {
                "docstring": "When set to on, the original iff images are kept after the conversion to PSD. Default is to remove them."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sceneName": {
                "docstring": "Specifies the scene name for interactive batch rendering.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "renderManip": {
        "description": "This command creates manipulators for cameras or lights. In query mode, return type is based on queried flag.", 
        "flags": {
            "camera": {
                "docstring": "Query or edit the visiblity status of the component camera manipulators. The order of components are: cycling index, center of interest, pivot, clipping planes, and unused."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "light": {
                "docstring": "Query or edit the visiblity status of the component light manipulators. The order of components are: cycling index, center of interest, and pivot.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "spotLight": {
                "docstring": "Query or edit the visiblity status of the component spot light manipulators. The order of components are: cycling index, center of interest, pivot, cone angle, penumbra, look through barn doors, and decay regions."
            }, 
            "state": {
                "docstring": "Query or edit the state of manipulators on an camera, ambient light, directional light, point light, or spot light. This flag's default value is on."
            }
        }
    }, 
    "renderPartition": {
        "description": "Set or query the model's current partition. When flag qis not used, a partion name must be passed as an argument. In this case the current partition is set to that name. ", 
        "flags": {
            "query": {
                "docstring": ""
            }
        }
    }, 
    "renderPassRegistry": {
        "description": "query information related with render passes. ", 
        "flags": {
            "channels": {
                "docstring": "Specify the number of channels for query."
            }, 
            "isPassSupported": {
                "docstring": "Return whether the pass is supported by the renderer This flag must be specified by the flag -passID firstly. The renderer whose default value is the current renderer is specified by the flag renderer.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "passID": {
                "docstring": "Specify the render pass ID for query."
            }, 
            "passName": {
                "docstring": "Get the pass name for the passID. This flag must be specified by the flag -passID firstly."
            }, 
            "renderer": {
                "docstring": "Specify a renderer when using this command. By default the current renderer is specified."
            }, 
            "supportedChannelCounts": {
                "docstring": "List channel counts supported by the renderer(specified by the flag -renderer) and the specified pass ID. This flag must be specified by the flag -passID firstly."
            }, 
            "supportedDataTypes": {
                "docstring": "List frame buffer types supported by the renderer(specified by the flag -renderer), the specified passID and channels. This flag must be specified by the flag -passID and -channels firstly."
            }, 
            "supportedPassSemantics": {
                "docstring": "List pass semantics supported by the specified passID. This flag must be specified by the flag -passId firstly."
            }, 
            "supportedRenderPassNames": {
                "docstring": "List render pass names supported by the renderer(specified by the flag -renderer)."
            }, 
            "supportedRenderPasses": {
                "docstring": "List render passes supported by the renderer(specified by the flag -renderer)."
            }
        }
    }, 
    "renderQualityNode": {
        "description": "The renderQualityNode creates a render quality node and registers it with the model. The createNode command will not register nodes of this type correctly. ", 
        "flags": {
            "name": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": ""
            }, 
            "shared": {
                "docstring": ""
            }, 
            "skipSelect": {
                "docstring": ""
            }
        }
    }, 
    "renderSettings": {
        "description": "Query interface to the common tab of the render settings ", 
        "flags": {
            "camera": {
                "docstring": "Specify a camera that you want to replace the current renderable camera"
            }, 
            "customTokenString": {
                "docstring": "Specify a custom key-value string to use to replace custom tokens in the file name. Use with firstImageName or lastImageName. Basic tokens (Scene, Layer, RenderLayer, Camera, Version, Extension) will be automatically expanded. Any other tokens must be specified here to be expanded. The format of the string is a space separated list of tokens-value pairs. For example, if the file name string is \"myFile_myToken_myOtherToken_v\" then the argument to this flag string should take the form \"myToken=myTokenValue myOtherToken=myOtherTokenValue\"."
            }, 
            "firstImageName": {
                "docstring": "Returns the first image name"
            }, 
            "fullPath": {
                "docstring": "Returns the full path for the image using the current project. Use with firstImageName, lastImageName, or genericFrameImageName."
            }, 
            "fullPathTemp": {
                "docstring": "Returns the full path for the preview render of the image using the current project. Use with firstImageName, lastImageName, or genericFrameImageName."
            }, 
            "genericFrameImageName": {
                "docstring": "Returns the generic frame image name with the custom specified frame index token"
            }, 
            "imageGenericName": {
                "docstring": "Returns the image generic name"
            }, 
            "lastImageName": {
                "docstring": "Returns the last image name"
            }, 
            "layer": {
                "docstring": "Specify a render layer name that you want to replace the current render layer"
            }, 
            "leaveUnmatchedTokens": {
                "docstring": "Do not remove unmatched tokens from the name string. Use with firstImageName or lastImageName.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "renderThumbnailUpdate": {
        "description": "Toggle the updating of object thumbnails. These are visible in tools like the Attribute Editor and Hypershade. All thumbnails everywhere will not update to reflect changes to the object until this command is used to toggle to true. In query mode, return type is based on queried flag.", 
        "flags": {
            "query": {
                "docstring": ""
            }
        }
    }, 
    "renderWindowEditor": {
        "description": "Create a editor window that can receive the result of the rendering process ", 
        "flags": {
            "autoResize": {
                "docstring": "Lets the render view editor automatically resize the viewport or not."
            }, 
            "blendMode": {
                "docstring": "Sets the blend mode for the render view. New image sent to the render view will be blended with the previous image in the render view, and the composited image will appear."
            }, 
            "caption": {
                "docstring": "Sets the caption which appears at the bottom of the render view."
            }, 
            "changeCommand": {
                "docstring": "Parameters: First string: commandSecond string: editorNameThird string: editorCmdFourth string: updateFuncCall the command when something changes in the editor The command should have this prototype :command(string $editor, string $editorCmd, string $updateFunc, int $reason)The possible reasons could be : 0: no particular reason1: scale color2: buffer (single/double)3: axis4: image displayed5: image saved in memory"
            }, 
            "clear": {
                "docstring": "Clear the image with the given color at the given resolution. Argumnets are respecively: width height red green blue."
            }, 
            "colorManage": {
                "docstring": "When used with the writeImage flag, causes the written image to be color-managed using the settings from the view color manager attached to the view.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "compDisplay": {
                "docstring": "0 : disable compositing.1 : displays the composited image immediately.For example, when foreground layer tile is sent to the render view window, the composited tile is displayed in the render view window, and the original foreground layer tile is not displayed.2 : display the un-composited image, and keep the composited image for the future command.For example, when foreground layer tile is sent to the render view window, the original foreground layer tile is not displayed, and the composited tile is stored in a buffer.3 : show the current composited image. If there is a composited image in the buffer, display it."
            }, 
            "compImageFile": {
                "docstring": "Open the given image file and blend with the buffer as if the image was just rendered."
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "currentCamera": {
                "docstring": "Get or set the current camera. (used when redoing last render)"
            }, 
            "currentCameraRig": {
                "docstring": "Get or set the current camera rig name. If a camera rig is specified, it will be used when redoing the last render as opposed to the currentCamera value, as the currentCamera value will hold the child camera last used for rendering the camera rig."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "displayImage": {
                "docstring": "Set a particular image in the Editor Image Stack as the current Editor Image. Images are added to the Editor Image Stack using the \"si/saveImage\" flag."
            }, 
            "displayImageViewCount": {
                "docstring": "Query the number of views stored for a given image in the Editor Image Stack. This is not the same as querying using \"viewImageCount\" which returns the number of views for the current rendered image."
            }, 
            "displayStyle": {
                "docstring": "Set the mode to display the image. Valid values are: \"color\" to display the basic RGB image\"mask\" to display the mask channel\"lum\" to display the luminance of the image"
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "doubleBuffer": {
                "docstring": "Set the display in double buffer mode"
            }, 
            "drawAxis": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "frameImage": {
                "docstring": "Frames the image inside the window."
            }, 
            "frameRegion": {
                "docstring": "Frames the region inside the window."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "loadImage": {
                "docstring": "load an image from disk and set it as the current Editor Image"
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "marquee": {
                "docstring": "The arguments define the four corners of a rectangle: top left bottom right. The rectangle defines a marquee for the render computation."
            }, 
            "nbImages": {
                "docstring": "returns the number of images"
            }, 
            "nextViewImage": {
                "docstring": "The render editor has the capability to render multiple cameras within a single view. This is different from image binning where an image is saved. Multiple image views are useful for comparing two different camera renders side-by-side. The nextViewImage flag tells the editor that it should prepare its internal image storage mechanism to store to the next view location."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "pcaption": {
                "docstring": "Get or set the permanent caption which appears under the image that is currently showing in the render editor."
            }, 
            "query": {
                "docstring": ""
            }, 
            "realSize": {
                "docstring": "Display the image with a one to one pixel match."
            }, 
            "removeAllImages": {
                "docstring": "remove all the Editor Images from the Editor Image Stack"
            }, 
            "removeImage": {
                "docstring": "remove the current Editor Image from the Editor Image Stack"
            }, 
            "resetRegion": {
                "docstring": "Forces a reset of any marquee/region."
            }, 
            "resetViewImage": {
                "docstring": "The render editor has the capability to render multiple cameras within a single view. This is different from image binning where an image is saved. Multiple image views are useful for comparing two different camera renders side-by-side. The resetViewImage flag tells the editor that it should reset its internal image storage mechanism to the first image. This would happen at the very start of a render view render."
            }, 
            "saveImage": {
                "docstring": "save the current Editor Image to memory. Saved Editor Images are stored in an Editor Image Stack. The most recently saved image is stored in position 0, the second most recently saved image in position 1, and so on... To set the current Editor Image to a previously saved image use the \"di/displayImage\" flag."
            }, 
            "scaleBlue": {
                "docstring": "Define the scaling factor for the blue component in the View. The default value is 1 and can be between -1000 to +1000"
            }, 
            "scaleGreen": {
                "docstring": "Define the scaling factor for the green component in the View. The default value is 1 and can be between -1000 to +1000"
            }, 
            "scaleRed": {
                "docstring": "Define the scaling factor for the red component in the View. The default value is 1 and can be between -1000 to +1000"
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "showRegion": {
                "docstring": "Shows the current region at the given resolution. The two parameters define the width and height."
            }, 
            "singleBuffer": {
                "docstring": "Set the display in single buffer mode"
            }, 
            "snapshot": {
                "docstring": "Makes a copy of the camera of the model editor at the given size. First argument is the editor name, second is the width, third is the height."
            }, 
            "snapshotMode": {
                "docstring": ""
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "stereo": {
                "docstring": "Puts the editor into stereo image mode. The effective resolution of the output image is twice the size of the horizontal size. The orientation of the images can be set using the stereoOrientation flag."
            }, 
            "stereoImageOrientation": {
                "docstring": "Specifies the orientation of stereo camera renders. The first argument specifies the orientation value for the firstleft image and the second argument specifies the orientation value for the right image. The orientation values are 'normal', the image appears as seen throught he camera, or 'mirrored', the image is mirrored horizontally."
            }, 
            "stereoMode": {
                "docstring": "Specifies how the image is displayed in the view. By default the stereo is rendered with a side by side image. The rendered image is a single image that is twice the size of a normal image, 'both'. Users can also choose to display as 'redcyan', 'redcyanlum', 'leftonly', 'rightonly', or 'stereo'. both - displays both the left and right redcyan - displays the images as a red/cyan pair. redcyanlum - displays the luminance of the images as a red/cyan pair. leftonly - displays the left side only rightonly - displays the right side only stereo - mode that supports Crystal Eyes(tm) or Zscreen (tm) renders"
            }, 
            "toggle": {
                "docstring": "Turns the ground plane display on/off."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "viewImageCount": {
                "docstring": "The render editor has the capability to render multiple cameras within a single view. This is different from image binning where an image is saved. Multiple image views are useful for comparing two different camera renders side-by-side. The viewImageCount flag tells the editor that it should prepare its internal image storage mechanism for a given number of views."
            }, 
            "writeImage": {
                "docstring": "write the current Editor Image to disk"
            }
        }
    }, 
    "renderWindowSelectContext": {
        "description": "Set the selection context for the render view panel. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "renderer": {
        "description": "Command to register renders. This command allows you to specify the UI name and procedure names for renderers. The command also allow you to query the UI name and the procedure names for the registered renders. In query mode, return type is based on queried flag.", 
        "flags": {
            "addGlobalsNode": {
                "docstring": "This flag allows the user to add a globals node the specified renderer uses."
            }, 
            "addGlobalsTab": {
                "docstring": "Add a tab associated with the specified renderer for the unified render globals window."
            }, 
            "batchRenderOptionsProcedure": {
                "docstring": "Set or query the batch render options procedure associated with the specified renderer."
            }, 
            "batchRenderOptionsStringProcedure": {
                "docstring": "Set or query the argument string that will be used with the command line utility 'Render' when doing a batch render"
            }, 
            "batchRenderProcedure": {
                "docstring": "Set or query the batch render procedure associated with the specified renderer."
            }, 
            "cancelBatchRenderProcedure": {
                "docstring": "Set or query returns the cancel batch render procedure associated with the specified renderer."
            }, 
            "changeIprRegionProcedure": {
                "docstring": "Set or query the change IPR region procedure associated with the specified renderer."
            }, 
            "commandRenderProcedure": {
                "docstring": "Set or query the command line rendering procedure associated with the specified renderer."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "The flag returns true if the specified renderer is registered in the registry, and it returns false otherwise."
            }, 
            "globalsNodes": {
                "docstring": "This flag returns the list of render globals nodes the specified renderer uses.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "globalsTabCreateProcNames": {
                "docstring": "This flag returns the names of procedures which are used to create the unified render globals window tabs which are associated with the specified renderer."
            }, 
            "globalsTabLabels": {
                "docstring": "This flag returns the labels of unified render globals window tabs which are associated with the specified renderer."
            }, 
            "globalsTabUpdateProcNames": {
                "docstring": "This flag returns the names of procedures which are used to update the unified render globals window tabs which are associated with the specified renderer."
            }, 
            "iprOptionsMenuLabel": {
                "docstring": "Set or query the label for the IPR update options menu which is under the render view's IPR menu."
            }, 
            "iprOptionsProcedure": {
                "docstring": "Set or query the IPR render options procedure associated with the specified renderer."
            }, 
            "iprOptionsSubMenuProcedure": {
                "docstring": "Set or query the procedure for creating the sub menu for the IPR update options menu which is under the render view's IPR menu."
            }, 
            "iprRenderProcedure": {
                "docstring": "Set or query the IPR render command associated with the specified renderer."
            }, 
            "iprRenderSubMenuProcedure": {
                "docstring": "Set or query the procedure for creating the sub menu for the IPR render menu which is under the render view's IPR menu."
            }, 
            "isRunningIprProcedure": {
                "docstring": "Set or query the isRunningIpr command associated with the specified renderer."
            }, 
            "logoCallbackProcedure": {
                "docstring": "Set or query the procedure which is a callback associated to the logo for the specified renderer. For example, the logo and the callback can be used in the unified render globals window beside the \"Render Using\" optionMenu."
            }, 
            "logoImageName": {
                "docstring": "Set or query the logo image name for the specified renderer. The logo is a image representing the renderer."
            }, 
            "namesOfAvailableRenderers": {
                "docstring": "Returns the names of renderers which are currently registered."
            }, 
            "pauseIprRenderProcedure": {
                "docstring": "Set or query the pause IPR render procedure associated with the specified renderer."
            }, 
            "polyPrelightProcedure": {
                "docstring": "Set or query the polygon prelight procedure associated with the specified renderer."
            }, 
            "query": {
                "docstring": ""
            }, 
            "refreshIprRenderProcedure": {
                "docstring": "Set or query the refresh IPR render procedure associated with the specified renderer."
            }, 
            "renderDiagnosticsProcedure": {
                "docstring": "Set or query the render diagnostics procedure associated with the specified renderer."
            }, 
            "renderGlobalsProcedure": {
                "docstring": "This flag is obsolete. It will be removed in the next release."
            }, 
            "renderMenuProcedure": {
                "docstring": "This flag is obsolete. It will be removed in the next release."
            }, 
            "renderOptionsProcedure": {
                "docstring": "Set or query the render options procedure associated with the specified renderer."
            }, 
            "renderProcedure": {
                "docstring": "Set or query the render command associated with the specified renderer."
            }, 
            "renderRegionProcedure": {
                "docstring": "Set or query the render region procedure associated with the specified renderer."
            }, 
            "rendererUIName": {
                "docstring": "Set or query the rendererUIName for the specified renderer. The rendererUIName is the name of the renderer as it would appear in menus."
            }, 
            "renderingEditorsSubMenuProcedure": {
                "docstring": "Set or query the procedure reponsible for creating renderer specific editors submenu under the \"Rendering Editors\" menu for the specified renderer."
            }, 
            "showBatchRenderLogProcedure": {
                "docstring": "Set or query the log file batch procedure associated with the specified renderer."
            }, 
            "showBatchRenderProcedure": {
                "docstring": "Set or query the show batch render procedure associated with the specified renderer."
            }, 
            "showRenderLogProcedure": {
                "docstring": "Set or query the log file render procedure associated with the specified renderer."
            }, 
            "startIprRenderProcedure": {
                "docstring": "Set or query the start IPR render procedure associated with the specified renderer."
            }, 
            "stopIprRenderProcedure": {
                "docstring": "Set or query the stop IPR render procedure associated with the specified renderer."
            }, 
            "textureBakingProcedure": {
                "docstring": "Set or query the texture baking procedure associated with the specified renderer."
            }, 
            "unregisterRenderer": {
                "docstring": "Unregister the specified renderer."
            }
        }
    }, 
    "reorder": {
        "description": "This command reorders (moves) objects relative to their siblings. For relative moves, both positive and negative numbers may be specified. Positive numbers move the object forward and negative numbers move the object backward amoung its siblings. When an object is at the end (beginning) of the list of siblings, a relative move of 1 (-1) will put the object at the beginning (end) of the list of siblings. That is, relative moves will wrap if necessary. If a shape is specified and it is the only child then its parent will be reordered. ", 
        "flags": {
            "back": {
                "docstring": "Move object(s) to back of sibling list."
            }, 
            "front": {
                "docstring": "Move object(s) to front of sibling list."
            }, 
            "relative": {
                "docstring": "Move object(s) relative to other siblings.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "reorderContainer": {
        "description": "This command reorders (moves) objects relative to their siblings in a container. For relative moves, both positive and negative numbers may be specified. Positive numbers move the object forward and negative numbers move the object backward amoung its siblings. When an object is at the end (beginning) of the list of siblings, a relative move of 1 (-1) will put the object at the beginning (end) of the list of siblings. That is, relative moves will wrap if necessary. Only nodes within one container can be moved at a time. Note: The container command's -nodeList flag will return a sorted list of contained nodes. To see the effects of reordering, use the -unsortedOrder flag in conjunction with the -nodeList flag. ", 
        "flags": {
            "back": {
                "docstring": "Move object(s) to back of container contents list"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "front": {
                "docstring": "Move object(s) to front of container contents list"
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Move object(s) relative to other container contentsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "reorderDeformers": {
        "description": "This command changes the order in which 2 deformation nodes affect the output geometry. The first string argument is the name of deformer1, the second is deformer2, followed by the list of objects they deform. It inserts deformer2 before deformer1. Currently supported deformer nodes include: sculpt, cluster, jointCluster, lattice, wire, jointLattice, boneLattice, blendShape. ", 
        "flags": {
            "name": {
                "docstring": "This flag is obsolete and is not used.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "repeatLast": {
        "description": "", 
        "flags": {
            "addCommand": {
                "docstring": ""
            }, 
            "addCommandLabel": {
                "docstring": ""
            }, 
            "commandList": {
                "docstring": ""
            }, 
            "commandNameList": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "historyLimit": {
                "docstring": ""
            }, 
            "item": {
                "docstring": ""
            }, 
            "numberOfHistoryItems": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "representation": {
        "description": "Command to register representations for the multiple representation framework, to create them, and to edit and query them. To support internationalization, representation support a per-object label for UI display; this label can be edited, and can be localized. Representation types also have a localized label. At representation creation time, the per-object representation label defaults to the representation type label. Since they are DAG nodes, representations also have node names, shown in the various DAG editors (Outliner, Hypergraph, Node Editor). At representation creation time, the node name defaults to the type name. A representation type name is the name under which it is registered. Representation type names are not localized. Representation type names may not necessarily correspond one to one to node types: for example, multiple representation types can be registered using a single node type, but with different create and create predicate procedures. For example, this can be used to support different simple, in-memory representations such as a bounding box, or a locator, using the same node type. When create new representation, multiple Maya objects can be specified and new representations will be created with one command. For other options, for example, add annotation, query and edit, only one representation node is supported. ", 
        "flags": {
            "activate": {
                "docstring": "Activate or inactivate the representation."
            }, 
            "annotation": {
                "docstring": "Specify annotation text for the argument representation."
            }, 
            "annotationProcedure": {
                "docstring": "Query or edit the procedure to create an annotation for a given registered representation type.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "canCreate": {
                "docstring": "Query to invoke the creation predicate for the specified type, on an argument geometry."
            }, 
            "createPredicate": {
                "docstring": "Query or edit the creation predicate procedure for a given registered representation type. This predicate is invoked to query whether creation of that registered representation type is possible."
            }, 
            "createProcedure": {
                "docstring": "Query or edit the creation procedure for a given registered representation type."
            }, 
            "createUIProcedure": {
                "docstring": "Query or edit the procedure to create the UI for a given registered representation type."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editNodeUIProcedure": {
                "docstring": "Query or edit the procedure to show a modal UI to edit a node, for a given representation type. The procedure is passed the path to the representation node as its single argument."
            }, 
            "label": {
                "docstring": "Query or edit the representation label for the argument representation."
            }, 
            "listTypes": {
                "docstring": "Query the list of available registered representation types."
            }, 
            "name": {
                "docstring": "Specify the name of new created representation nodes."
            }, 
            "original": {
                "docstring": "Set or query the original representation type."
            }, 
            "query": {
                "docstring": ""
            }, 
            "representationType": {
                "docstring": "Query the registered representation type for the argument representation."
            }, 
            "resetUIProcedure": {
                "docstring": "Query or edit the procedure to reset the UI options for a given registered representation type."
            }, 
            "saveUIProcedure": {
                "docstring": "Query or edit the procedure to save the UI options for a given registered representation type."
            }, 
            "type": {
                "docstring": "Set or query properties for the specified registered representation type. "
            }, 
            "typeLabel": {
                "docstring": "Query or edit the type label for the registered representation type."
            }
        }
    }, 
    "requires": {
        "description": "This command is used during file I/O to specify the requirements needed to load the given file. It defines what file format version was used to write the file, or what plug-ins are required to load the scene. The first string names a product (either \"maya\", or a plug-in name) The second string gives the version. This command is only useful during file I/O, so users should not have any need to use this command themselves. ", 
        "flags": {}
    }, 
    "reroot": {
        "description": "This command will reroot a skeleton. The selected joint or the given joint at the command line will be the new root of the skeleton. All ikHandles passing through the selected joint or above it will be deleted. The given(or selected) joint should not have skin attached. The command works on the given or selected joint. No options or flags are necessary. ", 
        "flags": {}
    }, 
    "resampleFluid": {
        "description": "A command to extend the fluid grid, keeping the voxels the same size, and keeping the existing contents of the fluid in the same place. Note that the fluid transform is also modified to make this possible. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "resampleDepth": {
                "docstring": "Change depth resolution to this valueFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "resampleHeight": {
                "docstring": "Change height resolution to this value"
            }, 
            "resampleWidth": {
                "docstring": "Change width resolution to this value"
            }
        }
    }, 
    "resetTool": {
        "description": "This command resets a tool back to its \"factory settings\" ", 
        "flags": {}
    }, 
    "resolutionNode": {
        "description": "The resolutionNode creates a render resolution node and registers it with the model. The createNode command will not register nodes of this type correctly. ", 
        "flags": {
            "name": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": ""
            }, 
            "shared": {
                "docstring": ""
            }, 
            "skipSelect": {
                "docstring": ""
            }
        }
    }, 
    "resourceManager": {
        "description": "List resources matching certain properties. ", 
        "flags": {
            "nameFilter": {
                "docstring": "List only resources matching the name. Argument may contain ? and \\* characters."
            }, 
            "saveAs": {
                "docstring": "Saves a copy of the resource (first parameter) as a separate file (second parameter).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "retarget": {
        "description": "This command is used to take motion from one character and retarget it to a second character of a different size. ", 
        "flags": {
            "endFrame": {
                "docstring": "Specify the retargeting end frame. Default is 10."
            }, 
            "lowerBody": {
                "docstring": "Specify the desired retargeting technique for the lower body. Valid options are: \"jointRotationsOnly\", \"scaledFootPlacement\" and \"absoluteFootPlacement\". Default is scaledFootPlacement."
            }, 
            "lowerScale": {
                "docstring": "Specify the way scale is calculated for the lower body. Valid techniques are: \"hipToFoot\", \"hipToToe\", \"overallHeight\", and \"other\". This option is used when the lowerBody flag is set to anything other than \"jointRotationsOnly\". Default is hipToFoot. When \"other\" is used, the lowerScaleFactor flag should be used to specify the scale factor."
            }, 
            "lowerScaleFactor": {
                "docstring": "Specify the scale factor for the lower body. This option is only used when the lowerScale is set to \"other\"."
            }, 
            "maintainOffset": {
                "docstring": "When this flag is used, the root of the target character will stay the same distance from the source as at the rest pose."
            }, 
            "restPoseFrame": {
                "docstring": "The retargeting solution takes the rest pose of the characters into consideration. For example, one character may be bowlegged with respect to the other in the rest pose. When retargeting animation from the bowlegged character to the non-bowlegged character, the solution will take the rest pose into account so that the target character will receive the walk animation without the bowlegged aspects of the walk. The user has 2 options for specifying a restPose: specifying a frame number at which the rest pose is defined, or defining a retargeting rest pose using the Retargeting-SetRestPose menu item. If you use a frame number for the rest pose, the best practice is to use a frame that does not lie within the range of frames being retargeted. This allows you to retarget without wiping out the rest pose.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "scaleHandsFrom": {
                "docstring": "Specify where the arms are scaled from. Valid arguments are: \"shoulder\", \"root\" and \"origin\". This option is only used when the upperBody flag is set to \"scaledHandPlacement\". Defaults is shoulder."
            }, 
            "startFrame": {
                "docstring": "Specify the retargeting start frame. Default is 0."
            }, 
            "upperBody": {
                "docstring": "Specify the desired retargeting technique for the upper body. Valid techniques are: \"jointRotationsOnly\", \"scaledHandPlacement\", \"absoluteHandPlacement\" and \"maintainHandDistance\". Default is jointRotationsOnly."
            }, 
            "upperScale": {
                "docstring": "Specify the way scale is calculated for the upper body. Valid techniques are: \"shoulderToWrist\", \"shoulderToHand\", \"followLower\", and \"other\". This option is used when the upperBody flag is set to anything other than \"jointRotationsOnly\". Defaults is shoulderToHand. When \"other\" is used, the upperScaleFactor flag should be used to specify the scale factor."
            }, 
            "upperScaleFactor": {
                "docstring": "Specify the scale factor for the upper body. This option is used when the upperScale is set to \"other\"."
            }, 
            "useExistingKeys": {
                "docstring": "When this flag is used, the existing keys on the target are used as a hint to help guide the retargeting solution. This option sometimes allows the solver to narrow in on a better solution."
            }
        }
    }, 
    "retimeHelper": {
        "description": "", 
        "flags": {
            "deleteFrame": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "frame": {
                "docstring": ""
            }, 
            "lockBar": {
                "docstring": ""
            }, 
            "locks": {
                "docstring": ""
            }, 
            "mouseOver": {
                "docstring": ""
            }, 
            "moveFrame": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "retimeKeyCtx": {
        "description": "This command creates a context which may be used to scale keyframes within the graph editor using the retime tool. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "reverseCurve": {
        "description": "The reverseCurve command reverses the direction of a curve or curve-on-surface. A string is returned containing the pathname of the newly reversed curve and the name of the resulting dependency node. The reversed curve has the same parameter range as the original curve. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curveOnSurface": {
                "docstring": "If possible, create 2D curve as a result"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "noChanges": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curveFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)"
            }
        }
    }, 
    "reverseSurface": {
        "description": "The reverseSurface command reverses one or both directions of a surface or can be used to \"swap\" the U and V directions (this creates the effect of reversing the surface normal). The name of the newly reversed surface and the name of the resulting dependency node is returned. The resulting surface has the same parameter ranges as the original surface. This command also handles selected surface isoparms. For a selected isoparm, imagine that the isoparm curve is reversed after the operation. E.g. reverseSurface surface.v[0.1] will reverse in the U direction. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "direction": {
                "docstring": "The direction to reverse the surface in: 0 - U, 1 - V, 2 - Both U and V, 3 - SwapDefault:0Advanced flags"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "noChanges": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "revolve": {
        "description": "This command creates a revolved surface by revolving the given profile curve about an axis. The profile curve can be a curve, curve-on-surface, surface isoparm, or trim edge. ", 
        "flags": {
            "autoCorrectNormal": {
                "docstring": "If this is set to true we will attempt to reverse the direction of the axis in case it is necessary to do so for the surface normals to end up pointing to the outside of the object.Default:false"
            }, 
            "axis": {
                "docstring": "Revolve axis"
            }, 
            "axisChoice": {
                "docstring": "Only used for computed axis/pivot case. As we are computing the axis for a planar curve, we have two choices for the major axis based axis. We will choose the axis corresponding to the longer dimension of the object (0), or explicitly choose one or the other (choices 1 and 2).Default:0"
            }, 
            "axisX": {
                "docstring": "X of the axisDefault:1"
            }, 
            "axisY": {
                "docstring": "Y of the axisDefault:0"
            }, 
            "axisZ": {
                "docstring": "Z of the axisDefault:0"
            }, 
            "bridge": {
                "docstring": "If true, we will close a partial revolve to get a pie shaped surface. The surface will be closed, but not periodic the way it is in the full revolve case.Default:falseAdvanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "computePivotAndAxis": {
                "docstring": "If this is set to 2, we will compute the axis, use the curve position and radius to compute the pivot for the revolve internally. The value of the pivot and axis attributes are ignored. If this is set to 1, we will take the supplied axis, but compute the pivot. If this is set to 0, we will take both the supplied axis and pivot.Default:0"
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting surface.Default:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endSweep": {
                "docstring": "The value for the end sweep angle, in the current units. This must be no more than the maximum, 360 degrees, or 2 Pi radians.Default:6.2831853"
            }, 
            "mergeItems": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "pivot": {
                "docstring": "Revolve pivot point"
            }, 
            "pivotX": {
                "docstring": "X of the pivotDefault:0"
            }, 
            "pivotY": {
                "docstring": "Y of the pivotDefault:0"
            }, 
            "pivotZ": {
                "docstring": "Z of the pivotDefault:0"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "The pivot point will be this distance away from the bounding box of the curve, if computedPivot is set to true. The value of the pivot attribute is ignored.Default:1"
            }, 
            "radiusAnchor": {
                "docstring": "The position on the curve for the anchor point so that we can compute the pivot using the radius value. If in 0 - 1 range, its on the curve, normalized parameter range. If 0 or 1, its computed based on the bounding box.Default:-1"
            }, 
            "range": {
                "docstring": "Force a curve range on complete input curve"
            }, 
            "rebuild": {
                "docstring": "Rebuild the input curve(s) before using them in the operation. Use nurbsCurveRebuildPref to set the parameters for the conversion."
            }, 
            "sections": {
                "docstring": "Number of sections of the resulting surface (if tolerance is not used).Default:8"
            }, 
            "startSweep": {
                "docstring": "The value for the start sweep angle, in the current units. This must be no more than the maximum, 360 degrees, or 2 Pi radians.Default:0"
            }, 
            "tolerance": {
                "docstring": "Tolerance to build to (if useTolerance attribute is set)Default:0.01"
            }, 
            "useLocalPivot": {
                "docstring": "If true, then the pivot of the profile curve is used as the start point of the axis of revolution.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTolerance": {
                "docstring": "Use the tolerance, or the number of sections to control the sections.Default:false"
            }
        }
    }, 
    "rigidBody": {
        "description": "This command creates a rigid body from a polygonal or nurbs surface. ", 
        "flags": {
            "active": {
                "docstring": "Creates a rigid body that is active. An active rigid body accepts and causes collisions and is effected by dynamic fields. This is the default."
            }, 
            "angularVelocity": {
                "docstring": "Current angular velocity of rigid body."
            }, 
            "applyForceAt": {
                "docstring": "Determines how forces are applied to the rigid body. The choices are centerOfMass | boundingBox | verticesOrCVs. Default: boundingBox"
            }, 
            "bounciness": {
                "docstring": "Sets the restitution (or bounciness) of the rigid body. Range: 0.0 - 2.0 Default: 0.6"
            }, 
            "cache": {
                "docstring": "Turns caching on (1) or off (0) for the rigid body. Default: off"
            }, 
            "centerOfMass": {
                "docstring": "Sets the center of mass (x,y,z) of the rigid body. Default: actual center of mass."
            }, 
            "collisions": {
                "docstring": "Truns collisions on/off for the rigid body. If the collisions are turned of the rigid body will not collide with any other rigid body. Default: on."
            }, 
            "contactCount": {
                "docstring": "returns the current contact count for the rigid body."
            }, 
            "contactName": {
                "docstring": "returns all the rigid body names which are in contact with this shape. One name for each contact will be returned.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "contactPosition": {
                "docstring": "returns all the contact position. One position for each contact will be returned."
            }, 
            "damping": {
                "docstring": "Sets the damping value of the rigid body. Range: -2.0 - 2.0 Default: 0.0"
            }, 
            "deleteCache": {
                "docstring": "Deletes the cache (if one exists) of the rigid body."
            }, 
            "dynamicFriction": {
                "docstring": "Sets the dynamic friction for the rigid body. Range: 0.0 - 1.0 Default: 0.2"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "force": {
                "docstring": "Current force on the rigid body."
            }, 
            "ignore": {
                "docstring": "Causes the rigid body to be ignored in the rigid solver. Default: off"
            }, 
            "impulse": {
                "docstring": "Applies an impulse (instantaneous) force on a rigid body. Default: 0.0 0.0 0.0"
            }, 
            "impulsePosition": {
                "docstring": "The position at which the impulse is applied. Default: the bodies center of mass."
            }, 
            "initialAngularVelocity": {
                "docstring": "Sets the initial angular velocity of the rigid body. Default: 0.0 0.0 0.0"
            }, 
            "initialVelocity": {
                "docstring": "Sets the initial velocity of the rigid body. Default: 0.0 0.0 0.0"
            }, 
            "layer": {
                "docstring": "Sets the collision layer of the rigid body. Only rigid bodies in the same collision layer can collide with each other. Range: = 0 Default: 0."
            }, 
            "lockCenterOfMass": {
                "docstring": "Locks the center of mass for the rigid body. Default: off"
            }, 
            "mass": {
                "docstring": "Sets the mass of the rigid body. Range: 0 Default: 1.0"
            }, 
            "name": {
                "docstring": "Assigns the rigid body the given name."
            }, 
            "orientation": {
                "docstring": "Sets the initial orientation (x,y,z) of the rigid body. Default: current orientation."
            }, 
            "particleCollision": {
                "docstring": "Turns the ability for a rigid body to collide with particles on and off. The particles will exert a force on the rigid body. Default: off"
            }, 
            "passive": {
                "docstring": "Creates a rigid body that is passive. A passive rigid body does not react to collisions but active rigid bodies can collide with it. Dynamic Fields will not effect a passive rigid body. Only passive rigid bodies can be keyframed."
            }, 
            "position": {
                "docstring": "Sets the initial position (x,y,z) of the rigid body. Default: current position."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeShape": {
                "docstring": ""
            }, 
            "solver": {
                "docstring": "The name of the solver which this rigid node is to resided. If the solver does not exists then the rigid body will not be created. If the edit flag is thrown add the solver exists, the rigid body will be moved to that solver."
            }, 
            "spinImpulse": {
                "docstring": "Applies an spin impulse (instantaneous rotational) force on a rigid body. Default: 0.0 0.0 0.0"
            }, 
            "standInObject": {
                "docstring": "Causes the simulator to use a stand in object for the simulation. The choices are none | cube | sphere. The default is none. Default: none"
            }, 
            "staticFriction": {
                "docstring": "Sets the static friction for the rigid body. Range: 0.0 - 1.0 Default: 0.2"
            }, 
            "tesselationFactor": {
                "docstring": "Sets the tesselation factor for a rigid body surface. Range: = 10 Default: 200."
            }, 
            "velocity": {
                "docstring": "Current velocity of rigid body."
            }
        }
    }, 
    "rigidSolver": {
        "description": "This command sets the attributes for the rigid solver In query mode, return type is based on queried flag.", 
        "flags": {
            "autoTolerances": {
                "docstring": "Turns the auto tolerance calculation on and off. The auto tolerances calculation will override the default or user defined values of the step size and collision tolerance value that is calculated based on the objects in the scene. Default: 0 (off)"
            }, 
            "bounciness": {
                "docstring": "Turns bounciness on and off for the an the objects in the simulation. Default value: on"
            }, 
            "cacheData": {
                "docstring": "Turns the cache on fall all rigid bodies in the system. Default value: off"
            }, 
            "collide": {
                "docstring": "Disallows the interpenetration of the two rigid bodies listed. Default: Collide is on for all bodies."
            }, 
            "collisionTolerance": {
                "docstring": "Sets the collision tolerance. This is the error at which two objects are considered to have collided. Range: 0.0005 - 1.000 Default: 0.02"
            }, 
            "contactData": {
                "docstring": "Turns the contact data information on/off for all rigid bodies. Default value: off"
            }, 
            "create": {
                "docstring": "Creates a new rigid solver."
            }, 
            "current": {
                "docstring": "Sets rigid solver as the current solver."
            }, 
            "deleteCache": {
                "docstring": "Deletes the cache for all rigid bodies in the system."
            }, 
            "displayCenterOfMass": {
                "docstring": "Displays the center of mass icon. Default value: on"
            }, 
            "displayConstraint": {
                "docstring": "Displays the constraint vectors. Default value: on"
            }, 
            "displayVelocity": {
                "docstring": "Displays the velocity vectors. Default value: off"
            }, 
            "dynamics": {
                "docstring": "Turns dynamics on and off for the an the objects in the simulation. Default value: on"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "friction": {
                "docstring": "Turns friction on and off for the an the objects in the simulation. Default value: on"
            }, 
            "interpenetrate": {
                "docstring": "Allows the two rigid bodies listed to interpenetrate. Default: interpenetration is off for all bodies."
            }, 
            "interpenetrationCheck": {
                "docstring": "Checks for interpenetrating rigid bodies in the scene."
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rigidBodies": {
                "docstring": "Returns a list of rigid bodies in the solver."
            }, 
            "rigidBodyCount": {
                "docstring": "Returns the number of rigid bodies in the solver.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "showCollision": {
                "docstring": "Displays the colliding objects in a different color."
            }, 
            "showInterpenetration": {
                "docstring": "Displays the interpenetrating objects in a different color."
            }, 
            "solverMethod": {
                "docstring": "Sets the solver method. The choices are 0 | 1 | 2. 0 = Euler (fastest/least acurate), 1 = Runge-Kutta ( slower/more acurate), 2 = adaptive Runge-Kutta (slowest/most acurate). The default is 2 (adaptive Runge-Kutta)"
            }, 
            "startTime": {
                "docstring": "Sets the start time for the solver."
            }, 
            "state": {
                "docstring": "Turns the rigid solver on or off."
            }, 
            "statistics": {
                "docstring": "Turns the statistic information on/off for all rigid bodies. Default value: off"
            }, 
            "stepSize": {
                "docstring": "Sets the solvers step size. This is the maximum size of a single step the solver will take at one time. Range: 0.0004 - 0.100 Default: 0.0333"
            }, 
            "velocityVectorScale": {
                "docstring": "scales the velocity vector display. Default value: 1.0"
            }
        }
    }, 
    "roll": {
        "description": "The roll command rotates a camera about its viewing direction, a positive angle produces clockwise camera rotation, while a negative angle produces counter-clockwise camera rotation. The default mode is relative and the rotation is applied with respect to the current orientation of the camera. When mode is set to absolute, the rotation is applied with respect to the plane constructed from the following three vectors in the world space: the world up vector, the camera view vector, and the camera up vector. The rotation angle is specified in degrees. The roll command can be applied to either a perspective or an orthographic camera. This command may be applied to more than one camera; objects that are not cameras are ignored. When no camera name supplied, this command is applied to all currently active cameras. ", 
        "flags": {
            "absolute": {
                "docstring": "Set to absolute mode."
            }, 
            "degree": {
                "docstring": "Set the amount of the rotation angle.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "relative": {
                "docstring": "Set to relative mode."
            }
        }
    }, 
    "rollCtx": {
        "description": "Create, edit, or query a roll context. ", 
        "flags": {
            "alternateContext": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rollScale": {
                "docstring": "In degrees of rotation per 100 pixels of cursor drag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "toolName": {
                "docstring": ""
            }
        }
    }, 
    "rotate": {
        "description": "The rotate command is used to change the rotation of geometric objects. The rotation values are specified as Euler angles (rx, ry, rz). The values are interpreted based on the current working unit for Angular measurements. Most often this is degrees. The default behaviour, when no objects or flags are passed, is to do a absolute rotate on each currently selected object in the world space. ", 
        "flags": {
            "absolute": {
                "docstring": "Perform an absolute operation."
            }, 
            "centerPivot": {
                "docstring": "Let the pivot be the center of the bounding box of all objects"
            }, 
            "deletePriorHistory": {
                "docstring": ""
            }, 
            "euler": {
                "docstring": "Modifer for -relative flag that specifies rotation values should be added to current XYZ rotation values."
            }, 
            "objectCenterPivot": {
                "docstring": "Let the pivot be the center of the bounding box of each object"
            }, 
            "objectSpace": {
                "docstring": "Perform rotation about object-space axis."
            }, 
            "pivot": {
                "docstring": "Define the pivot point for the transformation"
            }, 
            "preserveChildPosition": {
                "docstring": ""
            }, 
            "preserveUV": {
                "docstring": "When true, UV values on rotated components are projected across the rotation in 3d space. For small edits, this will freeze the world space texture mapping on the object. When false, the UV values will not change for a selected vertices. Default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reflection": {
                "docstring": "To move the corresponding symmetric components also."
            }, 
            "reflectionAboutBBox": {
                "docstring": "Sets the position of the reflection axis at the geometry bounding box"
            }, 
            "reflectionAboutOrigin": {
                "docstring": "Sets the position of the reflection axis at the origin"
            }, 
            "reflectionAboutX": {
                "docstring": "Specifies the X=0 as reflection plane"
            }, 
            "reflectionAboutY": {
                "docstring": "Specifies the Y=0 as reflection plane"
            }, 
            "reflectionAboutZ": {
                "docstring": "Specifies the Z=0 as reflection plane"
            }, 
            "reflectionTolerance": {
                "docstring": "Specifies the tolerance to findout the corresponding reflected components"
            }, 
            "relative": {
                "docstring": "Perform a operation relative to the object's current position"
            }, 
            "rotateX": {
                "docstring": "Rotate in X direction"
            }, 
            "rotateXY": {
                "docstring": "Rotate in X and Y direction"
            }, 
            "rotateXYZ": {
                "docstring": "Rotate in all directions (default)"
            }, 
            "rotateXZ": {
                "docstring": "Rotate in X and Z direction"
            }, 
            "rotateY": {
                "docstring": "Rotate in Y direction"
            }, 
            "rotateYZ": {
                "docstring": "Rotate in Y and Z direction"
            }, 
            "rotateZ": {
                "docstring": "Rotate in Z direction"
            }, 
            "worldSpace": {
                "docstring": "Perform rotation about global world-space axis."
            }
        }
    }, 
    "rotationInterpolation": {
        "description": "The rotationInterpolation command converts the rotation curves to the desired rotation interpolation representation. For example, an Euler-angled representation can be converted to Quaternion. In query mode, return type is based on queried flag.", 
        "flags": {
            "convert": {
                "docstring": "Specifies the rotation interpolation mode for the curves after converting. Possible choices are \"none\" (unsynchronized Euler-angled curves which are compatible with pre-4.0 Maya curves), \"euler\" (Euler-angled curves with keyframes kept synchronized), \"quaternion\" (quaternion curves with keyframes kept synchronized, but the exact interpolation depends on individual tangents), \"quaternionSlerp\" (applies quaternion slerp interpolation to the curve, ignoring tangent settings), \"quaternionSquad\" (applied cubic interpolation to the curve in quaternion space, ignoring tangent settings)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "roundCRCtx": {
        "description": "", 
        "flags": {
            "activeNodes": {
                "docstring": ""
            }, 
            "append": {
                "docstring": ""
            }, 
            "autoCreate": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "currentEdge": {
                "docstring": ""
            }, 
            "currentEdgeRadius": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "immediate": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "radiusToUse": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": ""
            }, 
            "toolNode": {
                "docstring": ""
            }, 
            "useGlobalTolerance": {
                "docstring": ""
            }
        }
    }, 
    "roundConstantRadius": {
        "description": "This command generates constant radius NURBS fillets and NURBS corner surfaces for matching edge pairs on NURBS surfaces. An edge pair is a matching pair of surface isoparms or trim edges. This command can handle more than one edge pair at a time. This command can also handle compoundedges, which is where an edge pair is composed of more than two surfaces. Use the \"-sa\" and \"-sb\" flags in this case. The results from this command are three surface var groups plus the name of the new roundConstantRadius dependency node, if history was on. The 1st var group contains trimmed copies of the original surfaces. The 2nd var group contains the new NURBS fillet surfaces. The 3rd var group contains the new NURBS corners (if any). A simple example of an edge pair is an edge of a NURBS cube, where two faces of the cube meet. This command generates a NURBS fillet at the edge and trims back the faces. Another example is a NURBS cylinder with a planar trim surface cap. This command will create a NURBS fillet where the cap meets the the cylinder and will trim back the cap and the cylinder. Another example involves all 12 edges of a NURBS cube. NURBS fillets are created where any face meets another face. NURBS corners are created whenever 3 edges meet at a corner. ", 
        "flags": {
            "append": {
                "docstring": "If true, then an edge pair is being added to an existing round dependency node. Default is false. You must specify an existing round dependency node when this flag is true. See example below."
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": ""
            }, 
            "radiuss": {
                "docstring": "Use this flag to specify radius. This overrides the \"r/radius\" flag. If only one \"rad\" flag is used, then it is applied to all edge pairs. If 1 \"rad\" flag is used, then the number of \"-rad\" flags must equal the number of edge pairs. For example, for four edge pairs, you must specify zero, one or four \"rad\" flags."
            }, 
            "side": {
                "docstring": "Use this flag for compound edges. It replaces the sidea/sideb flags and is compatible with Python. The first argument must be either \"a\" or \"b\". You must specify the same number of \"a\" values as \"b\" values. If no sides are specified with the \"side\" flag (or sidea/sideb flags), then the edges are assumed to be in pairs. See also examples below. For example, two faces of a cube meet at an edge pair. Suppose one of the faces is then split in two pieces at the middle of the edge, so that there is one face on side \"A\", and two pieces on side \"B\". In this case you would use the flag combination: -side \"a\" 1 -side \"b\" 2. You must specify the edges in the corresponding order: // MEL roundConstantRadius -side \"a\" 1 -side \"b\" 2 isoA isoB1 isoB2; # Python maya.cmds.roundConstantRadius( 'isoA', 'isoB1', 'isoB2', side=[(\"a\",1), (\"b\",2)] )Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "sidea": {
                "docstring": "Use this flag for compound edges in conjunction with the following \"-sb\" flag. This flag is not intended for use from Python. Please see \"side\" flag instead. You must specify the same number of \"-sa\" flags as \"-sb\" flags. If no \"-sa\" nor \"-sb\" flags are specified, then the edges are assumed to be in pairs. See also examples below. For example, two faces of a cube meet at an edge pair. Suppose one of the faces is then split in two pieces at the middle of the edge, so that there is one face on side \"A\", and two pieces on side \"B\". In this case you would use the flag combination: -sidea 1 -sideb 2. You must specify the edges in the corresponding order: roundConstantRadius -sidea 1 -sideb 2 isoA isoB1 isoB2;"
            }, 
            "sideb": {
                "docstring": "Use this flag for compound edges in conjunction with the \"-sa\" flag. See description for the \"-sa\" flag. This flag is not intended for use from Python. Please see \"side\" flag instead."
            }, 
            "tolerance": {
                "docstring": ""
            }
        }
    }, 
    "rowColumnLayout": {
        "description": "This command creates a rowColumn layout. A rowColumn layout positions children in either a row or column format. A column layout, specified with the -nc/numberOfColumnsflag, allows you set text alignment, attachments and offsets for each column in the layout. Every member of a column will have the same alignment, attachment and offsets. Likewise the row format, specified by the -nr/numberOfRowsflag, allows setting of these attributes for each row in the layout. Every member of a row will have the same attributes. The layout must be either a row or column format. This layout does not support both, or the specification of attributes on an individual child basis. Some flags only make sense for one of either the row format or the column format. For example the -rh/rowHeightflag can only be specified in row format. In column format the row height is determined by the tallest child in the row, plus offsets. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "columnAlign": {
                "docstring": "Alignment for text and pixmaps in the specified column. Values are: \"left\", \"right\" and \"center\". Only valid for column format, ie. number of columns specified with -nc/numberOfColumnsflag."
            }, 
            "columnAttach": {
                "docstring": "The attachements and offsets for the children in the specified column. The first argument is the 1-based column index. The second argument is the attachment, valid values are \"left\", \"right\" and \"both\". The third argument must be greater than 0 and specifies the offset."
            }, 
            "columnOffset": {
                "docstring": "The attachment offset for the specified column. The first argument is the 1-based column index. The second argument is the attachment, valid values are \"left\", \"right\" and \"both\". The third argument must be greater than 0 and specifies the offset."
            }, 
            "columnSpacing": {
                "docstring": "The space between columns in pixels. In column format this flag specifies that the space be to the left of the given column. In row format it specifies the space between all columns, however a valid column index is still required. The first argument is the 1-based column index. The second argument must be greater than 0 and specifies the spacing."
            }, 
            "columnWidth": {
                "docstring": "Width of a column. This flag is valid only in column format. The column width must be greater than 0. The first argument is the 1-based column index. The second argument must be greater than 0 and specifies the column width."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfColumns": {
                "docstring": "Number of columns. This flag is mutually exclusive to the -nr/numRowsflag. Either one or the other can be specified."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "numberOfRows": {
                "docstring": "Number of rows. This flag is mutually exclusive to the -nc/numColumnsflag. Either one or the other can be specified."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAlign": {
                "docstring": "Alignment for text and pixmaps in the specified row. Values are: \"left\", \"right\" and \"center\". Only valid for row format, ie. number of rows specified with -nr/numberOfRowsflag."
            }, 
            "rowAttach": {
                "docstring": "The attachements and offsets for the children in the specified row. The first argument is the 1-based row index. The second argument is the attachment, valid values are \"top\", \"bottom\" and \"both\". The third argument must be greater than 0 and specifies the offset."
            }, 
            "rowHeight": {
                "docstring": "Height of a row. This flag is only valid in row format. The row height must be greater than 0. The first argument is the 1-based row index. The second argument must be greater than 0 and specifies the row height."
            }, 
            "rowOffset": {
                "docstring": "The attachment offset for the specified row. The first argument is the 1-based row index. The second argument is the attachment, valid values are \"top\", \"bottom\" and \"both\". The third argument must be greater than 0 and specifies the offset."
            }, 
            "rowSpacing": {
                "docstring": "The space between rows, in pixels. In row format this specifies the space above the specified row. In column format it specifies the space between all rows, however a valid row index is still required. The first argument is the 1-based row index. The second argument must be greater than 0 and specifies the spacing.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "rowLayout": {
        "description": "This command creates a layout capable of positioning children into a single horizontal row. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout."
            }, 
            "adjustableColumn1": {
                "docstring": "Specifies that the first column has an adjustable size that changes with the size of the parent layout. Ignored if there isn't exactly one column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which of the two columns has an adjustable size that changes with the size of the parent layout. Ignored if there isn't exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies which of the three columns has an adjustable size that changes with the size of the parent layout. Ignored if there isn't exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which of the four columns has an adjustable size that changes with the size of the parent layout. Ignored if there isn't exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which of the five columns has an adjustable size that changes with the size of the parent layout. Ignored if there isn't exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which of the six columns has an adjustable size that changes with the size of the parent layout. Ignored if there isn't exactly six columns.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "columnAlign": {
                "docstring": "Text alignment for the specified column. Valid values are \"left\", \"right\", and \"center\""
            }, 
            "columnAlign1": {
                "docstring": "Text alignment for the first column. Valid values are \"left\", \"right\", and \"center\". Ignored if there isn't exactly one column."
            }, 
            "columnAlign2": {
                "docstring": "Text alignment for both columns. Valid values are \"left\", \"right\", and \"center\". Ignored if there isn't exactly two columns."
            }, 
            "columnAlign3": {
                "docstring": "Text alignment for all three columns. Valid values are \"left\", \"right\", and \"center\". Ignored if there isn't exactly three columns."
            }, 
            "columnAlign4": {
                "docstring": "Text alignment for all four columns. Valid values are \"left\", \"right\", and \"center\". Ignored if there isn't exactly four columns."
            }, 
            "columnAlign5": {
                "docstring": "Text alignment for all five columns. Valid values are \"left\", \"right\", and \"center\". Ignored if there isn't exactly five columns."
            }, 
            "columnAlign6": {
                "docstring": "Text alignment for all six columns. Valid values are \"left\", \"right\", and \"center\". Ignored if there isn't exactly six columns."
            }, 
            "columnAttach": {
                "docstring": "Horizontally attach a particular column. The first argument is a 1-based index specifying the column. The second argument is the attachment, valid values are \"left\", \"right\", and \"both\". The third argument is the offset value."
            }, 
            "columnAttach1": {
                "docstring": "Attachment type for the first column. Ignored if there isn't exactly one column. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach2": {
                "docstring": "Attachment type for both columns. Ignored if there isn't exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Attachment type for all three columns. Ignored if there isn't exactly three columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Attachment type for all four columns. Ignored if there isn't exactly four columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Attachment type for all five columns. Ignored if there isn't exactly five columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Attachment type for all six columns. Ignored if there isn't exactly six columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset1": {
                "docstring": "Used in conjunction with the -columnAttach1 flag. If that flag is not used then this flag will be ignored. Sets the offset for the first column. The offsets applied are based on the attachments specified with the -columnAttach1 flag. Ignored if there isn't exactly one column."
            }, 
            "columnOffset2": {
                "docstring": "Used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. Sets the offset for both columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there isn't exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "Used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. Sets the offset for all three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there isn't exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "Used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. Sets the offset for all four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there isn't exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "Used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. Sets the offset for all five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there isn't exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "Used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. Sets the offset for all six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there isn't exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Width of a particular column. The first argument is a 1-based index specifying the column. The second argument is the width value."
            }, 
            "columnWidth1": {
                "docstring": "Width for the first column. Ignored if there isn't exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Widths for both columns. Ignored if there isn't exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Widths for all three columns. Ignored if there isn't exactly three columns."
            }, 
            "columnWidth4": {
                "docstring": "Widths for all four columns. Ignored if there isn't exactly four columns."
            }, 
            "columnWidth5": {
                "docstring": "Widths for all five columns. Ignored if there isn't exactly five columns."
            }, 
            "columnWidth6": {
                "docstring": "Widths for all six columns. Ignored if there isn't exactly six columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfColumns": {
                "docstring": "Number of columns in the row. The specified number of columns must be a value greater than 0."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Vertically attach a particular column. The first argument is a 1-based index specifying the column. The second argument is the attachment, valid values are \"top\", \"bottom\", and \"both\". The third argument is the offset value."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "runTimeCommand": {
        "description": "", 
        "flags": {
            "annotation": {
                "docstring": ""
            }, 
            "category": {
                "docstring": ""
            }, 
            "categoryArray": {
                "docstring": ""
            }, 
            "command": {
                "docstring": ""
            }, 
            "commandArray": {
                "docstring": ""
            }, 
            "commandLanguage": {
                "docstring": ""
            }, 
            "default": {
                "docstring": ""
            }, 
            "defaultCommandArray": {
                "docstring": ""
            }, 
            "delete": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "numberOfCommands": {
                "docstring": ""
            }, 
            "numberOfDefaultCommands": {
                "docstring": ""
            }, 
            "numberOfUserCommands": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "save": {
                "docstring": ""
            }, 
            "userCommandArray": {
                "docstring": ""
            }
        }
    }, 
    "runup": {
        "description": "runup plays the scene through a frame of frames, forcing dynamic objects to evaluate as it does so. If no max frame is specified, runup runs up to the current time. ", 
        "flags": {
            "cache": {
                "docstring": "Cache the state after the runup."
            }, 
            "fromPreviousFrame": {
                "docstring": "Run up the animation from the previously evaluated frame. If no flag is supplied this is the default."
            }, 
            "fromStartFrame": {
                "docstring": "Run up the animation from the start frame. If no flag is supplied -fromPreviousFrame is the default."
            }, 
            "maxFrame": {
                "docstring": "Ending time for runup, in current user time units. The runup will always start at the minimum start frame for all dynamic objects."
            }, 
            "state": {
                "docstring": "Turns runup and cache on/off.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "sampleImage": {
        "description": "The sampleImage command is used to control parameters of sample images, such as swatches in the multilister. The fast option turns on or off some rendering cheats which speed up the render but may cause edges to look ragged. The resolution option specifies the width in pixels of the image which will be rendered for the specified node. Note that the width of the image is also the height of the image since sample images are square. ", 
        "flags": {
            "fastSample": {
                "docstring": "If fast but rough rendering for sampleImage is to be used"
            }, 
            "resolution": {
                "docstring": "The first argument to this flag specifies a resolution in pixels. The second argument specifies a dependency node. The effect of this flag is that further sample image renderings for the specified node will be made at the specified resolution.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "saveAllShelves": {
        "description": "This command writes all shelves that are immediate children of the specified control layout to the prefs directory. ", 
        "flags": {}
    }, 
    "saveFluid": {
        "description": "A command to save the current state of the fluid to the initial state cache. The grids to be saved are determined by the cache attributes: cacheDensity, cacheVelocity, etc. These attributes are normally set from the options on Set Initial State. The cache must be set up before invoking this command. In query mode, return type is based on queried flag.", 
        "flags": {
            "currentTime": {
                "docstring": "cache state of fluid at current time"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endTime": {
                "docstring": "end Time for cacheingFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "startTime": {
                "docstring": "start Time for cacheing"
            }
        }
    }, 
    "saveImage": {
        "description": "This command creates a static image control for non-xpm files used to display a thumbnail image of the scene file. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "currentView": {
                "docstring": "Generate the image from the current view."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "image": {
                "docstring": ""
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "objectThumbnail": {
                "docstring": "Use an image of the named object, if possible."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sceneFile": {
                "docstring": "The name of the file that the icon is to be associated with.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "saveInitialState": {
        "description": "saveInitialState saves the current state of dynamics objects as the initial state. A dynamic object is a particle shape, rigid body, rigid constraint or rigid solver. If no objects are specified, it saves the initial state for any selected objects. It returns the names of the objects for which initial state was saved. ", 
        "flags": {
            "attribute": {
                "docstring": "Save the initial state of the specified attribute only. This is a multi-use flag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "saveall": {
                "docstring": "Save the initial state for all dynamics objects in the scene."
            }
        }
    }, 
    "saveMenu": {
        "description": "This command is used for saving the contents of a menu, so that another instance of the menu may be recreated later. The command writes out a file which, when run as a script, will rebuild the menuItems contained in the original menu. Note that the fileName is relative to the user's marking menu preference directory. Note that this command is used solely by the Marking Menu Editor and is not intended to be used for general purposes. Note that this command doesn't work well with controls that have mixed mel and python command callbacks. Also, because it saves the menu state to a mel file, it does not work with callbacks that are python callable objects. The first argument is the name of the manu to save, the second one is the name of the file. ", 
        "flags": {}
    }, 
    "savePrefObjects": {
        "description": "This command saves preference dependency nodes to \"userPrefObjects.ma\" in the user preference directory. ", 
        "flags": {}
    }, 
    "savePrefs": {
        "description": "This command saves preferences to disk. If no flags are specified then all pref types get saved out. ", 
        "flags": {
            "colors": {
                "docstring": "Save the color prefs to disk"
            }, 
            "general": {
                "docstring": "Save the general prefs to disk (optionVars)"
            }, 
            "hotkeys": {
                "docstring": "Save the hotkeys to disk"
            }, 
            "menuSets": {
                "docstring": ""
            }, 
            "plugins": {
                "docstring": "Save the plug-in prefs to diskFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "uiLayout": {
                "docstring": "Save each window's size and position to disk"
            }
        }
    }, 
    "saveShelf": {
        "description": "This command saves the specified shelf (first argument) to the specified file (second argument). Note that this command doesn't work well with controls that have mixed mel and python command callbacks. Also, because it saves the state to a mel file, it does not work with callbacks that are python callable objects. ", 
        "flags": {}
    }, 
    "saveToolSettings": {
        "description": "This command causes all the tools not on the shelf to save their settings as optionVars. This is called automatically by the system when Maya exits. ", 
        "flags": {}
    }, 
    "saveViewportSettings": {
        "description": "This command causes all the 3d views to save their settings as optionVar's. This is called automatically by the system when Maya exits. ", 
        "flags": {}
    }, 
    "scale": {
        "description": "The scale command is used to change the sizes of geometric objects. The default behaviour, when no objects or flags are passed, is to do a relative scale on each currently selected object object using each object's existing scale pivot point. ", 
        "flags": {
            "absolute": {
                "docstring": "Perform an absolute operation."
            }, 
            "centerPivot": {
                "docstring": "Let the pivot be the center of the bounding box of all objects"
            }, 
            "deletePriorHistory": {
                "docstring": ""
            }, 
            "distanceOnly": {
                "docstring": "Scale only the distance between the objects."
            }, 
            "localSpace": {
                "docstring": ""
            }, 
            "objectCenterPivot": {
                "docstring": "Let the pivot be the center of the bounding box of each object"
            }, 
            "objectSpace": {
                "docstring": ""
            }, 
            "orientAxes": {
                "docstring": ""
            }, 
            "pivot": {
                "docstring": "Define the pivot point for the transformation"
            }, 
            "preserveChildPosition": {
                "docstring": ""
            }, 
            "preserveUV": {
                "docstring": "When true, UV values on scaled components are projected along the axis of scaling in 3d space. For small edits, this will freeze the world space texture mapping on the object. When false, the UV values will not change for a selected vertices. Default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reflection": {
                "docstring": "To move the corresponding symmetric components also."
            }, 
            "reflectionAboutBBox": {
                "docstring": "Sets the position of the reflection axis at the geometry bounding box"
            }, 
            "reflectionAboutOrigin": {
                "docstring": "Sets the position of the reflection axis at the origin"
            }, 
            "reflectionAboutX": {
                "docstring": "Specifies the X=0 as reflection plane"
            }, 
            "reflectionAboutY": {
                "docstring": "Specifies the Y=0 as reflection plane"
            }, 
            "reflectionAboutZ": {
                "docstring": "Specifies the Z=0 as reflection plane"
            }, 
            "reflectionTolerance": {
                "docstring": "Specifies the tolerance to findout the corresponding reflected components"
            }, 
            "relative": {
                "docstring": "Perform a operation relative to the object's current position"
            }, 
            "scaleX": {
                "docstring": "Scale in X direction"
            }, 
            "scaleXY": {
                "docstring": "Scale in X and Y direction"
            }, 
            "scaleXYZ": {
                "docstring": "Scale in all directions (default)"
            }, 
            "scaleXZ": {
                "docstring": "Scale in X and Z direction"
            }, 
            "scaleY": {
                "docstring": "Scale in Y direction"
            }, 
            "scaleYZ": {
                "docstring": "Scale in Y and Z direction"
            }, 
            "scaleZ": {
                "docstring": "Scale in Z direction"
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "scaleComponents": {
        "description": "This is a limited version of the scale command. First, it only works on selected components. You provide a pivot in world space, and you can provide a rotation. This rotation affects the scaling, so that rather than scaling in X, Y, Z, this is scaling in X, Y, and Z after they have been rotated by the given rotation. This allows selected components to be scaled in any arbitrary space, not just object or world space as the regular scale allows. Scale values are always relative, not absolute. ", 
        "flags": {
            "pivot": {
                "docstring": "The pivot position in world space (default is origin)"
            }, 
            "rotation": {
                "docstring": "The rotational offset for the scaling (default is none)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "scaleConstraint": {
        "description": "Constrain an object's scale to the scale of the target object or to the average scale of a number of targets. A scaleConstraint takes as input one or more \"target\" DAG transform nodes to which to scale the single \"constraint object\" DAG transform node. The scaleConstraint scales the constrained object at the weighted geometric mean of the world space target scale factors. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "layer": {
                "docstring": "Specify the name of the animation layer where the constraint should be added."
            }, 
            "maintainOffset": {
                "docstring": "The offset necessary to preserve the constrained object's initial scale will be calculated and used as the offset."
            }, 
            "name": {
                "docstring": "Sets the name of the constraint node to the specified name. Default name is constrainedObjectName_constraintType"
            }, 
            "offset": {
                "docstring": "Sets or queries the value of the offset. Default is 1,1,1."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the listed target(s) from the constraint."
            }, 
            "skip": {
                "docstring": "Specify the axis to be skipped. Valid values are \"x\", \"y\", \"z\" and \"none\". During creation, \"none\" is the default. This flag is multi-use.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "targetList": {
                "docstring": "Return the list of target objects."
            }, 
            "weight": {
                "docstring": "Sets the weight value for the specified target(s). If not given at creation time, the default value of 1.0 is used."
            }, 
            "weightAliasList": {
                "docstring": "Returns the names of the attributes that control the weight of the target objects. Aliases are returned in the same order as the targets are returned by the targetList flag"
            }
        }
    }, 
    "scaleKey": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.This command takes keyframes at (or within) the specified times (or time ranges) and scales them. If no times are specified, the scale is applied to active keyframes or (if no keys are active) all keys of active objects. ", 
        "flags": {
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "floatPivot": {
                "docstring": "Scale pivot along the x-axis for float-input animCurves"
            }, 
            "floatScale": {
                "docstring": "Amount of scale along the x-axis for float-input animCurves"
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "newEndFloat": {
                "docstring": "The end of the float range to which the float-input targets should be scaled."
            }, 
            "newEndTime": {
                "docstring": "The end of the time range to which the targets should be scaled."
            }, 
            "newStartFloat": {
                "docstring": "The start of the float range to which the float-input targets should be scaled."
            }, 
            "newStartTime": {
                "docstring": "The start of the time range to which the time-input targets should be scaled."
            }, 
            "scaleSpecifiedKeys": {
                "docstring": "Determines if only the specified keys are affected by the scale. If false, other keys may be adjusted with the scale. The default is true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }, 
            "timePivot": {
                "docstring": "Scale pivot along the time-axis for time-input animCurves"
            }, 
            "timeScale": {
                "docstring": "Amount of scale along the time-axis for time-input animCurves"
            }, 
            "valuePivot": {
                "docstring": "Scale pivot along the value-axis"
            }, 
            "valueScale": {
                "docstring": "Amount of scale along the value-axis"
            }
        }
    }, 
    "scaleKeyCtx": {
        "description": "This command creates a context which may be used to scale keyframes within the graph editor ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scaleSpecifiedKeys": {
                "docstring": "Determines if only the specified keys should be scaled. If false, the non-selected keys will be adjusted during the scale. The default is true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "type": {
                "docstring": "rect | manip Specifies the type of scale manipulator to use (Note: \"rect\" is a manipulator style context, and \"manip\" is a gestural style context)"
            }
        }
    }, 
    "sceneEditor": {
        "description": "This creates an editor for managing the files in a scene. ", 
        "flags": {
            "asURI": {
                "docstring": "When used with the 'selectItem' and 'unresolvedName' query, it indicates that the file name returned will be URI.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "onlyParents": {
                "docstring": "When used with the 'selectItem' or 'selectReference' queries it indicates that, if both a parent and a child file or reference are selected, only the parent will be returned."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "query": {
                "docstring": ""
            }, 
            "refreshReferences": {
                "docstring": "Force refresh of references"
            }, 
            "selectCommand": {
                "docstring": "A script to be executed when an item is selected."
            }, 
            "selectItem": {
                "docstring": "Query or change the currently selected item. When queried, the currently selected file name will be return."
            }, 
            "selectReference": {
                "docstring": "Query the currently selected reference. Returns the name of the currently selected reference node."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "shortName": {
                "docstring": "When used with the 'selectItem' query it indicates that the file name returned will be the short name (i.e. just a file name without any directory paths). If this flag is not present, the full name and directory path will be returned."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "unresolvedName": {
                "docstring": "When used with the 'selectItem' query it indicates that the file name returned will be unresolved (i.e. it will be the path originally specified when the file was loaded into Maya; this path may contain environment variables and may not exist on disk). If this flag is not present, the resolved name will be returned."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "withoutCopyNumber": {
                "docstring": "When used with the 'selectItem' query it indicates that the file name returned will not have a copy number appended to the end. If this flag is not present, the file name returned may have a copy number appended to the end."
            }
        }
    }, 
    "sceneUIReplacement": {
        "description": "This command returns existing scene based UI that can be utilized by the scene that is being loaded. It can also delete any such UI that is not used by the loading scene. ", 
        "flags": {
            "clear": {
                "docstring": "Frees any resources allocated by the command."
            }, 
            "deleteRemaining": {
                "docstring": "Delete any UI that is scene dependent and has not been referenced by this command since the last update.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "getNextFilter": {
                "docstring": "Returns the next filter of the specified type with the specified name."
            }, 
            "getNextPanel": {
                "docstring": "Returns the next panel of the specified type, preferably with the specified label."
            }, 
            "getNextScriptedPanel": {
                "docstring": "Returns the next scripted panel of the specified scripted panel type, preferably with the specified label."
            }, 
            "update": {
                "docstring": "Updates the state of the command to reflect the current state of the application. The string argument is the name of the main window pane layout holding the panels."
            }
        }
    }, 
    "scmh": {
        "description": "Set the current manipulator handle value(s). In UI units (where applicable), though the syntax is set to handle the unit type of the current manipulator handle (if available). ", 
        "flags": {
            "absolute": {
                "docstring": "The values are absolute"
            }, 
            "ignore": {
                "docstring": "This is a multiuse flag which specifies that the index-th (1-based) entry is to be ignored"
            }, 
            "quiet": {
                "docstring": "This flag suppresses all error messagesFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "relative": {
                "docstring": "The values are relative"
            }
        }
    }, 
    "scriptCtx": {
        "description": "This command allows a user to create their own tools based on the selection tool. A number of selection lists can be collected, the behaviour of the selection and the selection masks are fully customizable, etc. The command is processed prior to being executed. The keyword \"$Selection#\" where # is a number 1 or greater specifies a selection set. The context can specify several selection sets which are substituted in place of the $Selection# keyword in the form of a Mel string array. Items that are specific per set need to be specified in each set, if they are going to be specified for any of the sets. See examples below. In addition, in order to specify the type of selection you need to be making, any of the selection type flags from \"selectType\" command can be used here. ", 
        "flags": {
            "allComponents": {
                "docstring": ""
            }, 
            "allObjects": {
                "docstring": ""
            }, 
            "animBreakdown": {
                "docstring": ""
            }, 
            "animCurve": {
                "docstring": ""
            }, 
            "animInTangent": {
                "docstring": ""
            }, 
            "animKeyframe": {
                "docstring": ""
            }, 
            "animOutTangent": {
                "docstring": ""
            }, 
            "baseClassName": {
                "docstring": "This string will be used to produce MEL function names for the property sheets for the tool. For example, if \"myScriptTool\" was given, the functions \"myScriptToolValues\" and \"myScriptToolProperties\" will be used for the property sheets. The default is \"scriptTool\"."
            }, 
            "camera": {
                "docstring": ""
            }, 
            "cluster": {
                "docstring": ""
            }, 
            "collisionModel": {
                "docstring": ""
            }, 
            "controlVertex": {
                "docstring": ""
            }, 
            "cumulativeLists": {
                "docstring": "If set, the selection lists will be cumulative. For example, the second list will contain all the items from the first list, the third all the items from the second list etc. Make sure your script specified above takes that into account. Relevant if there is more than one selection set."
            }, 
            "curve": {
                "docstring": ""
            }, 
            "curveKnot": {
                "docstring": ""
            }, 
            "curveOnSurface": {
                "docstring": ""
            }, 
            "curveParameterPoint": {
                "docstring": ""
            }, 
            "dimension": {
                "docstring": ""
            }, 
            "dynamicConstraint": {
                "docstring": ""
            }, 
            "edge": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editPoint": {
                "docstring": ""
            }, 
            "emitter": {
                "docstring": ""
            }, 
            "enableRootSelection": {
                "docstring": "If set, the items to be selected are at their root transform level. Default is false."
            }, 
            "exists": {
                "docstring": ""
            }, 
            "exitUponCompletion": {
                "docstring": "If set, completing the last selection set will exit the tool. Default is true."
            }, 
            "expandSelectionList": {
                "docstring": "If set, the selection lists will expand to have a single component in each item. You probably want this as a default, otherwise two isoparms on the same surface will show up as 1 item. To ensure that components on the same object are returned in the order in which they are selected, use the selectPref -trackSelectionOrder oncommand in your -toolStartscript to enable ordered selection, then restore it to its original value in your -toolFinishscript."
            }, 
            "facet": {
                "docstring": ""
            }, 
            "field": {
                "docstring": ""
            }, 
            "finalCommandScript": {
                "docstring": "Supply the script that will be run when the user presses the enter key and the context is completed. Depending on the number of selection sets you have, the script can make use of variables string $Selection1[], $Selection2[], ..."
            }, 
            "fluid": {
                "docstring": ""
            }, 
            "follicle": {
                "docstring": ""
            }, 
            "forceAddSelect": {
                "docstring": "If set to true, together with -setAutoToggleSelection (see below) on the first selection set, causes the first selection after the computation of the previous result to be \"shift\" selection, unless a modifier key is pressed. Default is false. Flags for each selection set. These flags are multi-use."
            }, 
            "hairSystem": {
                "docstring": ""
            }, 
            "handle": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "hull": {
                "docstring": ""
            }, 
            "ignoreInvalidItems": {
                "docstring": "If you have multiple selection sets, the state of the selection set is recorded at the time you \"complete it\". You could then delete some of the items in that list and end up with invalid items in one or more of your selection sets. If this flag is set, those items will be detected and ignored. You will never know it happened. Its as if they were never selected in the first place, except that your selection set now does not have as many items as it may need. If this flag is not set, you will get a warning and your final command callback script will likely not execute because of an error condition."
            }, 
            "ikEndEffector": {
                "docstring": ""
            }, 
            "ikHandle": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "imagePlane": {
                "docstring": ""
            }, 
            "implicitGeometry": {
                "docstring": ""
            }, 
            "isoparm": {
                "docstring": ""
            }, 
            "joint": {
                "docstring": ""
            }, 
            "jointPivot": {
                "docstring": ""
            }, 
            "lastAutoComplete": {
                "docstring": "True if auto complete is set for the last selection set, false otherwise. Mostly used for query, but if present in conjuction with -sac/setAutoComplete flag, -sac flag takes precedence."
            }, 
            "lattice": {
                "docstring": ""
            }, 
            "latticePoint": {
                "docstring": ""
            }, 
            "light": {
                "docstring": ""
            }, 
            "localRotationAxis": {
                "docstring": ""
            }, 
            "locator": {
                "docstring": ""
            }, 
            "locatorUV": {
                "docstring": ""
            }, 
            "locatorXYZ": {
                "docstring": ""
            }, 
            "meshComponents": {
                "docstring": ""
            }, 
            "motionTrailPoint": {
                "docstring": ""
            }, 
            "motionTrailTangent": {
                "docstring": ""
            }, 
            "nCloth": {
                "docstring": ""
            }, 
            "nParticle": {
                "docstring": ""
            }, 
            "nParticleShape": {
                "docstring": ""
            }, 
            "nRigid": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nonlinear": {
                "docstring": ""
            }, 
            "nurbsCurve": {
                "docstring": ""
            }, 
            "nurbsSurface": {
                "docstring": ""
            }, 
            "objectComponent": {
                "docstring": ""
            }, 
            "orientationLocator": {
                "docstring": ""
            }, 
            "particle": {
                "docstring": ""
            }, 
            "particleShape": {
                "docstring": ""
            }, 
            "plane": {
                "docstring": ""
            }, 
            "polymesh": {
                "docstring": ""
            }, 
            "polymeshEdge": {
                "docstring": ""
            }, 
            "polymeshFace": {
                "docstring": ""
            }, 
            "polymeshFreeEdge": {
                "docstring": ""
            }, 
            "polymeshUV": {
                "docstring": ""
            }, 
            "polymeshVertex": {
                "docstring": ""
            }, 
            "polymeshVtxFace": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rigidBody": {
                "docstring": ""
            }, 
            "rigidConstraint": {
                "docstring": ""
            }, 
            "rotatePivot": {
                "docstring": ""
            }, 
            "scalePivot": {
                "docstring": ""
            }, 
            "sculpt": {
                "docstring": ""
            }, 
            "selectHandle": {
                "docstring": ""
            }, 
            "setAllowExcessCount": {
                "docstring": "If set, the number if items is to be interpreted as the minimum."
            }, 
            "setAutoComplete": {
                "docstring": "If set to true, as soon as the specified number of items is selected the tool will start the next selection set or run the command."
            }, 
            "setAutoToggleSelection": {
                "docstring": "If set to true, it is as if \"shift\" key is pressed when there are no modifiers pressed. That means that you get the \"toggle select\" behaviour by default. This only applies to the 3D view, and the selection done in the hypergraph, outliner or elsewhere is still a subject to the usual rules.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "setDoneSelectionPrompt": {
                "docstring": "If setAutoComplete is not set (see below) this string will be shown as soon as the tool has enough items for a particular selection set. If this is not set, but is needed, the same string as set with -setSelectionPrompt flag will be used."
            }, 
            "setNoSelectionHeadsUp": {
                "docstring": "Supply a string that will be shown as a heads up prompt when there is nothing selected. This must be set separately for each selection set."
            }, 
            "setNoSelectionPrompt": {
                "docstring": "Supply a string that will be shown as help when there is nothing selected. This must be set separately for each selection set."
            }, 
            "setSelectionCount": {
                "docstring": "The number of items in this selection set. 0 means as many as you need until completion."
            }, 
            "setSelectionHeadsUp": {
                "docstring": "Supply a string that will be shown as a heads up prompt when there is something selected. This must be set separately for each selection set."
            }, 
            "setSelectionPrompt": {
                "docstring": "Supply a string that will be shown as help when there is something selected. This must be set separately for each selection set."
            }, 
            "sets": {
                "docstring": ""
            }, 
            "showManipulators": {
                "docstring": "If set, the manipulators will be shown for any active objects. Basically, it is as if you are in the Show Manipulator tool."
            }, 
            "slugObject": {
                "docstring": ""
            }, 
            "slugVertex": {
                "docstring": ""
            }, 
            "spotlightComponent": {
                "docstring": ""
            }, 
            "spring": {
                "docstring": ""
            }, 
            "springComponent": {
                "docstring": ""
            }, 
            "stroke": {
                "docstring": ""
            }, 
            "subdiv": {
                "docstring": ""
            }, 
            "subdivMeshEdge": {
                "docstring": ""
            }, 
            "subdivMeshFace": {
                "docstring": ""
            }, 
            "subdivMeshPoint": {
                "docstring": ""
            }, 
            "subdivMeshUV": {
                "docstring": ""
            }, 
            "subdivisionPolymesh": {
                "docstring": ""
            }, 
            "subdivisionPolymeshEdge": {
                "docstring": ""
            }, 
            "subdivisionPolymeshFace": {
                "docstring": ""
            }, 
            "subdivisionPolymeshVertex": {
                "docstring": ""
            }, 
            "surfaceEdge": {
                "docstring": ""
            }, 
            "surfaceFace": {
                "docstring": ""
            }, 
            "surfaceKnot": {
                "docstring": ""
            }, 
            "surfaceParameterPoint": {
                "docstring": ""
            }, 
            "surfaceRange": {
                "docstring": ""
            }, 
            "surfaceUV": {
                "docstring": ""
            }, 
            "texture": {
                "docstring": ""
            }, 
            "title": {
                "docstring": "Supply a string that will be used as a precursor to all the messages; i.e., the \"name\" of the tool."
            }, 
            "toolCursorType": {
                "docstring": "Supply the string identifier to set the tool cursor type when inside of tool. The following are the valid ids: \"create\", \"dolly\", \"edit\", \"pencil\", \"track\", \"trackHorizontal\", \"trackVertical\", \"transformation\", \"tumble\", \"zoom\", \"zoomIn\", \"zoomOut\", \"flyThrough\", \"dot\", \"fleur\", \"leftArrow\", \"question\", \"doubleHorizArrow\", \"doubleVertArrow\", \"sizing\", \"dollyIn\", \"dollyOut\", \"brush\", \"camera\", \"noAccess\", \"input\", \"output\", \"leftCycle\", \"rightCycle\", \"rightExpand\", \"knife\"."
            }, 
            "toolFinish": {
                "docstring": "Supply the script that will be run when the user exits the script."
            }, 
            "toolStart": {
                "docstring": "Supply the script that will be run when the user first enters the script"
            }, 
            "totalSelectionSets": {
                "docstring": "Total number of selection sets."
            }, 
            "vertex": {
                "docstring": ""
            }
        }
    }, 
    "scriptEditorInfo": {
        "description": "Use this command to directly manipulate and query the contents of the Command Window window. Note: Due to recent changes, certain flags will no longer work on the Script Editor Window. All flags will continue to work with the CommandWindow (old Script Editor).Note: This command cannot be used to create a new script editor window.", 
        "flags": {
            "clearHistory": {
                "docstring": "Clears the read-only text in the upper field of the Command Window."
            }, 
            "clearHistoryFile": {
                "docstring": "Clear the file defined by the -hf/historyFilename flag, but only if -wh/writeHistory is true. Use this flag to start a new history file, since the default behaviour of the Command Window is to append to the existing file."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "historyFilename": {
                "docstring": "Sets or returns the name of the file that the Command Window will use to echo all of its history to. If this is an empty string when the -wh/writeHistory flag is set to true, then it will automatically be set to the default file."
            }, 
            "input": {
                "docstring": "Sets the text in the lower field of the Command Window. Set this value to an empty string to clear the field. Note: this flag only affects the Command Window and not the new script editor. To find out how to manipulate the new script editor please refer to the documentation on the cmdScrollFieldExecuter and cmdScrollFieldReporter."
            }, 
            "query": {
                "docstring": ""
            }, 
            "suppressErrors": {
                "docstring": "When true, Command Window and Script Editor will not display error messages."
            }, 
            "suppressInfo": {
                "docstring": "When true, Command Window and Script Editor will not display info messages generated by Maya."
            }, 
            "suppressResults": {
                "docstring": "When true, Command Window and Script Editor will not display command results."
            }, 
            "suppressStackWindow": {
                "docstring": "When true and when the stackTrace mechanism is on, this flag will suppress the display of the stack window. If stack trace is enabled then results will be returned to the output window instead of a separate stack window.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "suppressWarnings": {
                "docstring": "When true, Command Window and Script Editor will not display warning messages."
            }, 
            "writeHistory": {
                "docstring": "When true, Command Window will echo all of its history to the file defined by the -hf/historyFilename flag. This flag effectively turns file writing on/off."
            }
        }
    }, 
    "scriptJob": {
        "description": "This command creates a \"script job\", which is a MEL command or script. This job is attached to the named condition, event, or attribute. Each time the condition switches to the desired state (or the trigger is triggered, etc), the script is run. Script jobs are tied to the event loop in the interactive application. They are run during idle events. This means that script jobs do not exist in the batch application. The scriptJob command does nothing in batch mode. This triggering happens very frequently so for speed considerations no events are forwarded during playback. This means that you cannot use scriptJob -tc tcCallback;to alter animation behaviour. Use an expression instead, or the rendering callbacks \"preRenderMel\" and \"postRenderMel\". When setting up jobs for conditions, it is invalid to setup jobs for the true state, false state, and state change at the same time. The behaviour is undefined. The user can only setup jobs for the true and/or false state, or only for the state change, but not three at the same time. i.e. if you do: // Set up a job that runs for the life of the application. // This job cannot be deleted with the \"kill\" command no matter what. scriptJob -e \"SelectionChanged\" \"print \\\"Annoying Message!\\\\n\\\"\" -permanent;// set up a job for the true state scriptJob -ct \"playingBack\" playBackCallback;// set up a job for the false state scriptJob -cf \"playingBack\" playBackCallback;then you should NOT do scriptJob -cc \"playingBack\" playBackCallback;otherwise it will lead to undefined behaviour. This command can also be used to list available conditions and events, and to kill running jobs. ", 
        "flags": {
            "allChildren": {
                "docstring": "This flag can only be used in conjunction with the -ac/attributeChange flag. If it is specified, and the job is attached to a compound attribute, then the job will run due to changes to the specified attribute as well as changes to its children."
            }, 
            "attributeAdded": {
                "docstring": "Run the script when the named attribute is added. The string must identify both the dependency node and the particular attribute. If the dependency node is deleted, this job is killed (even if the deletion is undoable)."
            }, 
            "attributeChange": {
                "docstring": "Run the script when the named attribute changes value. The string must identify both the dependency node and the particular attribute. If the dependency node is deleted, this job is killed (even if the deletion is undoable)."
            }, 
            "attributeDeleted": {
                "docstring": "Run the script when the named attribute is deleted. The string must identify both the dependency node and the particular attribute. If the dependency node is deleted, this job is killed (even if the deletion is undoable)."
            }, 
            "compressUndo": {
                "docstring": "If this is set to true, and the scriptJob is undoable, then its action will be bundled with the last user action for undo purposes. For example; if the scriptJob was triggered by a selection change, then pressing undo will undo both the scriptJob and the selection change at the same time."
            }, 
            "conditionChange": {
                "docstring": "Run the script when the named condition changes state. The string must be the name of a pre-defined, or a user-defined boolean condition. To get a list of what conditions exist, use the -listConditions flag."
            }, 
            "conditionFalse": {
                "docstring": "Run the script when the named condition becomes false. The string must be the name of a pre-defined, or a user-defined boolean condition. To get a list of what conditions exist, use the -listConditions flag."
            }, 
            "conditionTrue": {
                "docstring": "Run the script when the named condition becomes true. The string must be the name of a pre-defined, or a user-defined boolean condition. To get a list of what conditions exist, use the -listConditions flag."
            }, 
            "connectionChange": {
                "docstring": "Run the script when the named attribute changes its connectivity. The string must identify both the dependency node and the particular attribute. If the dependency node is deleted, this job is killed (even if the deletion is undoable)."
            }, 
            "disregardIndex": {
                "docstring": "This flag can only be used in conjunction with the -ac/attributeChange flag. If it is specified, and the job is attached to a multi (indexed) attribute, then the job will run no matter which attribute in the multi changes."
            }, 
            "event": {
                "docstring": "Run the script when the named event occurs. This string must be the name of a pre-defined maya event. To get a list of what events exist, use the -listEvents flag."
            }, 
            "exists": {
                "docstring": "Returns true if a scriptJob with the specified \"job number\" exists, and false otherwise. The \"job number\" should be a value that was returned on creation of a new scriptJob."
            }, 
            "force": {
                "docstring": "This flag can only be used with -kill, -killAll, or -replacePrevious. It enables the deletion of protected jobs."
            }, 
            "idleEvent": {
                "docstring": "Run the script every time maya is idle. WARNING, as long as an idle event is is registered, the application will keep calling it and will use up all available CPU time. Use idleEvents with caution."
            }, 
            "kill": {
                "docstring": "Kills the job with the specified job number. Permanent jobs cannot be killed, however, and protected jobs can only be killed if the -force flag is used in the command."
            }, 
            "killAll": {
                "docstring": "Kills all jobs. Permanent jobs will not be deleted, and protected jobs will only be deleted if the -force flag is used."
            }, 
            "killWithScene": {
                "docstring": "Attaches the job to the current scene, and when the scene is emptied. The current scene is emptied by opening a new or existing scene."
            }, 
            "listConditions": {
                "docstring": "This causes the command to return a string array containing the names of all existing conditions. Below is the descriptions for all the existing conditions: Events Based on Available Maya FeaturesThese events are true when the given feature is available. Event NameMaya FeatureAnimationExistsAnimationAnimationUIExistsUser Interface for AnimationBaseMayaExistsAny Basic MayaBaseUIExistsAny Interactive MayaDatabaseUIExistsDeformersExistsDeformer FunctionsDeformersUIExistsUser Interface for DeformersDevicesExistsDevice SupportDimensionsExistsDimensioningDynamicsExistsDynamicsDynamicsUIExistsUser Interface for DynamicsExplorerExistsExplorerImageUIExistsUser Interface for ImagingKinematicsExistsKinematicsKinematicsUIExistsUser Interface for KinematicsManipsExistsManipulatorsModelExistsBasic Modeling ToolsModelUIExistsUser Interface for Basic ModelingNurbsExistsNurbs Modeling ToolsNurbsUIExistsUser Interface for Nurbs ModelingPolyCoreExistsBasic Polygonal SupportPolygonsExistsPolygonal ModelingPolygonsUIExistsUser Interface for Polygonal ModelingPolyTextureExistsPolygonal TexturingRenderingExistsBuilt-in RenderingRenderingUIExistsUser Interface for RenderingOther EventsautoKeyframeState:true when Maya has autoKeyframing enabledbusy:true when Maya is busy.deleteAllCondition:true when in the middle of a delete-all operationflushingScene:true while the scene is being flushed outGoButtonEnabled:true when the Go button in the panel context is enabled.hotkeyListChange:true when the list of hotkey definitions has changedplayingBack:true when Maya is playing back animation keyframes.playbackIconsCondition:instance of the playingBackcondition used on the time sliderreadingFile:true when Maya is reading a file.RedoAvailable:true when there are commands available for redo.SomethingSelected:true when some object(s) is selected.UndoAvailable:true when there are commands available for undo.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "listEvents": {
                "docstring": "This causes the command to return a string array containing the names of all existing events. Below is the descriptions for all the existing events: angularToleranceChanged:when the tolerance on angular units is changed. This tolerance can be changed by: using the MEL command, \"tolerance\" with the \"-angular\" flagchanging the pref under Options-GeneralPreferences-Modeling tab-Tangential ToleranceangularUnitChanged:when the user changes the angular unit.axisAtOriginChanged:when the axis changes at the origin.axisInViewChanged:when the axis changes at a particular view.ColorIndexChanged:when the color index values change.constructionHistoryChanged:when construction history is turned on or off.currentContainerChanged:when the user set or unset the current container.currentSoundNodeChanged:whenever the sound displayed in the time slider changes due to: the sound being removed (or no longer displayed) [RMB in the time slider]a new sound being displayed [RMB in the time slider]sound display being toggled [animation options]sound display mode being changed [animation options]DagObjectCreated:when a new DAG object is created.deleteAll:when a file new occursDisplayColorChanged:when the display color changes.displayLayerChange:when a layer has been created or destroyed.displayLayerManagerChange:when the display layer manager has changed.DisplayRGBColorChanged:when the RGB display color changes.glFrameTrigger:for internal use only.gridDisplayChanged:for internal use only.idle:when Maya is idle and there are no high priority idle tasksidleHigh:when Maya is idle. This is called before low priority idle tasks. You should almost always use \"idle\" instead.lightLinkingChanged:when any change occurs which modifies light linking relationships.lightLinkingChangedNonSG:when any change occurs which modifies light linking relationships, except when the change is a change of shading assignment.linearToleranceChanged:when the linear tolerance has been changed. This tolerance can be changed by: using the MEL command, \"tolerance\" with the \"-linear\" flagchanging the pref under Options-GeneralPreferences-Modeling tab-Positional TolerancelinearUnitChanged:when the user changes the linear unit through the Options menu.MenuModeChanged:when the user changes the menu set for the menu bar in the main Maya window (for example, from \"Modeling\" to \"Animation\").RecentCommandChanged:for internal use only.NewSceneOpened:when a new scene has been opened.PostSceneRead:after a scene has been read. Specifically after a file open, import or all child references have been read.nurbsToPolygonsPrefsChanged:when any of the nurbs-to-polygons prefs have changed. These prefs can be changed by: using the Mel command, \"nurbsToPolygonsPref\"changing the prefs under Polygons-Nurbs To Polygons-Option BoxplaybackRangeChanged:when the playback keyframe range changes.playbackRangeSliderChanged:when the animation start/end range (i.e. the leftmost or rightmost entry cells in the time slider range, the inner ones adjust the playback range) changequitApplication:when the user has chosen to quit, either through the quit MEL command, or through the Exit menu item.Redo:when user has selected redo from the menu and there was something to redo. This callback can be used for updating UI or local storage. Do not change the state of the scene or DG during this callback.renderLayerChange:when creation or deletion of a render layer node has occured.renderLayerManagerChange:when the current render layer has changed.RebuildUIValues:for internal use only.SceneOpened:when a scene has been opened.SceneSaved:when a scene has been saved.SelectionChanged:when a new selection is made.SelectModeChanged:when the selection mode changes.SelectPreferenceChanged:for internal use only.SelectPriorityChanged:when the selection priority changes.SelectTypeChanged:when the selection type changes.setEditorChanged:obsolete. No longer used.SetModified:when the set command is used to modify a setsnapModeChanged:when the snap mode changes. E.g. changes to grid snapping.timeChanged:when the time changes.timeUnitChanged:when the user changes the time unit.ToolChanged:when the user changes the tool/context.PostToolChanged:after the user changes the tool/context.NameChanged:when the user changes the name of an object with the rename command.Undo:when user has selected undo from the menu and there was something to undo. This callback can be used for updating UI or local storage. Do not change the state of the scene or DG during this callback.modelEditorChanged:when the user changes the options of a model editor."
            }, 
            "listJobs": {
                "docstring": "This causes the command to return a string array containing a description of all existing jobs, along with their job numbers. These numbers can be used to kill the jobs later."
            }, 
            "nodeDeleted": {
                "docstring": "Run the script when the named node is deleted"
            }, 
            "nodeNameChanged": {
                "docstring": "Run the script when the name of the named node changes"
            }, 
            "parent": {
                "docstring": "Attaches this job to a piece of maya UI. When the UI is destroyed, the job will be killed along with it."
            }, 
            "permanent": {
                "docstring": "Makes the job un-killable. Permanent jobs exist for the life of the application, or for the life of their parent object. The -killWithScene flag does apply to permanent jobs."
            }, 
            "protected": {
                "docstring": "Makes the job harder to kill. Protected jobs must be killed or replaced intentionally by using the -force flag. The -killWithScene flag does apply to protected jobs."
            }, 
            "replacePrevious": {
                "docstring": "This flag can only be used with the -parent flag. Before the new scriptJob is created, any existing scriptJobs that have the same parent are first deleted."
            }, 
            "runOnce": {
                "docstring": "If this is set to true, the script will only be run a single time. If false (the default) the script will run every time the triggering condition/event occurs. If the -uid or -nd flags are used, runOnce is turned on automatically."
            }, 
            "timeChange": {
                "docstring": "Run the script whenever the current time changes. The script will not be executed if the time is changed by clicking on the time slider, whereas scripts triggered by the \"timeChanged\" condition will be executed."
            }, 
            "uiDeleted": {
                "docstring": "Run the script when the named piece of UI is deleted."
            }
        }
    }, 
    "scriptNode": {
        "description": "scriptNodes contain scripts that are executed when a file is loaded or when the script node is deleted. The scriptNode command is used to create, edit, query, and test scriptNodes. In query mode, return type is based on queried flag.", 
        "flags": {
            "afterScript": {
                "docstring": "The script executed when the script node is deleted.C: The default is an empty string.Q: When queried, this flag returns a string."
            }, 
            "beforeScript": {
                "docstring": "The script executed during file load.C: The default is an empty string.Q: When queried, this flag returns a string."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "executeAfter": {
                "docstring": "Execute the script stored in the .after attribute of the scriptNode. This script is normally executed when the script node is deleted."
            }, 
            "executeBefore": {
                "docstring": "Execute the script stored in the .before attribute of the scriptNode. This script is normally executed when the file is loaded."
            }, 
            "name": {
                "docstring": "When creating a new scriptNode, this flag specifies the name of the node. If a non-unique name is used, the name will be modified to ensure uniqueness."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scriptType": {
                "docstring": "Specifies when the script is executed. The following values may be used: 0Execute on demand.1Execute on file load or on node deletion.2Execute on file load or on node deletion when not in batch mode.3Internal4Execute on software render5Execute on software frame render6Execute on scene configuration7Execute on time changedC: The default value is 0.Q: When queried, this flag returns an int."
            }, 
            "sourceType": {
                "docstring": "Sets the language type for both the attached scripts. Valid values are \"mel\" (enabled by default), and \"python\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "scriptTable": {
        "description": "This command creates/edits/queries the script table control. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "cellChangedCmd": {
                "docstring": "Sets the script to call when somebody has changed the value of a cell. The procedure is called with 2 integer arguments specifying the row and column for which the value was changed. The 3rd argument is the string which was entered into that cell. The procedure should return an integer value which indicates whether that value should be accepted (return true if yes, and false if no). The row and column numbers passed in are 1-based (ie. (1,1) is the upper left cell). The procedure should be of the form: global proc int procedureName(int $row, int $column, string $value)"
            }, 
            "clearRow": {
                "docstring": "Clear the contents for all the cells on the specified row. Any procedure specified by the -gcc flag will be called to populate the cleared cells The row number is 1-based (ie. the first row is 1 not 0)."
            }, 
            "clearTable": {
                "docstring": "Clears the contents of all the cells in the table. Any procedure specified by the -gcc flag will be called to populate the cleared cellsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "columnWidth": {
                "docstring": "Set the width of the specified column The column number is 1-based (ie. the first column is 1 not 0)."
            }, 
            "columns": {
                "docstring": "Set the number of columns in the table"
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "deleteRow": {
                "docstring": "Delete the specified row The row number is 1-based (ie. the first row is 1 not 0)."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "excludingHeaders": {
                "docstring": "when querying the count for the rows or the columns , the number returned will not include the headers"
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "getCellCmd": {
                "docstring": "Sets the script to call when it requires the contents of a cell. The procedure is called with 2 integer arguments specifying the row and column for which the value is required. The procedure should return a string which is the value for the cell. The row and column numbers passed in are 1-based (ie. (1,1) is the upper left cell). The procedure should be of the form: global proc string procedureName(int $row, int $column)"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "insertRow": {
                "docstring": "Insert an empty row before the specified row. Any procedure specified by the -gcc flag will be called to populate the new new cells. The row number is 1-based (ie. the first row is 1 not 0)."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "Set the label of the specified column. The column number is 1-based (ie. the first column is 1 not 0)."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowHeight": {
                "docstring": "Sets the height for each row in the scriptTable"
            }, 
            "rows": {
                "docstring": "Set the number of rows in the table"
            }, 
            "selectedCells": {
                "docstring": "The cells currently selected. This returns a list of indices, the first of each pair is the row, the second is the column, repeated for each cell selected The returned cell numbers are 1-based (ie. the first row is 1 not 0, the first column is 1 not 0)."
            }, 
            "selectedColumns": {
                "docstring": "The columns currently selected. This returns a list of indices of each column completely selected The returned column numbers are 1-based"
            }, 
            "selectedRow": {
                "docstring": "The current row selected. The returned row number is 1-based (ie. the first row is 1 not 0)."
            }, 
            "selectedRows": {
                "docstring": "The rows currently selected. This returns a list of indices of each row completely selected The returned row numbers are 1-based"
            }, 
            "selectionBehavior": {
                "docstring": "Set the selection behavior, valid values are from 0 to 2 (inclusive) 0 - Selecting single items. 1 - Selecting only rows. 2 - Selecting only columns."
            }, 
            "selectionMode": {
                "docstring": "Set the selection Mode, valid values are from 0 to 4 (inclusive)0 - Items cannot be selected.1 - When the user selects an item, any already-selected item becomes unselected, and the user cannot unselect the selected item by clicking on it.2 - When the user selects an item in the usual way, the selection status of that item is toggled and the other items are left alone. Multiple items can be toggled by dragging the mouse over them.3 - When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Ctrl key when clicking on an item, the clicked item gets toggled and all other items are left untouched. If the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item. Multiple items can be selected by dragging the mouse over them.4 - When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item."
            }, 
            "underPointerRow": {
                "docstring": "The row under the pointer. The returned row number is 1-based (ie. the first row is 1 not 0)."
            }, 
            "useDoubleClickEdit": {
                "docstring": "this controls the cell edit modeFalse: Click in the cell to select (in Row selection, the last cell of the row is edited, in Column selection, the last cell of the column is edited)(default)True: Clicked in cell is edited when double-clicked only"
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "scriptedPanel": {
        "description": "This command will create an instance of the specified scriptedPanelType. A panel is a collection of UI objects (buttons, fields, graphical views) that are grouped together. A panel can be moved around as a group within the application interface, and torn off to exist in its own window. The panel takes care of maintaining the state of its UI when it is relocated, or recreated. A scripted panel is a panel that is defined in MEL, with all of the required callbacks available as MEL proc's. ", 
        "flags": {
            "control": {
                "docstring": "Returns the top level control for this panel. Usually used for getting a parent to attach popup menus. CAUTION: panels may not have controls at times. This flag can return \"\" if no control is present."
            }, 
            "copy": {
                "docstring": "Makes this panel a copy of the specified panel. Both panels must be of the same type."
            }, 
            "createString": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the maya panel."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editString": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "init": {
                "docstring": "Initializes the panel's default state. This is usually done automatically on file -new and file -open."
            }, 
            "isUnique": {
                "docstring": "Returns true if only one instance of this panel type is allowed."
            }, 
            "label": {
                "docstring": "Specifies the user readable label for the panel."
            }, 
            "menuBarVisible": {
                "docstring": "Controls whether the menu bar for the panel is displayed."
            }, 
            "needsInit": {
                "docstring": "(Internal) On Edit will mark the panel as requiring initialization. Query will return whether the panel is marked for initialization. Used during file -new and file -open."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this panel."
            }, 
            "popupMenuProcedure": {
                "docstring": "Specifies the procedure called for building the panel's popup menu(s). The default value is \"buildPanelPopupMenu\". The procedure should take one string argument which is the panel's name."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replacePanel": {
                "docstring": "Will replace the specifed panel with this panel. If the target panel is within the same layout it will perform a swap."
            }, 
            "tearOff": {
                "docstring": "Will tear off this panel into a separate window with a paneLayout as the parent of the panel. When queried this flag will return if the panel has been torn off into its own window."
            }, 
            "tearOffCopy": {
                "docstring": "Will create this panel as a torn of copy of the specified source panel."
            }, 
            "type": {
                "docstring": "This flag specifies the type of scripted panel to create.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "unParent": {
                "docstring": "Specifies that the panel should be removed from its layout. This (obviously) cannot be used with query."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "scriptedPanelType": {
        "description": "This command defines the callbacks for a type of scripted panel. The panel type created by this command is then used when creating a scripted panel. See also the 'scriptedPanel' command. ", 
        "flags": {
            "addCallback": {
                "docstring": "This flag specifies the callback procedure for adding the panel to a particular control layout. The parent layout is guaranteed to be the current default layout when the proc is called. If its name is required then it can be queried with 'setParent -q'. Any editors should be parented here. global proc procName (string $panelName) { .... "
            }, 
            "copyStateCallback": {
                "docstring": "This flag specifies the callback procedure for copying the state of the panel when a tear-off copy of the panel is made. The callback proc has the form: global proc procName (string $panelName, string $newPanelName) { .... } This procedure will be executed immediately after the addCallback procedure has finished executing. At that point, the copied panel will be fully created and accessible to facilitate copying of panel settings. Note: the addCallback procedure is called after the createCallback procedure has been called."
            }, 
            "createCallback": {
                "docstring": "This flag specifies the callback procedure for initially creating the panel object. No UI should be created here. Any editors owned by the panel should be created here unparented. The callback proc has the form: global proc procName (string $panelName) { .... "
            }, 
            "customView": {
                "docstring": "This flag specifies if this view is a custom 3d view for MPx3dModelView types. This flag should only be used for MPx3dModelView types.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "deleteCallback": {
                "docstring": "This flag specifies the callback procedure for final deletion of the panel. The callback proc has the form: global proc procName (string $panelName) { .... "
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "initCallback": {
                "docstring": "This flag specifies the callback procedure for the initialize callback. This will be called on file -new and file -open to give the panel an opportunity to re-initialize to a starting state, if required. The panel may be parented or unparented at this time. The callback proc has the form: global proc procName (string $panelName) { .... "
            }, 
            "label": {
                "docstring": ""
            }, 
            "obsolete": {
                "docstring": "This flag specifies that this type is no longer used in Maya."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeCallback": {
                "docstring": "This flag specifies the callback procedure for removing the panel from its current control layout. Any editors should be unparented here. The callback proc has the form: global proc procName (string $panelName) { .... "
            }, 
            "retainOnFileOpen": {
                "docstring": "This flag specifies if panels of this type should be retained after restoring panel cofiguration during file open. Default value is false."
            }, 
            "saveStateCallback": {
                "docstring": "This flag specifies the callback procedure for saving the state of the panel. The callback proc has the form: global proc string procName (string $panelName) { .... } Note that the proc returns a string. This string will be executed after the createCallback has been called to facilitate restoring the panel state."
            }, 
            "unique": {
                "docstring": "This flag specifies if only one instance of this type of panel can exist at a given time."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "scrollField": {
        "description": "This command creates a scrolling field that handles multiple lines of text. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the value changes. This command is executed whenever the field loses focus."
            }, 
            "clear": {
                "docstring": "Removes all text in the field."
            }, 
            "command": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "The edit state of the field. By default, this flag is set to true and the field value may be changed by typing into it. If false then the field is 'read only' and can not be typed into. The text in the field can always be changed with the -tx/text flag regardless of the state of the -ed/editable flag."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enterCommand": {
                "docstring": "Command executed when the enter key is pressed. This applies to the enter key on the numeric keypad only."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "font": {
                "docstring": "The font for the text. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\"."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "insertText": {
                "docstring": "Insert text into the field at the current insertion position (specified by the -ip/insertionPosition flag)."
            }, 
            "insertionPosition": {
                "docstring": "The insertion position for inserted text. This is a 1 based value where position 1 specifies the beginning of the field. Position 0 may be used to specify the end of the field."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "keyPressCommand": {
                "docstring": "Command executed when any key is pressed."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfLines": {
                "docstring": "Number of lines in the scroll field.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selection": {
                "docstring": "The selected text in the field. An empty string is returned if there is no selected text."
            }, 
            "text": {
                "docstring": "The field text."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "wordWrap": {
                "docstring": "Specify true to break lines at spaces, tabs, or newlines. Text will continue on the following line. A value of false will not break text between words, in which case text may disappear beyond the edge of the field. This flag must be set at create time. Lines do not word wrap by default."
            }
        }
    }, 
    "scrollLayout": {
        "description": "This command creates a scroll layout. A scroll layout is useful for when you have a number of controls which cannot all be visible at a time. This layout will display a horizontal and/or vertical scroll bar when necessary to bring into view the hidden controls. Since the scroll layout provides no real positioning of children you should use another control layout as the immediate child. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "childResizable": {
                "docstring": "Set to true if you want the child of the control layout to be as wide as the scroll area. You may also indicate a minimum width for the child using the -mcw/minimumChildWidthflag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "horizontalScrollBarThickness": {
                "docstring": "Thickness of the horizontal scroll bar. Specify an integer value of pixels greater than or equal to 0. Other than setting the value to 0 to hide the scrollbar, this flag has no effect on Windows systems."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "minChildWidth": {
                "docstring": "A positive non-zero integer value indicating the minimum width the scroll layout's child. This flag only has meaning when the -cr/childResizableflag is set to true."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "resizeCommand": {
                "docstring": "The command invoked when the scroll layout is resized."
            }, 
            "scrollAreaHeight": {
                "docstring": "Return the height of the scroll area (in pixels)."
            }, 
            "scrollAreaValue": {
                "docstring": "Return the vertical and horizontal values of the scroll area (in pixels)."
            }, 
            "scrollAreaWidth": {
                "docstring": "Return the width of the scroll area (in pixels)."
            }, 
            "scrollByPixel": {
                "docstring": "Scroll the client area in the direction of the string. The int specifies the number of pixels.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "scrollPage": {
                "docstring": "Scroll the client area in the direction of the string. Valid values are \"up\", \"down\", \"left\" or \"right\"."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "verticalScrollBarThickness": {
                "docstring": "Thickness of the vertical scroll bar. Specify an integer value of pixels greater than or equal to 0. This flag has no effect on Windows systems."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "sculpt": {
        "description": "This command creates/edits/queries a sculpt object deformer. By default for creation mode an implicit sphere will be used as the sculpting object if no sculpt tool is specified. The name of the created/edited object is returned. ", 
        "flags": {
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "dropoffDistance": {
                "docstring": "Specifies the distance from the surface of the sculpt object at which the sculpt object produces no deformation effect. Default is 1.0. When queried, this flag returns a float."
            }, 
            "dropoffType": {
                "docstring": "Specifies how the deformation effect drops off from maximum effect at the surface of the sculpt object to no effect at dropoff distance limit. Valid values are: linear | none. Default is linear. When queried, this flag returns a string."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "groupWithLocator": {
                "docstring": "Groups the sculptor and its locator together under a single transform. Default is off."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "insideMode": {
                "docstring": "Specifies how the deformation algorithm deals with points that are inside the sculpting primitve. The choices are: ring | even. The default is even. When queried, this flag returns a string. Ring mode will tend to produce a contour like ring of points around the sculpt object as it passes through an object while even mode will try to spread the points out as evenly as possible across the surface of the sculpt object."
            }, 
            "maxDisplacement": {
                "docstring": "Defines the maximum amount the sculpt object may move a point on an object which it is deforming. Default is 1.0. When queried, this flag returns a float."
            }, 
            "mode": {
                "docstring": "Specifies which deformation algorithm the sculpt object should use. The choices are: flip | project | stretch. The default is stretch. When queried, this flag returns a string."
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "objectCentered": {
                "docstring": "Places the sculpt and locator in the center of the bounding box of the selected object(s) or components. Default is off which centers the sculptor and locator at the origin."
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "sculptTool": {
                "docstring": "Use the specified NURBS object as the sculpt tool instead of the default implicit sphere.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }
        }
    }, 
    "selLoadSettings": {
        "description": "This command is used to edit and query information about the implicit load settings. Currently this is primarily intended for internal use within the Preload Reference Editor. selLoadSettings acts on load setting IDs. When implict load settings are built for a target scene, there will be one load setting for each reference in the target scene. Each load setting has a numerical ID which is its index in a pre-order traversal of the target reference hierarchy (with the root scenefile being assigned an ID of 0). Although the IDs are numerical they must be passed to the command as string array. Example: Given the scene: a        / \\       b   c          / \\         d   e where: a references b and c c references d and e the IDs will be as follows: a = 0 b = 1 c = 2 d = 3 e = 4 selLoadSettings can be used to change the load state of a reference: whether it will be loaded or unloaded (deferred) when the target scene is opened. Note: selLoadSettings can accept multiple command parameters, but the order must be selected carefully such that no reference is set to the loaded state while its parent is in the unlaoded state. Given the scene: a | b [-] | c [-] where: a references b b references c a = 0 b = 1 c = 2 and b and c are currently in the unloaded state. The following command will succeed and change both b and c to the loaded state: selLoadSettings -e -deferReference 0 \"1\" \"2\"; whereas the following command will fail and leave both b and c in the unloaded state: selLoadSettings -e -deferReference 0 \"2\" \"1\"; Bear in mind that the following command will also change both b and c to the loaded state: selLoadSettings -e -deferReference 0 \"1\"; This is because setting a reference to the loaded state automatically sets all child references to the loaded state as well. And vice versa, setting a reference the the unloaded state automatically sets all child reference to the unloaded state. ", 
        "flags": {
            "activeProxy": {
                "docstring": "Change or query the active proxy of a proxy set. In query mode, returns the proxyTag of the active proxy; in edit mode, finds the proxy in the proxySet with the given tag and makes it the active proxy."
            }, 
            "asURI": {
                "docstring": "When used with a main query flag and the unresolvedName flag it indicates that the file names of all reference files returned will be URI. This URI may contain environment variables and may not exist on disk. If this flag is not present, the OS native file path will be returned."
            }, 
            "deferReference": {
                "docstring": "Change or query the load state of a reference."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "fileName": {
                "docstring": "Return the file name reference file(s) associated with the indicated load setting(s)."
            }, 
            "numSettings": {
                "docstring": "Return the number of settings in the group of implicit load settings. This is equivalent to number of references in the scene plus 1.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "proxyManager": {
                "docstring": "Return the name(s) of the proxy manager(s) associated with the indicated load setting(s)."
            }, 
            "proxySetFiles": {
                "docstring": "Return the name(s) of the proxy(ies) available in the proxy set associated with the indicated load setting(s)."
            }, 
            "proxySetTags": {
                "docstring": "Return the name(s) of the proxy tag(s) available in the proxy set associated with the indicated load setting(s)."
            }, 
            "proxyTag": {
                "docstring": "Return the name(s) of the proxy tag(s) associated with the indicated load setting(s)."
            }, 
            "query": {
                "docstring": ""
            }, 
            "referenceNode": {
                "docstring": "Return the name(s) of the reference node(s) associated with the indicated load setting(s)."
            }, 
            "shortName": {
                "docstring": "Formats the return value of the 'fileName' query flag to only return the short name(s) of the reference file(s)."
            }, 
            "unresolvedName": {
                "docstring": "Formats the return value of the 'fileName' query flag to return the unresolved name(s) of the reference file(s). The unresolved file name is the file name used when the reference was created, whether or not that file actually exists on disk. When Maya encounters a file name which does not exist on disk it attempts to resolve the name by looking for the file in a number of other locations. By default the 'fileName' flag will return this resolved value."
            }
        }
    }, 
    "select": {
        "description": "This command is used to put objects onto or off of the active list. If none of the five flags [-add, -af, -r, -d, -tgl] are specified, the default is to replace the objects on the active list with the given list of objects. When selecting a set as in \"select set1\", the behaviour is for all the members of the set to become selected instead of the set itself. If you want to select a set, the \"-ne/noExpand\" flag must be used. With the advent of namespaces, selection by name may be confusing. To clarify, without a qualified namespace, name lookup is limited to objects in the root namespace \":\". There are really two parts of a name: the namespace and the name itself which is unique within the namespace. If you want to select objects in a specific namespace, you need to include the namespace separator \":\". For example, 'select -r \"foo\\*\"' is trying to look for an object with the \"foo\" prefix in the root namespace. It is not trying to look for all objects in the namespace with the \"foo\" prefix. If you want to select all objects in a namespace (foo), use 'select \"foo:\\*\"'. Note: When the application starts up, there are several dependency nodes created by the system which must exist. These objects are not deletable but are selectable. All objects (dag and dependency nodes) in the scene can be obtained using the \"ls\" command without any arguments. When using the \"-all\", \"adn/allDependencyNodes\" or \"-ado/allDagObjects\" flags, only the deletable objects are selected. The non deletable object can still be selected by explicitly specifying their name as in \"select time1;\". ", 
        "flags": {
            "add": {
                "docstring": "Indicates that the specified items should be added to the active list without removing existing items from the active list."
            }, 
            "addFirst": {
                "docstring": "Indicates that the specified items should be added to the front of the active list without removing existing items from the active list."
            }, 
            "all": {
                "docstring": "Indicates that all deletable root level dag objects and all deletable non-dag dependency nodes should be selected."
            }, 
            "allDagObjects": {
                "docstring": "Indicates that all deletable root level dag objects should be selected."
            }, 
            "allDependencyNodes": {
                "docstring": "Indicates that all deletable dependency nodes including all deletable dag objects should be selected."
            }, 
            "clear": {
                "docstring": "Clears the active list. This is more efficient than \"select -d;\". Also \"select -d;\" will not remove sets from the active list unless the \"-ne\" flag is also specified."
            }, 
            "containerCentric": {
                "docstring": "Specifies that the same selection rules as apply to selection in the main viewport will also be applied to the select command. In particular, if the specified objects are members of a black-boxed container and are not published as nodes, Maya will not select them. Instead, their first parent valid for selection will be selected.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "deselect": {
                "docstring": "Indicates that the specified items should be removed from the active list if they are on the active list."
            }, 
            "hierarchy": {
                "docstring": "Indicates that all children, grandchildren, ... of the specified dag objects should also be selected."
            }, 
            "noExpand": {
                "docstring": "Indicates that any set which is among the specified items should not be expanded to its list of members. This allows sets to be selected as opposed to the members of sets which is the default behaviour."
            }, 
            "replace": {
                "docstring": "Indicates that the specified items should replace the existing items on the active list."
            }, 
            "toggle": {
                "docstring": "Indicates that those items on the given list which are on the active list should be removed from the active list and those items on the given list which are not on the active list should be added to the active list."
            }, 
            "visible": {
                "docstring": "Indicates that of the specified items only those that are visible should be affected."
            }
        }
    }, 
    "selectContext": {
        "description": "Creates a context to perform selection. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "selectKey": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.This command places keyframes and/or keyframe tangents on the active list. ", 
        "flags": {
            "addTo": {
                "docstring": "Add to the current selection of keyframes/tangents"
            }, 
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "clear": {
                "docstring": "Remove all keyframes and tangents from the active list."
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "inTangent": {
                "docstring": "Select in-tangents of keyframes in the specified time range"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "keyframe": {
                "docstring": "select only keyframes (cannot be combined with -in/-out)"
            }, 
            "outTangent": {
                "docstring": "Select out-tangents of keyframes in the specified time range"
            }, 
            "remove": {
                "docstring": "Remove from the current selection of keyframes/tangents"
            }, 
            "replace": {
                "docstring": "Replace the current selection of keyframes/tangents"
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }, 
            "toggle": {
                "docstring": "Toggle the picked state of the specified keyset"
            }, 
            "unsnappedKeys": {
                "docstring": "Select only keys that have times that are not a multiple of the specified numeric value.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "selectKeyCtx": {
        "description": "This command creates a context which may be used to select keyframes within the graph editor ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "selectKeyframe": {
        "description": "", 
        "flags": {
            "animation": {
                "docstring": ""
            }, 
            "attribute": {
                "docstring": ""
            }, 
            "controlPoints": {
                "docstring": ""
            }, 
            "float": {
                "docstring": ""
            }, 
            "hierarchy": {
                "docstring": ""
            }, 
            "includeUpperBound": {
                "docstring": ""
            }, 
            "index": {
                "docstring": ""
            }, 
            "selectionWindow": {
                "docstring": ""
            }, 
            "shape": {
                "docstring": ""
            }, 
            "time": {
                "docstring": ""
            }
        }
    }, 
    "selectKeyframeRegionCtx": {
        "description": "This command creates a context which may be used to select keyframes within the keyframe region of the dope sheet editor ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "selectMode": {
        "description": "The selectModecommand is used to change the selection mode. Object, component, root, leaf and template modes are mutually exclusive. ", 
        "flags": {
            "component": {
                "docstring": "Set component selection on. Component selection mode allows filtered selection based on the component selection mask. The component selection mask is the set of selection masks related to objects that indicate which components are selectable."
            }, 
            "hierarchical": {
                "docstring": "Set hierarchical selection on. There are three types of hierarchical selection: root, leaf and template. Hierarchical mode is set if root, leaf or template mode is set. Setting to hierarchical mode will set the mode to whichever of root, leaf, or template was last on."
            }, 
            "leaf": {
                "docstring": "Set leaf selection mode on. This mode allows the leaf level objects to be selected. It is similar to object selection mode but ignores the object selection mask."
            }, 
            "object": {
                "docstring": "Set object selection on. Object selection mode allows filtered selection based on the object selection mask. The object selection mask is the set of selection masks related to objects that indicate which objects are selectable. The masks are controlled by the \"selectType\" command. Object selection mode selects the leaf level objects."
            }, 
            "preset": {
                "docstring": "Allow selection of anything with the mask set, independent of it being an object or a component.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "root": {
                "docstring": "Set root selection mode on. This mode allows the root of a hierarchy to be selected by selecting any of its descendents. It ignores the object selection mask."
            }, 
            "template": {
                "docstring": "Set template selection mode on. This mode allows selection of templated objects. It selects the templated object closest to the root of the hierarchy."
            }
        }
    }, 
    "selectPref": {
        "description": "This command controls state variables used to selection UI behavior. ", 
        "flags": {
            "affectsActive": {
                "docstring": "Set affects-active toggle which when on causes the active list to be affected when changing between object and component selection mode."
            }, 
            "allowHiliteSelection": {
                "docstring": "When in component selection mode, allow selection of objects for editing. If an object is selected for editing, it appears in the hilite color and its selectable components are automatically displayed."
            }, 
            "autoSelectContainer": {
                "docstring": "When enabled, with container centric selection also on, whenever the root transform is selected in the viewport, the container node will automatically be selected as well."
            }, 
            "clickBoxSize": {
                "docstring": "When click selecting, this value defines the size of square picking region surrounding the cursor. The size of the square is twice the specified value. That is, the value defines the amount of space on all four sides of the cursor position. The size must be positive."
            }, 
            "clickDrag": {
                "docstring": "Set click/drag selection interaction on/off"
            }, 
            "containerCentricSelection": {
                "docstring": "When enabled, selecting any DAG node in a container in the viewport will select the container's root transform if there is one. If there is no root transform then the highest DAG node in the container will be selected. There is no effect when selecting nodes which are not in a container."
            }, 
            "disableComponentPopups": {
                "docstring": "A separate preference to allow users to disable popup menus when selecting components. This pref is only meaningful if the popupMenuSelection pref is enabled."
            }, 
            "expandPopupList": {
                "docstring": "When in popup selection mode, if this is set then all selection items that contain multiple objects or components will be be expanded such that each object or component will be a single new selection item."
            }, 
            "ignoreSelectionPriority": {
                "docstring": "If this is set, selection priority will be ignored when performing selection."
            }, 
            "manipClickBoxSize": {
                "docstring": "When selecting a manipulator, this value defines the size of square picking region surrounding the cursor. The size of the square is twice the specified value. That is, the value defines the amount of space on all four sides of the cursor position. The size must be positive."
            }, 
            "paintSelect": {
                "docstring": ""
            }, 
            "paintSelectWithDepth": {
                "docstring": ""
            }, 
            "popupMenuSelection": {
                "docstring": "If this is set, a popup menu will be displayed and used to determine the object to select. The menu lists the current user box (marquee) of selected candidate objects."
            }, 
            "preSelectHilite": {
                "docstring": ""
            }, 
            "preSelectHiliteSize": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectTypeChangeAffectsActive": {
                "docstring": ""
            }, 
            "singleBoxSelection": {
                "docstring": "Set single box selection on/off. This flag indicates whether just single object will be selected when the user box (marquee) selects several objects if flag set to true. Otherwise, all those objects inside the box will be selected."
            }, 
            "straightLineDistance": {
                "docstring": ""
            }, 
            "trackSelectionOrder": {
                "docstring": "When enabled, the order of selected objects and components will be tracked. The 'ls' command will be able to return the active list in the order of selection which will allow scripts to be written that depend on the order.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useDepth": {
                "docstring": ""
            }, 
            "xformNoSelect": {
                "docstring": "Disable selection in xform tools"
            }
        }
    }, 
    "selectPriority": {
        "description": "The selectPrioritycommand is used to change the selection priority of particular types of objects that can be selected when using the select tool. It accepts no other arguments besides the flags. These flags are the same as used by the 'selectType' command. ", 
        "flags": {
            "allComponents": {
                "docstring": "Set all component selection priority"
            }, 
            "allObjects": {
                "docstring": "Set all object selection priority"
            }, 
            "animBreakdown": {
                "docstring": "Set animation breakdown selection priority"
            }, 
            "animCurve": {
                "docstring": "Set animation curve selection priority"
            }, 
            "animInTangent": {
                "docstring": "Set animation in-tangent selection priority"
            }, 
            "animKeyframe": {
                "docstring": "Set animation keyframe selection priority"
            }, 
            "animOutTangent": {
                "docstring": "Set animation out-tangent selection priority"
            }, 
            "camera": {
                "docstring": "Set camera selection priority"
            }, 
            "cluster": {
                "docstring": "Set cluster selection priority"
            }, 
            "collisionModel": {
                "docstring": "Set collision model selection priority"
            }, 
            "controlVertex": {
                "docstring": "Set control vertex selection priority"
            }, 
            "curve": {
                "docstring": "Set curve selection priority"
            }, 
            "curveKnot": {
                "docstring": "Set curve knot selection priority"
            }, 
            "curveOnSurface": {
                "docstring": "Set curve-on-surface selection priority"
            }, 
            "curveParameterPoint": {
                "docstring": "Set curve parameter point selection priority"
            }, 
            "dimension": {
                "docstring": "Set dimension shape selection priority"
            }, 
            "dynamicConstraint": {
                "docstring": "Set dynamicConstraint selection priority"
            }, 
            "edge": {
                "docstring": "Set mesh edge selection priority"
            }, 
            "editPoint": {
                "docstring": "Set edit-point selection priority"
            }, 
            "emitter": {
                "docstring": "Set emitter selection priority"
            }, 
            "facet": {
                "docstring": "Set mesh face selection priority"
            }, 
            "field": {
                "docstring": "Set field selection priority"
            }, 
            "fluid": {
                "docstring": "Set fluid selection priority"
            }, 
            "follicle": {
                "docstring": "Set follicle selection priority"
            }, 
            "hairSystem": {
                "docstring": "Set hairSystem selection priority"
            }, 
            "handle": {
                "docstring": "Set object handle selection priority"
            }, 
            "hull": {
                "docstring": "Set hull selection priority"
            }, 
            "ikEndEffector": {
                "docstring": "Set ik end effector selection priority"
            }, 
            "ikHandle": {
                "docstring": "Set ik handle selection priority"
            }, 
            "imagePlane": {
                "docstring": "Set image plane selection mask priority"
            }, 
            "implicitGeometry": {
                "docstring": "Set implicit geometry selection priority"
            }, 
            "isoparm": {
                "docstring": "Set surface iso-parm selection priority"
            }, 
            "joint": {
                "docstring": "Set ik handle selection priority"
            }, 
            "jointPivot": {
                "docstring": "Set joint pivot selection priority"
            }, 
            "lattice": {
                "docstring": "Set lattice selection priority"
            }, 
            "latticePoint": {
                "docstring": "Set lattice point selection priority"
            }, 
            "light": {
                "docstring": "Set light selection priority"
            }, 
            "localRotationAxis": {
                "docstring": "Set local rotation axis selection priority"
            }, 
            "locator": {
                "docstring": "Set locator (all types) selection priority"
            }, 
            "locatorUV": {
                "docstring": "Set uv locator selection priority"
            }, 
            "locatorXYZ": {
                "docstring": "Set xyz locator selection priority"
            }, 
            "motionTrailPoint": {
                "docstring": "Set motion point selection priority"
            }, 
            "motionTrailTangent": {
                "docstring": "Set motion point tangent priorityFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "nCloth": {
                "docstring": "Set nCloth selection priority"
            }, 
            "nParticle": {
                "docstring": "Set nParticle point selection priority"
            }, 
            "nParticleShape": {
                "docstring": "Set nParticle shape selection priority"
            }, 
            "nRigid": {
                "docstring": "Set nRigid selection priority"
            }, 
            "nonlinear": {
                "docstring": "Set nonlinear selection priority"
            }, 
            "nurbsCurve": {
                "docstring": "Set nurbs-curve selection priority"
            }, 
            "nurbsSurface": {
                "docstring": "Set nurbs-surface selection priority"
            }, 
            "orientationAxis": {
                "docstring": ""
            }, 
            "orientationLocator": {
                "docstring": "Set orientation locator selection priority"
            }, 
            "particle": {
                "docstring": "Set particle point selection priority"
            }, 
            "particleShape": {
                "docstring": "Set particle shape selection priority"
            }, 
            "plane": {
                "docstring": "Set sketch plane selection priority"
            }, 
            "polymesh": {
                "docstring": "Set poly-mesh selection priority"
            }, 
            "polymeshEdge": {
                "docstring": "Set poly-mesh edge selection priority"
            }, 
            "polymeshFace": {
                "docstring": "Set poly-mesh face selection priority"
            }, 
            "polymeshFreeEdge": {
                "docstring": "Set poly-mesh free-edge selection priority"
            }, 
            "polymeshUV": {
                "docstring": "Set poly-mesh UV point selection priority"
            }, 
            "polymeshVertex": {
                "docstring": "Set poly-mesh vertex selection priority"
            }, 
            "polymeshVtxFace": {
                "docstring": "Set poly-mesh vtxFace selection priority"
            }, 
            "query": {
                "docstring": ""
            }, 
            "rigidBody": {
                "docstring": "Set rigid body selection priority"
            }, 
            "rigidConstraint": {
                "docstring": "Set rigid constraint selection priority"
            }, 
            "rootHandle": {
                "docstring": ""
            }, 
            "rotatePivot": {
                "docstring": "Set rotate pivot selection priority"
            }, 
            "scalePivot": {
                "docstring": "Set scale pivot selection priority"
            }, 
            "sculpt": {
                "docstring": "Set sculpt selection priority"
            }, 
            "selectHandle": {
                "docstring": "Set select handle selection priority"
            }, 
            "sets": {
                "docstring": ""
            }, 
            "slugObject": {
                "docstring": ""
            }, 
            "slugVertex": {
                "docstring": ""
            }, 
            "softBody": {
                "docstring": ""
            }, 
            "spotlightComponent": {
                "docstring": ""
            }, 
            "spring": {
                "docstring": "Set spring shape selection priority"
            }, 
            "springComponent": {
                "docstring": "Set individual spring selection priority"
            }, 
            "stroke": {
                "docstring": "Set stroke selection priority"
            }, 
            "subdiv": {
                "docstring": "Set subdivision surface selection priority"
            }, 
            "subdivMeshEdge": {
                "docstring": "Set subdivision surface mesh edge selection priority"
            }, 
            "subdivMeshFace": {
                "docstring": "Set subdivision surface mesh face selection priority"
            }, 
            "subdivMeshPoint": {
                "docstring": "Set subdivision surface mesh point selection priority"
            }, 
            "subdivMeshUV": {
                "docstring": "Set subdivision surface mesh UV map selection priority"
            }, 
            "subdivisionPolymesh": {
                "docstring": ""
            }, 
            "subdivisionPolymeshEdge": {
                "docstring": ""
            }, 
            "subdivisionPolymeshFace": {
                "docstring": ""
            }, 
            "subdivisionPolymeshVertex": {
                "docstring": ""
            }, 
            "surfaceEdge": {
                "docstring": "Set surface edge selection priority"
            }, 
            "surfaceFace": {
                "docstring": "Set surface face selection priority"
            }, 
            "surfaceKnot": {
                "docstring": "Set surface knot selection priority"
            }, 
            "surfaceParameterPoint": {
                "docstring": "Set surface parameter point selection priority"
            }, 
            "surfaceRange": {
                "docstring": "Set surface range selection priority"
            }, 
            "texture": {
                "docstring": "Set texture selection priority"
            }, 
            "vertex": {
                "docstring": "Set mesh vertex selection priority"
            }
        }
    }, 
    "selectType": {
        "description": "The selectTypecommand is used to change the set of allowable types of objects that can be selected when using the select tool. It accepts no other arguments besides the flags. There are basically two different types of items that are selectable when interactively selecting objects in the 3D views. They are classified as objects (entire objects) or components (parts of objects). The objectand componentcommand flags control which class of objects are selectable. It is possible to select components while in the object selection mode. To set the components which are selectable in object selection mode you must use the -ocm flag when specifying the component flags. ", 
        "flags": {
            "allComponents": {
                "docstring": "Set all component selection masks on/off"
            }, 
            "allObjects": {
                "docstring": "Set all object selection masks on/off"
            }, 
            "animBreakdown": {
                "docstring": "Set animation breakdown selection mask on/off."
            }, 
            "animCurve": {
                "docstring": "Set animation curve selection mask on/off."
            }, 
            "animInTangent": {
                "docstring": "Set animation in-tangent selection mask on/off."
            }, 
            "animKeyframe": {
                "docstring": "Set animation keyframe selection mask on/off."
            }, 
            "animOutTangent": {
                "docstring": "Set animation out-tangent selection mask on/off."
            }, 
            "camera": {
                "docstring": "Set camera selection mask on/off. (object flag)"
            }, 
            "cluster": {
                "docstring": "Set cluster selection mask on/off. (object flag)"
            }, 
            "collisionModel": {
                "docstring": "Set collision model selection mask on/off. (object flag)"
            }, 
            "controlVertex": {
                "docstring": "Set control vertex selection mask on/off. (component flag)"
            }, 
            "curve": {
                "docstring": "Set curve selection mask on/off. (object flag)"
            }, 
            "curveKnot": {
                "docstring": "Set curve knot selection mask on/off. (component flag)"
            }, 
            "curveOnSurface": {
                "docstring": "Set curve-on-surface selection mask on/off. (object flag)"
            }, 
            "curveParameterPoint": {
                "docstring": "Set curve parameter point selection mask on/off. (component flag)"
            }, 
            "dimension": {
                "docstring": "Set dimension shape selection mask on/off. (object flag)"
            }, 
            "dynamicConstraint": {
                "docstring": "Set dynamicConstraint selection mask on/off. (object flag)"
            }, 
            "edge": {
                "docstring": "Set mesh edge selection mask on/off. (component flag)"
            }, 
            "editPoint": {
                "docstring": "Set edit-point selection mask on/off. (component flag)"
            }, 
            "emitter": {
                "docstring": "Set emitter selection mask on/off. (object flag)"
            }, 
            "facet": {
                "docstring": "Set mesh face selection mask on/off. (component flag)"
            }, 
            "field": {
                "docstring": "Set field selection mask on/off. (object flag)"
            }, 
            "fluid": {
                "docstring": "Set fluid selection mask on/off. (object flag)"
            }, 
            "follicle": {
                "docstring": "Set follicle selection mask on/off. (object flag)"
            }, 
            "hairSystem": {
                "docstring": "Set hairSystem selection mask on/off. (object flag)"
            }, 
            "handle": {
                "docstring": "Set object handle selection mask on/off. (object flag)"
            }, 
            "hull": {
                "docstring": "Set hull selection mask on/off. (component flag)"
            }, 
            "ikEndEffector": {
                "docstring": "Set ik end effector selection mask on/off. (object flag)"
            }, 
            "ikHandle": {
                "docstring": "Set ik handle selection mask on/off. (object flag)"
            }, 
            "imagePlane": {
                "docstring": "Set image plane selection mask on/off. (component flag)"
            }, 
            "implicitGeometry": {
                "docstring": "Set implicit geometry selection mask on/off. (object flag)"
            }, 
            "isoparm": {
                "docstring": "Set surface iso-parm selection mask on/off. (component flag)"
            }, 
            "joint": {
                "docstring": "Set ik handle selection mask on/off. (object flag)"
            }, 
            "jointPivot": {
                "docstring": "Set joint pivot selection mask on/off. (component flag)"
            }, 
            "lattice": {
                "docstring": "Set lattice selection mask on/off. (object flag)"
            }, 
            "latticePoint": {
                "docstring": "Set lattice point selection mask on/off. (component flag)"
            }, 
            "light": {
                "docstring": "Set light selection mask on/off. (object flag)"
            }, 
            "localRotationAxis": {
                "docstring": "Set local rotation axis selection mask on/off. (component flag)"
            }, 
            "locator": {
                "docstring": "Set locator (all types) selection mask on/off. (object flag)"
            }, 
            "locatorUV": {
                "docstring": "Set uv locator selection mask on/off. (object flag)"
            }, 
            "locatorXYZ": {
                "docstring": "Set xyz locator selection mask on/off. (object flag)"
            }, 
            "meshComponents": {
                "docstring": ""
            }, 
            "motionTrailPoint": {
                "docstring": "Set motion point selection mask on/off."
            }, 
            "motionTrailTangent": {
                "docstring": "Set motion point tangent mask on/off.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "nCloth": {
                "docstring": "Set nCloth selection mask on/off. (object flag)"
            }, 
            "nParticle": {
                "docstring": "Set nParticle point selection mask on/off. (component flag)"
            }, 
            "nParticleShape": {
                "docstring": "Set nParticle shape selection mask on/off. (object flag)"
            }, 
            "nRigid": {
                "docstring": "Set nRigid selection mask on/off. (object flag)"
            }, 
            "nonlinear": {
                "docstring": "Set nonlinear selection mask on/off. (object flag)"
            }, 
            "nurbsCurve": {
                "docstring": "Set nurbs-curve selection mask on/off. (object flag)"
            }, 
            "nurbsSurface": {
                "docstring": "Set nurbs-surface selection mask on/off. (object flag)"
            }, 
            "objectComponent": {
                "docstring": "Component flags apply to object mode."
            }, 
            "orientationLocator": {
                "docstring": "Set orientation locator selection mask on/off. (object flag)"
            }, 
            "particle": {
                "docstring": "Set particle point selection mask on/off. (component flag)"
            }, 
            "particleShape": {
                "docstring": "Set particle shape selection mask on/off. (object flag)"
            }, 
            "plane": {
                "docstring": "Set sketch plane selection mask on/off. (object flag)"
            }, 
            "polymesh": {
                "docstring": "Set poly-mesh selection mask on/off. (object flag)"
            }, 
            "polymeshEdge": {
                "docstring": "Set poly-mesh edge selection mask on/off. (component flag)"
            }, 
            "polymeshFace": {
                "docstring": "Set poly-mesh face selection mask on/off. (component flag)"
            }, 
            "polymeshFreeEdge": {
                "docstring": "Set poly-mesh free-edge selection mask on/off. (component flag)"
            }, 
            "polymeshUV": {
                "docstring": "Set poly-mesh UV point selection mask on/off. (component flag)"
            }, 
            "polymeshVertex": {
                "docstring": "Set poly-mesh vertex selection mask on/off. (component flag)"
            }, 
            "polymeshVtxFace": {
                "docstring": "Set poly-mesh vertexFace selection mask on/off. (component flag)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "rigidBody": {
                "docstring": "Set rigid body selection mask on/off. (object flag)"
            }, 
            "rigidConstraint": {
                "docstring": "Set rigid constraint selection mask on/off. (object flag)"
            }, 
            "rotatePivot": {
                "docstring": "Set rotate pivot selection mask on/off. (component flag)"
            }, 
            "scalePivot": {
                "docstring": "Set scale pivot selection mask on/off. (component flag)"
            }, 
            "sculpt": {
                "docstring": "Set sculpt selection mask on/off. (object flag)"
            }, 
            "selectHandle": {
                "docstring": "Set select handle selection mask on/off. (component flag)"
            }, 
            "sets": {
                "docstring": ""
            }, 
            "slugObject": {
                "docstring": ""
            }, 
            "slugVertex": {
                "docstring": ""
            }, 
            "spotlightComponent": {
                "docstring": ""
            }, 
            "spring": {
                "docstring": "Set spring shape selection mask on/off. (object flag)"
            }, 
            "springComponent": {
                "docstring": "Set individual spring selection mask on/off. (component flag)"
            }, 
            "stroke": {
                "docstring": "Set the Paint Effects stroke selection mask on/off. (object flag)"
            }, 
            "subdiv": {
                "docstring": "Set subdivision surfaces selection mask on/off. (object flag)"
            }, 
            "subdivMeshEdge": {
                "docstring": "Set subdivision surfaces mesh edge selection mask on/off. (component flag)"
            }, 
            "subdivMeshFace": {
                "docstring": "Set subdivision surfaces mesh face selection mask on/off. (component flag)"
            }, 
            "subdivMeshPoint": {
                "docstring": "Set subdivision surfaces mesh point selection mask on/off. (component flag)"
            }, 
            "subdivMeshUV": {
                "docstring": "Set subdivision surfaces mesh UV map selection mask on/off. (component flag)"
            }, 
            "subdivisionPolymesh": {
                "docstring": ""
            }, 
            "subdivisionPolymeshEdge": {
                "docstring": ""
            }, 
            "subdivisionPolymeshFace": {
                "docstring": ""
            }, 
            "subdivisionPolymeshVertex": {
                "docstring": ""
            }, 
            "surfaceEdge": {
                "docstring": "Set surface edge selection mask on/off. (component flag)"
            }, 
            "surfaceFace": {
                "docstring": "Set surface face selection mask on/off. (component flag)"
            }, 
            "surfaceKnot": {
                "docstring": "Set surface knot selection mask on/off. (component flag)"
            }, 
            "surfaceParameterPoint": {
                "docstring": "Set surface parameter point selection mask on/off. (component flag)"
            }, 
            "surfaceRange": {
                "docstring": "Set surface range selection mask on/off. (component flag)"
            }, 
            "surfaceUV": {
                "docstring": "Set surface uv selection mask on/off. (component flag)"
            }, 
            "texture": {
                "docstring": "Set texture selection mask on/off. (object flag)"
            }, 
            "vertex": {
                "docstring": "Set mesh vertex selection mask on/off. (component flag)"
            }
        }
    }, 
    "selectedNodes": {
        "description": "", 
        "flags": {
            "dagObjects": {
                "docstring": ""
            }
        }
    }, 
    "selectionConnection": {
        "description": "This command creates a named selectionConnection object. This object is simply a shared selection list. It may be used by editors to share their highlight data. For example, an outliner may attach its selected list to one of these objects, and a graph editor may use the same object as a list source. Then, the graph editor would only display objects that are selected in the outliner. Selection connections are UI objects which contain a list of model objects. Selection connections are useful for specifying which objects are to be displayed within a particular editor. Editor's have three plug socketswhere a selection connection may be attached. They are: mainListConnectionan inputsocket which contains a list of objects that are to be displayed within the editorselectionConnectionan outputsocket which contains a list of objects that are selectedwithin the editorhighlightConnectionan inputsocket which contains a list of objects that are to be highlightedwithin the editorThere are several different types of selection connections that may be created. They include: activeLista selection connection which contains a list of everything in the model which is active (which includes geometry objects and keys)modelLista selection connection which contains a list of all the geometry (i.e. excluding keys) objects that are currently activekeyframeLista selection connection which contains a list of all the keys that are currently activeworldLista selection connection which contains a list of all the objects in the worldobjectLista selection connection which contains one model object (which may be a set)listLista selection connection which contains a list of selection connectionseditorLista selection connection which contains a list of objects that are attached to the mainListConnection of the specified editorsetLista selection connection which contains a list of all the sets in the worldcharacterLista selection connection which contains a list of all the characters in the worldhighlightLista selection connection which contains a list of objects to be highlighted in some fashionBelow is an example selectionConnection network between two editors. Editor 1 is setup to display objects on the activeList. Editor 2 is setup to display objects which are selected within Editor 1, and objects that are selected in Editor 2 are highlighted within Editor 1: -- Editor 1--       -- Editor 2-- inputList--| main |      |  |-| main |      | |      | sele |--|  |      | sele |--| |-| high |      |     | high |      |  | |   -------------       -------------   | |------------- fromEditor2 -------------| The following commands will establish this network: selectionConnection -activeList inputList; selectionConnection fromEditor1; selectionConnection fromEditor2; editor -edit -mainListConnection inputList Editor1; editor -edit -selectionConnection fromEditor1 Editor1; editor -edit -mainListConnection fromEditor1 Editor2; editor -edit -selectionConnection fromEditor2 Editor2; editor -edit -highlightConnection fromEditor2 Editor1; Note: to delete a selection connectionuse the deleteUI commandNote: commands which expect objects may be given a selection connection instead, and the command will operate upon the objects wrapped by the selection connectionNote: the graph editor and the dope sheet are the only editors which can use the editor connection to the highlightConnection of another editorWARNING: some flag combinations may not behave as you expect. The command is really intended for internal use for managing the outliner used by the various editors. ", 
        "flags": {
            "activeCacheList": {
                "docstring": "Specifies that this connection should reflect the cache that objects on the active list belong to."
            }, 
            "activeCharacterList": {
                "docstring": "Specifies that this connection should reflect the characters that objects on the active list belong to."
            }, 
            "activeList": {
                "docstring": "Specifies that this connection should reflect the active list (geometry objects and keys)."
            }, 
            "addScript": {
                "docstring": "Specify a script to be called when something is added to the selection."
            }, 
            "addTo": {
                "docstring": "The name of a selection connection that should be added to this list of connections."
            }, 
            "characterList": {
                "docstring": "Specifies that this connection should reflect all the characters in the world."
            }, 
            "clear": {
                "docstring": "Remove everything from the selection connection."
            }, 
            "connectionList": {
                "docstring": "Specifies that this connection should contain a list of selection connections."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "deselect": {
                "docstring": "Remove something from the selection.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editor": {
                "docstring": "Specifies that this connection should reflect the -mainListConnection of the specified editor."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Optionally specifies an itemFilter for this connection. An empty string (\"\") clears the current filter. If a filter is specified, all the information going into the selectionConnection must first pass through the filter before being accepted. NOTE: filters can only be attached to regular selectionConnections. They cannot be attached to any connection created using the -act, -mdl, -key, -wl, -sl, -cl, -lst, -obj, or -ren flags. We strongly recommend that you do not attach filters to a selectionConnection --- it is better to attach your filter to the editor that is using the selectionConnection instead."
            }, 
            "findObject": {
                "docstring": "Find a selection connection in this list that wraps the specified object."
            }, 
            "g": {
                "docstring": "A global selection connection cannot be deleted by any script commands."
            }, 
            "highlightList": {
                "docstring": "Specifies that this connection is being used as a highlight list."
            }, 
            "identify": {
                "docstring": "Find out what type of selection connection this is. May be: activeList | modelList | keyframeList | worldList | objectList listList | editorList | connection | unknown"
            }, 
            "keyframeList": {
                "docstring": "Specifies that this connection should reflect the animation portion of the active list."
            }, 
            "lock": {
                "docstring": "For activeList connections, locking the connection means that it will not listen to activeList changes."
            }, 
            "modelList": {
                "docstring": "Specifies that this connection should reflect the modeling (i.e. excluding keys) portion of the active list."
            }, 
            "object": {
                "docstring": "Specifies that this connection should wrap around the specified object (which may be a set). Query will return all the members of the selection connection (if the connection wraps a set, the set members will be returned)"
            }, 
            "parent": {
                "docstring": "The name of a UI object this should be attached to. When the parent is destroyed, the selectionConnection will auto-delete. If no parent is specified, the connection is created in the current controlLayout."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "The name of a selection connection that should be removed from this list of connections."
            }, 
            "removeScript": {
                "docstring": "Specify a script to be called when something is removed from the selection."
            }, 
            "select": {
                "docstring": "Add something to the selection. This does not replace the existing selection."
            }, 
            "setList": {
                "docstring": "Specifies that this connection should reflect all the sets in the world."
            }, 
            "switch": {
                "docstring": "Acts as a modifier to -connectionList which sets the list of objects to be the first non-empty selection connection. selection connections are tested in the order in which they are added."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "worldList": {
                "docstring": "Specifies that this connection should reflect all objects in the world."
            }
        }
    }, 
    "separator": {
        "description": "This command creates a separator widget in a variety of drawing styles. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "horizontal": {
                "docstring": "Specify the orientation of the separator. True for horizontal and false for vertical.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "style": {
                "docstring": "Specify the style of the separator. Valid values are \"none\", \"single\", \"double\", \"singleDash\", \"doubleDash\", \"in\" and \"out\"."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "sequenceManager": {
        "description": "The sequenceManager command manages sequences, shots, and their related scenes. In query mode, return type is based on queried flag.", 
        "flags": {
            "addSequencerAudio": {
                "docstring": "Add an audio clip to the sequencer by specifying a filename"
            }, 
            "attachSequencerAudio": {
                "docstring": "Add an audio clip to the sequencer by specifying an audio node"
            }, 
            "currentShot": {
                "docstring": "Returns the shot that is being used at the current sequence time."
            }, 
            "currentTime": {
                "docstring": "Set the current sequence time"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "listSequencerAudio": {
                "docstring": "List the audio clips added to the sequencerFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "listShots": {
                "docstring": "List all the currently defined shots across all scene segments"
            }, 
            "modelPanel": {
                "docstring": "Sets a dedicated modelPanel to be used as the panel that the sequencer will control."
            }, 
            "node": {
                "docstring": "Returns the SequenceManager node, of which there is only ever one."
            }, 
            "query": {
                "docstring": ""
            }, 
            "writableSequencer": {
                "docstring": "Get the writable sequencer node. Create it if it doesn't exist."
            }
        }
    }, 
    "setAttr": {
        "description": "Sets the value of a dependency node attribute. No value for the the attribute is needed when the -l/-k/-s flags are used. The -type flag is only required when setting a non-numeric attribute. The following chart outlines the syntax of setAttr for non-numeric data types: TYPEbelow means any number of values of type TYPE, separated by a space[TYPE]means that the value of type TYPEis optionalA|Bmeans that either of Aor Bmay appearIn order to run its examples, first execute these commands to create the sample attribute types:sphere -n node; addAttr -ln short2Attr -at short2; addAttr -ln short2a -p short2Attr -at short; addAttr -ln short2b -p short2Attr -at short; addAttr -ln short3Attr -at short3; addAttr -ln short3a -p short3Attr -at short; addAttr -ln short3b -p short3Attr -at short; addAttr -ln short3c -p short3Attr -at short; addAttr -ln long2Attr -at long2; addAttr -ln long2a -p long2Attr -at long; addAttr -ln long2b -p long2Attr -at long; addAttr -ln long3Attr -at long3; addAttr -ln long3a -p long3Attr -at long; addAttr -ln long3b -p long3Attr -at long; addAttr -ln long3c -p long3Attr -at long; addAttr -ln float2Attr -at float2; addAttr -ln float2a -p float2Attr -at \"float\"; addAttr -ln float2b -p float2Attr -at \"float\"; addAttr -ln float3Attr -at float3; addAttr -ln float3a -p float3Attr -at \"float\"; addAttr -ln float3b -p float3Attr -at \"float\"; addAttr -ln float3c -p float3Attr -at \"float\"; addAttr -ln double2Attr -at double2; addAttr -ln double2a -p double2Attr -at double; addAttr -ln double2b -p double2Attr -at double; addAttr -ln double3Attr -at double3; addAttr -ln double3a -p double3Attr -at double; addAttr -ln double3b -p double3Attr -at double; addAttr -ln double3c -p double3Attr -at double; addAttr -ln int32ArrayAttr -dt Int32Array; addAttr -ln doubleArrayAttr -dt doubleArray; addAttr -ln pointArrayAttr -dt pointArray; addAttr -ln vectorArrayAttr -dt vectorArray; addAttr -ln stringArrayAttr -dt stringArray; addAttr -ln stringAttr -dt \"string\"; addAttr -ln matrixAttr -dt \"matrix\"; addAttr -ln sphereAttr -dt sphere; addAttr -ln coneAttr -dt cone; addAttr -ln meshAttr -dt mesh; addAttr -ln latticeAttr -dt lattice; addAttr -ln spectrumRGBAttr -dt spectrumRGB; addAttr -ln reflectanceRGBAttr -dt reflectanceRGB; addAttr -ln componentListAttr -dt componentList; addAttr -ln attrAliasAttr -dt attributeAlias; addAttr -ln curveAttr -dt nurbsCurve; addAttr -ln surfaceAttr -dt nurbsSurface; addAttr -ln trimFaceAttr -dt nurbsTrimface; addAttr -ln polyFaceAttr -dt polyFaces; -type short2Array of two short integersValue Syntaxshort shortValue Meaningvalue1 value2Mel ExamplesetAttr node.short2Attr -type short2 1 2;Python Examplecmds.setAttr('node.short2Attr',1,2,type='short2')-type short3Array of three short integersValue Syntaxshort short shortValue Meaningvalue1 value2 value3Mel ExamplesetAttr node.short3Attr -type short3 1 2 3;Python Examplecmds.setAttr('node.short3Attr',1,2,3,type='short3')-type long2Array of two long integersValue Syntaxlong longValue Meaningvalue1 value2Mel ExamplesetAttr node.long2Attr -type long2 1000000 2000000;Python Examplecmds.setAttr('node.long2Attr',1000000,2000000,type='long2')-type long3Array of three long integersValue Syntaxlong long longValue Meaningvalue1 value2 value3Mel ExamplesetAttr node.long3Attr -type long3 1000000 2000000 3000000;Python Examplecmds.setAttr('node.long3Attr',1000000,2000000,3000000,type='long3')-type Int32ArrayVariable length array of long integersValue SyntaxValue MeaningMel ExamplesetAttr node.int32ArrayAttr -type Int32Array 2 12 75;Python Examplecmds.setAttr('node.int32ArrayAttr',[2,12,75],type='Int32Array')-type float2Array of two floatsValue Syntaxfloat floatValue Meaningvalue1 value2Mel ExamplesetAttr node.float2Attr -type float2 1.1 2.2;Python Examplecmds.setAttr('node.float2Attr',1.1,2.2,type='float2')-type float3Array of three floatsValue Syntaxfloat float floatValue Meaningvalue1 value2 value3Mel ExamplesetAttr node.float3Attr -type float3 1.1 2.2 3.3;Python Examplecmds.setAttr('node.float3Attr',1.1,2.2,3.3,type='float3')-type double2Array of two doublesValue Syntaxdouble doubleValue Meaningvalue1 value2Mel ExamplesetAttr node.double2Attr -type double2 1.1 2.2;Python Examplecmds.setAttr('node.double2Attr',1.1,2.2,type='double2')-type double3Array of three doublesValue Syntaxdouble double doubleValue Meaningvalue1 value2 value3Mel ExamplesetAttr node.double3Attr -type double3 1.1 2.2 3.3;Python Examplecmds.setAttr('node.double3Attr',1.1,2.2,3.3,type='double3')-type doubleArrayVariable length array of doublesValue SyntaxValue MeaningMel ExamplesetAttr node.doubleArrayAttr -type doubleArray 2 3.14159 2.782;Python Examplecmds.setAttr( \"node.doubleArrayAttr\", (2, 3.14159, 2.782,), type=\"doubleArray\")-type matrix4x4 matrix of doublesValue Syntaxdouble double double doubledouble double double doubledouble double double doubledouble double double doubleValue Meaningrow1col1 row1col2 row1col3 row1col4row2col1 row2col2 row2col3 row2col4row3col1 row3col2 row3col3 row3col4row4col1 row4col2 row4col3 row4col4Alternate Syntaxstring double double doubledouble double doubleintegerdouble double doubledouble double doubledouble double doubledouble double doubledouble double doubledouble double doubledouble double double doubledouble double double doubledouble double doublebooleanAlternate Meaning\"xform\" scaleX scaleY scaleZrotateX rotateY rotateZrotationOrder (0=XYZ, 1=YZX, 2=ZXY, 3=XZY, 4=YXZ, 5=ZYX)translateX translateY translateZshearXY shearXZ shearYZscalePivotX scalePivotY scalePivotZscaleTranslationX scaleTranslationY scaleTranslationZrotatePivotX rotatePivotY rotatePivotZrotateTranslationX rotateTranslationY rotateTranslationZrotateOrientW rotateOrientX rotateOrientY rotateOrientZjointOrientW jointOrientX jointOrientY jointOrientZinverseParentScaleX inverseParentScaleY inverseParentScaleZcompensateForParentScaleMel ExamplesetAttr node.matrixAttr -type \"matrix\" 1 0 0 0 0 1 0 0 0 0 1 0 2 3 4 1;setAttr node.matrixAttr -type \"matrix\" \"xform\" 1 1 1 0 0 0 0 2 3 4 0 0 00 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 1 1 1 0 false;Python Examplecmds.setAttr('node.matrixAttr',(1,0,0,0,0,1,0,0,0,0,1,0,2,3,4,1),type='matrix')cmds.setAttr('node.matrixAttr','xform',(1,1,1),(0,0,0),0,(2,3,4),(0,0,0),(0,0,0),(0,0,0),(0,0,0),(0,1,1),(0,0,1,0),(1,0,1,0),(1,2,3),False,type=\"matrix\")-type pointArrayVariable length array of pointsValue SyntaxValue MeaningMel ExamplesetAttr node.pointArrayAttr -type pointArray 2 1 1 1 1 2 2 2 1;Python Examplecmds.setAttr('node.pointArrayAttr',2,(1,1,1,1),(2,2,2,1),type='pointArray')-type vectorArrayVariable length array of vectorsValue SyntaxValue MeaningMel ExamplesetAttr node.vectorArrayAttr -type vectorArray 2 1 1 1 2 2 2;Python Examplecmds.setAttr('node.vectorArrayAttr',2,(1,1,1),(2,2,2),type='vectorArray')-type \"string\"Character stringValue SyntaxstringValue MeaningcharacterStringValueMel ExamplesetAttr node.stringAttr -type \"string\" \"blarg\";Python Examplecmds.setAttr('node.stringAttr',\"blarg\",type=\"string\")-type stringArrayVariable length array of stringsValue SyntaxValue MeaningMel ExamplesetAttr node.stringArrayAttr -type stringArray 3 \"a\" \"b\" \"c\";Python Examplecmds.setAttr('node.stringArrayAttr',3,\"a\",\"b\",\"c\",type='stringArray')-type sphereSphere dataValue SyntaxdoubleValue MeaningsphereRadiusExamplesetAttr node.sphereAttr -type sphere 5.0;-type coneCone dataValue Syntaxdouble doubleValue MeaningconeAngle coneCapMel ExamplesetAttr node.coneAttr -type cone 45.0 5.0;Python Examplecmds.setAttr('node.coneAttr',45.0,5.0,type='cone')-type reflectanceRGBReflectance dataValue Syntaxdouble double doubleValue MeaningredReflect greenReflect blueReflectMel ExamplesetAttr node.reflectanceRGBAttr -type reflectanceRGB 0.5 0.5 0.1;Python Examplecmds.setAttr('node.reflectanceRGBAttr',0.5,0.5,0.1,type='reflectanceRGB')-type spectrumRGBSpectrum dataValue Syntaxdouble double doubleValue MeaningredSpectrum greenSpectrum blueSpectrumMel ExamplesetAttr node.spectrumRGBAttr -type spectrumRGB 0.5 0.5 0.1;Python Examplecmds.setAttr('node.spectrumRGBAttr',0.5,0.5,0.1,type='spectrumRGB')-type componentListVariable length array of componentsValue SyntaxValue MeaningMel ExamplesetAttr node.componentListAttr -type componentList 3 cv[1] cv[12] cv[3];Python Examplecmds.setAttr('node.componentListAttr',3,'cv[1]','cv[12]','cv[3]',type='componentList')-type attributeAliasString alias dataValue Syntaxstring stringValue MeaningnewAlias currentNameMel ExamplesetAttr node.attrAliasAttr -type attributeAliasPython Examplecmds.setAttr('node.attrAliasAttr',(\"GoUp\", \"translateY\",\"GoLeft\", \"translateX\"),type='attributeAlias')-type nurbsCurveNURBS curve dataValue SyntaxValue MeaningMel Example// degree is the degree of the curve(range 1-7)// spans is the number of spans// form is open (0), closed (1), periodic (2)// dimension is 2 or 3, depending on the dimension of the curve// isRational is true if the curve CVs contain a rational component// knotCount is the size of the knot list// knotValue is a single entry in the knot list// cvCount is the number of CVs in the curve// xCVValue,yCVValue,[zCVValue] [wCVValue] is a single CV.// zCVValue is only present when dimension is 3.// wCVValue is only present when isRational is true.//setAttr node.curveAttr -type nurbsCurve 3 1 0 no 36 0 0 0 1 1 14 -2 3 0 -2 1 0 -2 -1 0 -2 -3 0;-type nurbsSurfaceNURBS surface dataValue Syntaxint int int int boolValue MeaninguDegree vDegree uForm vForm isRationalExample// uDegree is degree of the surface in U direction (range 1-7)// vDegree is degree of the surface in V direction (range 1-7)// uForm is open (0), closed (1), periodic (2) in U direction// vForm is open (0), closed (1), periodic (2) in V direction// isRational is true if the surface CVs contain a rational component// uKnotCount is the size of the U knot list// uKnotValue is a single entry in the U knot list// vKnotCount is the size of the V knot list// vKnotValue is a single entry in the V knot list// If \"TRIM\" is specified then additional trim information is expected// If \"NOTRIM\" is specified then the surface is not trimmed// cvCount is the number of CVs in the surface// xCVValue,yCVValue,zCVValue [wCVValue]is a single CV.// zCVValue is only present when dimension is 3.// wCVValue is only present when isRational is true//setAttr node.surfaceAttr -type nurbsSurface 3 3 0 0 no6 0 0 0 1 1 16 0 0 0 1 1 116 -2 3 0 -2 1 0 -2 -1 0 -2 -3 0-1 3 0 -1 1 0 -1 -1 0 -1 -3 01 3 0 1 1 0 1 -1 0 1 -3 03 3 0 3 1 0 3 -1 0 3 -3 0;-type nurbsTrimfaceNURBS trim face dataValue SyntaxValue MeaningExample// flipNormal if true turns the surface inside out// boundaryCount: number of boundaries// boundaryType:// tedgeCountOnBoundary : number of edges in a boundary// splineCountOnEdge : number of splines in an edge in// edgeTolerance : tolerance used to build the 3d edge// isEdgeReversed : if true, the edge is backwards// geometricContinuity : if true, the edge is tangent continuous// splineCountOnPedge : number of splines in a 2d edge// isMonotone : if true, curvature is monotone// pedgeTolerance : tolerance for the 2d edge//-type polyFacePolygon face dataValue SyntaxValue MeaningExample// This data type (polyFace) is meant to be used in file I/O// after setAttrs have been written out for vertex position// arrays, edge connectivity arrays (with corresponding start// and end vertex descriptions), texture coordinate arrays and// color arrays. The reason is that this data type references// all of its data through ids created by the former types.//// \"f\"specifies the ids of the edges making up a face -// negative value if the edge is reversed in the face// \"h\"specifies the ids of the edges making up a hole -// negative value if the edge is reversed in the face// \"mf\"specifies the ids of texture coordinates (uvs) for a face.// This data type is obsolete as of version 3.0. It is replaced by \"mu\".// \"mh\"specifies the ids of texture coordinates (uvs) for a hole// This data type is obsolete as of version 3.0. It is replaced by \"mu\".// \"mu\"The first argument refers to the uv set. This is a zero-based// integer number. The second argument refers to the number of vertices (n)// on the face which have valid uv values. The last n values are the uv// ids of the texture coordinates (uvs) for the face. These indices// are what used to be represented by the \"mf\" and \"mh\" specification.// There may be more than one \"mu\" specification, one for each unique uv set.// \"fc\"specifies the color index values for a face//setAttr node.polyFaceAttr -type polyFaces \"f\" 3 1 2 3 \"fc\" 3 4 4 6;-type meshPolygonal meshValue SyntaxValue MeaningExample// \"v\"specifies the vertices of the polygonal mesh// \"vn\"specifies the normal of each vertex// \"vt\"is optional and specifies a U,V texture coordinate for each vertex// \"e\"specifies the edge connectivity information between vertices//setAttr node.meshAttr -type mesh \"v\" 3 0 0 0 0 1 0 0 0 1\"vn\" 3 1 0 0 1 0 0 1 0 0\"vt\" 3 0 0 0 1 1 0\"e\" 3 0 1 \"hard\" 1 2 \"hard\" 2 0 \"hard\";-type latticeLattice dataValue SyntaxValue MeaningsDivisionCount tDivisionCount uDivisionCountExample// sDivisionCount is the horizontal lattice division count// tDivisionCount is the vertical lattice division count// uDivisionCount is the depth lattice division count// pointCount is the total number of lattice points// pointX,pointY,pointZ is one lattice point. The list is// specified varying first in S, then in T, last in U so the// first two entries are (S=0,T=0,U=0) (s=1,T=0,U=0)//setAttr node.latticeAttr -type lattice 2 5 2 20-2 -2 -2 2 -2 -2 -2 -1 -2 2 -1 -2 -2 0 -22 0 -2 -2 1 -2 2 1 -2 -2 2 -2 2 2 -2-2 -2 2 2 -2 2 -2 -1 2 2 -1 2 -2 0 22 0 2 -2 1 2 2 1 2 -2 2 2 2 2 2;In query mode, return type is based on queried flag.", 
        "flags": {
            "alteredValue": {
                "docstring": "The value is only the current value, which may change in the next evalution (if the attribute has an incoming connection). This flag is only used during file I/O, so that attributes with incoming connections do not have their data overwritten during the first evaluation after a file is opened."
            }, 
            "caching": {
                "docstring": "Sets the attribute's internal caching on or off. Not all attributes can be defined as caching. Only those attributes that are not defined by default to be cached can be made caching. As well, multi attribute elements cannot be made caching. Caching also affects child attributes for compound attributes."
            }, 
            "capacityHint": {
                "docstring": "Used to provide a memory allocation hint to attributes where the -size flag cannot provide enough information. This flag is optional and is primarily intended to be used during file I/O. Only certain attributes make use of this flag, and the interpretation of the flag value varies per attribute. This flag is currently used by (node.attribute): mesh.face - hints the total number of elements in the face edge listsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "channelBox": {
                "docstring": "Sets the attribute's display in the channelBox on or off. Keyable attributes are always display in the channelBox regardless of the channelBox settting."
            }, 
            "clamp": {
                "docstring": "For numeric attributes, if the value is outside the range of the attribute, clamp it to the min or max instead of failing"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "keyable": {
                "docstring": "Sets the attribute's keyable state on or off."
            }, 
            "lock": {
                "docstring": "Sets the attribute's lock state on or off."
            }, 
            "query": {
                "docstring": ""
            }, 
            "size": {
                "docstring": "Defines the size of a multi-attribute array. This is only a hint, used to help allocate memory as efficiently as possible."
            }, 
            "type": {
                "docstring": "Identifies the type of data. If the -type flag is not present, a numeric type is assumed."
            }
        }
    }, 
    "setAttrMapping": {
        "description": "This command applies an offset and scale to a specified device attachment. This command is different than the setInputDeviceMapping command, which applies a mapping to a device axis. The value from the device is multiplied by the scale and the offset is added to this product. With an absolute mapping, the attached attribute gets the resulting value. If the mapping is relative, the resulting value is added to the previous calculated value. The calculated value will also take into account the setInputDeviceMapping, if it was defined. As an example, if the space ball is setup with absolute attachment mappings, pressing in one direction will cause the attached attribute to get a constant value. If a relative mapping is used, and the spaceball is pressed in one direction, the attached attribute will get a constantly increasing (or constantly decreasing) value. Note that the definition of relative is different than the definition used by the setInputDeviceMapping command. In general, both a relative attachment mapping (this command) and a relative device mapping (setInputDeviceMapping) should not be used together one the same axis. In query mode, return type is based on queried flag.", 
        "flags": {
            "absolute": {
                "docstring": "Make the mapping absolute."
            }, 
            "attribute": {
                "docstring": "The attribute used in the attachment."
            }, 
            "axis": {
                "docstring": "The axis on the device used in the attachment."
            }, 
            "clutch": {
                "docstring": "The clutch button used in the attachment."
            }, 
            "device": {
                "docstring": "The device used in the attachment."
            }, 
            "offset": {
                "docstring": "Specify the offset value."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Make the mapping relative.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "scale": {
                "docstring": "Specify the scale value."
            }, 
            "selection": {
                "docstring": "This flag specifies the mapping should be on the selected objects"
            }
        }
    }, 
    "setDefaultShadingGroup": {
        "description": "The setDefaultShadingGroup command is used to change which shading group is considered the current default shading group. Subsequently created objects will be assigned to the new default group. In query mode, return type is based on queried flag.", 
        "flags": {
            "query": {
                "docstring": ""
            }
        }
    }, 
    "setDrivenKeyframe": {
        "description": "This command sets a driven keyframe. A driven keyframe is similar to a regular keyframe. However, while a standard keyframe always has an x-axis of time in the graph editor, for a drivenkeyframe the user may choose any attribute as the x-axis of the graph editor.For example, you can keyframe the emission of a faucet so that so that it emits whenever the faucet handle is rotated around y. The faucet emission in this example is called the driven attribute. The handle rotation is called the driver. Once you have used setDrivenKeyframe to set up the relationship between the emission and the rotation, you can go to the graph editor and modify the relationship between the attributes just as you would modify the animation curve on any keyframed object.In the case of an attribute driven by a single driver, the dependency graph is connected like this:driver attribute ---animCurve ---driven attributeYou can set driven keyframes with more than a single driver. The effects of the multiple drivers are combined together by a blend node. ", 
        "flags": {
            "attribute": {
                "docstring": "Attribute name to set keyframes on."
            }, 
            "controlPoints": {
                "docstring": "Explicitly specify whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false."
            }, 
            "currentDriver": {
                "docstring": "Set the driver to be used for the current driven keyframe to the attribute passed as an argument."
            }, 
            "driven": {
                "docstring": "Returns list of driven attributes for the selected item."
            }, 
            "driver": {
                "docstring": "Returns list of available drivers for the attribute."
            }, 
            "driverValue": {
                "docstring": "Value of the driver to use for this keyframe. Default value is the current value."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "hierarchy": {
                "docstring": "Controls the objects this command acts on, relative to the specified (or active) target objects. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" Default is \"hierarchy -query\""
            }, 
            "inTangentType": {
                "docstring": "The in tangent type for keyframes set by this command. Valid values are \"spline\", \"linear\", \"fast\", \"slow\", \"flat\", \"stepped\", \"step next\", \"fixed\", \"clamped\" and \"plateau\". Default is \"keyTangent -q -g -inTangentType\""
            }, 
            "insert": {
                "docstring": "Insert keys at the given time(s) and preserve the shape of the animation curve(s). Note: the tangent type on inserted keys will be fixed so that the curve shape can be preserved."
            }, 
            "insertBlend": {
                "docstring": "If true, a pairBlend node will be inserted for channels that have nodes other than animCurves driving them, so that such channels can have blended animation. If false, these channels will not have keys inserted. If the flag is not specified, the blend will be inserted based on the global preference for blending animation."
            }, 
            "outTangentType": {
                "docstring": "The out tangent type for keyframes set by this command. Valid values are \"spline\", \"linear\", \"fast\", \"slow\", \"flat\", \"stepped\", \"step next\", \"fixed\", \"clamped\" and \"plateau\". Default is \"keyTangent -q -g -outTangentType\""
            }, 
            "query": {
                "docstring": ""
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true"
            }, 
            "value": {
                "docstring": "Value to set the keyframe at. Default is the current value.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "setDynamic": {
        "description": "setDynamic sets the isDynamic attribute of particle objects on or off. If no objects are specified, it sets the attribute for any selected objects. If -all is thrown, it sets the attribute for all particle objects in the scene. By default it sets the attribute true (on); if the -off flag is thrown, it sets the attribute false (off). WARNING: setDynamic is obsolescent. This is the last version of Maya in which it will be supported. ", 
        "flags": {
            "allOnWhenRun": {
                "docstring": "Obsolete, no longer suppported or necessary."
            }, 
            "disableAllOnWhenRun": {
                "docstring": "Obsolete, no longer suppported or necessary.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "setAll": {
                "docstring": "Set for all objects."
            }, 
            "setOff": {
                "docstring": "Sets isDynamic false."
            }, 
            "setOn": {
                "docstring": "Sets isDynamic true. This flag is set by default."
            }
        }
    }, 
    "setEditCtx": {
        "description": "This command creates a tool that can be used to modify set membership. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "setFluidAttr": {
        "description": "Sets values of built-in fluid attributes such as density, velocity, etc., for individual grid cells or for all cells in the grid. ", 
        "flags": {
            "addValue": {
                "docstring": "Add specified value to attribute"
            }, 
            "attribute": {
                "docstring": "Specifies the fluid attribute for which to set values. Valid attributes are \"velocity\", \"density\", \"fuel\", \"color\", \"falloff\", and \"temperature\"."
            }, 
            "clear": {
                "docstring": "Set this attribute to 0"
            }, 
            "floatRandom": {
                "docstring": "If this was a scalar (e.g. density) attribute, use a random value in +-VALUE If fv is specified, it is used as the base value and combined with the random value. If the fv flag is not specified, the base is assumed to be 0."
            }, 
            "floatValue": {
                "docstring": "If this was a scalar (e.g. density) attribute, use this value"
            }, 
            "lowerFace": {
                "docstring": "Only valid with \"-at velocity\". Since velocity values are stored on the edges of each voxel and not at the center, using voxel based indices to set velocity necessarily affects neighboring voxels. Use this flag to only set velocity components on the lower left three faces of a voxel, rather than all six.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reset": {
                "docstring": "Set this attribute to default value"
            }, 
            "vectorRandom": {
                "docstring": "If this was a vector (e.g. velocity) attribute, use a random value in +-VALUE If vv is specified, it is used as the base value and combined with the random value. If the vv flag is not specified, the base is assumed to be 0,0,0."
            }, 
            "vectorValue": {
                "docstring": "If this was a vector (e.g. velocity) attribute, use this value"
            }, 
            "xIndex": {
                "docstring": "Only return values for cells with this X index"
            }, 
            "xvalue": {
                "docstring": "Only set the first component of the vector-valued attribute specified by the \"-at/attribute\" flag."
            }, 
            "yIndex": {
                "docstring": "Only return values for cells with this Y index"
            }, 
            "yvalue": {
                "docstring": "Only set the second component of the vector-valued attribute specified by the \"-at/attribute\" flag."
            }, 
            "zIndex": {
                "docstring": "Only return values for cells with this Z index"
            }, 
            "zvalue": {
                "docstring": "Only set the third component of the vector-valued attribute specified by the \"-at/attribute\" flag."
            }
        }
    }, 
    "setFocus": {
        "description": "Give keyboard focus to a specific control or panel, passed as an argument. ", 
        "flags": {}
    }, 
    "setInfinity": {
        "description": "Set the infinity type before (after) a paramCurve's first (last) keyframe. In query mode, return type is based on queried flag.", 
        "flags": {
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "postInfinite": {
                "docstring": "Set the infinity type after a paramCurve's last keyframe. Valid values are \"constant\", \"linear\", \"cycle\", \"cycleRelative\", \"oscillate\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preInfinite": {
                "docstring": "Set the infinity type before a paramCurve's first keyframe. Valid values are \"constant\", \"linear\", \"cycle\", \"cycleRelative\", \"oscillate\"."
            }, 
            "query": {
                "docstring": ""
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }
        }
    }, 
    "setInputDeviceMapping": {
        "description": "The command sets a scale and offset for all attachments made to a specified device axis. Any attachment made to a mapped device axis will have the scale and offset applied to its values. The value from the device is multiplied by the scale and the offset is added to this product. With an absolute mapping, the attached attribute gets the resulting value. If the mapping is relative, the final value is the offset added to the scaled difference between the current device value and the previous device value. This mapping will be applied to the device data before any mappings defined by the setAttrMapping command. A typical use would be to scale a device's input so that it is within a usable range. For example, the device mapping can be used to calibrate a spaceball to work in a specific section of a scene. As an example, if the space ball is setup with absolute device mappings, constantly pressing in one direction will cause the attached attribute to get a constant value. If a relative mapping is used, and the spaceball is pressed in one direction, the attached attribute will jump a constantly increasing (or constantly decreasing) value and will find a rest value equal to the offset. There are important differences between how the relative flag is handled by this command and the setAttrMapping command. (See the setAttrMapping documentation for specifics on how it calculates relative values). In general, both a relative device mapping (this command) and a relative attachment mapping (setAttrMapping) should not be used together on the same axis. ", 
        "flags": {
            "absolute": {
                "docstring": "report absolute axis values"
            }, 
            "axis": {
                "docstring": "specify the axis to map"
            }, 
            "device": {
                "docstring": "specify which device to map"
            }, 
            "offset": {
                "docstring": "specify the axis offset value"
            }, 
            "relative": {
                "docstring": "report the change in axis value since the last sample"
            }, 
            "scale": {
                "docstring": "specify the axis scale value"
            }, 
            "view": {
                "docstring": "translate the device coordinates into the coordinates of the active camera"
            }, 
            "world": {
                "docstring": "translate the device coordinates into world space coordinatesFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "setKeyCtx": {
        "description": "This command creates a context which may be used to set keys within the graph editor ", 
        "flags": {
            "breakdown": {
                "docstring": "Specifies whether or not to create breakdown keysFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "setKeyPath": {
        "description": "The setKeyPath command either creates or edits the path (a nurbs curve) based on the current position of the selected object at the current time. ", 
        "flags": {}
    }, 
    "setKeyframe": {
        "description": "This command creates keyframes for the specified objects, or the active objects if none are specified on the command line. The default time for the new keyframes is the current time. Override this behavior with the \"-t\" flag on the command line. The default value for the keyframe is the current value of the attribute for which a keyframe is set. Override this behavior with the \"-v\" flag on the command line. When setting keyframes on animation curves that do not have \"time\" as an input attribute (ie, they are unitless animation curves), use \"-f/-float\" to specify the unitless value at which to set a keyframe. The -time and -float flags may be combined in one command. This command sets up Dependency Graph relationships for proper evaluation of a given attribute at a given time. ", 
        "flags": {
            "animLayer": {
                "docstring": "Specifies that the new key should be placed in the specified animation layer. Note that if the objects being keyframed are not already part of the layer, this flag will be ignored."
            }, 
            "attribute": {
                "docstring": "Attribute name to set keyframes on."
            }, 
            "breakdown": {
                "docstring": "Sets the breakdown state for the key. Default is false"
            }, 
            "clip": {
                "docstring": "Specifies that the new key should be placed in the specified clip. Note that if the objects being keyframed are not already part of the clip, this flag will be ignored."
            }, 
            "controlPoints": {
                "docstring": "Explicitly specify whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false."
            }, 
            "dirtyDG": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "float": {
                "docstring": "Float time at which to set a keyframe on float-based animation curves."
            }, 
            "hierarchy": {
                "docstring": "Controls the objects this command acts on, relative to the specified (or active) target objects. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" Default is \"hierarchy -query\""
            }, 
            "identity": {
                "docstring": "Sets an identity key on an animation layer. An identity key is one that nullifies the effect of the anim layer. This flag has effect only when the attribute being keyed is being driven by animation layers."
            }, 
            "inTangentType": {
                "docstring": "The in tangent type for keyframes set by this command. Valid values are \"spline\", \"linear\", \"fast\", \"slow\", \"flat\", \"stepped\", \"step next\", \"fixed\", \"clamped\" and \"plateau\". Default is \"keyTangent -q -g -inTangentType\""
            }, 
            "insert": {
                "docstring": "Insert keys at the given time(s) and preserve the shape of the animation curve(s). Note: the tangent type on inserted keys will be fixed so that the curve shape can be preserved."
            }, 
            "insertBlend": {
                "docstring": "If true, a pairBlend node will be inserted for channels that have nodes other than animCurves driving them, so that such channels can have blended animation. If false, these channels will not have keys inserted. If the flag is not specified, the blend will be inserted based on the global preference for blending animation."
            }, 
            "minimizeRotation": {
                "docstring": "For rotations, ensures that the key that is set is a minimum distance away from the previous key. Default is false"
            }, 
            "noResolve": {
                "docstring": "When used with the -value flag, causes the specified value to be set directly onto the animation curve, without attempting to resolve the value across animation layers."
            }, 
            "outTangentType": {
                "docstring": "The out tangent type for keyframes set by this command. Valid values are \"spline\", \"linear\", \"fast\", \"slow\", \"flat\", \"stepped\", \"step next\", \"fixed\", \"clamped\" and \"plateau\". Default is \"keyTangent -q -g -outTangentType\""
            }, 
            "query": {
                "docstring": ""
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true"
            }, 
            "time": {
                "docstring": "Time at which to set a keyframe on time-based animation curves."
            }, 
            "useCurrentLockedWeights": {
                "docstring": "If we are setting a key over an existing key, use that key tangent's locked weight value for the new locked weight value. Default is falseFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "value": {
                "docstring": "Value at which to set the keyframe. Using the value flag will not cause the keyed attribute to change to the specified value until the scene re-evaluates. Therefore, if you want the attribute to update to the new value immediately, use the setAttr command in addition to setting the key."
            }
        }
    }, 
    "setKeyframeBlendshapeTargetWts": {
        "description": "This command can be used to keyframe per-point blendshape target weights. It operates on the currently selected objects as follows. When the base object is selected, then the target weights are keyed for all targets. When only target shapes are selected, then the weights for thoses targets are keyframed. ", 
        "flags": {}
    }, 
    "setMenuMode": {
        "description": "Optionally sets a new Menu Mode for the menu bar in the main Maya window. Returns the current Menu Mode, and if a new one is specified, then the previous Menu Mode is returned. Note that due to recent changes to the menu set architecture (8.0+), this function now takes a menu set as a parameter instead of a label. ", 
        "flags": {}
    }, 
    "setNodeTypeFlag": {
        "description": "This command sets static data on the specified node type. This will affect the class of node type as a whole. The argument passed may be the name of the node type or the node type tag. Node type tags may be found using the objectType command. ", 
        "flags": {
            "display": {
                "docstring": "Sets whether the node type will appear in the UI or not. Setting display to false will cause the node type to not appear in the UI."
            }, 
            "query": {
                "docstring": ""
            }, 
            "threadSafe": {
                "docstring": "Sets whether the node type will evaluate in parallel when using the parallel DG evaluation option in Viewport 2.0. In query mode returns true if the node type will evaluate in parallel when using the parallel DG evaluation option in Viewport 2.0.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "setParent": {
        "description": "This command changes the default parent to be the specified parent. Two special parents are \"/\" which indicates the top of the hierarchy, or \"..\" which indicates one level up in the hierarchy. Trying to move above the top level has no effect. A control must be parented to a control layout. A control layout may be parented to another control layout or a window. A menu may be parented to a window or a menu bar layout. For all of these cases the setParentcommand (with no flags) will indicate the current default parent. A menu item must be parented to a menu. To specify the default menu parent use the command setParent -m/menu. Note that all menu item objects created using the -sm/subMenumay also be treated as menu objects. The default parent is ignored by any object that explicitly sets the -p/parentflag when it is created. ", 
        "flags": {
            "defineTemplate": {
                "docstring": "Put a command in a mode where any other flags and args are parsed and added to the command template with the given name. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "menu": {
                "docstring": "Parent menu for menu items."
            }, 
            "query": {
                "docstring": ""
            }, 
            "topLevel": {
                "docstring": "Move to the top level in the hierarchy. Equivalent to use \"/\""
            }, 
            "upLevel": {
                "docstring": "Move up one level in the hierarchy. Equivalent to use \"..\""
            }, 
            "useTemplate": {
                "docstring": "Will force the command to use a command template given by the name other than the current one.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "setParticleAttr": {
        "description": "This action will set the value of the chosen attribute for every particle or selected component in the selected or passed particle object. Components should not be passed to the command line. For setting the values of components, the components must be selected and only the particle object's names should be passed to this action. If the attribute is a vector attribute and the -vv flag is passed, then the three floats passed will be used to set the values. If the attribute is a vector and the -fv flag is pass and the -vv flag is not passed, then the float will be repeated for each of the X, Y, and Z values of the attribute. Similarly, if the attribute is a float attribute and a vector value is passed, then the length of the vector passed will be used for the value. Note: The attribute passed must be a Per-Particle attribute. ", 
        "flags": {
            "attribute": {
                "docstring": "Tells the action which attribute you want to set"
            }, 
            "floatValue": {
                "docstring": "Tells what you want the value to be set to of a float attribute"
            }, 
            "object": {
                "docstring": "If this flag is passed and the STRING is the name of a particle object's transform or shape, then ONLY that object will be edited, ignoring the selection list or command line, and ALL of its particles' values will be changed for the specified attribute.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "randomFloat": {
                "docstring": "Tells the command to add a random value from -FLOAT to +FLOAT to the results of each particle. The default is 0.0."
            }, 
            "randomVector": {
                "docstring": "Tells the command to add a random value from -x,-y,-zto x,y,zto the results of each particle. The default 0 0 0."
            }, 
            "relative": {
                "docstring": "If this is set to TRUE (the default is FALSE), then the float or vector value will be added to the current value for each particle."
            }, 
            "vectorValue": {
                "docstring": "Tells what you want the value to be set to of a vector attribute"
            }
        }
    }, 
    "setRenderPassType": {
        "description": "This command will set the passID of a renderPass node and create the custom attributes specified by the corresponding render pass definition. If the render pass node already has a passID assigned to it, attributes that are no longer required become hidden, and new attributes are unhidden and/or created as needed. This allows passIDs to be changed back and forth without losing attribute data. It also allows common attributes to be transported from one render pass type to another. ", 
        "flags": {
            "defaultDataType": {
                "docstring": "If set, the render pass will use its default data type."
            }, 
            "numChannels": {
                "docstring": "Specify the number of channels to use in the render pass. Note that this flag is only valid if there is an implementation supporting the requested number of channels.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "type": {
                "docstring": "Specify the pass type to assign to the pass node(s)."
            }
        }
    }, 
    "setStartupMessage": {
        "description": "Update the startup window message. Also know as the 'Splash Screen', this is the window that appears while the application is starting up. ", 
        "flags": {}
    }, 
    "setToolTo": {
        "description": "This command switches control to the named context. ", 
        "flags": {}
    }, 
    "setUITemplate": {
        "description": "This command sets the current(default) command template for the ELF commands. The special name NONE can be used to set no templates current. See \"uiTemplate\" command also. ", 
        "flags": {
            "popTemplate": {
                "docstring": "Pop the current template off of the stack and sets the next template on the stack to be current.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pushTemplate": {
                "docstring": "Push the current template onto a stack that can later be popped."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "setXformManip": {
        "description": "This command changes some of the settings of the xform manip, to control its appearance. In query mode, return type is based on queried flag.", 
        "flags": {
            "query": {
                "docstring": ""
            }, 
            "showUnits": {
                "docstring": "If set to true, the xform manip displays current units; otherwise, the manip hides them.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "suppress": {
                "docstring": "If set to true, the xform manip is suppressed and therefore not visible or usable."
            }, 
            "useRotatePivot": {
                "docstring": "If set to true, the xform manip uses the rotate pivot; otherwise, the manip uses the bounding-box center. Defaults false."
            }, 
            "worldSpace": {
                "docstring": "If set to true, the xform manip is always in world space. If false, the manip is in object space. (Note: when multiple objects are selected the manip is always in world space, no matter what this is set to)"
            }
        }
    }, 
    "sets": {
        "description": "This command is used to create a set, query some state of a set, or perform operations to update the membership of a set. A set is a logical grouping of an arbitrary collection of objects, attributes, or components of objects. Sets are dependency nodes. Connections from objects to a set define membership in the set. Sets are used throughout Maya in a multitude of ways. They are used to define an association of material properties to objects, to define an association of lights to objects, to define a bookmark or named collection of objects, to define a character, and to define the components to be deformed by some deformation operation. Sets can be connected to any number of partitions. A partition is a node which enforces mutual exclusivity amoung the sets in the partition. That is, if an object is in a set which is in a partition, that object cannot be a member of any other set that is in the partition. Without any flags, the setscommand will create a set with a default name of \"set#\" (where # is an integer). If no items are specified on the command line, the currently selected items are added to the set. The -em/empty flag can be used to create an empty set and not have the selected items added to the set. Sets can be created to have certain restrictions on membership. There can be \"renderable\" sets which only allow renderable objects (such as nurbs geometry or polymesh faces) to be members of the set. There can also be vertex (or control point), edit point, edge, or face sets which only allow those types of components to be members of a set. Note that for these sets, if an object with a valid type of component is to be added to a set, the components of the object are added to the set instead. Sets can have an associated color which is only of use when creating vertex sets. The color can be one of the eight user defined colors defined in the color preferences. This color can be used, for example to distinguish which vertices are being deformed by a particular deformation. Objects, components, or attributes can be added to a set using one of three flags. The -add/addElement flag will add the objects to a set as long as this won't break any mutual exclusivity constraints. If there are any items which can't be added, the command will fail. The -in/include flag will only add those items which can be added and warn of those which can't. The -fe/forceElement flag will add all the items to the set but will also remove any of those items that are in any other set which is in the same partition as the set. There are several operations on sets that can be performed with the setscommand. Membership can be queried. Tests for whether an item is in a set or whether two sets share the same item can be performed. Also, the union, intersection and difference of sets can be performed which returns a list of members of the sets which are a result of the operation. ", 
        "flags": {
            "addElement": {
                "docstring": "Adds the list of items to the given set. If some of the items cannot be added to the set because they are in another set which is in the same partition as the set to edit, the command will fail."
            }, 
            "afterFilters": {
                "docstring": "Default state is false. This flag is valid in edit mode only. This flag is for use on sets that are acted on by deformers such as sculpt, lattice, blendShape. The default edit mode is to edit the membership of the group acted on by the deformer. If you want to edit the group but not change the membership of the deformer, set the flag to true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "clear": {
                "docstring": "An operation which removes all items from the given set making the set empty."
            }, 
            "color": {
                "docstring": "Defines the hilite color of the set. Must be a value in range [-1, 7] (one of the user defined colors). -1 marks the color has being undefined and therefore not having any affect. Only the vertices of a vertex set will be displayed in this color."
            }, 
            "copy": {
                "docstring": "Copies the members of the given set to a new set. This flag is for use in creation mode only."
            }, 
            "edges": {
                "docstring": "Indicates the new set can contain edges only. This flag is for use in creation or query mode only. The default value is false."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editPoints": {
                "docstring": "Indicates the new set can contain editPoints only. This flag is for use in creation or query mode only. The default value is false."
            }, 
            "empty": {
                "docstring": "Indicates that the set to be created should be empty. That is, it ignores any arguments identifying objects to be added to the set. This flag is only valid for operations that create a new set."
            }, 
            "facets": {
                "docstring": "Indicates the new set can contain facets only. This flag is for use in creation or query mode only. The default value is false."
            }, 
            "flatten": {
                "docstring": "An operation that flattens the structure of the given set. That is, any sets contained by the given set will be replaced by its members so that the set no longer contains other sets but contains the other sets' members."
            }, 
            "forceElement": {
                "docstring": "For use in edit mode only. Forces addition of the items to the set. If the items are in another set which is in the same partition as the given set, the items will be removed from the other set in order to keep the sets in the partition mutually exclusive with respect to membership."
            }, 
            "include": {
                "docstring": "Adds the list of items to the given set. If some of the items cannot be added to the set, a warning will be issued. This is a less strict version of the -add/addElement operation."
            }, 
            "intersection": {
                "docstring": "An operation that returns a list of items which are members of all the sets in the list."
            }, 
            "isIntersecting": {
                "docstring": "An operation which tests whether the sets in the list have common members."
            }, 
            "isMember": {
                "docstring": "An operation which tests whether all the given items are members of the given set."
            }, 
            "layer": {
                "docstring": "OBSOLETE. DO NOT USE."
            }, 
            "name": {
                "docstring": "Assigns string as the name for a new set. This flag is only valid for operations that create a new set."
            }, 
            "noSurfaceShader": {
                "docstring": "If set is renderable, do not connect it to the default surface shader. Flag has no meaning or effect for non renderable sets. This flag is for use in creation mode only. The default value is false."
            }, 
            "noWarnings": {
                "docstring": "Indicates that warning messages should not be reported such as when trying to add an invalid item to a set. (used by UI)"
            }, 
            "nodesOnly": {
                "docstring": "This flag is usable with the -q/query flag but is ignored if used with another queryable flags. This flag modifies the results of the set membership query such that when there are attributes (e.g. sphere1.tx) or components of nodes included in the set, only the nodes will be listed. Each node will only be listed once, even if more than one attribute or component of the node exists in the set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Removes the list of items from the given set."
            }, 
            "renderable": {
                "docstring": "This flag indicates that a special type of set should be created. This type of set (shadingEngine as opposed to objectSet) has certain restrictions on its membership in that it can only contain renderable elements such as lights and geometry. These sets are referred to as shading groups and are automatically connected to the \"renderPartition\" node when created (to ensure mutual exclusivity of the set's members with the other sets in the partition). This flag is for use in creation or query mode only. The default value is false which means a normal set is created."
            }, 
            "size": {
                "docstring": "Use the size flag to query the length of the set."
            }, 
            "split": {
                "docstring": "Produces a new set with the list of items and removes each item in the list of items from the given set."
            }, 
            "subtract": {
                "docstring": "An operation between two sets which returns the members of the first set that are not in the second set."
            }, 
            "text": {
                "docstring": "Defines an annotation string to be stored with the set."
            }, 
            "union": {
                "docstring": "An operation that returns a list of all the members of all sets listed."
            }, 
            "vertices": {
                "docstring": "Indicates the new set can contain vertices only. This flag is for use in creation or query mode only. The default value is false."
            }
        }
    }, 
    "shadingConnection": {
        "description": "Sets the connection state of a connection between nodes that are used in shading. Specify the destination attribute of the connection. In query mode, return type is based on queried flag.", 
        "flags": {
            "connectionState": {
                "docstring": "Specifies the state of the connection.On/True/1 means the connection is still active.Off/False/0 means the connection is inactive.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "shadingGeometryRelCtx": {
        "description": "This command creates a context that can be used for associating geometry to shading groups. You can put the context into shading-centric mode by using the -shadingCentric flag and specifying true. This means that the shading group is selected first then geometry associated with the shading group are highlighted. Subsequent selections result in assignments. Specifying -shadingCentric false means that the geometry is to be selected first. The shading group associated with the geometry will then be selected and subsequent selections will result in assignments being made. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "offCommand": {
                "docstring": "command to be issued when context is turned onFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "onCommand": {
                "docstring": "command to be issued when context is turned on"
            }, 
            "query": {
                "docstring": ""
            }, 
            "shadingCentric": {
                "docstring": "shading-centric mode."
            }
        }
    }, 
    "shadingLightRelCtx": {
        "description": "This command creates a context that can be used for associating lights to shading groups. You can put the context into shading-centric mode by using the -shadingCentric flag and specifying true. This means that the shading group is selected first then lights associated with the shading group are highlighted. Subsequent selections result in assignments. Specifying -shadingCentric false means that the light is to be selected first. The shading groups associated with the light will then be selected and subsequent selections will result in assignments being made. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "offCommand": {
                "docstring": "command to be issued when context is turned onFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "onCommand": {
                "docstring": "command to be issued when context is turned on"
            }, 
            "query": {
                "docstring": ""
            }, 
            "shadingCentric": {
                "docstring": "shading-centric mode."
            }
        }
    }, 
    "shadingNetworkCompare": {
        "description": "This command allows you to compare two shading networks. ", 
        "flags": {
            "byName": {
                "docstring": "Indicates whether the comparison should consider node names. If true, two shading networks will be considered equivalent only if the names of corresponding nodes are the same, ignoring namespaces. If false, two shading networks will be considered equivalent even if corresponding nodes are named differently. Default is 'false'."
            }, 
            "byValue": {
                "docstring": "Indicates whether the comparison should consider the values of unconnected attributes. If true, two shading networks will be considered equivalent only if corresponding, unconnected attributes are the same type and have the same value. Only attributes of type 'int', 'bool', 'float', and 'string' will have their values compared. If false, two shading networks will be considered equivalent even if corresponding, unconnected attributes have different values or are different types. Default is 'true'."
            }, 
            "delete": {
                "docstring": "Deletes the specified comparison from memory.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "equivalent": {
                "docstring": "Returns an int. 1 if the shading networks in the specified comparison are equivalent. 0 otherwise."
            }, 
            "network1": {
                "docstring": "Returns a string[]. Returns an empty string array if the shading networks in the specified comparison are not equivalent. Otherwise returns the nodes in the first shading network."
            }, 
            "network2": {
                "docstring": "Returns a string[]. Returns an empty string array if the shading networks in the specified comparison are not equivalent. Otherwise returns the nodes in the second shading network."
            }, 
            "query": {
                "docstring": ""
            }, 
            "upstreamOnly": {
                "docstring": "Indicates whether the comparison should consider nodes which are connected downstream from shading network nodes. If true, only those nodes which are upstream from the shading group will be considered. If, following only downstream connections, there is no connection path from a node to one of the shader attributes on the shading group, the node will not be considered. If false, a node will be considered if a connection path can found, following either upstream or downstream connections, which terminates with an input connection to one of the shading groups shader attributes. These dangling nodes do not directly contribute to the color, displacement, or volume characteristics of the shading group. Default is 'false'."
            }
        }
    }, 
    "shadingNode": {
        "description": "The shadingNode command classifies any DG node as a shader, texture light, post process, or utility so that it can be properly organized in the multi-lister. Recall that any DG node can be used a part of a a shader, texture or light - regardless of how it is classified by this. command. These classifications are provided for convenience in the UI. ", 
        "flags": {
            "asLight": {
                "docstring": "classify the current DG node as a light"
            }, 
            "asPostProcess": {
                "docstring": "classify the current DG node as a post process"
            }, 
            "asRendering": {
                "docstring": "classify the current DG node as a rendering nodeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "asShader": {
                "docstring": "classify the current DG node as a shader"
            }, 
            "asTexture": {
                "docstring": "classify the current DG node as a texture"
            }, 
            "asUtility": {
                "docstring": "classify the current DG node as a utility"
            }, 
            "name": {
                "docstring": "Sets the name of the newly-created node."
            }, 
            "parent": {
                "docstring": "Specifies the parent in the DAG under which the new node belongs."
            }, 
            "shared": {
                "docstring": ""
            }, 
            "skipSelect": {
                "docstring": ""
            }
        }
    }, 
    "shapeCompare": {
        "description": "Compares two shapes. If no shapes are specified in the command line, then the shapes from the active list are used. ", 
        "flags": {}
    }, 
    "shelfButton": {
        "description": "This control supports up to 3 icon images and 4 different display styles. The icon image displayed is the one that best fits the current size of the control given its current style. This command creates an iconTextButtonthat is designed to be on the shelf. The button contains a command that can be drag'n'dropped. ", 
        "flags": {
            "actionIsSubstitute": {
                "docstring": ""
            }, 
            "align": {
                "docstring": "The label alignment. Alignment values are \"left\", \"right\", and \"center\". By default, the label is aligned \"center\". Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "command": {
                "docstring": "Command executed when the control is pressed."
            }, 
            "commandRepeatable": {
                "docstring": "Set if the MEL command specified in the command flag should be repeatable or not. The \"g\" key, by default, is the shortcut to repeat the last executed command.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "disabledImage": {
                "docstring": "Image used when the button is disabled. Image size must be the same as the image specified with the i/imageflag. This is a Windows only flag."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "doubleClickCommand": {
                "docstring": "Command executed when the control is double clicked."
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enableCommandRepeat": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "font": {
                "docstring": "The font for the text. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\"."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "handleNodeDropCallback": {
                "docstring": "Specify a script callback which is called when a node is dropped on the control. The name of the node being dropped will be passed to the function (python callable) or appended to the end (script) to form the command to be executed."
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "highlightImage": {
                "docstring": "Highlight image displayed while the cursor is over the control. Image size must be the same as the image specified with the -i/imageflag. This is a Windows only flag."
            }, 
            "image": {
                "docstring": "If you are not providing images with different sizes then you may use this flag for the control's image. If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "This control supports three icons. The icon that best fits the current size of the control will be displayed."
            }, 
            "imageOverlayLabel": {
                "docstring": "A short string, up to 5 characters, representing a label that will be displayed on top of the image."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The text that appears in the control."
            }, 
            "labelEditingCallback": {
                "docstring": "Specify a callback which is called after the user double clicks the label of the control to give it a new label. The new label string will be passed to the callback."
            }, 
            "labelOffset": {
                "docstring": "The label offset. Default is 0. Currently only available when -st/style is set to \"iconAndTextCentered\"."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "marginHeight": {
                "docstring": "The number of pixels above and below the control content. The default value is 1 pixel."
            }, 
            "marginWidth": {
                "docstring": "The number of pixels on either side of the control content. The default value is 1 pixel."
            }, 
            "menuItem": {
                "docstring": ""
            }, 
            "menuItemPython": {
                "docstring": ""
            }, 
            "noDefaultPopup": {
                "docstring": ""
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "overlayLabelBackColor": {
                "docstring": "The RGBA color of the shadow behind the label defined by imageOverlayLabel. Default is 25% transparent black: 0 0 0 .25"
            }, 
            "overlayLabelColor": {
                "docstring": "The RGB color of the label defined by imageOverlayLabel. Default is a light grey: .8 .8 .8"
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectionImage": {
                "docstring": "Image displayed while the control is selected. Image size must be the same as the image specified with the -i/imageflag. This is a Windows only flag."
            }, 
            "sourceType": {
                "docstring": "Sets the language type for the command script. Can only be used in conjunction with the c/command or dcc/doubleClickCommand flags. Valid values are \"mel\" (enabled by default), and \"python\"."
            }, 
            "style": {
                "docstring": "The draw style of the control. Valid styles are \"iconOnly\", \"textOnly\", \"iconAndTextHorizontal\", \"iconAndTextVertical\", and \"iconAndTextCentered\". (Note: \"iconAndTextCentered\" is only available on Windows). If the \"iconOnly\" style is set, the icon will be scaled to the size of the control."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "shelfLayout": {
        "description": "This command creates a new empty shelf layout. The shelf layout can accept drops of commands scripts. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "cellHeight": {
                "docstring": "Set or query the height of the items in the shelf."
            }, 
            "cellWidth": {
                "docstring": "Set or query the width of the items in the shelf."
            }, 
            "cellWidthHeight": {
                "docstring": "Set the width and height of the items in the shelf."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "position": {
                "docstring": "Specify the name of a child control in the grid layout along with a 1-based integer value indicating the desired position of the child. Positions increase from left to right within a row and then wrap around to the next row increasing from top to bottom. For example, a grid layout with 3 columns and 2 rows has 6 visible positions where 1, 2 and 3 occupy the first row and 4, 5 and 6 occupy the second.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "style": {
                "docstring": "Set or query the current style of the items in the shelf. Valid styles are \"iconOnly\", \"textOnly\", \"iconAndTextHorizontal\" and \"iconAndTextVertical\"."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "shelfTabLayout": {
        "description": "This command creates/edits/queries a shelf tab group which is essentially a normal tabLayout with some drop behaviour in the tab bar. A garbage can icon can appear in the top right corner to dispose of buttons dragged to it from shelves. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when a tab is selected interactively. This command is only invoked when the selected tab changes. Re-selecting the current tab will not invoke this command."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "childResizable": {
                "docstring": "Set to true if you want the child of the control layout to be as wide as the scroll area. You may also indicate a minimum width for the child using the -mcw/minChildWidthflag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "doubleClickCommand": {
                "docstring": "Command executed when a tab is double clicked on. Note that the first click will select the tab and the second click will execute the double click command. Double clicking the current tab will re-invoke the double click command."
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "horizontalScrollBarThickness": {
                "docstring": "Thickness of the horizontal scroll bar. Specify an integer value greater than or equal to zero. This flag has no effect on Windows systems."
            }, 
            "image": {
                "docstring": "Image appearing in top right corner of tab layout."
            }, 
            "imageVisible": {
                "docstring": "Visibility of tab image."
            }, 
            "innerMarginHeight": {
                "docstring": "Margin height for all tab children."
            }, 
            "innerMarginWidth": {
                "docstring": "Margin width for all tab children."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "minChildWidth": {
                "docstring": "Specify a positive non-zero integer value indicating the minimum width the tab layout's children. This flag only has meaning when the -cr/childResizableflag is set to true."
            }, 
            "moveTab": {
                "docstring": "Move the tab from the current index to a new index.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preSelectCommand": {
                "docstring": "Command executed when a tab is selected but before it's contents become visible. Re-selecting the current tab will not invoke this command. Note that this command is not executed by using either of the -st/selectTabor -sti/selectTabIndexflags."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scrollable": {
                "docstring": "Puts all children of this layout within a scroll area."
            }, 
            "selectCommand": {
                "docstring": "Command executed when a tab is selected interactively This command will be invoked whenever a tab is selected, ie. re-selecting the current tab will invoke this command. Note that this command is not executed by using either of the -st/selectTabor -sti/selectTabIndexflags."
            }, 
            "selectTab": {
                "docstring": "The name, in short form, of the selected tab. An empty string is returned on query if there are no child tabs."
            }, 
            "selectTabIndex": {
                "docstring": "Identical to the -st/selectTabflag except this flag takes a 1-based index to identify the selected tab. A value of 0 is returned on query if there are not child tabs."
            }, 
            "tabLabel": {
                "docstring": "Set a tab label. The first argument is the name of a control that must be a child of the tab layout. The second argument is the label for the tab associated with that child. If this flag is queried then the tab labels for all the children are returned."
            }, 
            "tabLabelIndex": {
                "docstring": "Identical to the -tl/tabLabelflag except this flag takes a 1-based index to identify the tab you want to set the label for. If this flag is queried the tab labels for all the children are returned."
            }, 
            "tabsVisible": {
                "docstring": "Visibility of the tab labels."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "verticalScrollBarThickness": {
                "docstring": "Thickness of the vertical scroll bar. Specify an integer value greater than or equal to zero. This flag has no effect on Windows systems."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "shot": {
        "description": "Use this command to create a shot node or manipulate that node. ", 
        "flags": {
            "audio": {
                "docstring": "Specify the audio clip for this shot. Audio can be linked to a shot to allow playback of specific sounds when that shot is being displayed in the Sequencer. Refer to the shot node's documentation for details on how audio is used by shots and the Sequencer."
            }, 
            "clip": {
                "docstring": "The clip associated with this shot. This clip will be posted to the currentCamera's imagePlane. Refer to the shot node's documentation for details on how cameras are used by shots and the Sequencer."
            }, 
            "clipDuration": {
                "docstring": "Length of clip. This is used for the display of the clip indicator bar in the Sequencer."
            }, 
            "clipOpacity": {
                "docstring": "Opacity for the shot's clip, this value is assigned to the currentCamera's imagePlane. Refer to the shot node's documentation for details on how cameras are used by shots and the Sequencer."
            }, 
            "clipSyncState": {
                "docstring": "The viewport synchronization status of the clip associated with this shot. Return values are, 0 = no clip associated with this shot 1 = clip is fully in sync with viewport, and frames are 1:1 with sequencer 2 = clip is partially in sync with viewport, movie may be scaled to match sequencer 3 = clip not in sync with viewport (i.e. could have scale/time/camera differences)"
            }, 
            "clipZeroOffset": {
                "docstring": "Specify which time of the clip corresponds to the beginning of the shot. This is used to properly align splitted clips."
            }, 
            "copy": {
                "docstring": "This flag is used to copy a shot to the clipboard. In query mode, this flag allows you to query what, if anything, has been copied into the shot clipboard."
            }, 
            "currentCamera": {
                "docstring": "The camera associated with this shot. Refer to the shot node's documentation for details on how cameras are used by shots and the Sequencer."
            }, 
            "determineTrack": {
                "docstring": "Determines an available track for the shot. Returns a new track number or the existing track number if the current track is available.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endTime": {
                "docstring": "The shot end time in the Maya timeline. Changing the startTime will extend the duration of a shot."
            }, 
            "favorite": {
                "docstring": "Make the shot a favorite. This is a UI indicator only to streamline navigation in the Sequencer panel"
            }, 
            "linkAudio": {
                "docstring": "Specify an audio clip to link to this shot. Any currently linked audio will be unlinked."
            }, 
            "lock": {
                "docstring": "Lock a specific shot. This is different than locking an entire track, which is done via the shotTrack command"
            }, 
            "mute": {
                "docstring": "Mute a specific shot. This is different than muting an entire track, which is done via the shotTrack command"
            }, 
            "paste": {
                "docstring": "This flag is used to paste a shot or shots from the clipboard to the sequence timeline. Shots are added to the clipboard using the c/copy flag."
            }, 
            "pasteInstance": {
                "docstring": "This flag is used to paste an instance of a shot or shots from the clipboard to the sequence timeline. Unlike the p/paste flag, which duplicates the camera and image plane from the original source shot, the pi/pasteInstance flag shares the camera and image plane from the source shot. The audio node is duplicated."
            }, 
            "postHoldTime": {
                "docstring": "Specify the time length to append to the shot in the sequence timeline. This repeats the last frame of the shot, in sequence time, over the specified duration."
            }, 
            "preHoldTime": {
                "docstring": "Specify the time length to prepend to the shot in the sequence timeline. This repeats the first frame of the shot, in sequence time, over the specified duration."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scale": {
                "docstring": "Specify an amount to scale the Maya frame range of the shot. This will affect the sequenceEndFrame, leaving the sequenceStartFrame unchanged."
            }, 
            "sequenceDuration": {
                "docstring": "Return the sequence duration of the shot, which will include the holds and scale. This flag can only be queried."
            }, 
            "sequenceEndTime": {
                "docstring": "The shot end in the sequence timeline. Changing the endTime of a shot will scale it in sequence time."
            }, 
            "sequenceStartTime": {
                "docstring": "The shot start in the sequence timeline. Changing the startTime of a shot will shift it in sequence time."
            }, 
            "shotName": {
                "docstring": "Specify a user-defined name for this shot. This allows the assignment of names that are not valid as node names within Maya. Whenever the shotName attribute is defined its value is used in the UI."
            }, 
            "sourceDuration": {
                "docstring": "Return the number of source frames in the shot. This flag can only be queried."
            }, 
            "startTime": {
                "docstring": "The shot start time in the Maya timeline. Changing the startTime will extend the duration of a shot."
            }, 
            "track": {
                "docstring": "Specify the track in which this shot resides."
            }, 
            "unlinkAudio": {
                "docstring": "COMMENT Unlinks any currently linked audio."
            }
        }
    }, 
    "shotRipple": {
        "description": "When Ripple Edit Mode is enabled, neighboring shots to the shot that gets manipulated are moved in sequence time to either make way or close up gaps corresponding to that node's editing. Given some parameters about the shot edit that just took place, this command will choose which other shots to move, and move them the appropriate amounts If no shot name is provided, the command will attempt to use the first selected shot. In query mode, return type is based on queried flag.", 
        "flags": {
            "deleted": {
                "docstring": "Specify whether this ripple edit is due to a shot deletionFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endDelta": {
                "docstring": "Specify the change in the end time in frames"
            }, 
            "endTime": {
                "docstring": "Specify the initial shot end time in the sequence timeline."
            }, 
            "query": {
                "docstring": ""
            }, 
            "startDelta": {
                "docstring": "Specify the change in the start time in frames"
            }, 
            "startTime": {
                "docstring": "Specify the initial shot start time in the sequence timeline."
            }
        }
    }, 
    "shotTrack": {
        "description": "This command is used for inserting and removing tracks related to the shots displayed in the Sequencer. It can also be used to modify the track state, for example, to lock or mute a track. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "insertTrack": {
                "docstring": "This flag is used to insert a new empty track at the track index specified."
            }, 
            "lock": {
                "docstring": "This flag specifies whether shots on a track are to be locked or not."
            }, 
            "mute": {
                "docstring": "This flag specifies whether shots on a track are to be muted or not."
            }, 
            "numTracks": {
                "docstring": "To query the number of tracksFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeEmptyTracks": {
                "docstring": "This flag is used to remove all tracks that have no clips."
            }, 
            "removeTrack": {
                "docstring": "This flag is used to remove the track with the specified index. The track must have no clips on it before it can be removed."
            }, 
            "solo": {
                "docstring": "This flag specifies whether shots on a track are to be soloed or not."
            }, 
            "swapTracks": {
                "docstring": "This flag is used to swap the contents of two specified tracks."
            }
        }
    }, 
    "showHelp": {
        "description": "Invokes a web browser to open the on-line documentation and help files. It will open the help page for a given topic, or open a browser to a specific URL. In query mode, return type is based on queried flag.", 
        "flags": {
            "absolute": {
                "docstring": "The specified \"URL\" is an absolute URL that should be passed directly to the web browser."
            }, 
            "docs": {
                "docstring": "Use this flag to directly specify a help file relative to the on-line documentation root."
            }, 
            "helpTable": {
                "docstring": "Use this flag to specify which file will be used to search for help topics when the -d/docs and -a/absolute flags are not used. If only a file name is specified and not a path, then the file is assumed to be in the maya application directory.If this flag does not accept an argument if it is queried.The default value is \"helpTable\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "showHidden": {
        "description": "The showHiddencommand is used to make invisible objects visible. If no flags are specified, only the objects given to the command will be made visible. If a parent of an object is invisible, the object will still be invisible. Invisibility is inherited. To ensure the object becomes visible, use the -a/above flag. This forces all invisible ancestors of the object(s) to be visible. If the -b/below flag is used, any invisible objects below the object will be made visible. To make all objects visible, use the -all/allObjects flag. See also:hide ", 
        "flags": {
            "above": {
                "docstring": "make objects and all their invisible ancestors visible"
            }, 
            "allObjects": {
                "docstring": "make all invisible objects visible"
            }, 
            "below": {
                "docstring": "make objects and all their invisible decendents visibleFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "showManipCtx": {
        "description": "This command can be used to create a show manip context. The show manip context will display manips for all selected objects that have valid manips defined for them. ", 
        "flags": {
            "currentNodeName": {
                "docstring": "Returns the name of the first node that the context is attached to.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "incSnap": {
                "docstring": "If true, the manipulator owned by the context will use incremental snapping for specified mode."
            }, 
            "incSnapRelative": {
                "docstring": "If true, the manipulator owned by the context will use relative incremental snapping for specified mode."
            }, 
            "incSnapUI": {
                "docstring": "Returns an array of elements indicating what kind of incremental snap UI is required by the manipulator owned by the context. If no UI is required, the result array will contain a single element of with the value 0. The other values and their meanings are: 1 - UI for linear incremental translate2 - UI for incremental rotate3 - UI for inclremental scale"
            }, 
            "incSnapValue": {
                "docstring": "Supply the step value which the manipulator owned by the context will use for specified mode."
            }, 
            "lockSelection": {
                "docstring": "If true, this context will never change the current selection. By default this is set to false."
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "toggleIncSnap": {
                "docstring": "Toggles (enables/disables) snapping for all modes."
            }, 
            "toolFinish": {
                "docstring": "Supply the script that will be run when the user exits the script."
            }, 
            "toolStart": {
                "docstring": "Supply the script that will be run when the user first enters the script"
            }
        }
    }, 
    "showSelectionInTitle": {
        "description": "This command causes the title of the window specified as an argument to be linked to the current file and selection. When selection changes, the window title will change to show the current file name and the name of the last selected object. ", 
        "flags": {}
    }, 
    "showShadingGroupAttrEditor": {
        "description": "The showShadingGroupAttrEditor command opens up the attribute editor for the current object's shading-group information. ", 
        "flags": {
            "query": {
                "docstring": ""
            }
        }
    }, 
    "showWindow": {
        "description": "Make a window visible. If no window is specified then the current window (most recently created) is used. See also the windowcommand's vis/visibleflag. If the specified window is iconified, it will be opened. ", 
        "flags": {}
    }, 
    "simplify": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.This command will simplify (reduce the number of keyframes) an animation curve. ", 
        "flags": {
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "floatTolerance": {
                "docstring": "Specify the x-axis tolerance (defaults to 0.05) for float-input animCurves such as those created by \"Set Driven Keyframe\". This flag is ignored on animCurves driven by time. Higher floatTolerance values will result in sparser keys which may less accurately represent the initial curve."
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }, 
            "timeTolerance": {
                "docstring": "Specify the x-axis tolerance (defaults to 0.05 seconds) for time-input animCurves. This flag is ignored on animCurves driven by floats. Higher time tolerance values will result in sparser keys which may less accurately represent the initial curve."
            }, 
            "valueTolerance": {
                "docstring": "Specify the value tolerance (defaults to 0.01)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "singleProfileBirailSurface": {
        "description": "This cmd creates a railed surface by sweeping the profile curve along the two rail curves. One of the requirements for surface creation is the profile curve must intersect the two rail curves. If the profile is a surface curve i.e. isoparm, curve on surface or trimmed edge then tangent continuity across the surface underlying the profile may be enabled using the flag -tp1 true. The first argument represetns the profile curve, the second and third the rails. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "tangentContinuityProfile1": {
                "docstring": "Need to be tangent continuous across the profile. The profile must be a surface curve.Default:false"
            }, 
            "transformMode": {
                "docstring": "transform mode ( Non proportional, proportional ). Non proportional is default value.Default:0Advanced flags"
            }
        }
    }, 
    "skinBindCtx": {
        "description": "This command creates a tool that can be used to edit volumes from an interactive bind. ", 
        "flags": {
            "about": {
                "docstring": "The space in which the axis should be mirrored. Valid values are: \"world\" and \"object\"."
            }, 
            "axis": {
                "docstring": "The mirror axis. Valid values are: \"x\",\"y\", and \"z\"."
            }, 
            "colorRamp": {
                "docstring": "Set the values on the color ramp used to display the weight values."
            }, 
            "currentInfluence": {
                "docstring": "Set the index of the current influence or volume to be adjusted by the manipulator."
            }, 
            "displayInactiveMode": {
                "docstring": "Determines the display mode for drawing volumes that are not selected, in particular which volume cages if any are displayed. 0 - None 1 - Nearby volumes 2 - All volumes"
            }, 
            "displayNormalized": {
                "docstring": "Display raw select weights (false) or finalized normalized weights (true)."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "falloffCurve": {
                "docstring": "Set the values on the falloff curve control."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }, 
            "symmetry": {
                "docstring": "Controls whether or not the tool operates in symmetric (mirrored) mode."
            }, 
            "tolerance": {
                "docstring": "The tolerance setting for determining whether another influence is symmetric to the the current influence.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "skinCluster": {
        "description": "The skinCluster command is used for smooth skinning in maya. It binds the selected geometry to the selected joints or skeleton by means of a skinCluster node. Each point of the bound geometry can be affected by any number of joints. The extent to which each joint affects the motion of each point is regulated by a corresponding weight factor. Weight factors can be modified using the skinPercent command. The command returns the name of the new skinCluster.The skinCluster binds only a single geometry at a time. Thus, to bind multiple geometries, multiple skinCluster commands must be issued.Upon creation of a new skinCluster, the command can be used to add and remove transforms (not necessarily joints) that influence the motion of the bound skin points.The skinCluster command can also be used to adjust parameters such as the dropoff, nurbs samples, polygon smoothness on a particular influence object. Note: Any custom weights on a skin point that the influence object affects will be lost after adjusting these parameters. ", 
        "flags": {
            "addInfluence": {
                "docstring": "The specified transform or joint will be added to the list of transforms that influence the bound geometry. The maximum number of influences will be observed and only the weights of the cv's that the specified transform effects will change. This flag is multi-use."
            }, 
            "addToSelection": {
                "docstring": "When used in conjunction with the selectInfluenceVerts flag, causes the vertices afftected by the influence to be added to the current selection, without first de-selecting other vertices."
            }, 
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "baseShape": {
                "docstring": "This flag can be used in conjunction with the -addInfluence flag to specify the shape that will be used as the base shape when an influence object with geometry is added to the skinCluster. If the flag is not used then the command will make a copy of the influence object's shape and use that as a base shape."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "bindMethod": {
                "docstring": "This flag sets the binding method. 0 - Closest distance between a joint and a point of the geometry. 1 - Closest distance between a joint, considering the skeleton hierarchy, and a point of the geometry. 2 - Surface heat map diffusion."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "dropoffRate": {
                "docstring": "Sets the rate at which the influence of a transform drops as the distance from that transform increases. The valid range is between 0.1 and 10.0. In Create mode it sets the dropoff rate for all the bound joints. In Edit mode the flag is used together with the inf/influence flag to set the dropoff rate of a particular influence. Note: When the flag is used in Edit mode, any custom weights on the skin points the given transform influences will be lost."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "forceNormalizeWeights": {
                "docstring": "If the normalization mode is none or post, it is possible (indeed likely) for the weights in the skin cluster to no longer add up to 1. This flag forces all weights to add back to 1 again."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "heatmapFalloff": {
                "docstring": "This flag sets the the heatmap binding falloff. If set to 0.0 (default) the deformation will be smoother due to many small weights spread over the mesh surface per influence. However, if set to 1.0, corresponding to maximum falloff, the number of influences per point will be reduced and points will tend to be greatly influenced by their closest joint decreasing the overall spread of small weights. This flag only works when using heatmap binding."
            }, 
            "ignoreBindPose": {
                "docstring": "This flag is deprecated and no longer used. It will be ignored if used."
            }, 
            "ignoreHierarchy": {
                "docstring": "Deprecated. Use bindMethod flag instead. Disregard the place of the joints in the skeleton hierarchy when computing the closest joints that influence a point of the geometry."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "influence": {
                "docstring": "This flag specifies the influence object that will be used for the current edit operation. In query mode, returns a string array of the influence objects (joints and transform). In query mode, this flag can accept a value."
            }, 
            "lockWeights": {
                "docstring": "Lock the weights of the specified influence object to their current value or to the value specified by the -weight flag."
            }, 
            "maximumInfluences": {
                "docstring": "Sets the maximum number of transforms that can influence a point (have non-zero weight for the point) when the skinCluster is first created or a new influence is added. Note: When this flag is used in Edit mode any custom weights will be lost and new weights will be reassigned to the whole skin."
            }, 
            "moveJointsMode": {
                "docstring": "If set to true, puts the skin into a mode where joints can be moved without modifying the skinning. If set to false, takes the skin out of move joints mode."
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "normalizeWeights": {
                "docstring": "This flag sets the normalization mode. 0 - none, 1 - interactive, 2 - post (default) Interactive normalization makes sure the weights on the influences add up to 1.0, always. Everytime a weight is changed, the weights are automatically normalized. This may make it difficult to perform weighting operations, as the normalization may interfere with the weights the user has set. Post normalization leaves the weights the user has set as is, and only normalizes the weights at the moment it is needed (by dividing by the sum of the weights). This makes it easier for users to weight their skins."
            }, 
            "nurbsSamples": {
                "docstring": "Sets the number of sample points that will be used along an influence curve or in each direction on an influence NURBS surface to influence the bound skin. The more the sample points the more closely the skin follows the influence NURBS curve/surface."
            }, 
            "obeyMaxInfluences": {
                "docstring": "When true, the skinCluster will continue to enforce the maximum influences each time the user modifies the weight, so that any given point is only weighted by the number of influences in the skinCluster's maximumInfluences attribute."
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "polySmoothness": {
                "docstring": "This flag controls how accurately the skin control points follow a given polygon influence object. The higher the value of polySmoothnmess the more rounded the deformation resulting from a polygonal influence object will be."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "removeFromSelection": {
                "docstring": "When used in conjunction with the selectInfluenceVerts flag, causes the vertices afftected by the influence to be removed from the current selection."
            }, 
            "removeInfluence": {
                "docstring": "Remove the specified transform or joint from the list of transforms that influence the bound geometry The weights for the affected points are renormalized. This flag is multi-use."
            }, 
            "removeUnusedInfluence": {
                "docstring": "If this flag is set to true then transform or joint whose weights are all zero (they have no effect) will not be bound to the geometry. Having this option set will help speed-up the playback of animation."
            }, 
            "selectInfluenceVerts": {
                "docstring": "Given the name of a transform, this will select the verts or control points being influenced by this transform, so users may visualize which vertices are being influenced by the transform."
            }, 
            "skinMethod": {
                "docstring": "This flag set the skinning method. 0 - classical linear skinning (default). 1 - dual quaternion (volume preserving), 2 - a weighted blend between the two."
            }, 
            "smoothWeights": {
                "docstring": "This flag is used to detect sudden jumps in skin weight values, which often indicates bad weighting, and then smooth out those jaggies in skin weights. The argument is the error tolerance ranging from 0 to 1. A value of 1 means that the algorithm will smooth a vertex only if there is a 100% change in weight values from its neighbors. The recommended default to use is 0.5 (50% change in weight value from the neighbors)."
            }, 
            "smoothWeightsMaxIterations": {
                "docstring": "This flag is valid only with the smooth weights flag. It is possible that not all the vertices detected as needing smoothing can be smoothed in 1 iteration (because all of their neighbors also have bad weighting and need to be smoothed). With more iterations, more vertices can be smoothed. This flag controls the maximum number of iterations the algorithm will attempt to smooth weights. The default is 2 for this flag."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "toSelectedBones": {
                "docstring": "geometry will be bound to the selected bones only."
            }, 
            "toSkeletonAndTransforms": {
                "docstring": "geometry will be bound to the skeleton and any transforms in the hierarchy. If any of the transforms are also bindable objects, assume that only the last object passed to the command is the bindable object. The rest are treated as influences."
            }, 
            "unbind": {
                "docstring": "Unbinds the geometry from the skinCluster and deletes the skinCluster node"
            }, 
            "unbindKeepHistory": {
                "docstring": "Unbinds the geometry from the skinCluster, but keeps the skinCluster node so that its weights can be used when the skin is rebound. To rebind, use the skinCluster command."
            }, 
            "useGeometry": {
                "docstring": "When adding an influence to a skinCluster, use the geometry parented under the influence transform to determine the weight dropoff of that influence."
            }, 
            "volumeBind": {
                "docstring": "Creates a volume bind node and attaches it to the new skin cluster node. This node holds hull geometry parameters for a volume based weighting system. This system is used in interactive skinning. The value passed will determine the minimum weight value when initializing the volume. The volume in be increase to enclose all the vertices that are above this value."
            }, 
            "volumeType": {
                "docstring": "Defines the initial shape of the binding volume (see volumeBind). 0 - Default (currently set to a capsule) 1 - Capsule, 2 - Cylinder.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "weight": {
                "docstring": "This flag is only valid in conjunction with the -addInfluence flag. It sets the weight for the influence object that is being added."
            }, 
            "weightedInfluence": {
                "docstring": "This flag returns a string array of the influence objects (joints and transform) that have non-zero weighting."
            }
        }
    }, 
    "skinPercent": {
        "description": "This command edits and queries the weight values on members of a skinCluster node, given as the first argument. If no object components are explicitly mentioned in the command line, the current selection list is used. Note that setting multiple weights in a single invocation of this command is far more efficient than calling it once per weighted vertex. In query mode, return type is based on queried flag.", 
        "flags": {
            "ignoreBelow": {
                "docstring": "Limits the output of the -value and -transform queries to the entries whose weight values are over the specified limit. This flag has to be used before the -query flag. "
            }, 
            "normalize": {
                "docstring": "If set, the weights not assigned by the -transformValue flag are normalized so that the sum of the all weights for the selected object component add up to 1. The default is on. NOTE: The skinCluster has a normalizeWeights attribute which when set to OFF overrides this attribute! If the skinCluster.normalizeWeights attribute is OFF, you must set it to Interactive in order to normalize weights using the skinPercent command."
            }, 
            "pruneWeights": {
                "docstring": "Sets to zero any weight smaller than the given value for all the selected components. To use this command to set all the weights to zero, you must turn the -normalize flag \"off\" or the skinCluster node will normalize the weights to sum to one after pruning them. Weights for influences with a true value on their \"Hold Weights\" attribute will not be pruned.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Used with -transformValue to specify a relative setting of values. If -relative is true, the value passed to -tv is added to the previous value. Otherwise, it replaces the previous value."
            }, 
            "resetToDefault": {
                "docstring": "Sets the weights of the selected components to their default values, overwriting any custom weights."
            }, 
            "transform": {
                "docstring": "If used after the -query flag (without an argument) the command returns an array of strings corresponding to the names of the transforms influencing the selected object components. If used before the -query flag (with a transform name), the command returns the weight of the selected object component corresponding to the given transform. The command will return an average weight if several components have been selected. In query mode, this flag can accept a value."
            }, 
            "transformMoveWeights": {
                "docstring": ""
            }, 
            "transformValue": {
                "docstring": "Accepts a pair consisting of a transform name and a value and assigns that value as the weight of the selected object components corresponding to the given transform."
            }, 
            "value": {
                "docstring": "Returns an array of doubles corresponding to the joint weights for the selected object component."
            }, 
            "zeroRemainingInfluences": {
                "docstring": "If set, the weights not assigned by the -transformValue flag are set to 0. The default is off."
            }
        }
    }, 
    "smoothCurve": {
        "description": "The smooth command smooths the curve at the given control points. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "smoothness": {
                "docstring": "smoothness factorDefault:10.0Advanced flags"
            }
        }
    }, 
    "smoothTangentSurface": {
        "description": "The smoothTangentSurface command smooths the surface along an isoparm at each parameter value. The name of the surface is returned and if history is on, the name of the resulting dependency node is also returned. This command only applies to parameter values with a multiple knot value. (If the given parameter value has no multiple knot associated with it, then the dependency node is created but the surface doesn't change.)When would you use this? If you have a surface consisting of a number of Bezier patches or any isoparms with more than a single knot multiplicity, you could get into a situation where a tangent break occurs. So, it only makes sense to do this operation on the knot isoparms, and not anywhere in between, because the surface is already smooth everywhere in between.If you have a cubic or higher degree surface, asking for the maximal smoothness will give you tangent, curvature, etc. up to the degree-1 continuity. Asking for tangent will just give you tangent continuity.It should be mentioned that this is \"C\", not \"G\" continuity we're talking about, so technically, you can still see visual tangent breaks if the surface is degenerate. Note: A single smoothTangentSurface command cannot smooth in both directions at once; you must use two separate commands to do this. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "direction": {
                "docstring": "Direction in which to smooth knot: 0 - V direction, 1 - U directionDefault:1"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameter": {
                "docstring": "Parameter value(s) where knots are addedDefault:0.0"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "smoothness": {
                "docstring": "Smoothness to get: 0 - Tangent, 1 - Maximum (based on the degree)Default:1Advanced flags"
            }
        }
    }, 
    "snapKey": {
        "description": "This command operates on a keyset. A keyset is defined as a group of keys within a specified time range on one or more animation curves. The animation curves comprising a keyset depend on the value of the \"-animation\" flag: keysOrObjects: Any active keys, when no target objects or -attribute flags appear on the command line, orAll animation curves connected to all keyframable attributes of objects specified as the command line's targetList, when there are no active keys.keys: Only act on active keys or tangents. If there are no active keys or tangents, don't do anything.objects: Only act on specified objects. If there are no objects specified, don't do anything.Note that the \"-animation\" flag can be used to override the curves uniquely identified by the multi-use \"-attribute\" flag, which takes an argument of the form attributeName, such as \"translateX\". Keys on animation curves are identified by either their time values or their indices. Times and indices can be given individually or as part of a list or range. -time 10palmeans the key at frame 10 (PAL format).-time 1.0sec -time 15ntsc -time 20means the keys at time 1.0 second, frame 15 (in NTSC format), and time 20 (in the currently defined global time unit).-time \"10:20\"means all keys in the range from 10 to 20, inclusive, in the current time unit.Omitting one end of a range means \"go to infinity\", as in the following examples: -time \"10:\"means all keys from time 10 (in the current time unit) onwards.-time \":10\"means all keys up to (and including) time 10 (in the current time unit).-time \":\"is a short form to specify all keys.-index 0means the first key of each animation curve. (Indices are 0-based.)-index 2 -index 5 -index 7means the 3rd, 6th, and 8th keys.-index \"1:5\"means the 2nd, 3rd, 4th, 5th, and 6th keys of each animation curve.This command \"snaps\" all target key times and/or values so that they have times and/or values that are multiples of the specified flag arguments. If neither multiple is specified, default is time snapping with a multiple of 1.0. Note that this command will fail to move keys over other neighboring keys: a key's index will not change as a result of a snapKey operation.TbaseKeySetCmd.h ", 
        "flags": {
            "animation": {
                "docstring": "Where this command should get the animation to act on. Valid values are \"objects,\" \"keys,\" and \"keysOrObjects\" Default: \"keysOrObjects.\" (See Description for details.)"
            }, 
            "attribute": {
                "docstring": "List of attributes to select "
            }, 
            "controlPoints": {
                "docstring": "This flag explicitly specifies whether or not to include the control points of a shape (see \"-s\" flag) in the list of attributes. Default: false. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "float": {
                "docstring": "value uniquely representing a non-time-based key (or key range) on a time-based animCurve. Valid floatRange include single values (-f 10) or a string with a lower and upper bound, separated by a colon (-f \"10:20\") "
            }, 
            "hierarchy": {
                "docstring": "Hierarchy expansion options. Valid values are \"above,\" \"below,\" \"both,\" and \"none.\" (Not valid for \"pasteKey\" cmd.)"
            }, 
            "includeUpperBound": {
                "docstring": "When the -t/time or -f/float flags represent a range of keys, this flag determines whether the keys at the upper bound of the range are included in the keyset. Default value: true. This flag is only valid when the argument to the -t/time flag is a time range with a lower and upper bound. (When used with the \"pasteKey\" command, this flag refers only to the time range of the target curve that is replaced, when using options such as \"replace,\" \"fitReplace,\" or \"scaleReplace.\" This flag has no effect on the curve pasted from the clipboard.)"
            }, 
            "index": {
                "docstring": "index of a key on an animCurve "
            }, 
            "shape": {
                "docstring": "Consider attributes of shapes below transforms as well, except \"controlPoints\". Default: true. (Not valid for \"pasteKey\" cmd.)"
            }, 
            "time": {
                "docstring": "time uniquely representing a key (or key range) on a time-based animCurve. Valid timeRanges include single values (-t 10) or a string with a lower and upper bound, separated by a colon (-t \"10:20\") "
            }, 
            "timeMultiple": {
                "docstring": "If this flag is present, key times will be snapped to a multiple of the specified float value."
            }, 
            "valueMultiple": {
                "docstring": "If this flag is present, key values will be snapped to a multiple of the specified float value.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "snapMode": {
        "description": "The snapMode command is used to control snapping. It toggles the snapping modes in effect and sets information used for snapping. ", 
        "flags": {
            "curve": {
                "docstring": "Set curve snap mode"
            }, 
            "distanceIncrement": {
                "docstring": "Set the distance for the snapping to objects such as a lines or planes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edgeMagnet": {
                "docstring": "Number of extra magnets to snap onto, regularly spaced along the edge."
            }, 
            "edgeMagnetTolerance": {
                "docstring": "Precision for edge magnet snapping."
            }, 
            "grid": {
                "docstring": "Set grid snap mode"
            }, 
            "liveFaceCenter": {
                "docstring": "While moving on live polygon objects, snap to its face centers."
            }, 
            "livePoint": {
                "docstring": "While moving on live polygon objects, snap to its vertices."
            }, 
            "pixelCenter": {
                "docstring": "Snap UV to the center of the pixel instead of the corner."
            }, 
            "pixelSnap": {
                "docstring": "Snap UVs to the nearest pixel center or corner."
            }, 
            "point": {
                "docstring": "Set point snap mode"
            }, 
            "query": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": "Tolerance defines the size of the square region in which points must lie in order to be snapped to. The tolerance value is the distance from the cursor position to the boundary of the square (in all four directions)."
            }, 
            "useTolerance": {
                "docstring": "If useTolerance is set, then point snapping is limited to points that are within a square region surrounding the cursor position. The size of the square is determined by the tolerance value."
            }, 
            "uvTolerance": {
                "docstring": "uvTolerance defines the size of the square region in which points must lie in order to be snapped to, in the UV Texture Editor. The tolerance value is the distance from the cursor position to the boundary of the square (in all four directions)."
            }, 
            "viewPlane": {
                "docstring": "Set view-plane snap mode"
            }
        }
    }, 
    "snapTogetherCtx": {
        "description": "The snapTogetherCtx command creates a tool for snapping surfaces together. ", 
        "flags": {
            "clearSelection": {
                "docstring": "Sets whether the tool should clear the selection on entry to the tool. Default true."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }, 
            "setOrientation": {
                "docstring": "Sets whether the tool should orient as well as moving an item. Default true."
            }, 
            "snapPolygonFace": {
                "docstring": "Sets whether the tool should snap the cursor to polygon face centers. Default false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "snapshot": {
        "description": "This command can be used to create either a series of surfaces evaluated at the times specified by the command flags, or a motion trail displaying the trajectory of the object's pivot point at the times specified.If the constructionHistory flag is true, the output shapes or motion trail will re-update when modifications are made to the animation or construction history of the original shape. When construction history is used, the forceUpdate flag can be set to false to control when the snapshot recomputes, which will typically improve performance. ", 
        "flags": {
            "constructionHistory": {
                "docstring": "update with changes to original geometry"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endTime": {
                "docstring": "time to stop copying target geometry Default: 10.0"
            }, 
            "increment": {
                "docstring": "time increment between copies Default: 1.0"
            }, 
            "motionTrail": {
                "docstring": "Rather than create a series of surfaces, create a motion trail displaying the location of the object's pivot point at the specified time steps. Default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "the name of the snapshot node. Query returns string."
            }, 
            "query": {
                "docstring": ""
            }, 
            "startTime": {
                "docstring": "time to begin copying target geometry Default: 1.0"
            }, 
            "update": {
                "docstring": "This flag can only be used if the snapshot has constructionHistory. It sets the snapshot node's update value. The update value controls whether the snapshot updates on demand (most efficient), when keyframes change (efficient), or whenever any history changes (least efficient). Valid values are \"demand\", \"animCurve\", \"always\". Default: \"always\""
            }
        }
    }, 
    "snapshotBeadContext": {
        "description": "", 
        "flags": {}
    }, 
    "snapshotBeadCtx": {
        "description": "Creates a context for manipulating in and/or out tangent beads on the motion trail ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "inTangent": {
                "docstring": "Indicates that we will be showing beads for the in tangent when entering the context"
            }, 
            "name": {
                "docstring": ""
            }, 
            "outTangent": {
                "docstring": "Indicates that we will be showing beads for the out tangent when entering the contextFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "snapshotModifyKeyCtx": {
        "description": "Creates a context for inserting/delete keys on an editable motion trail ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "soft": {
        "description": "Makes a soft body from the object(s) passed on the command line or in the selection list. The geometry can be a NURBS, polygonal, lattice object. The resulting soft body is made up of a hierarchy with a particle shape and a geometry shape, thus: T     / \\   T   G  /       P         Dynamics are applied to the particle shape and the resulting particle positions then drive the locations of the geometry's CVs, vertices, or lattice points. With the convert option, the particle shape and its transform are simply inserted below the original shape's hierarchy. With the duplicate option, the original geometry's transform and shape are duplicated underneath its parent, and the particle shape is placed under the duplicate. Note that any animation on the hierarchy will affect the particle shape as well. If you do not want then, then reparent the structure outside the hierarchy. When duplicating, the soft portion (the duplicate) is given the name \"copyOf\" + \"original object name\". The particle portion is always given the name \"original object name\" + \"Particles.\" None of the flags of the soft command can be queried. The soft -q command is used only to identify when an object is a soft body, or when two objects are part of the same soft body. See the examples. ", 
        "flags": {
            "convert": {
                "docstring": "This tells the command that you want the original object to be the actual deformed object. The particle shape portion of the soft body will be inserted in the same hierarchy as the original, under the same parent (with one additional intervening transform which is initially the identity). If no flags are passed, then this is assumed. The combination -c -h 1 is not valid; if you have this in your scripts, remove the -h 1."
            }, 
            "duplicate": {
                "docstring": "This tells the command that you want to make a copy of the original object and use the copy as the deforming geometry. Input connections to the original object are duplicated. You would do this if you wanted to keep the original object in your scene and also have a copy of it that was a soft body. This flag and -dh are mutually exclusive."
            }, 
            "duplicateHistory": {
                "docstring": "This is the same as -d, except that upstream history, is duplicated as well, instead of just input connections. This flag and -d are mutually exclusive."
            }, 
            "goal": {
                "docstring": "This is the same as -d, but in addition it tells the command that you want the resulting soft body to try to follow the original geometry, using the set goal weight as the value that controls how strongly it is to follow it. A value of 1.0 will try to follow exactly, and a value of 0.0 will not follow at all. The default value is 0.5. This value must be from 0.0 to 1.0. You could use -d with -g, but it is redundant. If you want history to be duplicated, you can use -dh and -g together."
            }, 
            "hideOriginal": {
                "docstring": "This flag is used only when duplicating (-d, -g, or -dh). If set to true, whichever of the two objects is NOT the soft object will be hidden. In other words, with -d -h true, the original object will be hidden; with -d -c -h 1 the duplicate object will be hidden. You would typically do this if you want to use the non-dynamic object as a goal for the soft one (see -g) but you do not want it visible in the scene. The flags -h 1 and -c are mutually exclusive."
            }, 
            "name": {
                "docstring": "This flag is obsolete. If you wish to give your new soft object a name, use the rename command (or from the UI, use the outliner).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "softMod": {
        "description": "The softMod command creates a softMod or edits the membership of an existing softMod. The command returns the name of the softMod node upon creation of a new softMod. ", 
        "flags": {
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "bindState": {
                "docstring": "Specifying this flag adds in a compensation to ensure the softModed objects preserve their spatial position when softModed. This is required to prevent the geometry from jumping at the time the softMod is created in situations when the softMod transforms at softMod time are not identity."
            }, 
            "curveInterpolation": {
                "docstring": "Ramp interpolation corresponding to the specified curvePoint position. Integer values of 0-3 are valid, corresponding to \"none\", \"linear\", \"smooth\" and \"spline\" respectively. This flag may only be used in conjunction with the curvePoint and curveValue flag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "curvePoint": {
                "docstring": "Position of ramp value on normalized 0-1 scale. This flag may only be used in conjunction with the curveInterpolation and curveValue flags."
            }, 
            "curveValue": {
                "docstring": "Ramp value corresponding to the specified curvePoint position. This flag may only be used in conjunction with the curveInterpolation and curvePoint flags."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "envelope": {
                "docstring": "Set the envelope value for the deformer. Default is 1.0"
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "falloffAroundSelection": {
                "docstring": "Falloff will be calculated around any selected components"
            }, 
            "falloffBasedOnX": {
                "docstring": "Falloff will be calculated using the X component."
            }, 
            "falloffBasedOnY": {
                "docstring": "Falloff will be calculated using the Y component."
            }, 
            "falloffBasedOnZ": {
                "docstring": "Falloff will be calculated using the Z component."
            }, 
            "falloffCenter": {
                "docstring": "Set the falloff center point of the softMod."
            }, 
            "falloffMasking": {
                "docstring": "Deformation will be restricted to selected components"
            }, 
            "falloffMode": {
                "docstring": "Set the falloff method used for the softMod."
            }, 
            "falloffRadius": {
                "docstring": "Set the falloff radius of the softMod."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Enable relative mode for the softMod. In relative mode, Only the transformations directly above the softMod are used by the softMod. Default is off."
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "resetGeometry": {
                "docstring": "Reset the geometry matrices for the objects being deformed by the softMod. This flag is used to get rid of undesirable effects that happen if you scale an object that is deformed by a softMod."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "weightedNode": {
                "docstring": "Transform node in the DAG above the softMod to which all percents are applied. The second node specifies the descendent of the first node from where the transformation matrix is evaluated. Default is the softMod handle."
            }
        }
    }, 
    "softModContext": {
        "description": "", 
        "flags": {}
    }, 
    "softModCtx": {
        "description": "Controls the softMod context. ", 
        "flags": {
            "dragSlider": {
                "docstring": "Specify the slider mode for hotkey radius resizing."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "falseColor": {
                "docstring": "Enable or disable false color display on the soft mod manipulator.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": "Reset the tool options to their default values."
            }
        }
    }, 
    "softSelect": {
        "description": "This command allows you to change the soft modelling options. Soft modelling is an option that allows for reflection of basic manipulator actions such as move, rotate, and scale. In query mode, return type is based on queried flag.", 
        "flags": {
            "compressUndo": {
                "docstring": "Controls how soft selection settings behave in undo: 0 means all changes undo individually1 means all consecutive changes undo as a group2 means only interactive changes undo as a groupWhen queried, returns an int indicating the current undo behaviour."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enableFalseColor": {
                "docstring": "Set soft select color feedback on or off. When queried, returns an int indicating whether color feedback is currently enabled."
            }, 
            "query": {
                "docstring": ""
            }, 
            "softSelectColorCurve": {
                "docstring": "Sets the color ramp used to display false color feedback for soft selected components in the viewport. The color curve is encoded as a string of comma separated floating point values representing the falloff curve CVs. Each CV is represented by 5 successive values: 3 RGB values (the color to use), an input value (the selection weight), and a curve interpolation type. When queried, returns a string containing the encoded CVs of the current color feedback curve."
            }, 
            "softSelectCurve": {
                "docstring": "Sets the falloff curve used to calculate selection weights for components within the falloff distance. The curve is encoded as a string of comma separated floating point values representing the falloff curve CVs. Each CV is represented by 3 successive values: an output value (the selection weight at this point), an input value (the normalised falloff distance) and a curve interpolation type. When queried, returns a string containing the encoded CVs of the current falloff curve."
            }, 
            "softSelectDistance": {
                "docstring": "Sets the falloff distance (radius) used for world and object space soft selection. When queried, returns an float indicating the current falloff distance."
            }, 
            "softSelectEnabled": {
                "docstring": "Sets soft selection based modeling on or off. When queried, returns an int indicating the current state of the option."
            }, 
            "softSelectFalloff": {
                "docstring": "Sets the falloff mode: 0 for volume based falloff1 for surface based falloff2 for global falloffWhen queried, returns an int indicating the falloff mode."
            }, 
            "softSelectReset": {
                "docstring": "Resets soft selection to its default settings.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "softSelectUVDistance": {
                "docstring": "Sets the falloff distance (radius) used for UV space soft selection. When queried, returns an float indicating the current falloff distance."
            }
        }
    }, 
    "softSelectOptionsCtx": {
        "description": "", 
        "flags": {
            "buttonDown": {
                "docstring": ""
            }, 
            "buttonUp": {
                "docstring": ""
            }, 
            "colorCurve": {
                "docstring": ""
            }, 
            "condition": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enableFalseColor": {
                "docstring": ""
            }, 
            "enabled": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "falloffCurve": {
                "docstring": ""
            }, 
            "falloffMode": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "size": {
                "docstring": ""
            }, 
            "uvSize": {
                "docstring": ""
            }
        }
    }, 
    "sound": {
        "description": "Creates an audio node which can be used with UI commands such as soundControl or timeControl which support sound scrubbing and sound during playback. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "endTime": {
                "docstring": "Time at which to end the sound."
            }, 
            "file": {
                "docstring": "Name of sound file."
            }, 
            "length": {
                "docstring": "The length (in the current time unit) of the sound."
            }, 
            "mute": {
                "docstring": "Mute the audio clip.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": "Name to give the resulting audio node."
            }, 
            "offset": {
                "docstring": "Time at which to start the sound."
            }, 
            "query": {
                "docstring": ""
            }, 
            "sourceEnd": {
                "docstring": "Time offset from the start of the sound file at which to end the sound."
            }, 
            "sourceStart": {
                "docstring": "Time offset from the start of the sound file at which to start the sound."
            }
        }
    }, 
    "soundControl": {
        "description": "This command creates a control used for changing current time and scratching/scrubbing through sound files. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "beginScrub": {
                "docstring": "Set this widget up for sound scrubbing. Subsequent changes to current time will result in \"sound scrubbing\" behavior, until the \"-endScrub\" command is issued for this widget."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "displaySound": {
                "docstring": "Turn sound display off. Query returns int."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "endScrub": {
                "docstring": "End sound scubbing for this widget. This stops sound scrubbing behavior and should be issued before any subsequent \"-beginScrub\" flags"
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "maxTime": {
                "docstring": "Controls the max time of the range displayed in the control. Query returns float."
            }, 
            "minTime": {
                "docstring": "Controls the min time of the range displayed in the control. Query returns float."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "pressCommand": {
                "docstring": "script to run on mouse-down in this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "releaseCommand": {
                "docstring": "script to run on mouse-up in this control.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "repeatChunkSize": {
                "docstring": "How much sound (in the current time unit) is repeated when -repeatOnHold is true. Default is 1.0."
            }, 
            "repeatOnHold": {
                "docstring": "Repeat sound during mouse-down events"
            }, 
            "resample": {
                "docstring": "Resample the sound display to fit the widget"
            }, 
            "sound": {
                "docstring": "Name of audio depend node whose data should display in the sound-display widget. Query returns string."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "waveform": {
                "docstring": "Determines what part of the sound waveform to display, when -displaySound is \"true\". Valid values are \"top\", \"bottom\", and \"both\". Default is \"top\". Query returns string."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "spBirailCtx": {
        "description": "", 
        "flags": {
            "activeNodes": {
                "docstring": ""
            }, 
            "autoCreate": {
                "docstring": ""
            }, 
            "bldProfileFirst": {
                "docstring": ""
            }, 
            "bldProfileLast": {
                "docstring": ""
            }, 
            "bldProfiles": {
                "docstring": ""
            }, 
            "bldRailOne": {
                "docstring": ""
            }, 
            "bldRailTwo": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "immediate": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": ""
            }, 
            "polygon": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": ""
            }, 
            "tangentContinuityProfile1": {
                "docstring": ""
            }, 
            "toolNode": {
                "docstring": ""
            }, 
            "transformMode": {
                "docstring": ""
            }
        }
    }, 
    "spaceLocator": {
        "description": "The command creates a locator at the specified position in space. By default it is created at (0,0,0). ", 
        "flags": {
            "absolute": {
                "docstring": "If set, the locator's position is in world space.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name for the locator."
            }, 
            "position": {
                "docstring": "Location in 3-dimensional space where locator is to be created."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "If set, the locator's position is relative to its local space. The locator is created in relative mode by default."
            }
        }
    }, 
    "sphere": {
        "description": "The sphere command creates a new sphere. The number of spans in the in each direction of the sphere is determined by the useTolerance attribute. If -ut is true then the -tolerance attribute will be used. If -ut is false then the -sections attribute will be used. ", 
        "flags": {
            "axis": {
                "docstring": "The primitive's axisAdvanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting surface: 1 - linear, 3 - cubicDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endSweep": {
                "docstring": "The angle at which to end the surface of revolution. Default is 2Pi radians, or 360 degrees.Default:6.2831853"
            }, 
            "heightRatio": {
                "docstring": "Ratio of \"height\" to \"width\"Default:2.0"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "pivot": {
                "docstring": "The primitive's pivot point"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "The radius of the objectDefault:1.0"
            }, 
            "sections": {
                "docstring": "The number of sections determines the resolution of the surface in the sweep direction. Used only if useTolerance is false.Default:8"
            }, 
            "spans": {
                "docstring": "The number of spans determines the resolution of the surface in the opposite direction.Default:1"
            }, 
            "startSweep": {
                "docstring": "The angle at which to start the surface of revolutionDefault:0"
            }, 
            "tolerance": {
                "docstring": "The tolerance with which to build the surface. Used only if useTolerance is trueDefault:0.01"
            }, 
            "useTolerance": {
                "docstring": "Use the specified tolerance to determine resolution. Otherwise number of sections will be used.Default:false"
            }
        }
    }, 
    "spotLight": {
        "description": "The spotLight command is used to edit the parameters of existing spotLights, or to create new ones. The default behaviour is to create a new spotlight. ", 
        "flags": {
            "barnDoors": {
                "docstring": ""
            }, 
            "bottomBarnDoorAngle": {
                "docstring": ""
            }, 
            "coneAngle": {
                "docstring": "angle of the spotLight"
            }, 
            "decayRate": {
                "docstring": "decay rate of the light (0-no decay, 1-slow, 2-realistic, 3-fast)"
            }, 
            "discRadius": {
                "docstring": "radius of the disc around the light"
            }, 
            "dropOff": {
                "docstring": "dropOff of the spotLight"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": ""
            }, 
            "intensity": {
                "docstring": "intensity of the light (expressed as a percentage)"
            }, 
            "leftBarnDoorAngle": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "specify the name of the light"
            }, 
            "penumbra": {
                "docstring": "specify penumbra region"
            }, 
            "position": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rgb": {
                "docstring": "color of the light (0-1)"
            }, 
            "rightBarnDoorAngle": {
                "docstring": ""
            }, 
            "rotation": {
                "docstring": ""
            }, 
            "shadowColor": {
                "docstring": "the shadow color"
            }, 
            "shadowDither": {
                "docstring": "dither the shadowFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "shadowSamples": {
                "docstring": "number of shadow samples."
            }, 
            "softShadow": {
                "docstring": "soft shadow"
            }, 
            "topBarnDoorAngle": {
                "docstring": ""
            }, 
            "useRayTraceShadows": {
                "docstring": "ray trace shadows"
            }
        }
    }, 
    "spotLightPreviewPort": {
        "description": "This command creates a 3dPort that displays an image representing the illumination provided by the spotLight. It is a picture of a plane being illuminated by a light. The optional argument is the name of the 3dPort. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "spotLight": {
                "docstring": "Name of the spotLight."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "widthHeight": {
                "docstring": "The width and height of the port.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "spreadSheetEditor": {
        "description": "This command creates a new spread sheet editor in the current layout. ", 
        "flags": {
            "allAttr": {
                "docstring": "Returns a list of all the attribute names currently being displayed. This flag is ignored when not being queried."
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "execute": {
                "docstring": "Immediately executes the command string once for every selected cell in the spreadSheet. Before the command is executed, \"#A\" is substituted with the name of the cell's attribute, \"#N\" is substituted with the name of the cell's node, and \"#P\" is substituted with the full path name of the node.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "fixedAttrList": {
                "docstring": "Forces the editor to only display attributes with the specified names."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "keyableOnly": {
                "docstring": "Limits the displayed attributes to be those that are keyable. True by default"
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "longNames": {
                "docstring": "Controls whether the attributes are displayed using their long names or their short names."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "niceNames": {
                "docstring": "Controls whether the attribute names will be displayed in a more user-friendly, readable way. When this is on, the longNames flag is ignored. When this is off, attribute names will be displayed either long or short, according to the longNames flag. Default is on. Queried, returns a boolean."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "precision": {
                "docstring": "Specifies the maximum number of digits displayed to the right of the decimal place. Can be 0 to 20."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectedAttr": {
                "docstring": "Returns a list of all the attribute names that are selected. This flag is ignored when not being queried."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "showShapes": {
                "docstring": "If true, when transforms are selected their shapes will be displayed instead."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "spring": {
        "description": "The spring command can do any of the following:\\* create a new spring object (shape plus transform). The shape contains springs between the points (particles, cvs, etc.) of the objects selected or listed on the command line.\\* create new springs and add them to an existing spring object\\* edit or query certain attributes of an existing spring objectOne \"spring object\" may have hundreds or even thousands of individual springs. Certain attributes of the spring object specify exactly where the springs are attached to which other objects.Springs may be attached to the following: particles, vertices of soft bodies, CVs or edit points of curves or surfaces, vertices of polygonal objects, and points of lattices. In the case where one endpoint of a spring is non-dynamic (a CV, edit point, etc.), the spring does not affect its motion, but the motion of the point affects the spring. A spring will be created only if at least one of the endpoints is dynamic: for example, a spring will never be created between two CVs. A single spring object can hold springs which are incident to any number of other objects.The spring has creation-only flags and editable flags. Creation-only flags (minDistance, maxDistance, add, exclusive, all, wireframe, walklength, checkExisting) can be used only when creating new springs (including adding springs to existing spring object). Editable flags modify attributes of an existing spring object.If a spring object is created, this command returns the names of the shape and transform. If a spring object is queried, the command returns the results of the query. ", 
        "flags": {
            "addSprings": {
                "docstring": "If specified, springs will be added to the existing selected set of springs. (Default is to create a new spring object.)"
            }, 
            "allPoints": {
                "docstring": "If True, sets the mode of spring application to All. This will add springs between all points selected. (Default is False.)"
            }, 
            "count": {
                "docstring": "Return the number of springs in the shape. Query-only. We maintain this flag only for compatibility with earlier versions of Maya. To get the count of springs, it is much faster and simpler to use the spring shape's count attribute: getAttr shapeName.count."
            }, 
            "damp": {
                "docstring": ""
            }, 
            "damping": {
                "docstring": "Damping factor for the springs created in the spring object. (Default = 0.2 )"
            }, 
            "dampingPS": {
                "docstring": "Damping factor for the springs created in the spring object. This will initialize all the entries in dampingPS to the specified value. In both the flag and the attribute name, \"PS\" stands for \"per-spring.\" (Default = 0.2 )"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endForceWeight": {
                "docstring": "Amount of the force of the spring that gets applied to the point to which the spring ends. Valid range is from 0.0 to 1.0. (Default = 1.0 )"
            }, 
            "exclusive": {
                "docstring": "If true, tells the command to create springs only between pairs of points which are not in the same object. (Default is False.)"
            }, 
            "length": {
                "docstring": "Vestigial form of \"restLength.\" Please use \"restLength\" instead."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance between two points that a spring would be considered."
            }, 
            "minDistance": {
                "docstring": "Minimum distance between two points that a spring would be considered. (Default = 0.0. See Defaults for more information on this flag's default.)"
            }, 
            "minMax": {
                "docstring": "If True, sets the mode of the spring application to Min/Max. This will add springs between all points from the specified point groups that are between the minimum and maximum distance values set with min and max. (Default is False.) Note: This gets automatically set if either the min or max flags are used."
            }, 
            "name": {
                "docstring": "Name of spring object."
            }, 
            "noDuplicate": {
                "docstring": "Check for existing springs and don't add a new spring between two points already connected by a spring in the same object. Only the object the command is working on is checked. This flag is relevant only when using -add. (Default = false)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "restLength": {
                "docstring": "Per-object rest length for the new springs. Springs can use either their per-object or per-spring rest length. See the -lPS and -ulp flags."
            }, 
            "restLengthPS": {
                "docstring": "Per-spring rest length for the new springs. This will initialize all the entries in restLengthPS to the specified value. If this flag is not thrown, each rest length will be initialized to the distance between the two points at the time the spring is created (i.e., the initial length of the spring). When playing back, springs can use either their per-spring or per-object rest length. See the -rl and -urp flags. In both the flag and the attribute name, \"PS\" stands for \"per-spring.\""
            }, 
            "startForceWeight": {
                "docstring": "Amount of the force of the spring that gets applied to the point from which the spring starts. Valid range is from 0.0 to 1.0. (Default = 1.0 )"
            }, 
            "stiffness": {
                "docstring": "Stiffness of the springs created in the spring object. (Default = 1.0 ) -damp float Vestigial form of \"damping.\" Please use \"damping\" instead."
            }, 
            "stiffnessPS": {
                "docstring": "Stiffness of the springs created in the spring object. This will initialize all the entries in stiffnessPS to the specified value. In both the flag and the attribute name, \"PS\" stands for \"per-spring.\" (Default = 1.0 )"
            }, 
            "strength": {
                "docstring": ""
            }, 
            "useDampingPS": {
                "docstring": "Specifies whether to use dampingPS (per spring damping). If set to false, the per object damping attribute value will be used. This flag simply sets the useDampingPS attribute of the spring shape. In both the flag and the attribute name, \"PS\" stands for \"per-spring.\" (Default = false )"
            }, 
            "useRestLengthPS": {
                "docstring": "Specifies whether to use restLengthPS (per spring restLength). If set to false, the per object restLength attribute value will be used. This flag simply sets the useRestLengthPS attribute of the spring shape. In both the flag and the attribute name, \"PS\" stands for \"per-spring.\" (Default = false )"
            }, 
            "useStiffnessPS": {
                "docstring": "Specifies whether to use stiffnessPS (per spring stiffness). If set to false, the per object stiffness attribute value will be used. This flag simply sets the useStiffnessPS attribute of the spring shape. In both the flag and the attribute name, \"PS\" stands for \"per-spring.\" (Default = false )"
            }, 
            "walkLength": {
                "docstring": "This flag is valid only when doing wireframe creation. It will create springs between pairs of points connected by the specified number of edges. For example, if walk length is 2, each pair of points separated by no more than 2 edges will get a spring. Walk length measures the distance between pairs of vertices just like the number of blocks measures the distance between two intersections in a city."
            }, 
            "wireframe": {
                "docstring": "If True, sets the mode of the spring application to Wireframe. This is valid only for springs created on a soft body. It will add springs along all edges connecting the adjacent points (vertices or CV's) of curves and surfaces. (Default is False.)"
            }
        }
    }, 
    "squareSurface": {
        "description": "This command produces a square surface given 3 or 4 curves. This resulting square surface is created within the intersecting region of the selected curves. The order of selection is important and the curves must intersect or their ends must meet.You must specify one continuity type flag for each selected curve. If continuity type is 1 (fixed, no tangent continuity) then the curveFitCheckpoints flag (cfc) is not required. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "continuityType1": {
                "docstring": "Continuity type legal values for curve 1: 1 - fixed boundary 2 - tangent continuity 3 - implied tangent continuityDefault:2"
            }, 
            "continuityType2": {
                "docstring": "Continuity type legal values for curve 2: 1 - fixed boundary 2 - tangent continuity 3 - implied tangent continuityDefault:2"
            }, 
            "continuityType3": {
                "docstring": "Continuity type legal values for curve 3: 1 - fixed boundary 2 - tangent continuity 3 - implied tangent continuityDefault:2"
            }, 
            "continuityType4": {
                "docstring": "Continuity type legal values for curve 4: 1 - fixed boundary 2 - tangent continuity 3 - implied tangent continuityDefault:2"
            }, 
            "curveFitCheckpoints": {
                "docstring": "The number of points per span to check the tangency deviation between the boundary curve and the created tangent square surface. Only available for the tangent continuity type.Default:5"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endPointTolerance": {
                "docstring": "Tolerance for end points, only used if endPoint attribute is true.Default:0.1Advanced flags"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rebuildCurve1": {
                "docstring": "A boolean to determine if input curve 1 should be rebuilt (with curvature continuity).Default:false"
            }, 
            "rebuildCurve2": {
                "docstring": "A boolean to determine if input curve 2 should be rebuilt (with curvature continuity).Default:false"
            }, 
            "rebuildCurve3": {
                "docstring": "A boolean to determine if input curve 3 should be rebuilt (with curvature continuity).Default:false"
            }, 
            "rebuildCurve4": {
                "docstring": "A boolean to determine if input curve 4 should be rebuilt (with curvature continuity).Default:false"
            }
        }
    }, 
    "srtContext": {
        "description": "This command can be used to create a combined transform (translate/scale/rotate) context. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "stackTrace": {
        "description": "", 
        "flags": {
            "dump": {
                "docstring": ""
            }, 
            "parameterCount": {
                "docstring": ""
            }, 
            "parameterType": {
                "docstring": ""
            }, 
            "parameterValue": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "state": {
                "docstring": ""
            }
        }
    }, 
    "stitchSurface": {
        "description": "The stitchSurface command aligns two surfaces together to be G(0) and/or G(1) continuous by ajusting only the Control Vertices of the surfaces. The two surfaces can be stitched by specifying the two isoparm boundary edges that are to stitched together. The edge to which the two surfaces are stitched together is obtained by doing a weighted average of the two edges. The weights for the two edges is specified using the flags -wt0, -wt1 respectively. ", 
        "flags": {
            "bias": {
                "docstring": "Blend Cvs in between input surface and result from stitch. A value of 0.0 returns the input surfaceDefault:1.0"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "cascade": {
                "docstring": "Cascade the created stitch node. (Only if the surface has a stitch history)Default is 'false'.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "cvIthIndex": {
                "docstring": "The ith boundary cv index on the input surfaceDefault:-1"
            }, 
            "cvJthIndex": {
                "docstring": "The jth boundary cv index on the input surfaceDefault:-1"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "fixBoundary": {
                "docstring": "Fix Boundary Cvs while Solving for any G1 constraints.Default:falseAdvanced flags"
            }, 
            "keepG0Continuity": {
                "docstring": "Stitch together with positional continuity.Default is 'true'."
            }, 
            "keepG1Continuity": {
                "docstring": "Stitch together with tangent continuity.Default is 'false'."
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "numberOfSamples": {
                "docstring": "The number of samples on the edge.Default is 20."
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameterU": {
                "docstring": "The U parameter value on surface for a point constraint.Default:-10000"
            }, 
            "parameterV": {
                "docstring": "The V parameter value on surface for a point constraintDefault:-10000"
            }, 
            "positionalContinuity": {
                "docstring": "Toggle on(off) G0 continuous at edge corresponding to multi index.Default:true"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)"
            }, 
            "stepCount": {
                "docstring": "Step count for the number of discretizations.Default:20"
            }, 
            "tangentialContinuity": {
                "docstring": "Toggle on(off) G1 continuity across edge corresponding to multi index.Default:false"
            }, 
            "togglePointNormals": {
                "docstring": "Toggle on(off) normal point constraints on the surface.Default:false"
            }, 
            "togglePointPosition": {
                "docstring": "Toggle on(off) position point constraints on the surface.Default:true"
            }, 
            "toggleTolerance": {
                "docstring": "Toggle on(off) so as to use Tolerance or specified steps for discretization.Default:false"
            }, 
            "tolerance": {
                "docstring": "Tolerance to use while discretizing the edgeDefault:0.1"
            }, 
            "weight0": {
                "docstring": "The weighting factor for the first edge.Default is 0.5."
            }, 
            "weight1": {
                "docstring": "The weighting factor for the second edge.Default is 0.5."
            }
        }
    }, 
    "stitchSurfaceCtx": {
        "description": "", 
        "flags": {
            "activeNodes": {
                "docstring": ""
            }, 
            "autoCreate": {
                "docstring": ""
            }, 
            "bias": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "cascade": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "cvIthIndex": {
                "docstring": ""
            }, 
            "cvJthIndex": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "fixBoundary": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "immediate": {
                "docstring": ""
            }, 
            "keepG0Continuity": {
                "docstring": ""
            }, 
            "keepG1Continuity": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "numberOfSamples": {
                "docstring": ""
            }, 
            "object": {
                "docstring": ""
            }, 
            "parameterU": {
                "docstring": ""
            }, 
            "parameterV": {
                "docstring": ""
            }, 
            "positionalContinuity": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": ""
            }, 
            "stepCount": {
                "docstring": ""
            }, 
            "tangentialContinuity": {
                "docstring": ""
            }, 
            "togglePointNormals": {
                "docstring": ""
            }, 
            "togglePointPosition": {
                "docstring": ""
            }, 
            "toggleTolerance": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": ""
            }, 
            "toolNode": {
                "docstring": ""
            }, 
            "weight0": {
                "docstring": ""
            }, 
            "weight1": {
                "docstring": ""
            }
        }
    }, 
    "stitchSurfacePoints": {
        "description": "The stitchSurfacePoints command aligns two or more surface points along the boundaries together to a single point. In the process, a node to average the points is created. The points are averaged together in a weighted fashion. The points may be control vertices along the boundaries. If the points are CVs then they are stitched together only with positional continuity. Note: No two points can lie on the same surface. ", 
        "flags": {
            "bias": {
                "docstring": "Blend Cvs in between input surface and result from stitch. A value of 0.0 returns the input surfaceDefault:1.0"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "cascade": {
                "docstring": "Cascade the created stitch node. (Only if the surface has a stitch history)Default is 'false'.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "cvIthIndex": {
                "docstring": "The ith boundary cv index on the input surfaceDefault:-1"
            }, 
            "cvJthIndex": {
                "docstring": "The jth boundary cv index on the input surfaceDefault:-1"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "equalWeight": {
                "docstring": "Assign equal weights to all the points being stitched together.Default is 'true'. If false, the first point is assigned a weight of 1.0 and the rest are assigned 0.0."
            }, 
            "fixBoundary": {
                "docstring": "Fix Boundary Cvs while Solving for any G1 constraints.Default:falseAdvanced flags"
            }, 
            "keepG0Continuity": {
                "docstring": "Stitch together the points with positional continuity.Default is 'true'."
            }, 
            "keepG1Continuity": {
                "docstring": "Stitch together the points with tangent continuity.Default is 'false'."
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "parameterU": {
                "docstring": "The U parameter value on surface for a point constraint.Default:-10000"
            }, 
            "parameterV": {
                "docstring": "The V parameter value on surface for a point constraintDefault:-10000"
            }, 
            "positionalContinuity": {
                "docstring": "Toggle on(off) G0 continuous at edge corresponding to multi index.Default:true"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)"
            }, 
            "stepCount": {
                "docstring": "Step count for the number of discretizations.Default:20"
            }, 
            "tangentialContinuity": {
                "docstring": "Toggle on(off) G1 continuity across edge corresponding to multi index.Default:false"
            }, 
            "togglePointNormals": {
                "docstring": "Toggle on(off) normal point constraints on the surface.Default:false"
            }, 
            "togglePointPosition": {
                "docstring": "Toggle on(off) position point constraints on the surface.Default:true"
            }, 
            "toggleTolerance": {
                "docstring": "Toggle on(off) so as to use Tolerance or specified steps for discretization.Default:false"
            }, 
            "tolerance": {
                "docstring": "Tolerance to use while discretizing the edgeDefault:0.1"
            }
        }
    }, 
    "stringArrayIntersector": {
        "description": "The stringArrayIntersector command creates and edits an object which is able to efficiently intersect large string arrays. The intersector object maintains a sense of \"the intersection so far\", and updates the intersection when new string arrays are provided using the -i/intersect flag. Note that the string intersector object may be deleted using the deleteUI command. ", 
        "flags": {
            "allowDuplicates": {
                "docstring": "Should the intersector allow duplicates in the input arrays (true), or combine all duplicate entries into a single, unique entry (false). This flag must be used when initially creating the intersector. Default is 'false'."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "intersect": {
                "docstring": "Intersect the specified string array with the current intersection being maintained by the intersector."
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": "Reset the intersector to begin a new intersection.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "stroke": {
        "description": "The stroke command creates a new Paint Effects stroke node. ", 
        "flags": {
            "name": {
                "docstring": "Sets the name of the stroke to the input string"
            }, 
            "pressure": {
                "docstring": "On creation, allows the copying of the pressure mapping settings from the Paint Effects Tool. Default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "seed": {
                "docstring": "Sets the random seed for this stroke."
            }
        }
    }, 
    "subdAutoProjection": {
        "description": "Projects a texture map onto an object, using several orthogonal projections simultaneously. The argument is a face selection list. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "layout": {
                "docstring": "What layout algorithm should be used:0 UV pieces are aligned along the U axis.1 UV pieces are moved in a square shape."
            }, 
            "layoutMethod": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "optimize": {
                "docstring": "Use two different flavors for the cut generation.0 Every face is assigned to the best plane. This optimizes the map distortion.1 Small UV pieces are incorporated into larger ones, when the extra distortion introduced is reasonable. This tends to produce fewer UV pieces."
            }, 
            "percentageSpace": {
                "docstring": "When layout is set to square, this value is a percentage of the texture area which is added around each UV piece. It can be used to ensure each UV piece uses different pixels in the texture.Maximum value is 5 percent."
            }, 
            "planes": {
                "docstring": "Number of intermediate projections used. Valid numbers are 4, 5, 6, 8, and 12.C: Default is 6."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scale": {
                "docstring": "How to scale the pieces, after projections:0 No scale is applied.1 Uniform scale to fit in unit square.2 Non proportional scale to fit in unit square."
            }, 
            "skipIntersect": {
                "docstring": "When on, self intersection of UV pieces are not tested. This makes the projection faster and produces fewer pieces, but may lead to overlaps in UV space."
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is \"off\".Common flags"
            }
        }
    }, 
    "subdCleanTopology": {
        "description": "Command cleans topology of subdiv surfaces - at all levels. It cleans the geometry of vertices that satisfy the following conditions: - Zero edits - Default uvs (uvs obtained by subdividing parent face). - No creases. ", 
        "flags": {}
    }, 
    "subdCollapse": {
        "description": "This command converts a takes a subdivision surface, passed as the argument, and produces a subdivision surface with a number of hierarchy levels \"removed\". Returns the name of the subdivision surface created and optionally the DG node that does the conversion. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "level": {
                "docstring": "The level which will now become the base meshDefault:0Advanced flags"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dep. node (where applicable)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "subdDisplayMode": {
        "description": "", 
        "flags": {
            "hideFaceGadgets": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "showComponentsAsNumerals": {
                "docstring": ""
            }, 
            "showFaceRegions": {
                "docstring": ""
            }, 
            "showVisualEdgeVertices": {
                "docstring": ""
            }, 
            "showVisualEdges": {
                "docstring": ""
            }, 
            "subdivEdgeMask": {
                "docstring": ""
            }
        }
    }, 
    "subdDuplicateAndConnect": {
        "description": "This command duplicates the input subdivision surface object, connects up the outSubdiv attribute of the original subd shape to the create attribute of the newly created duplicate shape and copies over the shader assignments from the original shape to the new duplicated shape. The command will fail if no objects are selected or sent as argument or if the object sent as argument is not a subdivision surface object. ", 
        "flags": {}
    }, 
    "subdEditUV": {
        "description": "Command edits uvs on subdivision surfaces. When used with the query flag, it returns the uv values associated with the specified components. ", 
        "flags": {
            "angle": {
                "docstring": "Specifies the angle value (in degrees) that the uv values are to be rotated by."
            }, 
            "pivotU": {
                "docstring": "Specifies the pivot value, in the u direction, about which the scale or rotate is to be performed."
            }, 
            "pivotV": {
                "docstring": "Specifies the pivot value, in the v direction, about which the scale or rotate is to be performed."
            }, 
            "query": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "Specifies whether this command is editing the values relative to the currently existing values. Default is true;"
            }, 
            "rotation": {
                "docstring": "Specifies whether this command is editing the values with rotation values"
            }, 
            "scale": {
                "docstring": "Specifies whether this command is editing the values with scale values"
            }, 
            "scaleU": {
                "docstring": "Specifies the scale value in the u direction."
            }, 
            "scaleV": {
                "docstring": "Specifies the scale value in the v direction."
            }, 
            "uValue": {
                "docstring": "Specifies the value, in the u direction - absolute if relative flag is false.."
            }, 
            "uvSetName": {
                "docstring": "Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "vValue": {
                "docstring": "Specifies the value, in the v direction - absolute if relative flag is false.."
            }
        }
    }, 
    "subdLayoutUV": {
        "description": "Move UVs in the texture plane to avoid overlaps. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "flipReversed": {
                "docstring": "If this flag is turned on, the reversed UV pieces are fliped."
            }, 
            "layout": {
                "docstring": "How to move the UV pieces, after cuts are applied:0 No move is applied.1 Layout the pieces along the U axis.2 Layout the pieces in a square shape."
            }, 
            "layoutMethod": {
                "docstring": "Which layout method to use:0 Block Stacking.1 Shape Stacking."
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "percentageSpace": {
                "docstring": "When layout is set to square, this value is a percentage of the texture area which is added around each UV piece. It can be used to ensure each UV piece uses different pixels in the texture.Maximum value is 5 percent."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rotateForBestFit": {
                "docstring": "0 No rotation is applied. 1 Only allow 90 degree rotations. 2 Allow free rotations."
            }, 
            "scale": {
                "docstring": "How to scale the pieces, after move and cuts:0 No scale is applied.1 Uniform scale to fit in unit square.2 Non proportional scale to fit in unit square."
            }, 
            "separate": {
                "docstring": "Which UV edges should be cut:0 No cuts.1 Cut only along folds.2 Make all necessary cuts to avoid all intersections."
            }, 
            "worldSpace": {
                "docstring": "If true, performs the operation in world space coordinates as opposed to local space.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "subdListComponentConversion": {
        "description": "This command converts subdivision surface components from one or more types to another one or more types, and returns the list of the conversion. It doesn't change the currently selected objects. Use the \"-in/internal\" flag to specify conversion to \"connected\" vs. \"contained\" components. For example, if the internal flag is specified when converting from subdivision surface vertices to faces, then only faces that are entirely contained by the vertices will be returned. If the internal flag is not specified, then all faces that are connected to the vertices will be returned. ", 
        "flags": {
            "border": {
                "docstring": ""
            }, 
            "fromEdge": {
                "docstring": "Indicates the component type to convert from: Edges"
            }, 
            "fromFace": {
                "docstring": "Indicates the component type to convert from: Faces"
            }, 
            "fromUV": {
                "docstring": "Indicates the component type to convert from: UVs"
            }, 
            "fromVertex": {
                "docstring": "Indicates the component type to convert from: Vertex"
            }, 
            "internal": {
                "docstring": "Applicable when converting from \"smaller\" component types to larger ones. Specifies conversion to \"connected\" vs. \"contained\" components. See examples below.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "toEdge": {
                "docstring": "Indicates the component type to convert to: Edges"
            }, 
            "toFace": {
                "docstring": "Indicates the component type to convert to: Faces"
            }, 
            "toUV": {
                "docstring": "Indicates the component type to convert to: UVs"
            }, 
            "toVertex": {
                "docstring": "Indicates the component type to convert to: Vertices"
            }, 
            "uvShell": {
                "docstring": "Will return uv components within the same UV shell. Only works with flags -tuv and -fuv."
            }, 
            "uvShellBorder": {
                "docstring": "Will return uv components on the border within the same UV shell. Only works with flags -tuv and -fuv."
            }
        }
    }, 
    "subdMapCut": {
        "description": "Cut along edges of the texture mapping. The cut edges become map borders. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable).Q: When queried, this flag returns an int.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "subdMapSewMove": {
        "description": "This command can be used to Move and Sew together separate UV pieces along geometric edges. UV pieces that correspond to the same geometric edge, are merged together by moving the smaller piece to the larger one.The argument is a UV selection list. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable).Q: When queried, this flag returns an int.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "limitPieceSize": {
                "docstring": "When on, this flag tells that the face number limit described above should be used."
            }, 
            "name": {
                "docstring": "Name the resulting object."
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "numberFaces": {
                "docstring": "Maximum number of faces in a UV piece. When trying to combine two UV pieces into a single one, the merge operation is rejected if the smaller piece has more faces than the number specified by this flag.This flag is only used when limitPieceSizeis set to on.Common flags"
            }, 
            "query": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "subdMatchTopology": {
        "description": "Command matches topology across multiple subdiv surfaces - at all levels. ", 
        "flags": {
            "frontOfChain": {
                "docstring": "This command is used to specify that the new addTopology node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the addTopology node will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "subdMirror": {
        "description": "This command takes a subdivision surface, passed as the argument, and produces a subdivision surface that is a mirror. Returns the name of the subdivision surface created and optionally the DG node that does the mirroring. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable)"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dep. node (where applicable)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "xMirror": {
                "docstring": "Mirror the vertices in XDefault:false"
            }, 
            "yMirror": {
                "docstring": "Mirror the vertices in YDefault:false"
            }, 
            "zMirror": {
                "docstring": "Mirror the vertices in ZDefault:falseAdvanced flags"
            }
        }
    }, 
    "subdPlanarProjection": {
        "description": "Projects a map onto an object, using an orthogonal projection. The piece of the map defined from isu, isv, icx, icy area, is placed at pcx, pcy, pcz location. ", 
        "flags": {
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "createNewMap": {
                "docstring": "This flag when set true will create a new map with a the name passed in, if the map does not already exist.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "imageCenter": {
                "docstring": "This flag specifies the center point of the 2D model layout.C: Default is 0.5 0.5.Q: When queried, this flag returns a float[2]."
            }, 
            "imageCenterX": {
                "docstring": "This flag specifies X for the center point of the 2D model layout.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "imageCenterY": {
                "docstring": "This flag specifies Y for the center point of the 2D model layout.C: Default is 0.5.Q: When queried, this flag returns a float."
            }, 
            "imageScale": {
                "docstring": "This flag specifies the UV scale : Enlarges or reduces the 2D version of the model in U or V space relative to the 2D centerpoint.C: Default is 1.0 1.0.Q: When queried, this flag returns a float[2]."
            }, 
            "imageScaleU": {
                "docstring": "This flag specifies the U scale : Enlarges or reduces the 2D version of the model in U space relative to the 2D centerpoint.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "imageScaleV": {
                "docstring": "This flag specifies the V scale : Enlarges or reduces the 2D version of the model in V space relative to the 2D centerpoint.C: Default is 1.0.Q: When queried, this flag returns a float."
            }, 
            "insertBeforeDeformers": {
                "docstring": "This flag specifies if the projection node should be inserted before or after deformer nodes already applied to the shape. Inserting the projection after the deformer leads to texture swimming during animation and is most often undesirable.C: Default is on."
            }, 
            "keepImageRatio": {
                "docstring": ""
            }, 
            "mapDirection": {
                "docstring": "This flag specifies the mapping direction.'x', 'y' and 'z' projects the map along the corresponding axis.'c' projects along the current camera viewing direction.'p' does perspective projection if current camera is perspective.'b' projects along the best plane fitting the objects selected."
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "projectionCenter": {
                "docstring": "This flag specifies the origin point from which the map is projected.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "projectionCenterX": {
                "docstring": "This flag specifies X for the origin point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionCenterY": {
                "docstring": "This flag specifies Y for the origin point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionCenterZ": {
                "docstring": "This flag specifies Z for the origin point from which the map is projected.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "projectionHeight": {
                "docstring": ""
            }, 
            "projectionScale": {
                "docstring": "This flag specifies the width and the height of the map relative to the 3D projection axis.C: Default is 1.0 1.0.Q: When queried, this flag returns a float[2]."
            }, 
            "projectionWidth": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "rotate": {
                "docstring": "This flag specifies the mapping rotate angles.C: Default is 0.0 0.0 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateX": {
                "docstring": "This flag specifies X mapping rotate angle.C: Default is 0.0.Q: When queried, this flag returns a float[3]."
            }, 
            "rotateY": {
                "docstring": "This flag specifies Y mapping rotate angle.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotateZ": {
                "docstring": "This flag specifies Z mapping rotate angle.C: Default is 0.0.Q: When queried, this flag returns a float."
            }, 
            "rotationAngle": {
                "docstring": "This flag specifies the rotation angle in the mapping space. When the angle is positive, then the map rotates counterclockwise on the mapped model, whereas when it is negative then the map rotates lockwise on the mapped model.C: Default is 10.0.Q: When queried, this flag returns a float."
            }, 
            "smartFit": {
                "docstring": ""
            }, 
            "worldSpace": {
                "docstring": "This flag specifies which reference to use. If \"on\" : all geometrical values are taken in world reference. If \"off\" : all geometrical values are taken in object reference.C: Default is \"off\".Q: When queried, this flag returns an int."
            }
        }
    }, 
    "subdToBlind": {
        "description": "The subdivision surface hierarchical edits will get copied into blind data on the given polygon. The polygon face count and topology must match the subdivision surface base mesh face count and topology. If they don't, the blind data will still appear, but is not guaranteed to produce the same result when converted back to a subdivision surface.The command takes a single subdivision surface and a single polygonal object. Additional subdivision surfaces or polygonal objects will be ignored. ", 
        "flags": {
            "absolutePosition": {
                "docstring": "If set to true, the hierarchical edits are represented as the point positions, not the point offsets. Most of the time, this is not desirable, but if you're just going to be merging/deleting a bunch of things and not move any vertices, then you could set it to true. False is the default and saves the offsets.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "includeCreases": {
                "docstring": "If set, the creases get transfered as well. With it false, the subdivision surface created from the blind data + polygon will have lost all the craese information. The default is false."
            }, 
            "includeZeroOffsets": {
                "docstring": "If set, the zero offset will get included in the blind data. This will greatly increase the size of the blind data, but will also let you keep all created vertices in the conversion back to polys. This flag does not change the behaviour for the vertices up to and including level 2 as they're always created. If not set, only the edited vertices will be included in the blind data. This will still maintain the shape of your object faithfully. The default is false."
            }
        }
    }, 
    "subdToNurbs": {
        "description": "", 
        "flags": {
            "addUnderTransform": {
                "docstring": ""
            }, 
            "applyMatrixToResult": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": ""
            }, 
            "outputType": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "subdToPoly": {
        "description": "This command tessellates a subdivision surface and produces polygon. The name of the new polygon is returned. If construction history is ON, then the name of the new dependency node is returned as well. ", 
        "flags": {
            "addUnderTransform": {
                "docstring": ""
            }, 
            "applyMatrixToResult": {
                "docstring": "If true, the matrix on the input geometry is applied to the object and the resulting geometry will have identity matrix on it. If false the conversion is done on the local space object and the resulting geometry has the input object's matrix on it.Default:trueAdvanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "connectShaders": {
                "docstring": "If true, all shader assignment will be copied from the original subdiv surface to the converted polygonal surface.Default:trueFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off (where applicable)"
            }, 
            "copyUVTopology": {
                "docstring": "Copy over uv topology (shared/unshared) from the original subdivision surface to the converted polygonal mesh.Default:false"
            }, 
            "depth": {
                "docstring": "The depth at which constant-depth tessellates the surfaceDefault:0"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "extractPointPosition": {
                "docstring": "Determines how the position of a mesh point is calculated If on the position of the mesh point is returned. If off the position of the point of the surface is returned.Default:false"
            }, 
            "format": {
                "docstring": "Format: 0 - Uniform1 - Adaptive2 - Polygon Count3 - VerticesDefault:0"
            }, 
            "inSubdCVId": {
                "docstring": "Input CV Id"
            }, 
            "inSubdCVIdLeft": {
                "docstring": "Higher 32 bit integer of the input CV Id"
            }, 
            "inSubdCVIdRight": {
                "docstring": "Lower 32 bit integer of the input CV Id"
            }, 
            "maxPolys": {
                "docstring": "The maximum number of polygons at which by polygons tessellates. If this attribute is greater than zero, it will override the sample count and depth attributes.Default:0"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dep. node (where applicable)"
            }, 
            "outSubdCVId": {
                "docstring": "Output CV Id"
            }, 
            "outSubdCVIdLeft": {
                "docstring": "Higher 32 bit integer of the output CV Id"
            }, 
            "outSubdCVIdRight": {
                "docstring": "Lower 32 bit integer of the output CV Id"
            }, 
            "outv": {
                "docstring": "Out Vertices corresponding to the inSubDCVs."
            }, 
            "preserveVertexOrdering": {
                "docstring": "Preserve vertex ordering in conversionDefault:true"
            }, 
            "query": {
                "docstring": ""
            }, 
            "sampleCount": {
                "docstring": "The number of samples per faceDefault:1"
            }, 
            "shareUVs": {
                "docstring": "Force sharing of uvs on all common vertices - the value of this attribute gets overridden by the value of the copyUVTopology attribute.Default:false"
            }, 
            "subdNormals": {
                "docstring": "Keep subdiv surface normalsDefault:false"
            }
        }
    }, 
    "subdTransferUVsToCache": {
        "description": "The subdivision surface finer level uvs will get copied to the polygonToSubd node sent in as argument.The command takes a single subdivision surface and a single polygonToSubd node as input. Additional inputs will be ignored. Please note that this command is an internal command and is to be used with care, directly by the user ", 
        "flags": {}
    }, 
    "subdiv": {
        "description": "Provides useful information about the selected subdiv or components, such as the deepest subdivided level, the children or parents of the currently selected components, etc. In query mode, return type is based on queried flag.", 
        "flags": {
            "currentLevel": {
                "docstring": "When queried, this flag returns an integer representing the level of the currently selected subdiv surface component(s). Returns -1, if there are more than one level of CVs are selected, (even if they are from different objects) Returns -2, if there are no input subdiv CVs to process."
            }, 
            "currentSubdLevel": {
                "docstring": "When queried, this flag returns an integer representing the level of the currently selected subdiv surface, regardless of whether components are selected or not. Returns -2, if there are no input subdiv CVs to process."
            }, 
            "deepestLevel": {
                "docstring": "When queried, this flag returns an integer representing the deepest level to which the queried subdiv surface has been subdivided."
            }, 
            "displayLoad": {
                "docstring": "When queried, this flag prints the display load of selected subdiv"
            }, 
            "edgeStats": {
                "docstring": "When queried, this flag prints stats on the current subd."
            }, 
            "faceStats": {
                "docstring": "When queried, this flag prints stats on the current subd."
            }, 
            "maxPossibleLevel": {
                "docstring": "When queried, this flag returns an integer representing the maximum possible level to which the queried subdiv surface can been subdivided."
            }, 
            "proxyMode": {
                "docstring": "When queried, this flag returns an integer representing whether or not the subdivision surface is in \"polygon proxy\" mode. \"Proxy\" mode allows the base mesh of a subdivision surface without construction history to be edited using the polygonal editing tools. Returns 1, if the subdivision surface is in \"polygon proxy\" mode. Returns 0, if the surface is not currently in \"proxy\" mode, but could be put into \"proxy\" mode since it has no construction history. (This state is also known as \"standard\" mode.) Returns 2, if the surface is not in \"proxy\" mode and cannot be put into proxy mode, as it has construction history.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "smallOffsets": {
                "docstring": "When queried, this flag prints the number of subdiv vertices in the hierarchy that have a small enough offset so that the vertex is not required"
            }
        }
    }, 
    "subdivCrease": {
        "description": "Set the creasing on subdivision mesh edges or mesh points that are on the selection list. ", 
        "flags": {
            "sharpness": {
                "docstring": "Specifies the sharpness value to set the crease toFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "subdivDisplaySmoothness": {
        "description": "Sets or querys the display smoothness of subdivision surfaces on the selection list or of all subdivision surfaces if the -all option is set. Smoothness options are; rough, medium, or fine. Rough is the default. ", 
        "flags": {
            "all": {
                "docstring": "If set, change smoothness for all subdivision surfacesFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "smoothness": {
                "docstring": "Smoothness - 1 rough, 2 medium, 3 fine"
            }
        }
    }, 
    "subgraph": {
        "description": "", 
        "flags": {}
    }, 
    "substituteGeometry": {
        "description": "This command can be used to replace the geometry which is already connected to deformers with a new geometry. The weights on the old geometry will be retargeted to the new geometry. ", 
        "flags": {
            "disableNonSkinDeformers": {
                "docstring": "This flag controls the state of deformers other than skin deformers after the substitution has taken place. If the flag is true then non-skin deformer nodes are left in a disabled state at the completion of the command. Default value is false."
            }, 
            "newGeometryToLayer": {
                "docstring": "Create a new layer for the new geometry."
            }, 
            "oldGeometryToLayer": {
                "docstring": "Create a new layer and move the old geometry to this layer"
            }, 
            "reWeightDistTolerance": {
                "docstring": "Specify the distance tolerance value to be used for retargeting weights. While transferring weights the command tries to find the corresponding vertices by overlapping the geometries with all deformers disabled. Sometimes this results in selection of unrelated vertices. (Example when a hole in the old geometry has been filled with new vertices in the new geometry.) This distance tolerance value is used to detect this kind of faults and either ignore these cases or to vary algorithm to find more corresponding vertices.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "retainOldGeometry": {
                "docstring": "A copy of the old geometry should be retained"
            }
        }
    }, 
    "superCtx": {
        "description": "", 
        "flags": {
            "attach": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "surface": {
        "description": "The cmd creates a NURBS spline surface (rational or non rational). The surface is created by specifying control vertices (CV's) and knot sequences in the U and V direction. You cannot query the properties of the surface using this command. See examples below. ", 
        "flags": {
            "degreeU": {
                "docstring": "Degree in surface U direction. Default is degree 3."
            }, 
            "degreeV": {
                "docstring": "Degree in surface V direction. Default is degree 3."
            }, 
            "formU": {
                "docstring": "The string for open is \"open\" , for closed is \"closed\" or for periodic is \"periodic\" in U."
            }, 
            "formV": {
                "docstring": "The string for open is \"open\" , for closed is \"closed\" or for periodic is \"periodic\" in V."
            }, 
            "knotU": {
                "docstring": "Knot value(s) in U direction. One flag per knot value. There must be (numberOfPointsInU + degreeInU - 1) knots and the knot vector must be non-decreasing."
            }, 
            "knotV": {
                "docstring": "Knot value(s) in V direction. One flag per knot value. There must be (numberOfPointsInV + degreeInV - 1) knots and the knot vector must be non-decreasing."
            }, 
            "name": {
                "docstring": ""
            }, 
            "objectSpace": {
                "docstring": ""
            }, 
            "point": {
                "docstring": "To specify non rational CV with (x, y, z) values. \"linear\" means that this flag can take values with units. Note that you must specify (degree+1) surface points in any direction to create a visible surface span. eg. if the surface is degree 3 in the U direction, you must specify 4 CVs in the U direction. Points are specified in rows of U and columns of V. If you want to incorporate units, add the unit name to the value, eg. \"-p 3.3in 5.5ft 6.6yd\""
            }, 
            "pointWeight": {
                "docstring": "To specify rational CV with (x, y, z, w) values. \"linear\" means that this flag can take values with units. Note that you must specify (degree+1) surface points in any direction to create a visible surface span. eg. if the surface is degree 3 in the U direction, you must specify 4 CVs in the U direction. Points are specified in rows of U and columns of V.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "worldSpace": {
                "docstring": ""
            }
        }
    }, 
    "surfaceSampler": {
        "description": "Maps surface detail from a source surface to a new texture map on a target surface. Both objects must be selected when the command is invoked, with the source surface selected first, and the target last. ", 
        "flags": {
            "camera": {
                "docstring": "Specify the camera to use for camera specific lighting calculations such as specular highlights or reflections."
            }, 
            "fileFormat": {
                "docstring": "The image format as a file extension (e.g. \"dds\"). This must be included once for every output map specified."
            }, 
            "filename": {
                "docstring": "The filename to use when creating the map. This must be included once for every output map specified."
            }, 
            "filterSize": {
                "docstring": "The filter size to use in pixels. Larger values (e.g. over 2.0) will produce smoother/softer results, while values closer to 1.0 will produce sharper results."
            }, 
            "filterType": {
                "docstring": "The filter type to use. 0 is a Guassian filter, 1 is a triangular filter, 2 is a box filter."
            }, 
            "flipU": {
                "docstring": "Flip the U coordinate of the generated image."
            }, 
            "flipV": {
                "docstring": "Flip the V coordinate of the generated image.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "ignoreMirroredFaces": {
                "docstring": "Stops reverse wound (i.e. mirrored) faces from contributing to the map generation."
            }, 
            "ignoreTransforms": {
                "docstring": "Controls whether transforms are used (meaning the search is performed in worldspace), or not (meaning the search is performed in object space)."
            }, 
            "mapHeight": {
                "docstring": "Pixel width of the generated map. This must be included once for every output map specified."
            }, 
            "mapMaterials": {
                "docstring": "Where appropriate (e.g. normal maps), this controls whether the material should be included when sampling the map attribute. This must be included once for every output map specified."
            }, 
            "mapOutput": {
                "docstring": "Specifies a new output map to create. One of \"normal\", \"displacement\" \"diffuseRGB\", \"litAndShadedRGB\", or \"alpha\""
            }, 
            "mapSpace": {
                "docstring": "The space to generate the map in. Valid keyword is \"object\". Default is tangent space. This must be included once for every output map specified."
            }, 
            "mapWidth": {
                "docstring": "Pixel width of the generated map. Some output image formats require even or power of 2. This must be included once for every output map specified."
            }, 
            "maxSearchDistance": {
                "docstring": "Controls the maximum distance away from a target surface that will be searched for source surfaces. A value of 0 indicates no limit. When generated maps include artifacts from the \"other side\" of an object, try setting this value to a distance approximately equal to the radius of the object. If this flag is included, it must be included once for every target."
            }, 
            "maximumValue": {
                "docstring": "The maximum value to include in the map. This allows control of how floating point values (like displacement) are quantised into integer image formats."
            }, 
            "overscan": {
                "docstring": "The number of additional pixels to render around UV borders. This will help to minimise texel filtering artifacts on UV seams. When mipmaps are going to be generated for the texture a higher value may be necessary (in addition to a filterSize greater than 1)."
            }, 
            "searchCage": {
                "docstring": "Specifies a search envelope surface to use as a search guide when looking for source surfaces. If this flag is included, it must be included once for every target."
            }, 
            "searchMethod": {
                "docstring": "Controls the search method used to match sample points on a target surface to points on the sources. 0 is closest to envelope, 1 is prefer any intersection inside envelope to intersections outside it, and 2 is only use intersections inside envelope."
            }, 
            "searchOffset": {
                "docstring": "Specifies a fixed offset from a target surface to use as the starting point when looking for source surfaces. This value is only used when no search cage is specified for a given target. If this flag is included, it must be included once for every target."
            }, 
            "shadows": {
                "docstring": "Where appropriate (e.g. lit and shaded), this controls whether shadows are included in the calculation. Currently only depth map shadows are supported."
            }, 
            "source": {
                "docstring": "Specifies a surface to use as a sampling source"
            }, 
            "sourceUVSpace": {
                "docstring": "Specifies that the transfer of data between the surfaces should be done in UV space and specifies the name of the UV set on the source surface(s) that should be used as the transfer space."
            }, 
            "superSampling": {
                "docstring": "Controls the number of sampling points calculated for each output value. The algorithm will use 2 ^ n squared samples for each point (so a value of 0 will use a single sample, while a value of 3 will calculate 64 samples for each point)."
            }, 
            "target": {
                "docstring": "Specified a surface to sample output information for."
            }, 
            "targetUVSpace": {
                "docstring": "Specifies that the transfer of data between the surfaces should be done in UV space and specifies the name of the UV set on the target surface(s) that should be used as the transfer space."
            }, 
            "useGeometryNormals": {
                "docstring": "Controls whether geometry or surface normals are used for surface searching. Using geometry normals will ensure a smooth mapping but can introduce distorted mappings where there are large distances between the source and target surfaces. Surface normals can introduce overlapping or discontinuous mappings, but does allow map distortion to be influenced by surface normal direction."
            }, 
            "uvSet": {
                "docstring": "The name of the UV set to use when creating output maps. If this flag is included, it must be included once for every target."
            }
        }
    }, 
    "surfaceShaderList": {
        "description": "Add/Remove a relationship between an object and the current shading group. In query mode, return type is based on queried flag.", 
        "flags": {
            "add": {
                "docstring": "add object(s) to shader group list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "remove object(s) to shader group list.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "swatchDisplayPort": {
        "description": "This command creates a 3dPort that displays a swatch representing the shading node. The optional argument is the name of the 3dPort. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "borderColor": {
                "docstring": "The border color of the swatch."
            }, 
            "borderWidth": {
                "docstring": "The border width of the swatch. The value will be clamped between 0 and 4."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "pressCommand": {
                "docstring": "Specifies the command to be run when the swatch is clicked on.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "renderSize": {
                "docstring": "The render size of the swatch. The value will be clamped between 32 and 512."
            }, 
            "shadingNode": {
                "docstring": "Name of the shadingNode."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "widthHeight": {
                "docstring": "The width and height of the port."
            }
        }
    }, 
    "swatchRefresh": {
        "description": "The swatchRefreshcommand causes image source node swatches to be refreshed on screen. The purpose of this command is to provide a mechanism to trigger a swatch refresh in cases that are not subject to dirty propagation in the dependency graph. This command only works with imageSource-derived node types. Invoking this command with no arguments will cause all imageSource swatches to be refreshed. ", 
        "flags": {}
    }, 
    "switchTable": {
        "description": "This command creates/edits/queries the switch table control. The optional argument is the name of the control. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label1": {
                "docstring": "Set the label of the first column"
            }, 
            "label2": {
                "docstring": "Set the label of the second column"
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectedRow": {
                "docstring": "The current row selected."
            }, 
            "switchNode": {
                "docstring": "The switch node to be displayed in the control."
            }, 
            "underPointerRow": {
                "docstring": "The row under the pointer.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "symbolButton": {
        "description": "This command creates a symbol button. A symbol button behaves like a regular button, the only difference is a symbol button displays an image rather that a text label. A command may be attached to the button which will be executed when the button is pressed. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "command": {
                "docstring": "Command executed when the symbol button is pressed.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "image": {
                "docstring": "Image for the button."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "symbolCheckBox": {
        "description": "This command creates a symbol check box. A symbol check box is a simple control containing a pixmap and a state of either on or off. Commands can be attached to any or all of the following events: when the symbol check box is turned on, turned off, or simply when it's state is changed. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the check box's state is changed. Note that this flag should not be used in conjunction with onCommand and offCommand. That is, one should either use changeCommand and test the state of the check box from inside the callback, or use onCommand and offCommand as separate callbacks."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "disableOffImage": {
                "docstring": "Image displayed when the check box is off and disabled."
            }, 
            "disableOnImage": {
                "docstring": "Image displayed when the check box is on and disabled."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "image": {
                "docstring": "Image of the check box."
            }, 
            "innerMargin": {
                "docstring": "This flag will revert the symbolCheckBox to its pre Maya 2.5 behaviour of having a 2 pixel inner margin. This flag is for backward compatibility on Linux only, and will be removed in future releases.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "offCommand": {
                "docstring": "Command executed when the symbol check box is turned off."
            }, 
            "offImage": {
                "docstring": "Image displayed when the check box is off."
            }, 
            "onCommand": {
                "docstring": "Command executed when the symbol check box is turned on."
            }, 
            "onImage": {
                "docstring": "Image displayed when the check box is on."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "value": {
                "docstring": "Value of the check box."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "symmetricModelling": {
        "description": "This command allows you to change the symmetric modelling options. Symmetric modelling is an option that allows for reflection of basic manipulator actions such as move, rotate, and scale. In query mode, return type is based on queried flag.", 
        "flags": {
            "about": {
                "docstring": "Set the space in which symmetry should be calculated (object or world). When queried, returns a string which is the current space being used."
            }, 
            "axis": {
                "docstring": "Set the current axis to be reflected over. When queried, returns a string which is the current axis"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "preserveSeam": {
                "docstring": "Controls whether selection or symmetry should take priority on the plane of symmetry. When queried, returns an int for the option"
            }, 
            "query": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": ""
            }, 
            "seamFalloffCurve": {
                "docstring": "Set the seam's falloff curve, used to control the seam strength within the seam tolerance. The string is a comma separated list of sets of 3 values for each curve point. When queried, returns a string which is the current space being used.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "seamTolerance": {
                "docstring": "Set the seam tolerance used for reflection. When preserveSeam is enabled, this tolerance controls the width of the enforced seam. When queried, returns a float of the seamTolerance"
            }, 
            "symmetry": {
                "docstring": "Set the symmetry option on or off When queried, returns an int for the option"
            }, 
            "tolerance": {
                "docstring": "Set the tolerance of reflection. When queried, returns a float of the tolerance"
            }
        }
    }, 
    "sysFile": {
        "description": "This command provides a system independent way to create a directory or to rename or delete a file. ", 
        "flags": {
            "copy": {
                "docstring": "Copy the file to the name given by the newFileName paramter."
            }, 
            "delete": {
                "docstring": "Deletes the file."
            }, 
            "makeDir": {
                "docstring": "Create the directory path given in the parameter. This will create the entire path if more than one directory needs to be created."
            }, 
            "move": {
                "docstring": "Behaves identically to the -rename flag and remains for compatibility with old scripts"
            }, 
            "removeEmptyDir": {
                "docstring": "Delete the directory path given in the parameter if the directory is empty. The command will not delete a directory which is not empty.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "rename": {
                "docstring": "Rename the file to the name given by the newFileName parameter."
            }
        }
    }, 
    "tabLayout": {
        "description": "This command creates a tab group. Tab groups are a specialized form of control layouts that contain only control layouts. Whenever a control layout is added to a tab group it will have a tab provided for it that allows selection of that group from amongst other tabbed control groups. Only one child of a tab layout is visible at a time. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when a tab is selected interactively. This command is only invoked when the selected tab changes. Re-selecting the current tab will not invoke this command."
            }, 
            "childArray": {
                "docstring": "Returns a string array of the names of the layout's immediate children."
            }, 
            "childResizable": {
                "docstring": "Set to true if you want the child of the control layout to be as wide as the scroll area. You may also indicate a minimum width for the child using the -mcw/minChildWidthflag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "doubleClickCommand": {
                "docstring": "Command executed when a tab is double clicked on. Note that the first click will select the tab and the second click will execute the double click command. Double clicking the current tab will re-invoke the double click command."
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "horizontalScrollBarThickness": {
                "docstring": "Thickness of the horizontal scroll bar. Specify an integer value greater than or equal to zero. This flag has no effect on Windows systems."
            }, 
            "image": {
                "docstring": "Image appearing in top right corner of tab layout."
            }, 
            "imageVisible": {
                "docstring": "Visibility of tab image."
            }, 
            "innerMarginHeight": {
                "docstring": "Margin height for all tab children."
            }, 
            "innerMarginWidth": {
                "docstring": "Margin width for all tab children."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "minChildWidth": {
                "docstring": "Specify a positive non-zero integer value indicating the minimum width the tab layout's children. This flag only has meaning when the -cr/childResizableflag is set to true."
            }, 
            "moveTab": {
                "docstring": "Move the tab from the current index to a new index.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "numberOfChildren": {
                "docstring": "Returns in an int the number of immediate children of the layout."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preSelectCommand": {
                "docstring": "Command executed when a tab is selected but before it's contents become visible. Re-selecting the current tab will not invoke this command. Note that this command is not executed by using either of the -st/selectTabor -sti/selectTabIndexflags."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "scrollable": {
                "docstring": "Puts all children of this layout within a scroll area."
            }, 
            "selectCommand": {
                "docstring": "Command executed when a tab is selected interactively This command will be invoked whenever a tab is selected, ie. re-selecting the current tab will invoke this command. Note that this command is not executed by using either of the -st/selectTabor -sti/selectTabIndexflags."
            }, 
            "selectTab": {
                "docstring": "The name, in short form, of the selected tab. An empty string is returned on query if there are no child tabs."
            }, 
            "selectTabIndex": {
                "docstring": "Identical to the -st/selectTabflag except this flag takes a 1-based index to identify the selected tab. A value of 0 is returned on query if there are not child tabs."
            }, 
            "tabLabel": {
                "docstring": "Set a tab label. The first argument is the name of a control that must be a child of the tab layout. The second argument is the label for the tab associated with that child. If this flag is queried then the tab labels for all the children are returned."
            }, 
            "tabLabelIndex": {
                "docstring": "Identical to the -tl/tabLabelflag except this flag takes a 1-based index to identify the tab you want to set the label for. If this flag is queried the tab labels for all the children are returned."
            }, 
            "tabsVisible": {
                "docstring": "Visibility of the tab labels."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "verticalScrollBarThickness": {
                "docstring": "Thickness of the vertical scroll bar. Specify an integer value greater than or equal to zero. This flag has no effect on Windows systems."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "tangentConstraint": {
        "description": "Constrain an object's orientation based on the tangent of the target curve[s] at the closest point[s] to the object. A tangentConstraint takes as input one or more NURBS curves (the targets) and a DAG transform node (the object). The tangentConstraint orients the constrained object such that the aimVector (in the object's local coordinate system) aligns in world space to combined tangent vector. The upVector (again the the object's local coordinate system) is aligned in world space with the worldUpVector. The combined tangent vector is a weighted average of the tangent vector for each target curve at the point closest to the constrained object. ", 
        "flags": {
            "aimVector": {
                "docstring": "Set the aim vector. This is the vector in local coordinates that points at the target. If not given at creation time, the default value of (1.0, 0.0, 0.0) is used."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "layer": {
                "docstring": "Specify the name of the animation layer where the constraint should be added."
            }, 
            "name": {
                "docstring": "Sets the name of the constraint node to the specified name. Default name is constrainedObjectName_constraintType"
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "removes the listed target(s) from the constraint."
            }, 
            "targetList": {
                "docstring": "Return the list of target objects."
            }, 
            "upVector": {
                "docstring": "Set local up vector. This is the vector in local coordinates that aligns with the world up vector. If not given at creation time, the default value of (0.0, 1.0, 0.0) is used."
            }, 
            "weight": {
                "docstring": "Sets the weight value for the specified target(s). If not given at creation time, the default value of 1.0 is used."
            }, 
            "weightAliasList": {
                "docstring": "Returns the names of the attributes that control the weight of the target objects. Aliases are returned in the same order as the targets are returned by the targetList flag"
            }, 
            "worldUpObject": {
                "docstring": "Set the DAG object use for worldUpType \"object\" and \"objectrotation\". See worldUpType for greater detail. The default value is no up object, which is interpreted as world space."
            }, 
            "worldUpType": {
                "docstring": "Set the type of the world up vector computation. The worldUpType can have one of 5 values: \"scene\", \"object\", \"objectrotation\", \"vector\", or \"none\". If the value is \"scene\", the upVector is aligned with the up axis of the scene and worldUpVector and worldUpObject are ignored. If the value is \"object\", the upVector is aimed as closely as possible to the origin of the space of the worldUpObject and the worldUpVector is ignored. If the value is \"objectrotation\" then the worldUpVector is interpreted as being in the coordinate space of the worldUpObject, transformed into world space and the upVector is aligned as closely as possible to the result. If the value is \"vector\", the upVector is aligned with worldUpVector as closely as possible and worldUpMatrix is ignored. Finally, if the value is \"none\" no twist calculation is performed by the constraint, with the resulting \"upVector\" orientation based previous orientation of the constrained object, and the \"great circle\" rotation needed to align the aim vector with its constraint. The default worldUpType is \"vector\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "worldUpVector": {
                "docstring": "Set world up vector. This is the vector in world coordinates that up vector should align with. See -wut/worldUpType (below)for greater detail. If not given at creation time, the default value of (0.0, 1.0, 0.0) is used."
            }
        }
    }, 
    "targetWeldCtx": {
        "description": "Create a new context to weld vertices together on a poly object. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "mergeToCenter": {
                "docstring": "If mergeToCenter is set to true then the source and target vertices's will be moved to the center before doing the merge. If set to false the source vertex will be moved to the target vertex before doing the merge.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "testPa": {
        "description": "", 
        "flags": {}
    }, 
    "testPassContribution": {
        "description": "", 
        "flags": {
            "renderLayer": {
                "docstring": ""
            }, 
            "renderPass": {
                "docstring": ""
            }
        }
    }, 
    "texLatticeDeformContext": {
        "description": "This command creates a context which may be used to deform UV maps with lattice manipulator. This context only works in the texture UV editor. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "envelope": {
                "docstring": "Specifies the influence of the lattice."
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "latticeColumns": {
                "docstring": "Specifies the number column points the lattice contains. The maximum size lattice is restricted to 8 columns."
            }, 
            "latticeRows": {
                "docstring": "Specifies the number of rows the lattice contains. The maximum size lattice is restricted to 8 rows."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }, 
            "snapPixelMode": {
                "docstring": "Specifies the influenced uv points should be snapped to a pixel center or corner."
            }, 
            "useBoundingRect": {
                "docstring": "When constructing the lattice use the bounding box of the selected UVs for the extents of the lattice. When this is disabled the extents of the marquee selections are used as the extents for the lattice.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "texManipContext": {
        "description": "Command used to register the texManipCtx tool. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "texMoveContext": {
        "description": "This command can be used to create, edit, or query a texture editor move manip context. Note that the above flags control the global behaviour of all texture editor move manip contexts. Changing one context independently is not allowed. Changing a context's behaviour using the above flags, will change all existing texture editor move manip contexts. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "position": {
                "docstring": "Returns the current position of the manipulator"
            }, 
            "query": {
                "docstring": ""
            }, 
            "snapComponentsRelative": {
                "docstring": "Value can be : true or false. If true, while snapping a group of UVs, the relative spacing between them will be preserved. If false, all the UVs will be snapped to the target point"
            }, 
            "snapPixelMode": {
                "docstring": "set the snapping mode to be the pixel center or upper left cornerFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "texMoveUVShellContext": {
        "description": "This command can be used to create, edit, or query a texture editor move manip context. Note that the above flags control the global behaviour of all texture editor move manip contexts. Changing one context independently is not allowed. Changing a context's behaviour using the above flags, will change all existing texture editor move manip contexts. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "iterations": {
                "docstring": ""
            }, 
            "mask": {
                "docstring": ""
            }, 
            "position": {
                "docstring": "Returns the current position of the manipulatorFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "shellBorder": {
                "docstring": ""
            }
        }
    }, 
    "texRotateContext": {
        "description": "This command can be used to create, edit, or query a rotate context for the UV Texture Editor. Note that the above flag controls the global behaviour of all texture editor rotate contexts. Changing one context independently is not allowed. Changing a context's behaviour using the above flag, will change all existing texture editor rotate contexts. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "position": {
                "docstring": "Returns the current position of the manipulatorFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "snap": {
                "docstring": ""
            }, 
            "snapRelative": {
                "docstring": ""
            }, 
            "snapValue": {
                "docstring": ""
            }
        }
    }, 
    "texScaleContext": {
        "description": "This command can be used to create, edit, or query a scale context for the UV Texture Editor. Note that the above flag controls the global behaviour of all texture editor scale contexts. Changing one context independently is not allowed. Changing a context's behaviour using the above flag, will change all existing texture editor scale contexts. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "position": {
                "docstring": "Returns the current position of the manipulatorFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "snap": {
                "docstring": ""
            }, 
            "snapRelative": {
                "docstring": ""
            }, 
            "snapValue": {
                "docstring": ""
            }
        }
    }, 
    "texSelectContext": {
        "description": "Command used to register the texSelectCtx tool. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "texSelectShortestPathCtx": {
        "description": "Creates a new context to select shortest edge path between two vertices or UVs in the texture editor window. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "texSmoothContext": {
        "description": "", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "pinBorder": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "space": {
                "docstring": ""
            }
        }
    }, 
    "texSmudgeUVContext": {
        "description": "This command creates a context for smudge UV tool. This context only works in the texture UV editor. ", 
        "flags": {
            "dragSlider": {
                "docstring": "radius | none Enables the drag slider mode. This is to support brush resizing while holding the 'b' or 'B' button."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "effectType": {
                "docstring": "fixed | smudge Specifies the effect of the tool. In fixed mode, the UVs move as if they are attached by a rubber band. In smudge mode the UVs are moved as the cursor is dragged over the UVs."
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "functionType": {
                "docstring": "exponential | linear | constant. Specifies how UVs fall off from the center of influence."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "pressure": {
                "docstring": "Pressure value when effect type is set to smudge."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "Radius of the smudge tool. All UVs within this radius are affected by the tool"
            }, 
            "smudgeIsMiddle": {
                "docstring": "By default, the left mouse button initiates the smudge. However, this conflicts with selection. When smudgeIsMiddle is on, smudge mode is activated by the middle mouse button instead of the left mouse button.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "texWinToolCtx": {
        "description": "This class creates a context for the View Tools \"track\", \"dolly\", and \"box zoom\" in the texture window. ", 
        "flags": {
            "alternateContext": {
                "docstring": ""
            }, 
            "boxzoom": {
                "docstring": "Perform Box ZoomFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dolly": {
                "docstring": "Dollies the view"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "toolName": {
                "docstring": ""
            }, 
            "track": {
                "docstring": "Tracks the view"
            }
        }
    }, 
    "text": {
        "description": "Create a simple text label control. ", 
        "flags": {
            "align": {
                "docstring": "The label alignment. Alignment values are \"left\", \"right\", and \"center\". Note that the alignment will only be noticable if the control is wider than the label length. By default, the label is aligned \"center\"."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "dropRectCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is hovering above the drop site. It returns the shape of the rectangle to be drawn to highlight the entry, if the control can receive the dropped data. The MEL version of the callback is of the form: global proc int[] callbackName(string $dropControl, int $x, int $y) The return value is an array of size 4, with the parameters, in order, being the left and top coordinates of the rectangle to be drawn, followed by the width and height. This functionality is currently only implemented in MEL."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "font": {
                "docstring": "The font for the text. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\"."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "hyperlink": {
                "docstring": "Sets the text to be a hyperlink if the argument is true.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The label text. The default label is the name of the control."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "recomputeSize": {
                "docstring": "If true then the control will recompute it's size to just fit the size of the label. If false then the control size will remain fixed as you change the size of the label. The default value of this flag is true."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "wordWrap": {
                "docstring": "If true then label text is wrapped where necessary at word-breaks. If false, it is not wrapped at all. The default value of this flag is false."
            }
        }
    }, 
    "textCurves": {
        "description": "The textCurves command creates NURBS curves from a text string using the specified font. A single letter can be made up of more than one NURBS curve. The number of curves per letter varies with the font. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "font": {
                "docstring": "The font to use"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only."
            }, 
            "object": {
                "docstring": "Create the result shapes, or just the dependency nodeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "text": {
                "docstring": "The string to create the curves for"
            }
        }
    }, 
    "textField": {
        "description": "Create a text field control. ", 
        "flags": {
            "alwaysInvokeEnterCommandOnReturn": {
                "docstring": "Sets whether to always invoke the enter command when the return key is pressed by the user.By default, this option is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the text changes. This command is not invoked when the value changes via the -tx/text flag."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "The edit state of the field. By default, this flag is set to true and the field value may be changed by typing into it. If false then the field is 'read only' and can not be typed into. The text in the field can always be changed with the -tx/text flag regardless of the state of the -ed/editable flag."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enterCommand": {
                "docstring": "Command executed when the keypad 'Enter' key is pressed."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fileName": {
                "docstring": "Text in the field as a filename. This does conversions between internal and external (UI) file representation."
            }, 
            "font": {
                "docstring": "The font for the text. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\"."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "insertText": {
                "docstring": "Insert text into the field at the current insertion position (specified by the -ip/insertionPosition flag)."
            }, 
            "insertionPosition": {
                "docstring": "The insertion position for inserted text. This is a 1 based value where position 1 specifies the beginning of the field. Position 0 may be used to specify the end of the field."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "receiveFocusCommand": {
                "docstring": "Command executed when the field receives focus."
            }, 
            "text": {
                "docstring": "The field text."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "textFieldButtonGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command adds a button to the textFieldGrp command. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "buttonCommand": {
                "docstring": "Command attached to the button."
            }, 
            "buttonLabel": {
                "docstring": "Label text of the button."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the field text changes and user presses Enter or Return."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "The edit state of the field. By default, this flag is set to true and the field value may be changed by typing into it. If false then the field is 'read only' and can not be typed into. The text in the field can always be changed with the -tx/textflag regardless of the state of the -ed/editableflag."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enableButton": {
                "docstring": "Enable state of the button. By default, this flag is set to true and the button is enabled. Specify true, and the button will appear dimmed or greyed-out indicating it is disabled.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fileName": {
                "docstring": "Text in the field as a filename. This does conversions between internal and external (UI) file representation."
            }, 
            "forceChangeCommand": {
                "docstring": "If used together with -text or -inserText flag, change command will be executed after text modification."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "insertText": {
                "docstring": "Insert text into the field at the current insertion position (specified by the -ip/insertionPosition flag)."
            }, 
            "insertionPosition": {
                "docstring": "The insertion position for inserted text. This is a 1 based value where position 1 specifies the beginning of the field. Position 0 may be used to specify the end of the field."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "Label text for the group."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "text": {
                "docstring": "Text in the field."
            }, 
            "textChangedCommand": {
                "docstring": "Command executed immediately when the field text changes."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "textFieldGrp": {
        "description": "All of the group commands position their individual controls in columns starting at column 1. The layout of each control (ie. column) can be customized using the -cw/columnWidth, -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumnflags. By default, columns are left aligned with no offset and are 100 pixels wide. Only one column in any group can be adjustable. This command creates a pre-packaged collection of label text and editable text field. The label text is optional. ", 
        "flags": {
            "adjustableColumn": {
                "docstring": "Specifies which column has an adjustable size that changes with the sizing of the layout. The column value is a 1-based index. You may also specify 0 to turn off the previous adjustable column."
            }, 
            "adjustableColumn2": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly two columns."
            }, 
            "adjustableColumn3": {
                "docstring": "Specifies that the column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly three columns."
            }, 
            "adjustableColumn4": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly four columns."
            }, 
            "adjustableColumn5": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly five columns."
            }, 
            "adjustableColumn6": {
                "docstring": "Specifies which column has an adjustable size that changes with the size of the parent layout. Ignored if there is not exactly six columns."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the field text changes and user presses Enter or Return."
            }, 
            "columnAlign": {
                "docstring": "Arguments are : column number, alignment type. Possible alignments are: left | right | center. Specifies alignment type for the specified column."
            }, 
            "columnAlign2": {
                "docstring": "Sets the text alignment of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign3": {
                "docstring": "Sets the text alignment for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign4": {
                "docstring": "Sets the text alignment for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign5": {
                "docstring": "Sets the text alignment for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAlign6": {
                "docstring": "Sets the text alignment for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"center\"."
            }, 
            "columnAttach": {
                "docstring": "Arguments are : column number, attachment type, and offset. Possible attachments are: left | right | both. Specifies column attachment types and offets."
            }, 
            "columnAttach2": {
                "docstring": "Sets the attachment type of both columns. Ignored if there is not exactly two columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach3": {
                "docstring": "Sets the attachment type for all 3 columns. Ignored if there is not exactly 3 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach4": {
                "docstring": "Sets the attachment type for all 4 columns. Ignored if there is not exactly 4 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach5": {
                "docstring": "Sets the attachment type for all 5 columns. Ignored if there is not exactly 5 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnAttach6": {
                "docstring": "Sets the attachment type for all 6 columns. Ignored if there is not exactly 6 columns. Valid values are \"left\", \"right\", and \"both\"."
            }, 
            "columnOffset2": {
                "docstring": "This flag is used in conjunction with the -columnAttach2 flag. If that flag is not used then this flag will be ignored. It sets the offset for the two columns. The offsets applied are based on the attachments specified with the -columnAttach2 flag. Ignored if there is not exactly two columns."
            }, 
            "columnOffset3": {
                "docstring": "This flag is used in conjunction with the -columnAttach3 flag. If that flag is not used then this flag will be ignored. It sets the offset for the three columns. The offsets applied are based on the attachments specified with the -columnAttach3 flag. Ignored if there is not exactly three columns."
            }, 
            "columnOffset4": {
                "docstring": "This flag is used in conjunction with the -columnAttach4 flag. If that flag is not used then this flag will be ignored. It sets the offset for the four columns. The offsets applied are based on the attachments specified with the -columnAttach4 flag. Ignored if there is not exactly four columns."
            }, 
            "columnOffset5": {
                "docstring": "This flag is used in conjunction with the -columnAttach5 flag. If that flag is not used then this flag will be ignored. It sets the offset for the five columns. The offsets applied are based on the attachments specified with the -columnAttach5 flag. Ignored if there is not exactly five columns."
            }, 
            "columnOffset6": {
                "docstring": "This flag is used in conjunction with the -columnAttach6 flag. If that flag is not used then this flag will be ignored. It sets the offset for the six columns. The offsets applied are based on the attachments specified with the -columnAttach6 flag. Ignored if there is not exactly six columns."
            }, 
            "columnWidth": {
                "docstring": "Arguments are : column number, column width. Sets the width of the specified column where the first parameter specifies the column (1 based index) and the second parameter specifies the width."
            }, 
            "columnWidth1": {
                "docstring": "Sets the width of the first column. Ignored if there is not exactly one column."
            }, 
            "columnWidth2": {
                "docstring": "Sets the column widths of both columns. Ignored if there is not exactly two columns."
            }, 
            "columnWidth3": {
                "docstring": "Sets the column widths for all 3 columns. Ignored if there is not exactly 3 columns."
            }, 
            "columnWidth4": {
                "docstring": "Sets the column widths for all 4 columns. Ignored if there is not exactly 4 columns."
            }, 
            "columnWidth5": {
                "docstring": "Sets the column widths for all 5 columns. Ignored if there is not exactly 5 columns."
            }, 
            "columnWidth6": {
                "docstring": "Sets the column widths for all 6 columns. Ignored if there is not exactly 6 columns."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editable": {
                "docstring": "The edit state of the field. By default, this flag is set to true and the field value may be changed by typing into it. If false then the field is 'read only' and can not be typed into. The text in the field can always be changed with the -tx/textflag regardless of the state of the -ed/editableflag."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fileName": {
                "docstring": "Text in the field as a filename. This does conversions between internal and external (UI) file representation."
            }, 
            "forceChangeCommand": {
                "docstring": "If used together with -text or -inserText flag, change command will be executed after text modification."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "insertText": {
                "docstring": "Insert text into the field at the current insertion position (specified by the -ip/insertionPosition flag)."
            }, 
            "insertionPosition": {
                "docstring": "The insertion position for inserted text. This is a 1 based value where position 1 specifies the beginning of the field. Position 0 may be used to specify the end of the field."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "Label text for the group."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rowAttach": {
                "docstring": "Arguments are : column, attachment type, offset. Possible attachments are: top | bottom | both. Specifies attachment types and offsets for the entire row."
            }, 
            "text": {
                "docstring": "Text in the field."
            }, 
            "textChangedCommand": {
                "docstring": "Command executed immediately when the field text changes.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "textManip": {
        "description": "Shows/hides the text manip. In query mode, return type is based on queried flag.", 
        "flags": {
            "query": {
                "docstring": ""
            }, 
            "visible": {
                "docstring": "Shows/hides the text manip.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "textScrollList": {
        "description": "This command creates/edits/queries a text scrolling list. The list can be in single select mode where only one item at at time is selected, or in multi-select mode where many items may be selected. Note: The -dgc/dragCallback flag works only on Windows. ", 
        "flags": {
            "allItems": {
                "docstring": "All the items."
            }, 
            "allowAutomaticSelection": {
                "docstring": "Specify automatic selection mode. When automaticSelection is on each item that the mouse is over (during dragging once an item has been selected) will be selected. Thus, if -sc/selectCommand someCommandis set, someCommandwill be called for each selected item. If -aas/allowAutomaticSelectionis off, then only the item selected when the mouse button is up will be the selected item, so -sc/selectCommand someCommandis only called once if it is set."
            }, 
            "allowMultiSelection": {
                "docstring": "Specify multi or single selection mode."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "append": {
                "docstring": "Add an item to the end of the list."
            }, 
            "appendPosition": {
                "docstring": "Append an item at the specified position. The position is a 1-based index."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "deleteKeyCommand": {
                "docstring": "Specify the command to be executed when the delete or backspace key is pressed."
            }, 
            "deselectAll": {
                "docstring": "Deselect all items."
            }, 
            "deselectIndexedItem": {
                "docstring": "Deselect the indexed item. Indecies are 1-based."
            }, 
            "deselectItem": {
                "docstring": "Deselect the item that contains the specified text."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "doubleClickCommand": {
                "docstring": "Specify the command to be executed when an item is double clicked."
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "font": {
                "docstring": "The font for the list items. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\".Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfItems": {
                "docstring": "Number of items."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "numberOfRows": {
                "docstring": "Number of visible rows."
            }, 
            "numberOfSelectedItems": {
                "docstring": "Number of selected items."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeAll": {
                "docstring": "Remove all items."
            }, 
            "removeIndexedItem": {
                "docstring": "Remove the indexed item. Indecies are 1-based."
            }, 
            "removeItem": {
                "docstring": "Remove the item with the specified text."
            }, 
            "selectCommand": {
                "docstring": "Specify the command to be executed when an item is selected."
            }, 
            "selectIndexedItem": {
                "docstring": "Select the indexed item. Indecies are 1-based."
            }, 
            "selectItem": {
                "docstring": "Select the item that contains the specified text."
            }, 
            "showIndexedItem": {
                "docstring": "Show the indexed item. Scroll the list as necessary so that the indexed item is visible. Indecies are 1-based."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "textureLassoContext": {
        "description": "", 
        "flags": {
            "drawClosed": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "texturePlacementContext": {
        "description": "Create a command for creating new texture placement contexts. By default label mapping is on when the context is created. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "labelMapping": {
                "docstring": "Set the context to label mapping.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "textureWindow": {
        "description": "This command is used to create a UV Texture Editor and to query or edit the texture editor settings. The UV Texture Editor displays texture mapped polygon objects in 2D texture space. Only active objects are visible in this window. The UV Texture Editor has the ability to display two types of images. The Texture Image is a visualisation of the current texture and associated placement parameters. The Editor Image is a user specified image loaded from disk. A UV Texture Editor can be invoked by selecting the \"Window -UV Texture Editor...\" menu item from the main maya menu listing that appears at the top of the maya window. It can also be invoked by selecting the \"Panel -UV Texture Editor\" item under the \"Panels\" menu item that appears at the top right hand corner of the view. As a UV Texture Editor typically exists at start-up time, and as only one of these can exist at any given time, this command is normally used to query and edit the editor settings. ", 
        "flags": {
            "backFacingColor": {
                "docstring": ""
            }, 
            "changeCommand": {
                "docstring": "Parameters: First string: commandSecond string: editorNameThird string: editorCmdFourth string: updateFuncCall the command when something changes in the editor The command should have this prototype :command(string $editor, string $editorCmd, string $updateFunc, int $reason)The possible reasons could be : 0: no particular reason1: scale color2: buffer (single/double)3: axis4: image displayed5: image saved in memory"
            }, 
            "clearImage": {
                "docstring": "Clears the current Editor Image"
            }, 
            "control": {
                "docstring": "Query only. Returns the top level control for this editor. Usually used for getting a parent to attach popup menus. Caution: It is possible, at times, for an editor to exist without a control. This flag returns \"NONE\" if no control is present."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "displayAxes": {
                "docstring": "Specify true to display the grid axes."
            }, 
            "displayDivisionLines": {
                "docstring": "Specify true to display the subdivision lines between grid lines."
            }, 
            "displayGridLines": {
                "docstring": "Specify true to display the grid lines."
            }, 
            "displayImage": {
                "docstring": "Set a particular image in the Editor Image Stack as the current Editor Image. Images are added to the Editor Image Stack using the \"si/saveImage\" flag."
            }, 
            "displayLabels": {
                "docstring": "Specify true to display the grid line numeric labels."
            }, 
            "displaySolidMap": {
                "docstring": "Display an solid over lay for the active texture map.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "displayStyle": {
                "docstring": "Set the mode to display the image. Valid values are: \"color\" to display the basic RGB image\"mask\" to display the mask channel\"lum\" to display the luminance of the image"
            }, 
            "divisions": {
                "docstring": "Sets the number of subdivisions between main grid lines"
            }, 
            "docTag": {
                "docstring": "Attaches a tag to the Maya editor."
            }, 
            "doubleBuffer": {
                "docstring": "Set the display in double buffer mode"
            }, 
            "drawAxis": {
                "docstring": ""
            }, 
            "drawSubregions": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "filter": {
                "docstring": "Specifies the name of an itemFilter object to be placed on this editor. This filters the information coming onto the main list of the editor."
            }, 
            "forceMainConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object. This is a variant of the -mainListConnection flag in that it will force a change even when the connection is locked. This flag is used to reduce the overhead when using the -unlockMainConnection , -mainListConnection, -lockMainConnection flags in immediate succession."
            }, 
            "forceRebake": {
                "docstring": "Forces the current cache texture to refresh."
            }, 
            "frameAll": {
                "docstring": "This will zoom on the whole scene."
            }, 
            "frameSelected": {
                "docstring": "This will zoom on the currently selected objects."
            }, 
            "frontFacingColor": {
                "docstring": ""
            }, 
            "highlightConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its highlight list. Not all editors have a highlight list. For those that do, it is a secondary selection list."
            }, 
            "imageBaseColor": {
                "docstring": "The base color of the image, default is white 1.0 1.0 1.0"
            }, 
            "imageDisplay": {
                "docstring": "Turns on or off Texture Image display"
            }, 
            "imageNames": {
                "docstring": "The image names for all Texture Images available for display, if any."
            }, 
            "imageNumber": {
                "docstring": "Sets the number of the Texture Image to display This depends on the number of textures corresponding to the current selection. If there are N textures, then the possible Texture Image numbers are 0 to N-1."
            }, 
            "imagePixelSnap": {
                "docstring": "Sets a mode so that uv transformations in the UV Texture Editor will cause uv values to snap to image pixel corners. Which pixels are used depends on whether a Texture Image or an Editor Image is being displayed, if both are displayed the Texture Image pixels will be used."
            }, 
            "imageRatio": {
                "docstring": "Sets the window to draw using the Texture Image's height versus width ratio. If the width is greater than the height than than the width is set to be 1 \"unit\" in the window and the height is adjusted by width divided by height. This only affects the display of a Texture Image, not an Editor Image."
            }, 
            "imageSize": {
                "docstring": "Returns the size of the Texture Image currently being display. The values returned are width followed by height. Image size can only be queried."
            }, 
            "imageTileRange": {
                "docstring": "Sets the UV range of the display. The 4 values specify the minimum U, V and maximum U, V in that order. When viewing a Texture Image, these values affect how many times the image is tiled based on appropriate parameters (e.g. Repeat UV, Mirror, Wrap, etc...) When viewing an Editor Image these values determine the visible size of the image. For example, setting the range to ( 0, 0, 2, 1 ) will cause the Editor Image to be loaded into a 2x1 rectangle, distorting it as necessary to fill the available space."
            }, 
            "imageUnfiltered": {
                "docstring": "Sets the Texture Image to draw unfiltered. The image will appear \"pixelated\" when the display resolution is higher than the resolution of the image."
            }, 
            "internalFaces": {
                "docstring": "Display contained faces by the selected components."
            }, 
            "labelPosition": {
                "docstring": "The position of the grid's numeric labels. Valid values are \"axis\" and \"edge\"."
            }, 
            "loadImage": {
                "docstring": "load an image from disk and set it as the current Editor Image"
            }, 
            "lockMainConnection": {
                "docstring": "Locks the current list of objects within the mainConnection, so that only those objects are displayed within the editor. Further changes to the original mainConnection are ignored."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will use as its source of content. The editor will only display items contained in the selectionConnection object."
            }, 
            "maxResolution": {
                "docstring": "This flag will set the current cached texture's maximum resolution."
            }, 
            "nbImages": {
                "docstring": "returns the number of images"
            }, 
            "numUvSets": {
                "docstring": "This flag will return the number of uv sets for selected objects in the texture window."
            }, 
            "numberOfImages": {
                "docstring": "The number of Texture Images currently available for display."
            }, 
            "panel": {
                "docstring": "Specifies the panel that the editor belongs to. By default if an editor is created in the create callback of a scripted panel it will belong to that panel. If an editor doesn't belong to a panel it will be deleted when the window that it is in is deleted."
            }, 
            "parent": {
                "docstring": "Specifies the parent layout for this editor. This flag will only have an effect if the editor is currently un-parented."
            }, 
            "query": {
                "docstring": ""
            }, 
            "realSize": {
                "docstring": "This will display the image with the size of the internal buffer. Note: This argument no long has any affect on image display."
            }, 
            "relatedFaces": {
                "docstring": "Display connected faces by the selected components."
            }, 
            "removeAllImages": {
                "docstring": "remove all the Editor Images from the Editor Image Stack"
            }, 
            "removeImage": {
                "docstring": "remove the current Editor Image from the Editor Image Stack"
            }, 
            "reset": {
                "docstring": "Resets the ground plane to its default values."
            }, 
            "saveImage": {
                "docstring": "save the current Editor Image to memory. Saved Editor Images are stored in an Editor Image Stack. The most recently saved image is stored in position 0, the second most recently saved image in position 1, and so on... To set the current Editor Image to a previously saved image use the \"di/displayImage\" flag."
            }, 
            "scaleBlue": {
                "docstring": "Define the scaling factor for the blue component in the View. The default value is 1 and can be between -1000 to +1000"
            }, 
            "scaleGreen": {
                "docstring": "Define the scaling factor for the green component in the View. The default value is 1 and can be between -1000 to +1000"
            }, 
            "scaleRed": {
                "docstring": "Define the scaling factor for the red component in the View. The default value is 1 and can be between -1000 to +1000"
            }, 
            "selectInternalFaces": {
                "docstring": "Add to selectionList the faces which are contained by (internal to) selected components."
            }, 
            "selectRelatedFaces": {
                "docstring": "Add to selectionList the faces which are connected to (non-internally related to) selected components."
            }, 
            "selectionConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the editor will synchronize with its own selection list. As the user selects things in this editor, they will be selected in the selectionConnection object. If the object undergoes changes, the editor updates to show the change."
            }, 
            "setUvSet": {
                "docstring": "This flag will set the current uv set on one given selected object within the texture window."
            }, 
            "singleBuffer": {
                "docstring": "Set the display in single buffer mode"
            }, 
            "size": {
                "docstring": "Sets the size of the grid."
            }, 
            "spacing": {
                "docstring": "Sets the spacing between main grid lines."
            }, 
            "stateString": {
                "docstring": "Query only flag. Returns the MEL command that will edit an editor to match the current editor state. The returned command string uses the string variable $editorName in place of a specific name."
            }, 
            "style": {
                "docstring": "This flag is obsolete and should not be used."
            }, 
            "toggle": {
                "docstring": "Turns the ground plane display on/off."
            }, 
            "unParent": {
                "docstring": "Specifies that the editor should be removed from its layout. This cannot be used with query."
            }, 
            "unlockMainConnection": {
                "docstring": "Unlocks the mainConnection, effectively restoring the original mainConnection (if it is still available), and dynamic updates."
            }, 
            "updateMainConnection": {
                "docstring": "Causes a locked mainConnection to be updated from the orginal mainConnection, but preserves the lock state."
            }, 
            "useFaceGroup": {
                "docstring": "Display faces that are associated with the groupId that is set on the mesh node that is drawn. (The attribute \"displayFacesWithGroupId\")"
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "uvSets": {
                "docstring": "This flag will return strings containing uv set and object name pairs for selected objects in the texture window. The syntax of each pair is \"objectName | uvSetName\", where | is a literal character."
            }, 
            "viewPortImage": {
                "docstring": "Toggles the view port/ caching texture images."
            }, 
            "writeImage": {
                "docstring": "write the current Editor Image to disk"
            }
        }
    }, 
    "threadCount": {
        "description": "This command sets the number of threads to be used by Maya in regions of code that are multithreaded. By default the number of threads is equal to the number of logical CPUs, not the number of physical CPUs. Logical CPUs are different from physical CPUs in the following ways:A physical CPU with hyperthreading counts as two logical CPUsA dual-core CPU counts as two logical CPUsWith some workloads, using one thread per logical CPU may not perform well. This is sometimes the case with hyperthreading. It is worth experimenting with different numbers of threads to see which gives the best performance. Note that having more threads can mean Maya uses more memory. Setting a value of zero means the number of threads used will equal the number of logical processors in the system. In query mode, return type is based on queried flag.", 
        "flags": {
            "numberOfThreads": {
                "docstring": "Sets the number of threads to useFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "threePointArcCtx": {
        "description": "The threePointArcCtx command creates a new context for creating 3 point arcs ", 
        "flags": {
            "degree": {
                "docstring": "VAlid values are 1 or 3. Default degree 3."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "spans": {
                "docstring": "Default is 8.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "timeCode": {
        "description": "Use this command to query and set the time code information in the file ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "mayaStartFrame": {
                "docstring": "Sets the Maya start time of the time code, in frames. In query mode, returns the Maya start frame of the time code.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "productionStartFrame": {
                "docstring": "Sets the production start time of the time code, in terms of frames. In query mode, returns the sub-second frame of production start time."
            }, 
            "productionStartHour": {
                "docstring": "Sets the production start time of the time code, in terms of hours. In query mode, returns the hour of production start time."
            }, 
            "productionStartMinute": {
                "docstring": "Sets the production start time of the time code, in terms of minutes. In query mode, returns the minute of production start time."
            }, 
            "productionStartSecond": {
                "docstring": "Sets the production start time of the time code, in terms of seconds. In query mode, returns the second of production start time."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "timeControl": {
        "description": "This command creates a control that can be used for changing current time, displaying/editing keys, and displaying/scrubbing sound.Note: only one timeControl may be created. The one Maya creates on startup can be accessed from the global string variable $gPlayBackSlider. Also, it is not a good idea to delete it. ", 
        "flags": {
            "animCurveNames": {
                "docstring": "When \"showKeys\" is not \"none\", querying this flag will return the names of all the animCurves for which keyframe ticks are being displayed. Query returns string[]."
            }, 
            "animLayerFilterOptions": {
                "docstring": "Specifies whether a filter is to be applied when displaying animation layers. If so, the options can be \"allAffecting\" (no filter), \"active\" (only the active layers on the object will be displayed) and \"animLayerEditor\" (the settings will be taken from the animation layer editor)."
            }, 
            "animLayerShowWeight": {
                "docstring": ""
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "beginScrub": {
                "docstring": "Set this widget up for sound scrubbing. Subsequent changes to current time will result in \"sound scrubbing\" behavior, until the \"-endScrub\" command is issued for this widget."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "displaySound": {
                "docstring": "Turn sound display off. Query returns int."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "endScrub": {
                "docstring": "End sound scubbing for this widget. This stops sound scrubbing behavior and should be issued before any subsequent \"-beginScrub\" flags"
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "forceRefresh": {
                "docstring": "Force a refresh of the time control UI.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "globalTime": {
                "docstring": "\"true\" means this widget controls and displays the global, dependency graph time. \"false\" means time changes here do NOT affect the dependency graph. Query returns int."
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "mainListConnection": {
                "docstring": "Specifies the name of a selectionConnection object which the time slider will use as its source of content. The time slider will only display keys for items contained in the selectionConnection object."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "pressCommand": {
                "docstring": "script to run on mouse-down in this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "range": {
                "docstring": "Returns string representing the currently highlighted range visible on the time slider. A range from 10 to 20 would be returned as \"10:20\". When there's no range visible on the time slider, the query returns a range spanning the current time: for example, \"10:11\". These values are in the current time unit."
            }, 
            "rangeArray": {
                "docstring": "Returns a float array representing the currently highlighted range visible on the time slider. A range from 10 to 20 would be returned as { 10.0, 20.0 }. When there's no range visible on the time slider, the query returns values spanning the current time: { 10.0, 11.0 }. These values are in the current time unit."
            }, 
            "rangeVisible": {
                "docstring": "Returns true if a currently highlighted range is visible on the time slider, false if no."
            }, 
            "releaseCommand": {
                "docstring": "script to run on mouse-up in this control."
            }, 
            "repeatChunkSize": {
                "docstring": "How much sound (in the current time unit) is repeated when -repeatOnHold is true. Default is 1.0."
            }, 
            "repeatOnHold": {
                "docstring": "Repeat sound during mouse-down events"
            }, 
            "resample": {
                "docstring": "Resample the sound display to fit the widget"
            }, 
            "showKeys": {
                "docstring": "\"active\" will show tick marks for keyframes on all active objects. \"none\" shows no tick marks. Any other name is taken as the name of a channel box whose selected attributes will display tick marks. Default \"active\". Query returns string."
            }, 
            "showKeysCombined": {
                "docstring": "This flag can be used in conjunction with the showKeys flag to enable a combination of \"active\" + \"channel box\" behavior. Specifically, if channel box attributes are selected, tick marks will be shown for those attributes. If no channel box attributes are selected, tick marks will be shown for keyframes on all active objects."
            }, 
            "snap": {
                "docstring": "\"true\" means this widget is constrained to having values that are integers representing the current time unit.. \"false\" means the current time indicator is \"free floating\" and not constrained."
            }, 
            "sound": {
                "docstring": "Name of audio depend node whose data should display in the sound-display widget. Query returns string."
            }, 
            "tickSize": {
                "docstring": "Specifies the witdth of keyframe ticks drawn in the time slider. The value will be clamped to the range [1, 63]."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "waveform": {
                "docstring": "Determines what part of the sound waveform to display, when -displaySound is \"true\". Valid values are \"top\", \"bottom\", and \"both\". Default is \"top\". Query returns string."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "timePort": {
        "description": "This command creates a simple time control widget. See also the \"timeControl\" command. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "globalTime": {
                "docstring": "\"true\" means this widget controls and displays the global, dependency graph time. \"false\" means time changes here do NOT affect the dependency graph. Query returns int."
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "snap": {
                "docstring": "\"true\" means this widget is constrained to having values that are integers representing the current time unit.. \"false\" means the current time indicator is \"free floating\" and not constrained.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "timeWarp": {
        "description": "This command is used to create a time warp input to a set of animation curves. ", 
        "flags": {
            "deleteFrame": {
                "docstring": "The flag value indicates the 0-based index of the warp frame to delete. This flag can only be used in edit mode."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "frame": {
                "docstring": "In create and edit mode, this flag can be used to specify warp frames added to the warp operation. In query mode, this flag returns a list of the frame values where warping occurs. The moveFrame flag command can be used to query the associated warped values."
            }, 
            "g": {
                "docstring": "In create mode, creates a global time warp node which impacts every animated object in the scene. In query mode, returns the global time warp node. Note: only one global time warp can exist in the scene.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "interpType": {
                "docstring": "This flag can be used to set the interpolation type for a given span. Valid interpolation types are linear, easeIn and easeOut. When queried, it returns a string array of the interpolation types for the specified time warp."
            }, 
            "moveFrame": {
                "docstring": "This flag can be used to move a singular warp frame. The first value specified indicates the 0-based index of the warp frame to move. The second value indicates the new warp frame value. This flag can only be used in edit and query mode. When queried, it returns an array of the warped frame values."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "timer": {
        "description": "Allow simple timing of scripts and commands. The resolution of this timer is at the level of your OS's gettimeofday()function. Note:This command does not handle stacked calls. For example, this code below will give an incorrect answer on the second timer -ecall.timer -s; timer -s; timer -e; timer -e; To do this use named timers: timer -s; timer -s -name \"innerTimer\"; timer -e -name \"innerTimer\"; timer -e; I the -e flag or -lap flag return the time elapsed since the last 'timer -s' call.I the -s flag has no return value.", 
        "flags": {
            "endTimer": {
                "docstring": "Stop the timer and return the time elapsed since the timer was started (in seconds). Once a timer is turned off it no longer exists, though it can be recreated with a new start"
            }, 
            "lapTime": {
                "docstring": "Get the lap time of the timer (time elapsed since start in seconds). Unlike the endflag this keeps the timer running."
            }, 
            "name": {
                "docstring": "Use a named timer for the operation. If this is omitted then the default timer is assumed.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "startTimer": {
                "docstring": "Start the timer."
            }
        }
    }, 
    "timerX": {
        "description": "Used to calculate elapsed time. This command returns sub-second accurate time values. It is useful from scripts for timing the length of operations. Call this command before and after the operation you wish to time. On the first call, do not use any flags. It will return the start time. Save this value. After the operation, call this command a second time, and pass the saved start time using the -st flag. The elapsed time will be returned. ", 
        "flags": {
            "startTime": {
                "docstring": "When this flag is used, the command returns the elapsed time since the specified start time.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "toggle": {
        "description": "The toggle command is used to toggle the display of various object features for objects which have these components. For example, CV and edit point display may be toggled for those listed NURB curves or surfaces. Note: This command is not undoable. ", 
        "flags": {
            "above": {
                "docstring": "Toggle state for all objects above listed objects."
            }, 
            "below": {
                "docstring": "Toggle state for all objects below listed objects."
            }, 
            "boundary": {
                "docstring": "Toggle boundary display of listed mesh objects."
            }, 
            "boundingBox": {
                "docstring": ""
            }, 
            "controlVertex": {
                "docstring": "Toggle CV display of listed curves and surfaces."
            }, 
            "doNotWrite": {
                "docstring": "Toggle the \"this should be written to the file\" state."
            }, 
            "editPoint": {
                "docstring": "Toggle edit point display of listed curves and surfaces."
            }, 
            "extent": {
                "docstring": "Toggle display of extents of listed mesh objects."
            }, 
            "facet": {
                "docstring": "For use with normalflag. Set the normal display style to facet display."
            }, 
            "geometry": {
                "docstring": "Toggle geometry display of listed objects."
            }, 
            "gl": {
                "docstring": "Toggle state for all objects"
            }, 
            "highPrecisionNurbs": {
                "docstring": "Toggle high precision display for NurbsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "hull": {
                "docstring": "Toggle hull display of listed curves and surfaces."
            }, 
            "latticePoint": {
                "docstring": "Toggle point display of listed lattices"
            }, 
            "latticeShape": {
                "docstring": "Toggle display of listed lattices"
            }, 
            "localAxis": {
                "docstring": "Toggle local axis display of listed objects."
            }, 
            "newCurve": {
                "docstring": "Set component display state of new curve objects"
            }, 
            "newPolymesh": {
                "docstring": "Set component display state of new polymesh objects"
            }, 
            "newSurface": {
                "docstring": "Set component display state of new surface objects"
            }, 
            "normal": {
                "docstring": "Toggle display of normals of listed surface and mesh objects."
            }, 
            "origin": {
                "docstring": "Toggle origin display of listed surfaces."
            }, 
            "point": {
                "docstring": "For use with normal flag. Set the normal display style to vertex display."
            }, 
            "pointDisplay": {
                "docstring": "Toggle point display of listed surfaces."
            }, 
            "pointFacet": {
                "docstring": "For use with normalflag. Set the normal display style to vertex and face display."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rotatePivot": {
                "docstring": "Toggle rotate pivot display of listed objects."
            }, 
            "scalePivot": {
                "docstring": "Toggle scale pivot display of listed objects."
            }, 
            "selectHandle": {
                "docstring": "Toggle select handle display of listed objects."
            }, 
            "state": {
                "docstring": "Explicitly set the state to true or false instead of toggling the state. Can not be queried."
            }, 
            "surfaceFace": {
                "docstring": "Toggle surface face handle display of listed surfaces."
            }, 
            "template": {
                "docstring": "Toggle template state of listed objects"
            }, 
            "uvCoords": {
                "docstring": "Toggle display uv coords of listed mesh objects."
            }, 
            "vertex": {
                "docstring": "Toggle vertex display of listed mesh objects."
            }
        }
    }, 
    "toggleAxis": {
        "description": "Toggles the state of the display axis. Note: the display of the axis in the bottom left corner has been rendered obsolete by the headsUpDisplay command. ", 
        "flags": {
            "origin": {
                "docstring": "Turns display of the axis at the origin of the ground plane on or off."
            }, 
            "query": {
                "docstring": ""
            }, 
            "view": {
                "docstring": "Turns display of the axis at the bottom left of each view on or off. (Obsolete - refer to the headsUpDisplay command)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "toggleWindowVisibility": {
        "description": "Toggle the visibility of a window. If no window is specified then the current window (most recently created) is used. See also the windowcommand's vis/visibleflag. ", 
        "flags": {}
    }, 
    "tolerance": {
        "description": "This command sets tolerances used by modelling operations that require a tolerance, such as surface fillet. Linear tolerance is also known as \"positional\" tolerance. Angular tolerance is also known as \"tangential\" tolerance. In query mode, return type is based on queried flag.", 
        "flags": {
            "angular": {
                "docstring": "Sets the angular, or \"tangential\" tolerance.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "linear": {
                "docstring": "Sets the linear, or \"positonal\" tolerance."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "toolBar": {
        "description": "Create a toolbar. Tool bars are movable panel that contains a set of controls. They are placed in the tool bar area around the central control in a main window. Tool bars can be moved inside their current area, moved into new areas and floated. ", 
        "flags": {
            "allowedArea": {
                "docstring": "Areas where the dock control may be placed. Valid values are \"top\", \"left\", \"bottom\", \"right\" and \"all\". The default is \"all\"."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "area": {
                "docstring": "The initial dock area for this dock control. This is a required flag."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "content": {
                "docstring": "The name of the control that is a content of this dock control. Valid values are \"top\", \"left\", \"bottom\" and \"right\". This is a required flag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "label": {
                "docstring": "The label text. The default label is the name of the control."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "toolButton": {
        "description": "This command creates a toolButton that is added to the most recently created tool button collection unless the cl/collectionflag is used. It also attaches the named tool, activating it when this control is selected. By default, this control only handles one tool at a time. Using the t/toolflag to associate a new tool will simply override the previous attached tool. If you use the amt/allowMultipleToolsflag then you will be able to attach more than one tool with this control. Only one tool will be current within the control. To access the other tools press the right mouse button to display a popup menu containing all the tools associated with this control. If you set the piv/popupIndicatorVisibleflag then a small arrow will be drawn on the control to indicate that additional tools are attached to this control. ", 
        "flags": {
            "allowMultipleTools": {
                "docstring": "Indicates whether this control will allow you to attach more than one tool. By default, this control accepts only one tool. You can add multiple tools by setting this flag to true. Only one tool will be current and displayed at any one time. Use the pop up menu attached to the right mouse button to view all the tools."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "changeCommand": {
                "docstring": "Command executed when the control's state is changed. Note that this flag should not be used in conjunction with onCommand and offCommand. That is, one should either use changeCommand and test the state of the control from inside the callback, or use onCommand and offCommand as separate callbacks."
            }, 
            "collection": {
                "docstring": "To explicitly add a tool button to a tool collection."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "doubleClickCommand": {
                "docstring": "Command executed when the control is double clicked."
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "This control supports three images. The image that best fits the current size of the control will be displayed. This flag applies the image to the current tool."
            }, 
            "imageOverlayLabel": {
                "docstring": "A short string (5 characters) label that will be displayed on top of the icon."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "offCommand": {
                "docstring": "Command executed when the control is turned off."
            }, 
            "onCommand": {
                "docstring": "Command executed when the control is turned on."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupIndicatorVisible": {
                "docstring": "Edit this flag to set the visibility of the popup tool indicator. The indicator is a simple image that appears in the top right corner of the button when more that one tool is associated with this control. This flag is queryable and true by default.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "select": {
                "docstring": "Will set this button as the selected one. This flag also queries the select state of the control."
            }, 
            "style": {
                "docstring": "The draw style of the control. Valid styles are \"iconOnly\", \"textOnly\", \"iconAndTextHorizontal\" and \"iconAndTextVertical\"."
            }, 
            "tool": {
                "docstring": "The name of the tool to be attached to the button. If the tool specified is already attached to this button then it will be selected. Query this flag to return the current tool. This flag may be specified more than once to attach more than one tool."
            }, 
            "toolArray": {
                "docstring": "This query only flag returns the names of all the tools attached to the toolButton control."
            }, 
            "toolCount": {
                "docstring": "This query only flag return the number of tools attached to the toolButton control."
            }, 
            "toolImage1": {
                "docstring": ""
            }, 
            "toolImage2": {
                "docstring": ""
            }, 
            "toolImage3": {
                "docstring": "This control supports three images. The image that best fits the current size of the control will be displayed. This flag applies the image to the specified tool. The first argument is the name of the tool and the second is the name of the image. When queried an array of tool icon pairs is returned."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "toolCollection": {
        "description": "This command creates a tool button collection. Collections are parented to the current default layout if no parent is specified with the -p/parent flag. As children of the layout they will be deleted when the layout is deleted. Collections may also span more than one window if the -gl/global flag is used. In this case the collection has no parent and must be explicitly deleted with the 'deleteUI' command when it is no longer wanted. ", 
        "flags": {
            "collectionItemArray": {
                "docstring": "Returns a string list giving the long names of all the items in this collection.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "gl": {
                "docstring": "Set the collection to have no parent layout. This flag must be specified when the collection is created and can not be queried or edited. Consequently, global collections must be explicitly deleted."
            }, 
            "numberOfCollectionItems": {
                "docstring": "Returns the number of items that are in this collection."
            }, 
            "parent": {
                "docstring": "Specify the parent to associate the collection with. The collection will be deleted along with the parent. This flag must be specified when the collection is created and can not be edited."
            }, 
            "query": {
                "docstring": ""
            }, 
            "select": {
                "docstring": "Select the specified collection item. If queried will return the name of the currently selected collection item."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }
        }
    }, 
    "toolDropped": {
        "description": "This command builds and executes the commands necessary to recreate the specified tool button. It is invoked when a tool is dropped on the shelf. ", 
        "flags": {}
    }, 
    "toolHasOptions": {
        "description": "This command queries a tool to see if it has options. If it does, it returns true. Otherwise it returns false. ", 
        "flags": {}
    }, 
    "toolPropertyWindow": {
        "description": "End users should only call this command as 1. a query (in the custom tool property sheet code) or 2. with no arguments to create the default tool property sheet. The more complex uses of it are internal. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "field": {
                "docstring": "Sets/returns the name of the text field used to store the tool name in the property sheet."
            }, 
            "helpButton": {
                "docstring": "Sets/returns the name of the button used to show help on the tool in the property sheet."
            }, 
            "icon": {
                "docstring": "Sets/returns the name of the static picture object (used to display the tool icon in the property sheet)."
            }, 
            "inMainWindow": {
                "docstring": "Specify true if you want the tool settings to appear in the main window rather than a separate window.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "location": {
                "docstring": "Sets/returns the location of the current tool property sheet, or an empty string if there is none."
            }, 
            "noviceMode": {
                "docstring": "Sets/returns the 'novice mode' flag.(unused at the moment)"
            }, 
            "query": {
                "docstring": ""
            }, 
            "resetButton": {
                "docstring": "Sets/returns the name of the button used to restore the tool settings in the property sheet."
            }, 
            "selectCommand": {
                "docstring": "Sets/returns the property sheet's select command."
            }, 
            "showCommand": {
                "docstring": "Sets/returns the property sheet's display command."
            }
        }
    }, 
    "torus": {
        "description": "The torus command creates a new torus and/or a dependency node that creates one, and returns their names. ", 
        "flags": {
            "axis": {
                "docstring": "The primitive's axisAdvanced flags"
            }, 
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "degree": {
                "docstring": "The degree of the resulting surface: 1 - linear, 3 - cubicDefault:3"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "endSweep": {
                "docstring": "The angle at which to end the surface of revolution. Default is 2Pi radians, or 360 degrees.Default:6.2831853"
            }, 
            "heightRatio": {
                "docstring": "Ratio of \"height\" to \"width\"Default:2.0"
            }, 
            "minorSweep": {
                "docstring": "The sweep angle for the minor circle in the torusDefault:6.2831853"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "pivot": {
                "docstring": "The primitive's pivot point"
            }, 
            "polygon": {
                "docstring": "The value of this argument controls the type of the object created by this operation 0: nurbs surface1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)3: Bezier surface4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "radius": {
                "docstring": "The radius of the objectDefault:1.0"
            }, 
            "sections": {
                "docstring": "The number of sections determines the resolution of the surface in the sweep direction. Used only if useTolerance is false.Default:8"
            }, 
            "spans": {
                "docstring": "The number of spans determines the resolution of the surface in the opposite direction.Default:1"
            }, 
            "startSweep": {
                "docstring": "The angle at which to start the surface of revolutionDefault:0"
            }, 
            "tolerance": {
                "docstring": "The tolerance with which to build the surface. Used only if useTolerance is trueDefault:0.01"
            }, 
            "useTolerance": {
                "docstring": "Use the specified tolerance to determine resolution. Otherwise number of sections will be used.Default:false"
            }
        }
    }, 
    "track": {
        "description": "The track command translates a camera horizontally or vertically in the world space. The viewing-direction and up-direction of the camera are not altered. There is no translation in the viewing direction. The track command can be applied to either a perspective or an orthographic camera. When no camera name is supplied, this command is applied to the camera in the active view. ", 
        "flags": {
            "down": {
                "docstring": "Set the amount of down translation in unit distance.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "left": {
                "docstring": "Set the amount of left translation in unit distance."
            }, 
            "right": {
                "docstring": "Set the amount of right translation in unit distance."
            }, 
            "upDistance01": {
                "docstring": "Set the amount of up translation in unit distance. This is equivalent to using up/upDistance02 flag."
            }, 
            "upDistance02": {
                "docstring": "Set the amount of up translation in unit distance. This is equivalent to using u/upDistance01 flag."
            }
        }
    }, 
    "trackCtx": {
        "description": "This command can be used to create a track context. ", 
        "flags": {
            "alternateContext": {
                "docstring": "Set the ALT+MMB and ALT+SFT+MMB to refer to this context."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "toolName": {
                "docstring": ""
            }, 
            "trackGeometry": {
                "docstring": "Toggle whether the drag should try to track geometry. The context will compute a track plane by intersecting the initial press with geometry or the live object."
            }, 
            "trackScale": {
                "docstring": "Specify the distance to the track plane from the camera. The smaller the scale the slower the drag.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "transferAttributes": {
        "description": "Samples the attributes of a source surface (first argument) and transfers them onto a target surface (second argument). ", 
        "flags": {
            "after": {
                "docstring": ""
            }, 
            "afterReference": {
                "docstring": ""
            }, 
            "before": {
                "docstring": ""
            }, 
            "colorBorders": {
                "docstring": "Controls whether color borders are preserved when transferring color data. If this is non-zero, any color borders will be mapped onto the nearest edge on the target geometry. 0 means any color borders will be smoothly blended onto the vertices of the target geometry."
            }, 
            "deformerTools": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exclusive": {
                "docstring": ""
            }, 
            "flipUVs": {
                "docstring": "Controls how sampled UV data is flipped before being transferred to the target. 0 means no flipping; 1 means UV data is flipped in the U direction; 2 means UV data is flipped in the V direction; and 3 means it is flipped in both directions. In conjunction with mirroring, this allows the creation of symmetric UV mappings (e.g. the left hand side of the character on one side of the UV map, the right hand side on the other)."
            }, 
            "frontOfChain": {
                "docstring": ""
            }, 
            "geometry": {
                "docstring": ""
            }, 
            "geometryIndices": {
                "docstring": ""
            }, 
            "ignoreSelected": {
                "docstring": ""
            }, 
            "matchChoice": {
                "docstring": "When using topological component matching, selects between possible matches. If the meshes involved in the transfer operation have symmetries in their topologies, there may be more than one possible topological match. Maya scores the possible matches (by comparing the shapes of the meshes) and assigns them an index, starting at zero. Match zero, the default, is considered the best, but in the event that Maya chooses the wrong one, changing this value will allow the user to explore the other matches.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": ""
            }, 
            "parallel": {
                "docstring": ""
            }, 
            "prune": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": ""
            }, 
            "sampleSpace": {
                "docstring": "Selects which space the attribute transfer is performed in. 0 is world space, 1 is model space, 4 is component-based, 5 is topology-based. The default is world space."
            }, 
            "searchMethod": {
                "docstring": "Specifies which search method to use when correlating points. 0 is closest along normal, 3 is closest to point. The default is closest to point."
            }, 
            "searchScaleX": {
                "docstring": "Specifies an optional scale that should be applied to the x-axis of the target model before transferring data. A value of 1.0 (the default) means no scaling; a value of -1.0 would indicate mirroring along the x-axis."
            }, 
            "searchScaleY": {
                "docstring": "Specifies an optional scale that should be applied to the y-axis of the target model before transferring data. A value of 1.0 (the default) means no scaling; a value of -1.0 would indicate mirroring along the y-axis."
            }, 
            "searchScaleZ": {
                "docstring": "Specifies an optional scale that should be applied to the z-axis of the target model before transferring data. A value of 1.0 (the default) means no scaling; a value of -1.0 would indicate mirroring along the z-axis."
            }, 
            "sourceColorSet": {
                "docstring": "Specifies the name of a single color set on the source surface(s) that should be transferred to the target. This value is only used when the operation is configured to transfer a single color set (see the transferColors flag)."
            }, 
            "sourceUvSet": {
                "docstring": "Specifies the name of a single UV set on the source surface(s) that should be transferred to the target. This value is only used when the operation is configured to transfer a single UV set (see the transferUVs flag)."
            }, 
            "sourceUvSpace": {
                "docstring": "Specifies the name of the UV set on the source surface(s) that should be used as the transfer space. This value is only used when the operation is configured to transfer attributes in UV space."
            }, 
            "split": {
                "docstring": ""
            }, 
            "targetColorSet": {
                "docstring": "Specifies the name of a single color set on the target surface that should be receive the sampled color data. This value is only used when the operation is configured to transfer a single color set (see the transferColors flag)."
            }, 
            "targetUvSet": {
                "docstring": "Specifies the name of a single UV set on the target surface that should be receive the sampled UV data. This value is only used when the operation is configured to transfer a single UV set (see the transferUVs flag)."
            }, 
            "targetUvSpace": {
                "docstring": "Specifies the name of the UV set on the target surface( that should be used as the transfer space. This value is only used when the operation is configured to transfer attributes in UV space."
            }, 
            "transferColors": {
                "docstring": "Controls color set transfer. 0 means no color sets are transferred, 1 means that a single color set (specified by sourceColorSet and targetColorSet) is transferred, and 2 means that all color sets are transferred."
            }, 
            "transferNormals": {
                "docstring": "A non-zero value indicates vertex normals should be sampled and written into user normals on the target surface."
            }, 
            "transferPositions": {
                "docstring": "A non-zero value indicates vertex position should be sampled, causing the target surface to \"wrap\" to the source surface(s)."
            }, 
            "transferUVs": {
                "docstring": "Controls UV set transfer. 0 means no UV sets are transferred, 1 means that a single UV set (specified by sourceUVSet and targetUVSet) is transferred, and 2 means that all UV sets are transferred."
            }
        }
    }, 
    "transferShadingSets": {
        "description": "Command to transfer shading set assignments between meshes. The last mesh in the list receives the shading assignments from the other meshes. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "sampleSpace": {
                "docstring": "Selects which space the attribute transfer is performed in. 0 is world space, 1 is model space. The default is world space."
            }, 
            "searchMethod": {
                "docstring": "Specifies which search method to use when correlating points. 0 is closest along normal, 3 is closest to point. The default is closest to point.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "transformCompare": {
        "description": "Compares two transforms passed as arguments. If they are the same, returns 0. If they are different, returns 1. If no transforms are specified in the command line, then the transforms from the active list are used. ", 
        "flags": {
            "root": {
                "docstring": "Compare the root only, rather than the entire hierarchy below the roots.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "transformLimits": {
        "description": "The transformLimits command allows us to set, edit, or query the limits of the transformation that can be applied to objects. We can also turn any limits off which may have been previously set. When an object is first created, all the transformation limits are off by default.Transformation limits allow us to control how much an object can be transformed. This is most useful for joints, although it can be used any place we would like to limit the movement of an object.Default values are:( -1, 1) for translation, ( -1, 1) for scaling, and (-45,45) for rotation. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "enableRotationX": {
                "docstring": "enable/disable the lower and upper x-rotation limitsWhen queried, it returns boolean boolean"
            }, 
            "enableRotationY": {
                "docstring": "enable/disable the lower and upper y-rotation limitsWhen queried, it returns boolean boolean"
            }, 
            "enableRotationZ": {
                "docstring": "enable/disable the lower and upper z-rotation limitsWhen queried, it returns boolean boolean"
            }, 
            "enableScaleX": {
                "docstring": "enable/disable the lower and upper x-scale limitsWhen queried, it returns boolean boolean"
            }, 
            "enableScaleY": {
                "docstring": "enable/disable the lower and upper y-scale limitsWhen queried, it returns boolean boolean"
            }, 
            "enableScaleZ": {
                "docstring": "enable/disable the lower and upper z-scale limitsWhen queried, it returns boolean booleanFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "enableTranslationX": {
                "docstring": "enable/disable the ower and upper x-translation limitsWhen queried, it returns boolean boolean"
            }, 
            "enableTranslationY": {
                "docstring": "enable/disable the lower and upper y-translation limitsWhen queried, it returns boolean boolean"
            }, 
            "enableTranslationZ": {
                "docstring": "enable/disable the lower and upper z-translation limitsWhen queried, it returns boolean boolean"
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "turn all the limits off and reset them to their default values"
            }, 
            "rotationX": {
                "docstring": "set the lower and upper x-rotation limitsWhen queried, it returns angle angle"
            }, 
            "rotationY": {
                "docstring": "set the lower and upper y-rotation limitsWhen queried, it returns angle angle"
            }, 
            "rotationZ": {
                "docstring": "set the lower and upper z-rotation limitsWhen queried, it returns angle angle"
            }, 
            "scaleX": {
                "docstring": "set the lower and upper x-scale limitsWhen queried, it returns float float"
            }, 
            "scaleY": {
                "docstring": "set the lower and upper y-scale limitsWhen queried, it returns float float"
            }, 
            "scaleZ": {
                "docstring": "set the lower and upper z-scale limitsWhen queried, it returns float float"
            }, 
            "translationX": {
                "docstring": "set the lower and upper x-translation limitsWhen queried, it returns linear linear"
            }, 
            "translationY": {
                "docstring": "set the lower and upper y-translation limitsWhen queried, it returns linear linear"
            }, 
            "translationZ": {
                "docstring": "set the lower and upper z-translation limitsWhen queried, it returns linear linear"
            }
        }
    }, 
    "translator": {
        "description": "Set or query parameters associated with the file translators specified in as the argument. ", 
        "flags": {
            "defaultFileRule": {
                "docstring": "Returns the default file rule value, can return \"\" as wellFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "defaultOptions": {
                "docstring": "Return/set a string of default options used by this translator."
            }, 
            "extension": {
                "docstring": "Returns the default file extension for this translator."
            }, 
            "fileCompression": {
                "docstring": "Specifies the compression action to take when a file is saved. Possible values are \"compressed\", \"uncompressed\" \"asCompressed\"."
            }, 
            "filter": {
                "docstring": "Returns the filter string used for this translator."
            }, 
            "list": {
                "docstring": "Return a string array of all the translators that are loaded."
            }, 
            "loaded": {
                "docstring": "Returns true if the given translator is currently loaded."
            }, 
            "objectType": {
                "docstring": "This flag is obsolete. This will now return the same results as defaultFileRule going forward."
            }, 
            "optionsScript": {
                "docstring": "Query the name of the options script to use to post the user options UI. When this script is invoked it will expect the name of the parent layout in which the options will be displayed as well as the name of the callback to be invoked once the apply button has been depressed in the options area."
            }, 
            "query": {
                "docstring": ""
            }, 
            "readSupport": {
                "docstring": "Returns true if this translator supports read operations."
            }, 
            "writeSupport": {
                "docstring": "Returns true if this translator supports write operations."
            }
        }
    }, 
    "treeLister": {
        "description": "This command creates/edits/queries the tree lister control. The optional argument is the name of the control. ", 
        "flags": {
            "addFavorite": {
                "docstring": "Add an item path to the favorites folder. The item path does not have to actually be in the tree."
            }, 
            "addItem": {
                "docstring": "Add an item to the control. The arguments are item-path,icon path,command where item-path is the path from the root of the tree to the item's name icon path is the icon displayed in the results list command is the script which is executed when the item is LMB clicked"
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "clearContents": {
                "docstring": "Clears the contents of the control."
            }, 
            "collapsePath": {
                "docstring": "Collapse a path in the tree."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "executeItem": {
                "docstring": "Execute the command associated with an item."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandPath": {
                "docstring": "Expand a path in the tree."
            }, 
            "expandToDepth": {
                "docstring": "Expand the tree to the given depth."
            }, 
            "favoritesCallback": {
                "docstring": "This script is called whenever a favorite is added or removed. It is passed two arguments: The item's path and a boolean indicating if it is being added to favorites (True) or removed (False)."
            }, 
            "favoritesList": {
                "docstring": "Returns the list of favorite items."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "itemScript": {
                "docstring": "Returns the language and script command of the passed item path as a two-element list, the first element is the string \"MEL\" or \"Python\" and the second is the command script. Note that items with Python callable commands will be returned as strings. "
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeFavorite": {
                "docstring": "Remove an item from favorites. Accepts the full favorite path or the tail of the full path."
            }, 
            "removeItem": {
                "docstring": "Remove an item path."
            }, 
            "resultsPathUnderCursor": {
                "docstring": "Returns the path to the result (right-pane) item under the mouse cursor. Returns an empty string if there is no such item."
            }, 
            "selectPath": {
                "docstring": "Select a path in the tree.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "treeView": {
        "description": "This command creates a custom control. ", 
        "flags": {
            "addItem": {
                "docstring": "Adds a tree view item to the tree view. First argument specifies the item's name, second argument specifies the item's parent (use an empty string to have it at the top level of the tree)"
            }, 
            "allowDragAndDrop": {
                "docstring": "Allow the user to perform drag and drop of treeView items. If enabled, re-ordering / re-parenting operations can be perfomed with the middle mouse button. This flag takes precendence over other drag and drop related flags. Defaults to true."
            }, 
            "allowHiddenParents": {
                "docstring": "If not cleared(default), the treeView will make parent nodes of visibles nodes automatically visible"
            }, 
            "allowReparenting": {
                "docstring": "Allow the user to reparent items in the tree view using the middle mouse button. Defaults to true. If false, user can still reorder items within a group using the middle mouse button."
            }, 
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "attachButtonRight": {
                "docstring": "Sets tree view item's buttons to appear on the right or left. Argument specifies if they are to be attached to the right, if it is set to false they will attach on the left."
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "borderHighlite": {
                "docstring": "Sets an item's border as highlited or not. First Argument specifies item, second argument specifies on or off."
            }, 
            "borderHighliteColor": {
                "docstring": "Sets the color an item's border highlite will turn when highlite is enabled. first paramater specifies layer three float values specify RGB values, between 0 and 1."
            }, 
            "buttonErase": {
                "docstring": "If buttonErase was set true , then even if the button of the treeView item is set invisible , the treeView will still erase the buttonRect of this treeView item with background . First argument is the item name , second argument is whether buttonErase was set true or falseFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "buttonState": {
                "docstring": "Sets the state of a button. First argument specifies the layer, second argument specifies which button, third argument specifies the state Possible states: \"buttonUp\" - button is up \"buttonDown\" - button is down \"buttonThirdState\" - button is in state three (used by the \"3StateButton\" button style)"
            }, 
            "buttonStyle": {
                "docstring": "Sets the type of button, used to indicate possible states and if the button is reset upon release. First argument specifies the layer, second argument specifies which button, third argument specifies the type of button Possible button types: \"pushButton\" - two possible states, button is reset to up upon release \"2StateButton\" - two possible states, button changes state on click \"3StateButton\" - three button states, button changes state on click"
            }, 
            "buttonTextIcon": {
                "docstring": "Sets a one letter text to use as the icon to use for a specific button on a specific item. First argument specifies the item, second argument specifies the button, third argument specifies the icon text."
            }, 
            "buttonTooltip": {
                "docstring": "Sets a tooltip for specific button on a specific item. First argument specifies the item, second argument specifies the button, third argument specifies the tooltip."
            }, 
            "buttonTransparencyColor": {
                "docstring": "Sets the background color of a button that will be used if buttonTransparencyOverride is enabled. First argument specifies item, second argument specifies button, three floats specify RGB values, between 0 and 1."
            }, 
            "buttonTransparencyOverride": {
                "docstring": "Sets a button's background as being overriden or not. First argument specifies item, second argument specifies button, third argument specifies overridden or not."
            }, 
            "buttonVisible": {
                "docstring": "Sets a button as visible or not. First Argument specifies item. Second Argument specifies a button. Third Argument specifies visible or not."
            }, 
            "children": {
                "docstring": "Query the children of an item. If the argument is null, all items will be returned. "
            }, 
            "clearSelection": {
                "docstring": "Clears all selected items."
            }, 
            "contextMenuCommand": {
                "docstring": "Set the callback function to be invoked just before any attached context menu is shown. This can be used as a replacement to, or in addition to the postMenuCommand flag on the popupMenu command. The function should accept a string which will be the item that was clicked on (empty if no item was hit). The function should return true if the menu should be shown, false otherwise."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "displayLabel": {
                "docstring": "Set a label for the item that is different than the string that identifies the item. This label will be used in the display of the item. The first parameter specifies the item, the second specifies the display label."
            }, 
            "displayLabelSuffix": {
                "docstring": "Set a suffix for the display label for the item. This suffix will not be shown when renaming the item in the tree view."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragAndDropCommand": {
                "docstring": "Sets the callback function to be invoked upon drag and drop of layers. the callback function should take as parameters: - a string array of the dropped items - a string array of the items previous parents - an integer array of the items previous indexes - a string for the item(s) new parent - an integer array for the item's new indexes - a string for the item that now comes before the dropped items - a string for the item that now comes after the dropped items"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "editLabelCommand": {
                "docstring": "Set the callback function to be invoked when the user changes the name of an item by double clicking it in the UI. The callback should accept two string arguments: the item name and the new name. The item name refers to the name of the item and not the display label. The callback function should return a string. An empty string indicates that the rename operation was invalid and the control should revert to the original name. If the rename operation is valid the callback should return a string that identifies the item, possibly different from the new display name entered by the user."
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "enableButton": {
                "docstring": "Sets a specific button on a specific item to being usable or not. First argument specifies the item, second argument specifies the button, third argument specifies on or off."
            }, 
            "enableKeys": {
                "docstring": "By default the treeview does not accept input from the keyboard. By enabling keyboard support The treeview will support up/down navigation using the up/down arrow keys."
            }, 
            "enableLabel": {
                "docstring": "enables or disables the label of a tree view item from being displayed. The first parameter specifies the item, the second specifies on or off."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "expandCollapseCommand": {
                "docstring": "Set the callback function to be invoked upon hitting the expand/collapse button. The function should take as paramaters: - a string for the item for which the expand/collapse button was hit - an integer for the state of expansion"
            }, 
            "expandItem": {
                "docstring": "Expands or collapses an item's children. First argument specifies the item, second argument specifies expanded or collapsed."
            }, 
            "flatButton": {
                "docstring": ""
            }, 
            "font": {
                "docstring": "The first parameter specifies the item string for the TtreeViewNode in the TtreeNodeMap. The second string specifies the font for the text. Valid values are \"boldLabelFont\", \"smallBoldLabelFont\", \"tinyBoldLabelFont\", \"plainLabelFont\", \"smallPlainLabelFont\", \"obliqueLabelFont\", \"smallObliqueLabelFont\", \"fixedWidthFont\" and \"smallFixedWidthFont\"."
            }, 
            "fontFace": {
                "docstring": "Sets the font face used for the specified item's text: 0 for normal, 1 for bold, 2 for italic."
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parents"
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "hideButtons": {
                "docstring": "Hides the buttons for an item in the tree view. Can only be used when adding the item to the tree with the \"addItem\" flag. Space for the buttons is left to make sure items still line up correctly under their parent."
            }, 
            "highlite": {
                "docstring": "Sets an item as highlited. Highliting is shown by outlining the item. First paramater specifies the item, the second specifies the highliting or not."
            }, 
            "highliteColor": {
                "docstring": "Sets the color an item's highlite will turn when highlite is enabled. first paramater specifies layer three float values specify RGB values, between 0 and 1."
            }, 
            "ignoreButtonClick": {
                "docstring": "Sets a specific button on a specific item to ignore the button clicks First argument specifies the item ,second argument specifies the button, third argument specifies on or off"
            }, 
            "image": {
                "docstring": "Sets an image to use as the icon for the button. First argument specifies the item, second argument specifies the button, third argument specifies the image."
            }, 
            "isItemExpanded": {
                "docstring": "Is the item in the tree view expanded. "
            }, 
            "isLeaf": {
                "docstring": "Query whether an item is a leaf. "
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "itemDblClickCommand": {
                "docstring": "Set the callback function to be invoked when an item in the tree has been double clicked. The callback should accept one string, the name of the item that was double clicked. If this callback is defined, it supersedes the normal item renaming behavior."
            }, 
            "itemExists": {
                "docstring": "Queries the existence of the specified Tree View item. "
            }, 
            "itemIndex": {
                "docstring": "Get the index for the specified item in the list of children of the item's parent. Index is 0-based. "
            }, 
            "itemParent": {
                "docstring": "If the specified item is a child, it returns the parent item. If the specified item is not a child it returns nothing. "
            }, 
            "itemRenamedCommand": {
                "docstring": "Set the callback function to be invoked when an item in the tree has been renamed. This occurs if there is a successful return of the command attached by \"editLabelCommand\" or unconditionally if there is no editLabelCommand. The callback should accept two strings, the old name and the new name of the item that was renamed."
            }, 
            "itemSelected": {
                "docstring": "Queries the item is currently selected or not. "
            }, 
            "itemVisible": {
                "docstring": "Control the given item's visibility."
            }, 
            "labelBackgroundColor": {
                "docstring": "Set the background color for text label for a particular item in the tree. The first parameter specifies layer.Set (-1.0, -1.0, -1.0) to restore the background to the default of \"transparent\""
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "numberOfButtons": {
                "docstring": "Specifies the number of buttons for items in the tree."
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "ornament": {
                "docstring": "Sets an item as having an ornament (a small colored circle), its on/off state, if it should have a dot, and its size. First Argument specifies item, second argument specifies on or off, third argument specifies dotted or not, fourth argument specifies radius (in pixels)."
            }, 
            "ornamentColor": {
                "docstring": "Sets the color an ornament will be draw with for the specified layer."
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "pressCommand": {
                "docstring": "Sets the callback function to be invoked upon clicking a treeView button. First argument specifies which treeView button. Second argument specifies the callback function to be executed the callback function should take as parameters: - a string for the clicked button's item - an int for the clicked button's state"
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeAll": {
                "docstring": "Removes all items from the tree view."
            }, 
            "reverseTreeOrder": {
                "docstring": "Controls the order the tree will be drawn in (reversed if true)."
            }, 
            "rightPressCommand": {
                "docstring": "Sets the callback function to be invoked upon right clicking a treeView button. First argument specifies which treeView button. Second argument specifies the callback function to be executed the callback function should take as parameters: - a string for the clicked button's item - an int for the clicked button's state"
            }, 
            "select": {
                "docstring": ""
            }, 
            "selectCommand": {
                "docstring": "Set the callback function to be invoked when an item is selected or deselected in the tree. The function should accept one string argument and one integer argument: the item name and the select state respectively. If the function returns true, the select/deselect is considered valid and will occur normally, otherwise it will be disallowed. name and"
            }, 
            "selectItem": {
                "docstring": "Sets an item's selected state. first argument specifies the item, second argument specifies selection status"
            }, 
            "selectionChangedCommand": {
                "docstring": "Set the callback function to be invoked when a complete selection operation triggered by the user has occured successfully. The callback is invoked if the \"selectCommand\" callback has returned a non-empy value (or always there is no \"selectCommand\" callback). This differs from selectCommand in that a simple selection replacement will generate two calbacks with \"selectCommand\" (one for deselect of the old item and one for select of the new), whereas \"selectionChangedCommand\" will only be invoked once, after the selection is complete. The callback is not passed any parameters and does not need to return any value (ie. It is simply a notification mechanism)."
            }, 
            "selectionColor": {
                "docstring": "Sets the color an item will turn to indicate that it is selected. first paramater specifies the item three float values specify RGB values, between 0 and 1."
            }, 
            "showItem": {
                "docstring": "Show the item. Scroll the list as necessary so that item is visible."
            }, 
            "textColor": {
                "docstring": "Sets the label's text color for the specified layer. first argument specifies layer. three float values specify RGB values, between 0 and 1."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }
        }
    }, 
    "trim": {
        "description": "This command trims a surface to its curves on surface by first splitting the surface and then selecting which regions to keep or discard. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "locatorU": {
                "docstring": "u parameter value to position a locator on the surface.Default:0.5"
            }, 
            "locatorV": {
                "docstring": "v parameter value to position a locator on the surface.Default:0.5"
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency nodeFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": ""
            }, 
            "selected": {
                "docstring": "Specify whether to keep or discard selected regions.Default:0"
            }, 
            "shrink": {
                "docstring": "If true, shrink underlying surface to outer boundaries of trimmed surface.Default:false"
            }, 
            "tolerance": {
                "docstring": "The tolerance with which to trim.Default:0.001Advanced flags"
            }
        }
    }, 
    "trimCtx": {
        "description": "", 
        "flags": {
            "activeNodes": {
                "docstring": ""
            }, 
            "autoCreate": {
                "docstring": ""
            }, 
            "caching": {
                "docstring": ""
            }, 
            "constructionHistory": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "immediate": {
                "docstring": ""
            }, 
            "locatorU": {
                "docstring": ""
            }, 
            "locatorV": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": ""
            }, 
            "object": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": ""
            }, 
            "reset": {
                "docstring": ""
            }, 
            "selected": {
                "docstring": ""
            }, 
            "shrink": {
                "docstring": ""
            }, 
            "tolerance": {
                "docstring": ""
            }, 
            "toolNode": {
                "docstring": ""
            }
        }
    }, 
    "truncateFluidCache": {
        "description": "This command sets the end time of a fluid cache to the current time. If the current time is less than the end time of the cache, the cache is truncated so that only the portion of the cache up to and including the current time is preserved. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "truncateHairCache": {
        "description": "This command sets the end time of a hair cache to the current time. If the current time is less than the end time of the cache, the cache is truncated so that only the portion of the cache up to and including the current time is preserved. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "tumble": {
        "description": "The tumble command revolves the camera(s) by varying the azimuth and elevation angles in the perspective window. When both the azimuth and the elevation angles are supplied on the command line, the camera is firstly tumbled for the azimuth angle, then tumbled for the elevation angle. When no camera name is supplied, this command is applied to the camera in the active view. The camera's rotate pivot will override a specifed pivot point if the rotate pivot is not at the camera's eye point. ", 
        "flags": {
            "azimuthAngle": {
                "docstring": "Degrees to change the azimuth angle."
            }, 
            "elevationAngle": {
                "docstring": "Degrees to change the elevation angle."
            }, 
            "localTumble": {
                "docstring": "Describes what point the camera will tumble around: 0 for the camera's tumble pivot, 1 for the camera's center of interest, and 2 for the camera's local axis, offset by its tumble pivot.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pivotPoint": {
                "docstring": "Three dimensional point used as the pivot point in the world space."
            }, 
            "rotationAngles": {
                "docstring": "Two values in degrees to change the azimuth and elevation angles."
            }
        }
    }, 
    "tumbleCtx": {
        "description": "This command can be used to create, edit, or query a tumble context. ", 
        "flags": {
            "alternateContext": {
                "docstring": "Set the ALT+LMB and ALT+SFT+LMB to refer to this context."
            }, 
            "autoOrthoConstrain": {
                "docstring": "Automatically constrain horizontal and vertical rotations when the camera is orthographic. The shift key can be used to unconstrain the rotation."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "localTumble": {
                "docstring": "Describes what point the camera will tumble around: 0 for the camera's tumble pivot1 for the camera's center of interest2 for the camera's local axis, offset by its tumble pivot"
            }, 
            "name": {
                "docstring": ""
            }, 
            "objectTumble": {
                "docstring": ""
            }, 
            "orthoLock": {
                "docstring": "Orthographic cameras cannot be tumbled while orthoLock is on.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "orthoStep": {
                "docstring": "Specify the angular step in degrees for orthographic rotation. If camera is orthographic and autoOrthoConstrain is toggled on the rotation will be stepped by this amount."
            }, 
            "query": {
                "docstring": ""
            }, 
            "toolName": {
                "docstring": ""
            }, 
            "tumbleScale": {
                "docstring": "Set the rotation speed. A tumble scale of 1.0 will result in in 40 degrees of rotation per 100 pixels of cursor drag."
            }
        }
    }, 
    "turbulence": {
        "description": "A turbulence field causes irregularities (also called 'noise' or 'jitter') in the motion of affected objects. Use connectDynamic to cause the field to affect a dynamic object. If fields are created, this command returns the names of each of the fields. If a field was queried, the results of the query are returned. If a field was edited, the field name is returned. If object names are provided or the active selection list is non-empty, the command creates a field for every object in the list and calls addDynamic to add it to the object. If the list is empty, the command defaults to -pos 0 0 0. Setting the -pos flag with objects named on the command line is an error. ", 
        "flags": {
            "attenuation": {
                "docstring": "Attentuation rate of field"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "frequency": {
                "docstring": "Frequency of turbulence field. This determines how often motion is disrupted."
            }, 
            "magnitude": {
                "docstring": "Strength of field. As this increases, the affected objects will move faster."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which field is exerted."
            }, 
            "name": {
                "docstring": "name of field"
            }, 
            "noiseLevel": {
                "docstring": "If the noiseLevel parameter is greater than zero, the field will do multiple lookups in the table. Each additional lookup is weighted using noiseRatio (which see). The noiseLevel is the number of additional lookups, so if noiseLevel is 0, there is just one lookup. A value of 0 (the default) corresponds to the way the field behaved prior to Maya 3.0."
            }, 
            "noiseRatio": {
                "docstring": "If noiseLevel is greater than zero, then noiseRatio is the relative magnitude for each consecutive noise evaluation. These are cumulative: for example, if noiseRatio is 0.5, then the first evaluation is weighted 0.5, the second 0.25, and so on. Has no effect if noiseLevel is zero.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "perVertex": {
                "docstring": "Per-vertex application. If this flag is set true, then each individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical copy of the force field. If this flag is set to false, then the force is exerted only from the geometric center of the set of points."
            }, 
            "phase": {
                "docstring": "Phase shift of turbulence field. This influences the direction of the disruption. This flag is obsolete and is retained only for backward compatibility. It is replaced by -phaseX, -phaseY, and -phaseZ. Setting -phase is identical to setting -phaseZ (the phase shift was always in the Z dimension)."
            }, 
            "phaseX": {
                "docstring": "X component of phase shift of turbulence field. This influences the direction of the disruption."
            }, 
            "phaseY": {
                "docstring": "Y component of phase shift of turbulence field. This influences the direction of the disruption."
            }, 
            "phaseZ": {
                "docstring": "Z component of phase shift of turbulence field. This influences the direction of the disruption."
            }, 
            "position": {
                "docstring": "Position in space where you want to place a field. The field then emanates from this position in space rather than from an object. Note that you can both use -pos (creating a field at a position) and also provide object names."
            }, 
            "query": {
                "docstring": ""
            }, 
            "torusSectionRadius": {
                "docstring": ""
            }, 
            "volumeExclusion": {
                "docstring": ""
            }, 
            "volumeOffset": {
                "docstring": ""
            }, 
            "volumeShape": {
                "docstring": ""
            }, 
            "volumeSweep": {
                "docstring": ""
            }
        }
    }, 
    "twoPointArcCtx": {
        "description": "The twoPointArcCtx command creates a new context for creating two point circular arcs ", 
        "flags": {
            "degree": {
                "docstring": "Valid values are 1 or 3. Default degree 3."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "spans": {
                "docstring": "Default is 4.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "ubercam": {
        "description": "Use this command to create a \"ubercam\" with equivalent behavior to all cameras used by shots in the sequencer. ", 
        "flags": {}
    }, 
    "uiTemplate": {
        "description": "This command creates a new command template object. Template objects can hold default flag arguments for multiple UI commands. The command arguments are specified with the individual commands using the -defineTemplate flag and the desired flags and arguments. See also setUITemplate. ", 
        "flags": {
            "defineTemplate": {
                "docstring": ""
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified uiTemplate exists. Other flags are ignored.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "query": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": ""
            }
        }
    }, 
    "unassignInputDevice": {
        "description": "This command deletes all command strings associated with this device. In query mode, return type is based on queried flag.", 
        "flags": {
            "clutch": {
                "docstring": "Only delete command attachments with this clutch.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "device": {
                "docstring": "Specifies the device to work on."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "undo": {
        "description": "Takes the most recent command from the undo list and undoes it. ", 
        "flags": {}
    }, 
    "undoInfo": {
        "description": "This command controls the undo/redo parameters. ", 
        "flags": {
            "closeChunk": {
                "docstring": "Closes the chunk that was opened earlier by openChunk. Once close chunk is called, all undoable operations in the chunk will undo as a single undo operation. Use with CAUTION!! Improper use of this command can leave the undo queue in a bad state."
            }, 
            "infinity": {
                "docstring": "Set the queue length to infinity."
            }, 
            "length": {
                "docstring": "Specifies the number of items in the undo queue. The infinity flag overrides this one."
            }, 
            "openChunk": {
                "docstring": "Opens a chunk so that all undoable operations after this call will fall into the newly opened chunk, until close chunk is called. Once close chunk is called, all undoable operations in the chunk will undo as a single undo operation. Use with CAUTION!! Improper use of this command can leave the undo queue in a bad state."
            }, 
            "printQueue": {
                "docstring": "Prints to the Script Editor the contents of the undo queue."
            }, 
            "query": {
                "docstring": ""
            }, 
            "redoName": {
                "docstring": "Returns what will be redone (if anything)"
            }, 
            "redoQueueEmpty": {
                "docstring": "Return true if the redo queue is empty. Return false if there is at least one command in the queue to be redone."
            }, 
            "state": {
                "docstring": "Turns undo/redo on or off."
            }, 
            "stateWithoutFlush": {
                "docstring": "Turns undo/redo on or off without flushing the queue. Use with CAUTION!! Note that if you perform destructive operations while stateWithoutFlush is disabled, and you then enable it again, subsequent undo operations that try to go past the destructive operations may be unstable since undo will not be able to properly reconstruct the former state of the scene.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "undoName": {
                "docstring": "Returns what will be undone (if anything)"
            }, 
            "undoQueueEmpty": {
                "docstring": "Return true if the undo queue is empty. Return false if there is at least one command in the queue to be undone."
            }
        }
    }, 
    "unfold": {
        "description": "None ", 
        "flags": {
            "applyToShell": {
                "docstring": "Specifies that the selected components should be only work on shells that have something have been selected or pinned."
            }, 
            "areaWeight": {
                "docstring": "Surface driven importance. 0 treat all faces equal. 1 gives more importance to large ones."
            }, 
            "globalBlend": {
                "docstring": "This allows the user to blend between a local optimization method (globalBlend = 0.0) and a global optimization method (globalBlend = 1.0). The local optimization method looks at the ratio between the triangles on the object and the triangles in UV space. It has a side affect that it can sometimes introduce tapering problems. The global optimization is much slower, but takes into consideration the entire object when optimizing uv placement."
            }, 
            "globalMethodBlend": {
                "docstring": "The global optimization method uses two functions to compute a minimization. The first function controls edge stretch by using edges lengths between xyz and uv. The second function penalizes the first function by preventing configurations where triangles would overlap. For every surface there is a mix between these two functions that will give the appropriate response. Values closer to 1.0 give more weight to the edge length function. Values closer to 0.0 give more weight to surface area. The default value of '0.5' is a even mix between these two values."
            }, 
            "iterations": {
                "docstring": "Maximum number of iterations for each connected UV piece."
            }, 
            "optimizeAxis": {
                "docstring": "Degree of freedom for optimization 0=Optimize freely, 1=Move vertically only, 2=Move horzontally onlyFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "pinSelected": {
                "docstring": "Specifies that the selected components should be pinned instead the unselected components."
            }, 
            "pinUvBorder": {
                "docstring": "Specifies that the UV border should be pinned when doing the solve. By default only unselected components are pinned."
            }, 
            "scale": {
                "docstring": "Ratio between 2d and 3d space."
            }, 
            "stoppingThreshold": {
                "docstring": "Minimum distorsion improvment between two steps in %."
            }, 
            "useScale": {
                "docstring": "Adjust the scale or not."
            }
        }
    }, 
    "ungroup": {
        "description": "This command ungroups the specified objects. The objects will be placed at the same level in the hierarchy the group node occupied unless the -w flag is specified, in which case they will be placed under the world. If an object is ungrouped and there is an object in the new group with the same name then this command will rename the ungrouped object. See also:group, parent, instance, duplicate ", 
        "flags": {
            "absolute": {
                "docstring": "preserve existing world object transformations (overall object transformation is preserved by modifying the objects local transformation) [default]Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "parent": {
                "docstring": "put the ungrouped objects under the given parent"
            }, 
            "relative": {
                "docstring": "preserve existing local object transformations (don't modify local transformation)"
            }, 
            "world": {
                "docstring": "put the ungrouped objects under the world"
            }
        }
    }, 
    "uniform": {
        "description": "A uniform field pushes objects in a fixed direction. The field strength, but not the field direction, depends on the distance from the object to the field location. The transform is the associated dependency node. Use connectDynamic to cause the field to affect a dynamic object. If fields are created, this command returns the names of each of the fields. If a field was queried, the results of the query are returned. If a field was edited, the field name is returned. If object names are provided or the active selection list is non-empty, the command creates a field for every object in the list and calls addDynamic to add it to the object. If the list is empty, the command defaults to -pos 0 0 0. Setting the -pos flag with objects named on the command line is an error. ", 
        "flags": {
            "attenuation": {
                "docstring": "Attentuation rate of field"
            }, 
            "directionX": {
                "docstring": "X-component of direction."
            }, 
            "directionY": {
                "docstring": "Y-component of direction."
            }, 
            "directionZ": {
                "docstring": "Z-component of directionFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "magnitude": {
                "docstring": "Strength of field."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which field is exerted. -1 indicates that the field has no maximum distance."
            }, 
            "name": {
                "docstring": "name of field"
            }, 
            "perVertex": {
                "docstring": "Per-vertex application. If this flag is set true, then each individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical copy of the force field. If this flag is set to false, then the force is exerted only from the geometric center of the set of points."
            }, 
            "position": {
                "docstring": "Position in space where you want to place a field. The gravity then emanates from this position in space rather than from an object. Note that you can both use -pos (creating a field at a position) and also provide object names."
            }, 
            "query": {
                "docstring": ""
            }, 
            "torusSectionRadius": {
                "docstring": ""
            }, 
            "volumeExclusion": {
                "docstring": ""
            }, 
            "volumeOffset": {
                "docstring": ""
            }, 
            "volumeShape": {
                "docstring": ""
            }, 
            "volumeSweep": {
                "docstring": ""
            }
        }
    }, 
    "unloadPlugin": {
        "description": "Unload plug-ins from Maya. After the successful execution of this command, plug-in services will no longer be available. ", 
        "flags": {
            "addCallback": {
                "docstring": "Add a procedure to be called just before a plugin is unloaded. The procedure should have one string argument, which will be the plugin's name."
            }, 
            "force": {
                "docstring": "Unload the plugin even if it is providing services. This is not recommended. If you unload a plug-in that implements a node or data type in the scene, those instances will be converted to unknown nodes or data and the scene will no longer behave properly. Maya may become unstable or even crash. If you use this flag you are advised to save your scene in MayaAscii format and restart Maya as soon as possible."
            }, 
            "removeCallback": {
                "docstring": "Remove a procedure which was previously added with -addCallback.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "untangleUV": {
        "description": "This command will aid in the creation of non-overlapping regions (i.e. polygons) in texture space by untangling texture UVs. This is done in two stages:1) Use this command to map the UV border determined by the current selection or passed component into a shape that is more suitable for subsequent relaxation.2) Relax all the internal texture UVs by performing a length minimization algorithm on all edges in texture space. ", 
        "flags": {
            "mapBorder": {
                "docstring": "Map the border containing the selected UV into a variety of shapes that may be more amenable to UV relaxation operations. There are various types of mapping available. All the resulting mappings are fit inside the unit square.Valid values for the STRING are:circular- a circular mapping with picked UV closest to (0,0)square- map to unit square with picked UV at (0,0)shape- a mapping which attempts to reflect the actual shape of the object where the picked UV is placed on the line from (0,0) -(0.5,0.5)shape_circular- shape mapping which will interpolate to a circular mapping just enough to prevent self-intersections of the mapped bordershape_square- shape mapping which will interpolate to a square mapping just enough to prevent self-intersections of the mapped border"
            }, 
            "maxRelaxIterations": {
                "docstring": "The relaxation process is an iterative algorithm. Using this flag will put an upper limit on the number of iterations that will be performed."
            }, 
            "pinBorder": {
                "docstring": "If this is true, then the relevant texture borders are pinned in place during any relaxation"
            }, 
            "pinSelected": {
                "docstring": "If this is true, then then any selected UVs are pinned in place during any relaxation"
            }, 
            "pinUnselected": {
                "docstring": "If this is true, then all unselected UVs in each mesh are pinned in place during any relaxationFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "relax": {
                "docstring": "Relax all UVs in the shell of the selected UV's. The relaxation is done by simulating a spring system where each UV edge is treated as a spring. There are a number of different methods characterized by the way the UV edges are weighted in the spring system. These weightings are determined by STRING. Valid values for STRING are:uniform- every edge is weighted the same. This is the fastest method.inverse_length- every edge weight is inversely proportional to it's world space length.inverse_sqrt_length- every edge weight is inversely proportional the the square root of it's world space length.harmonic- this weighting can yield near optimal results in matching the UV's with the geometry, but can also take a long time."
            }, 
            "relaxTolerance": {
                "docstring": "This sets the tolerance which is used to determine when the relaxation process can stop. Smaller tolerances yield better results but can take much longer."
            }, 
            "shapeDetail": {
                "docstring": "If the mapBorder flag is set to circular or square, then this flag will control how much of the border's corresponding surface shape should be retained in the final mapped border."
            }
        }
    }, 
    "untrim": {
        "description": "Untrim the surface. ", 
        "flags": {
            "caching": {
                "docstring": "Modifies the node caching mode. See the node documentation for more information.Note:For advanced users only."
            }, 
            "constructionHistory": {
                "docstring": "Turn the construction history on or off"
            }, 
            "curveOnSurface": {
                "docstring": "If possible, create 2D curve as a result"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "name": {
                "docstring": "Name the resulting object"
            }, 
            "noChanges": {
                "docstring": ""
            }, 
            "nodeState": {
                "docstring": "Modifies the node state. See the node documentation for more information.Note:For advanced users only.Common flags"
            }, 
            "object": {
                "docstring": "Create the result, or just the dependency node"
            }, 
            "query": {
                "docstring": ""
            }, 
            "replaceOriginal": {
                "docstring": "Create \"in place\" (i.e., replace)"
            }, 
            "untrimAll": {
                "docstring": "if true, untrim all the trims for the surface else untrim only the last trimFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "upAxis": {
        "description": "The upAxis command changes the world up direction. Current implementation provides only two choices of axis (the Y-axis or the Z-axis) as the world up direction.By default, the ground plane in Maya is on the XY plane. Hence, the default up-direction is the direction of the positive Z-axis.The -ax flag is mandatory. In conjunction with the -ax flag, when the -rv flag is specified, the camera of currently active view is revolved about the X-axis such that the position of the groundplane in the view will remain the same as before the the up direction is changed.The screen update is applied to all cameras of all views. In query mode, return type is based on queried flag.", 
        "flags": {
            "axis": {
                "docstring": "This flag specifies the axis as the world up direction. The valid axis are either \"y\" or \"z\".When queried, it returns a string."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rotateView": {
                "docstring": "This flag specifies to rotate the view as well.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "userCtx": {
        "description": "", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "editCommand": {
                "docstring": ""
            }, 
            "editPrompt": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "finalCommand": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "noSelectionPrompt": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "selectionCount": {
                "docstring": ""
            }, 
            "selectionFlag": {
                "docstring": ""
            }, 
            "selectionMask": {
                "docstring": ""
            }, 
            "selectionPrompt": {
                "docstring": ""
            }
        }
    }, 
    "uvLink": {
        "description": "This command is used to make, break and query UV linking relationships between UV sets on objects and textures that use those UV sets. If no make, break or query flag is specified and both uvSet and texture flags are present, the make flag is assumed to be specified. If no make, break or query flag is specified and only one of the uvSet and texture flags is present, the query flag is assumed to be specified. The term \"texture\" in the context of UV linking is a bit of an oversimplification. In fact, UV sets can be linked to any node which takes UV coordinates as input. However in most cases it will be a texture to which you wish to link a UV set. ", 
        "flags": {
            "b": {
                "docstring": "The presence of this flag on the command indicates that the command is being invoked to break links between UV sets and textures."
            }, 
            "isValid": {
                "docstring": "This flag is used to verify whether or not a texture or UV set is valid for the purposes of UV linking. It should be used in conjunction with either the -texture flag or the -uvSet flag, but not both at the same time.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "make": {
                "docstring": "The presence of this flag on the command indicates that the command is being invoked to make links between UV sets and textures."
            }, 
            "query": {
                "docstring": ""
            }, 
            "queryObject": {
                "docstring": "This flag should only be used in conjunction with a query of a texture. This flag is used to indicate that the results of the query should be limited to UV sets of the object specified by this flag."
            }, 
            "texture": {
                "docstring": "The argument to the texture flag specifies the texture to be used by the command in performing the action."
            }, 
            "uvSet": {
                "docstring": "The argument to the uvSet flag specifies the UV set to be used by the command in performing the action."
            }
        }
    }, 
    "uvSnapshot": {
        "description": "Builds an image containg the UVs of the selected objects. ", 
        "flags": {
            "antiAliased": {
                "docstring": "When this flag is set, lines are antialiased."
            }, 
            "blueColor": {
                "docstring": "Blue component of line drawing. Default is 255."
            }, 
            "entireUVRange": {
                "docstring": "When this flag is set, the generated image will contain the entire uv range. Default is UV in 0-1 range."
            }, 
            "fileFormat": {
                "docstring": "Output file format. Any of those keyword: \"iff\", \"sgi\", \"pic\", \"tif\", \"als\", \"gif\", \"rla\", \"jpg\" Default is iff.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "greenColor": {
                "docstring": "Green component of line drawing. Default is 255."
            }, 
            "name": {
                "docstring": "Name of the file to be created."
            }, 
            "overwrite": {
                "docstring": "When this flag is set, existing file can be ovewritten."
            }, 
            "redColor": {
                "docstring": "Red component of line drawing. Default is 255."
            }, 
            "uMax": {
                "docstring": "Optional User Specified Max value for U. Default value is 1. This will take precedence over the \"entire range\" -euv flag."
            }, 
            "uMin": {
                "docstring": "Optional User Specified Min value for U. Default value is 0. This will take precedence over the \"entire range\" -euv flag."
            }, 
            "uvSetName": {
                "docstring": "Name of the uv set to use. Default is the current one."
            }, 
            "vMax": {
                "docstring": "Optional User Specified Max value for V. Default value is 1. This will take precedence over the \"entire range\" -euv flag."
            }, 
            "vMin": {
                "docstring": "Optional User Specified Min value for V. Default value is 0. This will take precedence over the \"entire range\" -euv flag."
            }, 
            "xResolution": {
                "docstring": "Horizontal size of the image. Default is 512."
            }, 
            "yResolution": {
                "docstring": "Vertical size of the image. Default is 512."
            }
        }
    }, 
    "view2dToolCtx": {
        "description": "This class creates a context for the View Tools \"track\", \"dolly\", and \"box zoom\" in the Hypergraph. ", 
        "flags": {
            "alternateContext": {
                "docstring": ""
            }, 
            "boxzoom": {
                "docstring": "Perform Box ZoomFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dolly": {
                "docstring": "Dollies the view"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": ""
            }, 
            "history": {
                "docstring": ""
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": ""
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "toolName": {
                "docstring": ""
            }, 
            "track": {
                "docstring": "Tracks the view"
            }
        }
    }, 
    "viewCamera": {
        "description": "The viewCamera command is used to position a camera to look directly at the side or top of another camera. This is primarily useful for the user when he or she is setting depth-of-field and clipping planes, if they are being used. The default behaviour: If no other flags are specified, the camera in the active panel is moved and the -t is presumed. If there is a camera selected, it is used as the target camera. ", 
        "flags": {
            "move": {
                "docstring": "Specifies which camera needs to move."
            }, 
            "sideView": {
                "docstring": "Position camera to look at the side of the target camera.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "topView": {
                "docstring": "Position camera to look at the top of the target camera (default)."
            }
        }
    }, 
    "viewClipPlane": {
        "description": "The viewClipPlane command can be used to query or set a camera's clip planes. If a camera is not specified, the camera in the active view will be used. The near and far clip plane flags may be used in conjunction with the auto clip plane flag. In query mode, return type is based on queried flag.", 
        "flags": {
            "autoClipPlane": {
                "docstring": "Compute the clip planes such that all object's in the camera's viewing frustum will be visible."
            }, 
            "farClipPlane": {
                "docstring": "Set or query the far clip plane.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "nearClipPlane": {
                "docstring": "Set or query the near clip plane."
            }, 
            "query": {
                "docstring": ""
            }, 
            "surfacesOnly": {
                "docstring": "This flag is to be used in conjunction with the auto clip plane flag. Only the bounding boxes of surfaces will be used to compute the camera's clipping planes."
            }
        }
    }, 
    "viewFit": {
        "description": "The viewFit command positions the specified camera so its point-of-view contains all selected objects other than itself. If no objects are selected, everything is fit to the view (excepting cameras, lights, and sketching plannes). The fit-factor, if specified, determines how much of the view should be filled. If a camera is not specified, the camera in the active view will be used. After the camera is moved, its center of interest is set to the center of the bounding box of the objects. ", 
        "flags": {
            "allObjects": {
                "docstring": "Specifies that all objects are to be fit regardless of the active list."
            }, 
            "animate": {
                "docstring": "Specifies that the transition between camera positions should be animated.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "fitFactor": {
                "docstring": "Specifies how much of the view should be filled with the \"fitted\" items."
            }, 
            "namespace": {
                "docstring": "Specifies a namespace that should be excluded. All objects in the specified namespace will be excluded from the fit process."
            }, 
            "panel": {
                "docstring": ""
            }
        }
    }, 
    "viewHeadOn": {
        "description": "The viewHeadOn command positions the specified camera so it is looking \"down\" the normal of the live object, and fitted to the live object. If the live object is a surface, an arbitrary normal is chosen. ", 
        "flags": {}
    }, 
    "viewLookAt": {
        "description": "The viewLookAt command positions the specified camera so it is looking at the centroid of all selected objects. If no objects are specified the camera will look at the ground plane. ", 
        "flags": {
            "position": {
                "docstring": "Position in world space to make the camera look at.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "viewManip": {
        "description": "Mel access to the view cube manipulator. In query mode, return type is based on queried flag.", 
        "flags": {
            "bottomLeft": {
                "docstring": "Positions the cube in the bottom left of the screen."
            }, 
            "bottomRight": {
                "docstring": "Positions the cube in the bottom right of the screen."
            }, 
            "compassAngle": {
                "docstring": "Angle (in degrees) to rotate the compass."
            }, 
            "dragSnap": {
                "docstring": "Enable snapping of orbit direction to view cube part directions during drag operation."
            }, 
            "drawCompass": {
                "docstring": "Show compass below the view cube."
            }, 
            "fitToView": {
                "docstring": "Fits the scene bounding box to the active view.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "frontParameters": {
                "docstring": ""
            }, 
            "goDefault": {
                "docstring": ""
            }, 
            "goHome": {
                "docstring": ""
            }, 
            "homeParameters": {
                "docstring": ""
            }, 
            "levelCamera": {
                "docstring": "Flattens the camera view rotation relative to the ground plane."
            }, 
            "minOpacity": {
                "docstring": "Opacity level (in range [0,1]) on view cube when the cursor is away from it (it is fully opaque when the cursor is in the view cube area)."
            }, 
            "namespace": {
                "docstring": ""
            }, 
            "postCommand": {
                "docstring": ""
            }, 
            "preCommand": {
                "docstring": ""
            }, 
            "preserveSceneUp": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "resetFront": {
                "docstring": ""
            }, 
            "resetHome": {
                "docstring": ""
            }, 
            "restoreCenter": {
                "docstring": "Repositions the pivot point for orbiting/tumbling the scene to the center of the scene's bounding box."
            }, 
            "selectionLockParameters": {
                "docstring": ""
            }, 
            "setFront": {
                "docstring": ""
            }, 
            "setHome": {
                "docstring": ""
            }, 
            "size": {
                "docstring": "Set or query the size of the View Cube, which can be one of \"tiny\", \"small\", \"normal\", \"large\" or \"auto\". When set to \"auto\" the View Cube will be automatically set to the size most appropriate for the view."
            }, 
            "toggleSelectionLock": {
                "docstring": ""
            }, 
            "topLeft": {
                "docstring": "Positions the cube in the top left of the screen."
            }, 
            "topRight": {
                "docstring": "Positions the cube in the top right of the screen."
            }, 
            "visible": {
                "docstring": "Shows/hides the view manip."
            }, 
            "zoomToFitScene": {
                "docstring": "Zoom the camera during animated transitions to fit the scene object in the viewport."
            }
        }
    }, 
    "viewPlace": {
        "description": "This command positions the camera as specified. The lookAt and viewDirection flags are mutually exclusive, as are the ortho and perspective flags. If this command switches a camera from ortho to perspective or the other way around without specifying a new field of view, then one is calculated based on a heuristic involving the selected objects. If the camera is not specified on the command line, the command will check to see if there is a camera on the active list. The user should be aware that some positions will be unattainable. For example, using a new camera located at the origin and specifying a lookAt of [0 0 -5] and an up of [1 1 1]. In these cases, the camera will always aim at the lookAt, and the new up direction will be determined by transforming the specified up into camera space and then projecting this vector onto a plane defined by the camera's up and right vectors. Using the example above, the new up vector will be [1 1 0]. ", 
        "flags": {
            "animate": {
                "docstring": ""
            }, 
            "eyePoint": {
                "docstring": "The new eye point in world coordinates."
            }, 
            "fieldOfView": {
                "docstring": "The new field of view (in degrees, for perspective cameras, and in world distance for ortho cameras)"
            }, 
            "lookAt": {
                "docstring": "The new look-at point in world coordinates."
            }, 
            "ortho": {
                "docstring": "Sets the camera to be orthgraphic."
            }, 
            "perspective": {
                "docstring": "Sets the camera to be perspective."
            }, 
            "upDirection": {
                "docstring": "The new up direction vector.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "viewDirection": {
                "docstring": "The new view direction vector."
            }
        }
    }, 
    "viewSet": {
        "description": "This command positions the camera to one of the pre-defined positions. If the fit flag is set in conjunction with persp, top, side, or front; the view is \"fit\" based on the list of selected objects (if there are any) or on all the objects if nothing is selected. If a camera is not specified, the camera in the active view will be used. If no flag is specified, the camera is set to the home position. In query mode, return type is based on queried flag.", 
        "flags": {
            "animate": {
                "docstring": ""
            }, 
            "back": {
                "docstring": "Moves the camera to the back position."
            }, 
            "bottom": {
                "docstring": "Moves the camera to the bottom position."
            }, 
            "fit": {
                "docstring": ""
            }, 
            "fitFactor": {
                "docstring": "Specifies how much of the view should be filled with the \"fitted\" itemsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "front": {
                "docstring": "Moves the camera to the front position."
            }, 
            "home": {
                "docstring": "Executes the camera's home attribute command. Before the string is executed, all occurances of \"%camera\" will be replaced by the camera's name. Use the camera command to set a camera's home command."
            }, 
            "keepRenderSettings": {
                "docstring": ""
            }, 
            "leftSide": {
                "docstring": "Moves the camera to the left side position."
            }, 
            "namespace": {
                "docstring": ""
            }, 
            "nextView": {
                "docstring": "Moves the camera to the next position. -fit Apply a viewFit after positioning camera to persp, top, side, or front."
            }, 
            "persp": {
                "docstring": "Moves the camera to the persp position."
            }, 
            "previousView": {
                "docstring": "Moves the camera to the previous position."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rightSide": {
                "docstring": "Moves the camera to the right side position."
            }, 
            "side": {
                "docstring": "Moves the camera to the (right) side position (deprecated)."
            }, 
            "t": {
                "docstring": ""
            }, 
            "top": {
                "docstring": "Moves the camera to the top position."
            }
        }
    }, 
    "visor": {
        "description": "Command for the creation and manipulation of a Visor UI element. The Visor is used to display the contents of a scene (rendering related nodes in particular), as well as files on disk which the user may wish to bring into the scene (shader and texture libraries for example). ", 
        "flags": {
            "addFolder": {
                "docstring": "Add a new folder to the current visual browser"
            }, 
            "addNodes": {
                "docstring": "Add dependency graph nodes by name to a user defined custom folder. The argument is a string encolsed in quotes with 1 one more node names seperated by blanks"
            }, 
            "allowPanningInX": {
                "docstring": "Specifies whether or not the user should be able to pan the contents of the visor horizontally. Default is true."
            }, 
            "allowPanningInY": {
                "docstring": "Specifies whether or not the user should be able to pan the contents of the visor vertically. Default is true."
            }, 
            "allowZooming": {
                "docstring": "Specifies whether or not the user should be able to zoom the contents of the visor. Default is true."
            }, 
            "command": {
                "docstring": "Mel command which will return a list of nodes to add to a folder"
            }, 
            "deleteFolder": {
                "docstring": "Delete the specified folder and all of its children"
            }, 
            "editFolder": {
                "docstring": "Edit the name and MEL command for an existing folder"
            }, 
            "folderList": {
                "docstring": "Return a string array of the folders in the visor."
            }, 
            "menu": {
                "docstring": "Set the name of the script to run to get a popup menu"
            }, 
            "name": {
                "docstring": "Name of the new folder"
            }, 
            "nodeType": {
                "docstring": "A node type used by folders of type nodeTypeInDAG"
            }, 
            "openDirectories": {
                "docstring": "When adding a new folder indicate if it sub directories will be show. The default is to not show sub directories."
            }, 
            "openFolder": {
                "docstring": "When adding a new folder indicate if it will be open or closed by default. The default is closed."
            }, 
            "parent": {
                "docstring": "Parent folder of this folder"
            }, 
            "path": {
                "docstring": "Path to a file system directory to be displayed in the folder"
            }, 
            "popupMenuScript": {
                "docstring": "Specifies the script to be called when the right mouse button is pressed in the visor. The name of the editor in which the right mouse button was pressed will be appended to the script at the time the script is called."
            }, 
            "query": {
                "docstring": ""
            }, 
            "rebuild": {
                "docstring": "Rebuild the visor after interactively adding a folder"
            }, 
            "refreshAllSwatches": {
                "docstring": "Refresh the swatches of all files currently displayed in this visor."
            }, 
            "refreshSelectedSwatches": {
                "docstring": "Refresh the swatches of all files currently selected in any visor."
            }, 
            "refreshSwatch": {
                "docstring": "Refresh the swatch of the file with the specified path.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "reset": {
                "docstring": "Clear all previously loaded folder descriptions in preperation for building a new visual browser"
            }, 
            "restrictPanAndZoom": {
                "docstring": "Specifies whether the panning and zooming of the visor should be restricted to keep the contents in the top left corner of the visor when they are smaller than the visible area within the visor. Default is true."
            }, 
            "saveSwatches": {
                "docstring": "Save swatches to disk for currently displayed image files."
            }, 
            "scrollBar": {
                "docstring": "Set the name of the scroll bar associated with visor"
            }, 
            "scrollPercent": {
                "docstring": "Set the percentage value for the scroll bar. Typicly called from a a scroll bars callback."
            }, 
            "selectedGadgets": {
                "docstring": "Return a string array of the currently selected gadgets (files, folders, nodes) in the visor."
            }, 
            "showDividers": {
                "docstring": "Specifies whether or not the visor should show dividers. The default is true. If -showDividers is set to false, dividers will be drawn as folders instead."
            }, 
            "showFiles": {
                "docstring": "Specifies whether or not the visor should show files. The default is true."
            }, 
            "showFolders": {
                "docstring": "Specifies whether or not the visor should show folders. The default is true."
            }, 
            "showNodes": {
                "docstring": "Specifies whether or not the visor should show nodes. The default is true."
            }, 
            "stateString": {
                "docstring": "Return the MEL command string to save the folder setup in visor"
            }, 
            "style": {
                "docstring": "Set display style for the browser. Options are: outliner A single column with an outliner style icon and a text label singleColumn A single column with an image style icon and a text label multiColumn A multiple column grid of swatches with the text label below the swatch"
            }, 
            "transform": {
                "docstring": "Name of a transform node used by folders of type nodeTypeInDAG"
            }, 
            "type": {
                "docstring": "Type of the new folder. Options are: commandA mel command that will return a list of depend nodes that will be displayed in the folderconnectedNodesThe nodes connected to the specified node name will be displayed in the folderdefaultNodesA mel command that will generate default node types. These nodes will not be part of the scene and are used for drag and drop creation of new nodes that are in the scene. The mel command use with this type is usually \"listNodetypes\".directoryA directory name in the file systemdirectoryCommandA mel command that will return a directory name in the file systemfolderAn empty folder(the default value). Empty folders can be used as user defined folders by dropping dependency graph nodes in to themnodeTypeInDAGList all nodes of a given type under a specified transforms in the DAG. For example list all the shaders for a character by specifying the top transform of the charactershelfItemsA directory containing mel files to use as shelf items"
            }
        }
    }, 
    "volumeAxis": {
        "description": "A volume axis field can push particles in four directions, defined with respect to a volume: along the axis, away from the axis or center, around the axis, and in a user-specified direction. These are analogous to the emission speed controls of volume emitters. The volume axis field also contains a wind turbulence model (different from the turbulence field) that simulates an evolving flow of liquid or gas. The turbulence has a build in animation that is driven by a connection to a time node. The transform is the associated dependency node. Use connectDynamic to cause the field to affect a dynamic object. If fields are created, this command returns the names of each of the fields. If a field was queried, the results of the query are returned. If a field was edited, the field name is returned. If object names are provided or the active selection list is non-empty, the command creates a field for every object in the list and calls addDynamic to add it to the object. If the list is empty, the command defaults to -pos 0 0 0. Setting the -pos flag with objects named on the command line is an error. ", 
        "flags": {
            "alongAxis": {
                "docstring": "Initial velocity multiplier in the direction along the central axis of the volume. See the diagrams in the documentation."
            }, 
            "aroundAxis": {
                "docstring": "Initial velocity multiplier in the direction around the central axis of the volume. See the diagrams in the documentation."
            }, 
            "attenuation": {
                "docstring": "Attentuation rate of field with distance. For sphere volumes, distance is computed from the center of the sphere. For cone, cylinder, and cube volumes, it is computed from the vertical axis of the volume. For torus volumes, it is computed from the ring in the middle of the solid portion of the torus."
            }, 
            "awayFromAxis": {
                "docstring": "Initial velocity multiplier in the direction away from the central axis of the volume. See the diagrams in the documentation. Used only with the cylinder, cone, and torus volumes."
            }, 
            "awayFromCenter": {
                "docstring": "Initial velocity multiplier in the direction away from the center point of a cube or sphere volume. Used only with the cube and sphere volumes."
            }, 
            "detailTurbulence": {
                "docstring": "The relative intensity of a second higher frequency turbulence. This can be used to create fine features in large scale flows. Both the speed and the frequency on this second turbulence are higher than the primary turbulence. When the detailTurbulence is non-zero the simulation may run a bit slower, due to the computation of a second turbulence.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "directionX": {
                "docstring": "x-component of force direction. Used with directional speed."
            }, 
            "directionY": {
                "docstring": "y-component of force direction. Used with directional speed."
            }, 
            "directionZ": {
                "docstring": "z-component of force direction. Used with directional speed."
            }, 
            "directionalSpeed": {
                "docstring": "Adds a component of speed in the direction specified by the directionX, Y, and Z attributes."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "invertAttenuation": {
                "docstring": "If this attribute is FALSE, the default, then the attenuation makes the field's effect decrease as the affected point is further from the volume's axis and closer to its edge. If the is set to TRUE, then the effect of the field increases in this case, making the full effect of the field felt at the volume's edge."
            }, 
            "magnitude": {
                "docstring": "Strength of field."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which field is exerted. A zero or negative value will turn off the field effect completely. For sphere volumes, distance is computed from the center of the sphere. For cone, cylinder, and cube volumes, it is computed from the vertical axis of the volume. For torus volumes, it is computed from the ring in the middle of the solid portion of the torus."
            }, 
            "name": {
                "docstring": "name of field"
            }, 
            "perVertex": {
                "docstring": "No effect for this type of field."
            }, 
            "position": {
                "docstring": "Position in space where you want to place the volume."
            }, 
            "query": {
                "docstring": ""
            }, 
            "torusSectionRadius": {
                "docstring": ""
            }, 
            "turbulence": {
                "docstring": "Adds a force simulating a turbulent wind that evolves over time."
            }, 
            "turbulenceFrequencyX": {
                "docstring": "The repeats of the turbulence function in X."
            }, 
            "turbulenceFrequencyY": {
                "docstring": "The repeats of the turbulence function in Y."
            }, 
            "turbulenceFrequencyZ": {
                "docstring": "The repeats of the turbulence function in Z."
            }, 
            "turbulenceOffsetX": {
                "docstring": "The translation of the turbulence function in X."
            }, 
            "turbulenceOffsetY": {
                "docstring": "The translation of the turbulence function in Y."
            }, 
            "turbulenceOffsetZ": {
                "docstring": "The translation of the turbulence function in Z."
            }, 
            "turbulenceSpeed": {
                "docstring": "The rate of change of the turbulence over time. The turbulence loops seamlessly every 1.0/turbulenceSpeed seconds. To animate this rate attach a new time node to the time input on the volumeAxisNode then animate the time value on the time node."
            }, 
            "volumeExclusion": {
                "docstring": ""
            }, 
            "volumeOffset": {
                "docstring": ""
            }, 
            "volumeShape": {
                "docstring": ""
            }, 
            "volumeSweep": {
                "docstring": ""
            }
        }
    }, 
    "volumeBind": {
        "description": "Command for creating and editing volume binding nodes. The node is use for storing volume data to define skin weighting data. ", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "influence": {
                "docstring": "Edit or Query the list of influences connected to the skin cluster.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "name": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "vortex": {
        "description": "A vortex field pulls objects in a circular direction, like a whirlpool or tornado. Objects affected by the vortex field tend to rotate around the axis specified by -ax, -ay, and -az. The transform is the associated dependency node. Use connectDynamic to cause the field to affect a dynamic object. If fields are created, this command returns the names of each of the fields. If a field was queried, the results of the query are returned. If a field was edited, the field name is returned. If object names are provided or the active selection list is non-empty, the command creates a field for every object in the list and calls addDynamic to add it to the object. If the list is empty, the command defaults to -pos 0 0 0. Setting the -pos flag with objects named on the command line is an error. ", 
        "flags": {
            "attenuation": {
                "docstring": "Attentuation rate of field"
            }, 
            "axisX": {
                "docstring": "X-component of vortex axis"
            }, 
            "axisY": {
                "docstring": "Y-component of vortex axis"
            }, 
            "axisZ": {
                "docstring": "Z-component of vortex axisFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "magnitude": {
                "docstring": "Strength of field."
            }, 
            "maxDistance": {
                "docstring": "Maximum distance at which field is exerted. -1 indicates that the field has no maximum distance."
            }, 
            "name": {
                "docstring": "name of field"
            }, 
            "perVertex": {
                "docstring": "Per-vertex application. If this flag is set true, then each individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical copy of the force field. If this flag is set to false, then the force is exerted only from the geometric center of the set of points."
            }, 
            "position": {
                "docstring": "Position in space where you want to place a field. The gravity then emanates from this position in space rather than from an object. Note that you can both use -pos (creating a field at a position) and also provide object names."
            }, 
            "query": {
                "docstring": ""
            }, 
            "torusSectionRadius": {
                "docstring": ""
            }, 
            "volumeExclusion": {
                "docstring": ""
            }, 
            "volumeOffset": {
                "docstring": ""
            }, 
            "volumeShape": {
                "docstring": ""
            }, 
            "volumeSweep": {
                "docstring": ""
            }
        }
    }, 
    "waitCursor": {
        "description": "This command sets/resets a wait cursor for the entire Maya application. This works as a stack, such that for each waitCursor -state oncommand executed there should be a matching waitCursor -state offcommand pending. Warning:If a script fails that has turned the wait cursor on, the wait cursor may be left on. You need to turn it off manually from the command line by entering and executing the command 'waitCursor -state off'. ", 
        "flags": {
            "query": {
                "docstring": ""
            }, 
            "state": {
                "docstring": "Set or reset the wait cursor for the entire Maya application.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "warning": {
        "description": "The warning command is provided so that the user can issue warning messages from his/her scripts. The string argument is displayed in the command window (or stdout if running in batch mode) after being prefixed with a warning message heading and surrounded by the appropriate language separators (# for Python, // for Mel). ", 
        "flags": {
            "showLineNumber": {
                "docstring": "Obsolete. Will be deleted in the next version of Maya. Use the checkbox in the script editor that enables line number display instead.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }, 
    "webBrowser": {
        "description": "This command is obsolete and will be removed in next version of Maya. The internal web browser of Maya has been replaced by a plug-in which allows your own browser to connect with Maya. Please refer help for information on how to setup communication of Maya with external web browser application. ", 
        "flags": {
            "annotation": {
                "docstring": "Annotate the control with an extra string value."
            }, 
            "back": {
                "docstring": ""
            }, 
            "backgroundColor": {
                "docstring": "The background color of the control. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0.When setting backgroundColor, the background is automatically enabled, unless enableBackground is also specified with a false value."
            }, 
            "command": {
                "docstring": ""
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Add a documentation flag to the control. The documentation flag has a directory structure like hierarchy. Eg. -dt render/multiLister/createNode/material"
            }, 
            "dragCallback": {
                "docstring": "Adds a callback that is called when the middle mouse button is pressed. The MEL version of the callback is of the form: global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods) The proc returns a string array that is transferred to the drop site. By convention the first string in the array describes the user settable message type. Controls that are application defined drag sources may ignore the callback. $mods allows testing for the key modifiers CTL and SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTL, 3 == CTL + SHIFT. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def callbackName( dragControl, x, y, modifiers ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"x\", \"y\", \"modifiers\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(x)d %(y)d %(modifiers)d'\")"
            }, 
            "dropCallback": {
                "docstring": "Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form: global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) The proc receives a string array that is transferred from the drag source. The first string in the msgs array describes the user defined message type. Controls that are application defined drop sites may ignore the callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link. In Python, it is similar, but there are two ways to specify the callback. The recommended way is to pass a Python function object as the argument. In that case, the Python callback should have the form: def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ): The values of these arguments are the same as those for the MEL version above. The other way to specify the callback in Python is to specify a string to be executed. In that case, the string will have the values substituted into it via the standard Python format operator. The format values are passed in a dictionary with the keys \"dragControl\", \"dropControl\", \"messages\", \"x\", \"y\", \"type\". The \"dragControl\" value is a string and the other values are integers (eg the callback string could be \"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'\")"
            }, 
            "edit": {
                "docstring": ""
            }, 
            "enable": {
                "docstring": "The enable state of the control. By default, this flag is set to true and the control is enabled. Specify false and the control will appear dimmed or greyed-out indicating it is disabled."
            }, 
            "enableBackground": {
                "docstring": "Enables the background color of the control."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "find": {
                "docstring": ""
            }, 
            "forward": {
                "docstring": ""
            }, 
            "fullPathName": {
                "docstring": "Return the full path name of the widget, which includes all the parentsFlag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "height": {
                "docstring": "The height of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "home": {
                "docstring": ""
            }, 
            "isObscured": {
                "docstring": "Return whether the control can actually be seen by the user. The control will be obscured if its state is invisible, if it is blocked (entirely or partially) by some other control, if it or a parent layout is unmanaged, or if the control's window is invisible or iconified."
            }, 
            "manage": {
                "docstring": "Manage state of the control. An unmanaged control is not visible, nor does it take up any screen real estate. All controls are created managed by default."
            }, 
            "matchCase": {
                "docstring": ""
            }, 
            "matchWholeWord": {
                "docstring": ""
            }, 
            "numberOfPopupMenus": {
                "docstring": "Return the number of popup menus attached to this control."
            }, 
            "openURL": {
                "docstring": ""
            }, 
            "parent": {
                "docstring": "The parent layout for this control."
            }, 
            "popupMenuArray": {
                "docstring": "Return the names of all the popup menus attached to this control."
            }, 
            "preventOverride": {
                "docstring": "If true, this flag disallows overriding the control's attribute via the control's right mouse button menu."
            }, 
            "query": {
                "docstring": ""
            }, 
            "reload": {
                "docstring": ""
            }, 
            "searchForward": {
                "docstring": ""
            }, 
            "stop": {
                "docstring": ""
            }, 
            "urlChangedCb": {
                "docstring": ""
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The visible state of the control. A control is created visible by default. Note that a control's actual appearance is also dependent on the visible state of its parent layout(s)."
            }, 
            "visibleChangeCommand": {
                "docstring": "Command that gets executed when visible state of the control changes."
            }, 
            "width": {
                "docstring": "The width of the control. The control will attempt to be this size if it is not overruled by parent layout conditions."
            }, 
            "wrap": {
                "docstring": ""
            }
        }
    }, 
    "webBrowserPrefs": {
        "description": "", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "preference": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "window": {
        "description": "This command creates a new window but leaves it invisible. It is most efficient to add the window's elements and then make it visible with the showWindow command. The window can have an optional menu bar. Also, the title bar and minimize/maximize buttons can be turned on or off. If the title bar is off, then you cannot have minimize or maximize buttons. Note: The window will require a control layout of some kind to arrange the controls (buttons, sliders, fields, etc.). Examples of control layouts are columnLayout, formLayout, rowLayout, etc. Note: This command will clear the uiTemplate stack. Templates for a window need to be set after the window cmd. ", 
        "flags": {
            "backgroundColor": {
                "docstring": "The background color of the window. The arguments correspond to the red, green, and blue color components. Each component ranges in value from 0.0 to 1.0."
            }, 
            "defineTemplate": {
                "docstring": "Puts a command in a mode where any other flags and args are parsed and added to the command template specified in the argument. They will be used as default arguments in any subsequent invocations of the command when templateName is set as the current template."
            }, 
            "docTag": {
                "docstring": "Attach a tag to the window."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "frontWindow": {
                "docstring": "Return the name of the front window. Note: you must supply the name of any window (the window does not need to exist). Returns \"unknown\" if the front window cannot be determined.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "height": {
                "docstring": "Height of the window excluding any window frame in pixels."
            }, 
            "iconName": {
                "docstring": "The window's icon title. By default it is the same as the window's title."
            }, 
            "iconify": {
                "docstring": "Icon state of the window."
            }, 
            "interactivePlacement": {
                "docstring": "Deprecated flag. Recognized but not implemented. This flag will be removed in a future version of Maya."
            }, 
            "leftEdge": {
                "docstring": "Position of the left edge of the window."
            }, 
            "mainMenuBar": {
                "docstring": ""
            }, 
            "mainWindow": {
                "docstring": "Main window for the application. The main window has an 'Exit' item in the Window Manager menu. By default, the first created window becomes the main window."
            }, 
            "maximizeButton": {
                "docstring": "Turns the window's maximize button on or off"
            }, 
            "menuArray": {
                "docstring": "Return a string array containing the names of the menus in the window's menu bar."
            }, 
            "menuBar": {
                "docstring": "Adds an empty menu bar to the window."
            }, 
            "menuBarVisible": {
                "docstring": "Visibility of the menu bar (if there is one)."
            }, 
            "menuIndex": {
                "docstring": "Sets the index of a specified menu."
            }, 
            "minimizeButton": {
                "docstring": "Turns the window's minimize button on or off."
            }, 
            "minimizeCommand": {
                "docstring": "Script executed after the window is minimized (iconified)."
            }, 
            "numberOfMenus": {
                "docstring": "Return the number of menus attached to the window's menu bar."
            }, 
            "query": {
                "docstring": ""
            }, 
            "resizeToFitChildren": {
                "docstring": "The window will always grow/shrink to just fit the controls it contains."
            }, 
            "restoreCommand": {
                "docstring": "Script executed after the window is restored from it's minimized (iconified) state."
            }, 
            "retain": {
                "docstring": "Retains the window after it has been closed. The default is to delete the window when it is closed."
            }, 
            "sizeable": {
                "docstring": "Whether or not the window may be interactively resized."
            }, 
            "title": {
                "docstring": "The window's title."
            }, 
            "titleBar": {
                "docstring": "Turns the window's title bar on or off."
            }, 
            "titleBarMenu": {
                "docstring": "Controls whether the title bar menu exists in the window title bar. Only valid if -tb/titleBaris true. This Windows only flag is true by default."
            }, 
            "toolbox": {
                "docstring": "Makes this a toolbox style window. A Windows only flag that makes the title bar smaller and uses a slightly different display style."
            }, 
            "topEdge": {
                "docstring": "Position of the top edge of the window."
            }, 
            "topLeftCorner": {
                "docstring": "Position of the window's top left corner."
            }, 
            "useTemplate": {
                "docstring": "Force the command to use a command template other than the current one."
            }, 
            "visible": {
                "docstring": "The window's visibility."
            }, 
            "width": {
                "docstring": "Width of the window excluding any window frame in pixels."
            }, 
            "widthHeight": {
                "docstring": "Window's width and height excluding any window frame in pixels."
            }
        }
    }, 
    "windowPref": {
        "description": "Create or modify preferred window attributes. The size and position of a window is retained during and between application sessions. A default window preference is created when a window is closed. Window preferences must be named and, consequently, only affect the window with a matching name. Note that window preferences are not applied to the main Maya window nor the Command window. In query mode, return type is based on queried flag.", 
        "flags": {
            "edit": {
                "docstring": ""
            }, 
            "enableAll": {
                "docstring": "Enable/disable all window preferences. Preferences are enabled by default. Set this flag to false and window's will ignore all preference values."
            }, 
            "exists": {
                "docstring": "Returns true|false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "height": {
                "docstring": "Height of the window."
            }, 
            "leftEdge": {
                "docstring": "Left edge position of the window."
            }, 
            "loadAll": {
                "docstring": "Reads in file with window attributes from disk."
            }, 
            "parentMain": {
                "docstring": "Set whether window is parented to main application window. Windows only."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Remove a window preference."
            }, 
            "removeAll": {
                "docstring": "Remove all window preferences."
            }, 
            "restoreMainWindowState": {
                "docstring": "Reads in file with main window state (positions of toolbars and dock controls).Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "saveAll": {
                "docstring": "Writes out file with window attributes."
            }, 
            "saveMainWindowState": {
                "docstring": "Writes out file with main window state (positions of toolbars and dock controls)."
            }, 
            "topEdge": {
                "docstring": "Top edge position of the window."
            }, 
            "topLeftCorner": {
                "docstring": "Top and left edge position of the window."
            }, 
            "width": {
                "docstring": "Width of the window."
            }, 
            "widthHeight": {
                "docstring": "Width and height of the window."
            }
        }
    }, 
    "wire": {
        "description": "This command creates a wire deformer.In the create mode the selection list is treated as the object(s) to be deformed, Wires are specified with the -w flag. Each wire can optionally have a holder which helps define the the regon of the object that is affected by the deformer. ", 
        "flags": {
            "after": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "afterReference": {
                "docstring": "The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then -after mode is used in adding the new deformer otherwise -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping."
            }, 
            "before": {
                "docstring": "If the default behavior for insertion/appending into/onto the existing chain is not what you want then you can use this flag to force the command to stick the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "crossingEffect": {
                "docstring": "Set the amount of convolution effect. Varies from fully convolved at 0 to a simple additive effect at 1 (which is what you get with the filter off). Default is 0. This filter should make its way into all blend nodes that deal with combining effects from multiple sources."
            }, 
            "deformerTools": {
                "docstring": "Returns the name of the deformer tool objects (if any) as string string ..."
            }, 
            "dropoffDistance": {
                "docstring": "Set the dropoff distance (second parameter) for the wire at index (first parameter)."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "envelope": {
                "docstring": "Set the envelope value for the deformer. Default is 1.0"
            }, 
            "exclusive": {
                "docstring": "Puts the deformation set in a deform partition."
            }, 
            "frontOfChain": {
                "docstring": "This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "geometry": {
                "docstring": "The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ..."
            }, 
            "geometryIndices": {
                "docstring": "Complements the -geometry flag in query mode. Returns the multi index of each geometry."
            }, 
            "groupWithBase": {
                "docstring": "Groups the wire with the base wire so that they can easily be moved together to create a ripple effect. Default is false.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "holder": {
                "docstring": "Set the specified curve or surface (second parameter as a holder for the wire at index (first parameter)."
            }, 
            "ignoreSelected": {
                "docstring": "Tells the command to not deform objects on the current selection list"
            }, 
            "localInfluence": {
                "docstring": "Set the local control a wire has with respect to other wires irrespective of whether it is deforming the surface. Varies from no local effect at 0 to full local control at 1. Default is 0."
            }, 
            "name": {
                "docstring": "Used to specify the name of the node being created"
            }, 
            "parallel": {
                "docstring": "Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "prune": {
                "docstring": "Removes any points not being deformed by the deformer in its current configuration from the deformer set."
            }, 
            "query": {
                "docstring": ""
            }, 
            "remove": {
                "docstring": "Specifies that objects listed after the -g flag should be removed from this deformer."
            }, 
            "split": {
                "docstring": "Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet)."
            }, 
            "wire": {
                "docstring": "Specify or query the wire curve name."
            }, 
            "wireCount": {
                "docstring": "Set the number of wires."
            }
        }
    }, 
    "wireContext": {
        "description": "This command creates a tool that can be used to create a wire deformer. ", 
        "flags": {
            "crossingEffect": {
                "docstring": "Set the amount of convolution filter effect. Varies from fully convolved at 0 to a simple additive effect at 1. Default is 0."
            }, 
            "deformationOrder": {
                "docstring": "Set the appropriate flag that determines the position in in the deformation hierarchy."
            }, 
            "dropoffDistance": {
                "docstring": "Set the dropoff Distance for the wires."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "envelope": {
                "docstring": "Set the envelope value for the deformer. Default is 1.0"
            }, 
            "exclusive": {
                "docstring": "Set exclusive mode on or off"
            }, 
            "exclusivePartition": {
                "docstring": "Set the name of an exclusive partition.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "groupWithBase": {
                "docstring": "Groups the wire with the base wire so that they can easily be moved together to create a ripple effect. Default is false."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "holder": {
                "docstring": "Controls whether the user can specify holders for the wires from the wire context. A holder is a curve that you can use to limit the wire's deformation region. Default is false."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "localInfluence": {
                "docstring": "Set the amount of local influence a wire has with respect to other wires. Default is 0."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }
        }
    }, 
    "workspace": {
        "description": "Create, open, or edit a workspace associated with a given workspace file. The string argument represents the workspace. If no workspace is specified then the current workspace is assumed. A workspace provides the underlying definition of a Maya Project. Each project has an associated workspace file, named workspace.mel, which is stored in the project root directory. The workspace file defines a set of rules that map file types to their storage, either relative to the project root or as an absolute location. These rules are used when resolving file paths at runtime. The workspace command operates directly on the low-level definition of the workspace to read, change and store the definition to the underlying file. Use of this command is not generally required, for most purposes it is recommended that project definition changes be done via the Project Window in the User Interface. ", 
        "flags": {
            "active": {
                "docstring": "This flag is a synonym for -o/openWorkspace."
            }, 
            "baseWorkspace": {
                "docstring": "A workspace may be based on another workspace. This means that all the settings in the base workspace apply to this workspace unless they are explicitly overridden."
            }, 
            "create": {
                "docstring": "Create a new directory. If the directory name is not a full path name, it will be created as a subdirectory of the \"current\" directory set with the -dir flag."
            }, 
            "directory": {
                "docstring": "This option will set the current workspace directory to the path specified. When queried it will return the current workspace directory. This directory is used as an initial directory for the fileBrowserand is part of the search path used for locating files. It should not be confused with the current workingdirectory as used by the pwdand chdircommands. When the file browser is used, it will set this value to the last location navigated to."
            }, 
            "expandName": {
                "docstring": "Query for the full path location of a filename using the current workspace definition. The path may be a project relative file name, a full path name or a variable name. The return value is always a full path name. If the path is an empty string, the return value will be the project root directory. Variable expansion is supported, and will consider both variables defined in the workspace as well as environment variables. There are three formats supported for expanding variable names: %variableName%, $variableName, ${variableName}. Maya will first attempt to find matching variables defined in the current workspace, then search for a matching environment variable. The tilde character ('~') is also supported. If a tilde is located at the beginning of a variable, Maya will only consider and expand environment variables, and will leave the tilde in the expanded result. On linux platforms only, a tilde can be used to expand a user's home directory, using the form ~username, ~, or ~/. When specified as ~username, it will be replaced with the corresponding user's home directory. When specified as ~ or ~/, it will be replaced with the value of the HOME environment variable."
            }, 
            "fileRule": {
                "docstring": "Set the default location for a file. The first parameter is the fileRule name(scenes, images, etc) and the second is the location. When queried, it returns a list of strings. The elements of the returned list alternate between fileRule names and the corresponding location. There is typically one file rule for each available translator. Environment variables are supported. You can set multiple path for the file rule by separating them with semicolons (;) on Windows and colons(:) on MacOSX and Linux. Note that whitespace at the beginning and end of each item in the separated sequence is significant and will be included as part of the path name (which is not usually desired unless the pathname does actually start or end with spaces). A valid filerule name cannot contain multiple byte characters."
            }, 
            "fileRuleEntry": {
                "docstring": "Return the location for the given fileRule."
            }, 
            "fileRuleList": {
                "docstring": "Returns a list of the currently defined file rules."
            }, 
            "filter": {
                "docstring": "This flag is obsolete.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "fullName": {
                "docstring": "Return the full name of the workspace."
            }, 
            "list": {
                "docstring": "This option will list the current workspace directory. If a path is specified for the \"workspaceFile\" then the contents of that directory will be listed. Otherwise, the contents of the directory set with the -dir flag will be listed."
            }, 
            "listFullWorkspaces": {
                "docstring": "Returns a list of the full path names of all the currently defined workspaces."
            }, 
            "listWorkspaces": {
                "docstring": "Returns a list of all the currently defined workspace names."
            }, 
            "newWorkspace": {
                "docstring": "This specifies that a new workspace is being created. If a workspace with this name already exists, the command will fail."
            }, 
            "objectType": {
                "docstring": "This flag is obsolete. All default locations will be added to the fileRules going forward."
            }, 
            "objectTypeEntry": {
                "docstring": "This flag is obsolete. This will now return the same as fileRuleEntry."
            }, 
            "objectTypeList": {
                "docstring": "This flag is obsolete. This will now return the same results as fileRuleList going forward."
            }, 
            "openWorkspace": {
                "docstring": "Open the workspace. The workspace becomes the current workspace."
            }, 
            "projectPath": {
                "docstring": "Convert filePath passed as argument to a filename that is relative to the project root directory (if possible) and return it. If the filePath is not under the project root directory, a full path name will be returned."
            }, 
            "query": {
                "docstring": ""
            }, 
            "removeFileRuleEntry": {
                "docstring": "Remove the given file rule from the specified workspace. If the workspace name is not specified, the given file rule will be removed from the current workspace."
            }, 
            "removeVariableEntry": {
                "docstring": "Remove the given variable from the specified workspace. If the workspace name is not specified, the given variable will be removed from the current workspace."
            }, 
            "renderType": {
                "docstring": "This flag is obsolete. All default render types will be added to fileRules going forward."
            }, 
            "renderTypeEntry": {
                "docstring": "This flag is obsolete, use fileRuleEntry going forward"
            }, 
            "renderTypeList": {
                "docstring": "This flag is obsolete, use fileRuleList going forward."
            }, 
            "rootDirectory": {
                "docstring": "Returns the root directory of the workspace."
            }, 
            "saveWorkspace": {
                "docstring": "Save the workspace. Workspaces are normally saved when Maya exits but this flag will make sure that the data is flushed to disk."
            }, 
            "shortName": {
                "docstring": "Query the short name of the workspace."
            }, 
            "update": {
                "docstring": "This flag reads all the workspace definitions from the project directory. It is used by Maya at startup time to find the available workspaces."
            }, 
            "updateAll": {
                "docstring": "This flag is a synonym for -u/update."
            }, 
            "variable": {
                "docstring": "Set or query the value of a project variable. Project variables are used when expanding names. See the -en/expandName flag below."
            }, 
            "variableEntry": {
                "docstring": "Given a variable name, will return its value."
            }, 
            "variableList": {
                "docstring": "Return a list of all variables in the workspace."
            }
        }
    }, 
    "wrinkle": {
        "description": "The wrinkle command is used to create a network of wrinkles on a surface. It automatically creates a network of wrinkle curves that control a wire deformer. The wrinkle curves are attached to a cluster deformer. ", 
        "flags": {
            "axis": {
                "docstring": "Specifies the plane of the wrinkle."
            }, 
            "branchCount": {
                "docstring": "Specifies the number of branches per wrinkle. Default is 2."
            }, 
            "branchDepth": {
                "docstring": "Specifies the depth of the branching. Default is 0."
            }, 
            "center": {
                "docstring": "Specifies the center of the wrinkle."
            }, 
            "crease": {
                "docstring": "Specifies an existing curve to serve as the wrinkle.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "dropoffDistance": {
                "docstring": "Specifies the dropoff distance around the center."
            }, 
            "envelope": {
                "docstring": "The envelope globally attenuates the amount of deformation. Default is 1.0."
            }, 
            "randomness": {
                "docstring": "Amount of randomness. Default is 0.2."
            }, 
            "style": {
                "docstring": "Specifies the wrinkle style. Valid values are \"radial\" or \"tangential\""
            }, 
            "thickness": {
                "docstring": "Wrinkle thickness. Default is 1.0."
            }, 
            "uvSpace": {
                "docstring": "1/2 length, 1/2 breadth, rotation angle, center u, v definition of a patch in uv space where the wrinkle is to be constructed."
            }, 
            "wrinkleCount": {
                "docstring": "Specifies the number of wrinkle lines to be generated. Default is 3."
            }, 
            "wrinkleIntensity": {
                "docstring": "Increasing the intensity makes it more wrinkly. Default is 0.5."
            }
        }
    }, 
    "wrinkleContext": {
        "description": "This command creates a context that creates wrinkles. ", 
        "flags": {
            "branchCount": {
                "docstring": "Set the number of branches spawned from a crease for radial wrinkles. Default is 2."
            }, 
            "branchDepth": {
                "docstring": "Set the depth of branching for radial wrinkles. Defaults to 0."
            }, 
            "edit": {
                "docstring": ""
            }, 
            "exists": {
                "docstring": "Returns true or false depending upon whether the specified object exists. Other flags are ignored."
            }, 
            "history": {
                "docstring": "If this is a tool command, turn the construction history on for the tool in question."
            }, 
            "image1": {
                "docstring": ""
            }, 
            "image2": {
                "docstring": ""
            }, 
            "image3": {
                "docstring": "Contexts support up to three icons that represent the tool associated with the context."
            }, 
            "name": {
                "docstring": "If this is a tool command, name the tool appropriately."
            }, 
            "query": {
                "docstring": ""
            }, 
            "randomness": {
                "docstring": "Set the deviation of the wirnkle creases from straight lines and other elements of the wrinkle structure. Defaults to 0.2."
            }, 
            "style": {
                "docstring": "Set the wrinkle characteristic shape.\"lines\"|\"radial\"|\"custom. Default is \"radial\"."
            }, 
            "thickness": {
                "docstring": "Set the thickness of wirnkle creases by setting the dropoff distance on the underlying wires.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "wrinkleCount": {
                "docstring": "Set the number of wrinkle creases. Default is 3."
            }, 
            "wrinkleIntensity": {
                "docstring": "Set the depth intensity of the wrinkle furrows. Defaults to 0.5."
            }
        }
    }, 
    "writeTake": {
        "description": "This action writes a take from a device with recorded data to a take (.mov) file. The writeTake action can also write the virtual definition of a device. See also: recordDevice, readTake, defineVirtualDevice ", 
        "flags": {
            "angle": {
                "docstring": "Sets the angular unit used in the take. Valid strings are [deg|degree|rad|radian].C: The default is the current user angular unit."
            }, 
            "device": {
                "docstring": "Specifies the device that contains the take. This is a required argument. If the device does not contain a take, the action will fail."
            }, 
            "linear": {
                "docstring": "Sets the linear unit used in the take. Valid strings are [mm|millimeter|cm|centimeter|m|meter|km|kilometer|in|inch|ft|foot|yd|yard|mi|mile]C: The default is the current user linear unit.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }, 
            "noTime": {
                "docstring": "The take (.mov) file will not contain time stamps.C: The default is to put time stamps in the take file."
            }, 
            "precision": {
                "docstring": "Sets the number of digits to the right of the decimal place in the take file.C: The default is 6."
            }, 
            "take": {
                "docstring": "Write out the take to a file with the specified name."
            }, 
            "virtualDevice": {
                "docstring": "Writes out the virtual device definition to a mel script with the specified file name."
            }
        }
    }, 
    "xform": {
        "description": "This command can be used query/set any element in a transformation node. It can also be used to query some values that cannot be set directly such as the transformation matrix or the bounding box. It can also set both pivot points to convenient values. All values are specified in transformation coordinates. (attribute-space) In addition, the attributes are applied/returned in the order in which they appear in the flags section. (which corresponds to the order they appear in the transformation matrix as given below) See also:move, rotate, scale In query mode, return type is based on queried flag.", 
        "flags": {
            "absolute": {
                "docstring": "perform absolute transformation (default)"
            }, 
            "boundingBox": {
                "docstring": "Returns the bounding box of an object. The values returned are in the following order: xmin ymin zmin xmax ymax zmax."
            }, 
            "boundingBoxInvisible": {
                "docstring": "Returns the bounding box of an object. This includes the bounding boxes of all invisible children which are not included using the boundingBox flag. The values returned are in following order: xmin ymin zmin xmax ymax zmax."
            }, 
            "centerPivots": {
                "docstring": "Set pivot points to the center of the object's bounding box. (see -p flag)"
            }, 
            "deletePriorHistory": {
                "docstring": ""
            }, 
            "euler": {
                "docstring": "modifer for -relative flag that specifies rotation values should be added to current XYZ rotation values."
            }, 
            "matrix": {
                "docstring": "Sets/returns the composite transformation matrix. \\*Note\\* the matrix is represented by 16 double arguments that are specified in row order."
            }, 
            "objectSpace": {
                "docstring": "treat values as object-space transformation values (only works for pivots, translations, rotation, rotation axis, matrix, and bounding box flags)"
            }, 
            "pivots": {
                "docstring": "convenience method that changes both the rotate and scale pivots simultaneously. (see -rp -sp flags for more info)"
            }, 
            "preserve": {
                "docstring": "preserve overall transformation. used to prevent object from \"jumping\" when changing pivots or rotation order. the default value is true. (used with -sp, -rp, -roo, -cp, -ra)"
            }, 
            "preserveUV": {
                "docstring": ""
            }, 
            "query": {
                "docstring": ""
            }, 
            "reflection": {
                "docstring": ""
            }, 
            "reflectionAboutBBox": {
                "docstring": ""
            }, 
            "reflectionAboutOrigin": {
                "docstring": ""
            }, 
            "reflectionAboutX": {
                "docstring": ""
            }, 
            "reflectionAboutY": {
                "docstring": ""
            }, 
            "reflectionAboutZ": {
                "docstring": ""
            }, 
            "reflectionTolerance": {
                "docstring": ""
            }, 
            "relative": {
                "docstring": "perform relative transformation"
            }, 
            "rotateAxis": {
                "docstring": "rotation axis orientation (when used with the -p flag the overall rotation is preserved by modifying the rotation to compensate for the axis rotation)"
            }, 
            "rotateOrder": {
                "docstring": "rotation order (when used with the -p flag the overall rotation is preserved by modifying the local rotation to be quivalent to the old one) Valid values for this flag are xyz | yzx | zxy | xzy | yxz | zyx"
            }, 
            "rotatePivot": {
                "docstring": "rotate pivot point transformation (when used with the -p flag the overall transformation is preserved by modifying the rotation translation)"
            }, 
            "rotateTranslation": {
                "docstring": "rotation translation"
            }, 
            "rotation": {
                "docstring": "rotation transformation"
            }, 
            "scale": {
                "docstring": "scale transformation"
            }, 
            "scalePivot": {
                "docstring": "scale pivot point transformation (when used with the -p flag the overall transformation is preserved by modifying the scale translation)"
            }, 
            "scaleTranslation": {
                "docstring": "scale translation"
            }, 
            "shear": {
                "docstring": "shear transformation. The values represent the shear xy,xz,yz"
            }, 
            "translation": {
                "docstring": "translation"
            }, 
            "worldSpace": {
                "docstring": "treat values as world-space transformation values (only works for pivots, translations, rotation, rotation axis, matrix, and bounding box flags)"
            }, 
            "worldSpaceDistance": {
                "docstring": "Values for -sp, -rp, -st, -rt, -t, -piv flags are treated as world space distances to move along the local axis. (where the local axis depends on whether the command is operating in local-space or object-space. This flag has no effect for world space."
            }, 
            "zeroTransformPivots": {
                "docstring": "reset pivot points and pivot translations without changing the overall matrix by applying these values into the translation channel.Flag can appear in Create mode of commandFlag can have multiple arguments, passed either as a tuple or a list."
            }
        }
    }
}